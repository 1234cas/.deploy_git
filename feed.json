{
    "version": "https://jsonfeed.org/version/1",
    "title": "Sparkle",
    "subtitle": "加油",
    "icon": "https://1234cas.github.io/1234cas.github.io/images/favicon.ico",
    "description": "好好读书",
    "home_page_url": "https://1234cas.github.io/1234cas.github.io",
    "items": [
        {
            "id": "https://1234cas.github.io/1234cas.github.io/%E5%9F%BA%E7%A1%80/",
            "url": "https://1234cas.github.io/1234cas.github.io/%E5%9F%BA%E7%A1%80/",
            "title": "基础",
            "date_published": "2022-03-29T02:52:39.753Z",
            "content_html": "\n\n\t<div class=\"row\">\n    <embed src=\"BOM.pdf\" width=\"100%\" height=\"550\" type=\"application/pdf\">\n\t</div>\n\n\n",
            "tags": [
                "前端",
                "前端"
            ]
        },
        {
            "id": "https://1234cas.github.io/1234cas.github.io/reading-minutes/%E5%85%B3%E4%BA%8E%E7%AC%94%E8%AE%B0/",
            "url": "https://1234cas.github.io/1234cas.github.io/reading-minutes/%E5%85%B3%E4%BA%8E%E7%AC%94%E8%AE%B0/",
            "title": "关于笔记",
            "date_published": "2022-03-28T03:00:07.082Z",
            "content_html": "<p>重要的加粗 重点的一两个词<code>加红</code></p>\n",
            "tags": [
                "读书笔记",
                "读书笔记"
            ]
        },
        {
            "id": "https://1234cas.github.io/1234cas.github.io/qianduan/Vue/vue%E7%AC%94%E8%AE%B0/",
            "url": "https://1234cas.github.io/1234cas.github.io/qianduan/Vue/vue%E7%AC%94%E8%AE%B0/",
            "title": "Vue笔记",
            "date_published": "2022-03-27T15:06:47.509Z",
            "content_html": "<h1 id=\"Vue笔记\"><a href=\"#Vue笔记\" class=\"headerlink\" title=\"Vue笔记\"></a>Vue笔记</h1><h2 id=\"01\"><a href=\"#01\" class=\"headerlink\" title=\"01\"></a>01</h2><p>前端开发:模块化 组件化 规范化 自动化<br>npm run dev 会先去webpack.config里面查看配置 然后再执行<br>项目源码 在页面中导入的是经webpack处理过的代码 所以要修改代码都要 修改源码再run 页面才会变<br>Source Map:1.省略devtool选项 防止暴露源码<br>2.把devtool设置为nosource-source-map 只定位行数不暴露源码<br>3.把devtool设置为source-map 定位行数且显示源码<br>开发环境第三种 生产环境第一种或者第二种</p>\n<h2 id=\"02\"><a href=\"#02\" class=\"headerlink\" title=\"02\"></a>02</h2><p><strong>数据驱动视图</strong><br><strong>双向数据绑定</strong><br><strong>MVVM <code>Model</code> <code>View</code> <code>ViewModel</code></strong></p>\n<pre><code class=\"javascript\">v-text &#123;&#125;&#123;&#125; v-html \nv-on简写@ v-bind简写:\nv-model \nthis===vm 在方法中访问data的数据可以用this.数据名 在data中声明的数据都会挂载到vm的属性上\n方法add:function()&#123;&#125;简写为add()&#123;&#125;\n@click=&quot;add(1,$event)&quot;\n只要接收的值被覆盖都可以用$event\n@click.prevent=&quot;add&quot; 事件修饰符 .stop .esc .enter\n表单元素用v-model 修饰符 .number .trim .lazy\nv-if和v-show一般都用v-if 还可以搭配if-else或者if-else-if 但是直接写三元就可以\n在&quot;&quot;里面写字符串要加单引号(就当成在写js)\n&lt;tr v-for=&quot;(item ,index) in list&quot; :title=&quot;item.name+index&quot; :key=&quot;item.id&quot;&gt;\nv-for(item in items)item是每一项 items是被循环的数组 要搭配使用:key=&quot;item.id&quot;\n</code></pre>\n<p><code>过滤器filter&#123;&#123;mes | capi | format(arg1) &#125;&#125; 在filters节点定义过滤器 可以连续使用多个过滤器 过滤器的本质是js函数 所以可以接收参数</code></p>\n<pre><code class=\"js\">filters:&#123;\n    capi(mes)&#123;\n        return mes.charAt(0).toUpperCase()+mes.slice(1)\n    &#125;\n&#125;\n上面定义的是私有过滤器 在入口函数main.js里面可以定义全局过滤器\nVue.filter(&#39;capi&#39;,mes=&gt;&#123;\n    return mes.charAt(0).toUpperCase()+mes.slice(1)\n&#125;)\nVue.filter(&#39;format&#39;,(mes,arg)=&gt;&#123;&#125;)\n</code></pre>\n<h2 id=\"03\"><a href=\"#03\" class=\"headerlink\" title=\"03\"></a>03</h2><p><strong>监听器<code>watch</code> 可以用来监听值的变化 并且发起请求 比对值是否可用</strong></p>\n<pre><code class=\"js\">watch:&#123;\n    async username(oldVal,newVal)&#123;\n        console(oldVal,newVal)\n        if(newVal.trim()===&#39;&#39;) return\n        const &#123;data:res&#125;=await axios.get(&#39;https://www.escook.cn/api/finduser&#39;+newVal)\n        console.log(res)\n    &#125;\n&#125;\n如果需要immediate或者deep就需要把username改为对象形式\nusername:&#123;\n    handle:async function(newVal)&#123;\n        if(newVal.trim()===&#39;&#39;) return\n        const &#123;data :res&#125;=await axios.get(&#39;https://www.escook.cn/api/finduser&#39;+newVal)\n        console.log(res)\n    &#125;,\n    //如果需要初次加载就立即被调用\n    immediate:true,\n    //如果监听的是一个对象 如果对象的属性发生了变化 则无法监听到 这时候需要deep选项\n    deep:true\n&#125;\n如果只想监听一个属性也可以写成这样\n&#39;info.username&#39;:&#123;\n&#125;\n</code></pre>\n<p><strong>计算属性<code>computed</code></strong><br><strong>计算属性指的是通过一系列运算之后 最终得到一个属性值 这个动态计算出来的属性值可以被模板结构或 methods 方法使用。</strong></p>\n<pre><code class=\"js\">computed:&#123;\n    rgb()&#123;return `rgb($&#123;this.r&#125;,$&#123;this.g&#125;,$&#123;this.b&#125;)`&#125;\n&#125;\n</code></pre>\n<p>计算属性的特点<br>① 虽然计算属性在声明的时候被定义为方法，但是<strong>计算属性的本质是一个属性</strong><br>② 计算属性会缓存计算的结果，<strong>只有计算属性依赖的数据变化时，才会重新进行运算</strong></p>\n<p>日期格式用day.js</p>\n<h3 id=\"axios\"><a href=\"#axios\" class=\"headerlink\" title=\"axios\"></a><code>axios</code></h3><pre><code class=\"js\">axios(&#123;\n    method:&quot;GET&quot;,\n    url:&quot;&quot;,\n    //get参数\n    params:&#123;&#125;,\n    //post参数\n    data:&#123;&#125;,\n&#125;).then(res=&gt;&#123;console.log(res)&#125;)\n\n写模板 import Test from &#39;./Test.vue&#39; 导入 渲染\n&lt;button id=&quot;btnPost&quot;&gt;&lt;/button&gt;\n&lt;button id=&quot;btnGet&quot;&gt;&lt;/button&gt;\n\n&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    document.querySelector(&#39;#btnPost&#39;).addEventListener(&#39;click&#39;, async function () &#123;\n        const &#123; data &#125; = await axios(&#123;\n            method: &quot;POST&quot;,\n            url: &quot;http://www.liulongbin.top:3006/api/post&quot;,\n            data: &#123;\n                name: &quot;zs&quot;,\n                age: 20\n            &#125;\n        &#125;)\n        console.log(data);\n    &#125;)\n    document.querySelector(&#39;#btnGet&#39;).addEventListener(&#39;click&#39;, async function () &#123;\n        //解构赋值的时候 使用:进行重命名\n        //调用axios,使用async/await进行简化\n        //使用解构赋值 从axios封装的对象中 把data属性解构出来\n        //解构出来的属性用:进行重命名 一般都重命名为&#123;data:res&#125;\n        const &#123; data: res &#125; = await axios(&#123;\n            method: &quot;GET&quot;,\n            url: &quot;http://www.liulongbin.top:3006/api/getbooks&quot;\n        &#125;)\n        console.log(res.data);\n    &#125;)\n&lt;/script&gt;\n</code></pre>\n<p>在main.js文件中</p>\n<pre><code class=\"js\">import axios from &#39;axios&#39;\n//全局配置axios的请求根路径\naxios.defaults.baseURL=&quot;请求根路径&quot;\n//把axios挂载到Vue.prototype上 供每个.vue的实例直接使用\nVue.prototype.$http=axios\n//以后再.vue组件中组件要发起请求 直接调用this.$http.xxx\n//但是把axios挂载到Vue.prototype上不利于API接口的复用\n</code></pre>\n<h3 id=\"vue-cli\"><a href=\"#vue-cli\" class=\"headerlink\" title=\"vue-cli\"></a><code>vue-cli</code></h3><pre><code class=\"js\">npm install -g @vue/cli\nvue create 项目的名称\nnew Vue(&#123;\n    // render 函数中，渲染的是哪个 .vue 组件，那么这个组件就叫做 “根组件”\n    render: h =&gt; h(App)\n&#125;).$mount(&#39;#app&#39;)\n$mount()和el的作用一样\nimport Left from &#39;@/components/Left.vue&#39; @指向src目录\n在webpack.config.js里面的module.exports=&#123;\n    resolve:&#123;\n        alias:&#123;\n           @:path.join(__dirname,&#39;./src&#39;)\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"使用组件三步骤\"><a href=\"#使用组件三步骤\" class=\"headerlink\" title=\"使用组件三步骤\"></a>使用组件三步骤</h3><pre><code class=\"js\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;!-- 以标签的形式使用注册好的组件 --&gt;\n        &lt;Left&gt;&lt;/Left&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<pre><code class=\"js\">&lt;script&gt;\n    //导入需要使用的.vue组件\n    import Left from &#39;@/components/Left.vue&#39;\n    export default &#123;\n        //注册组件\n        //.vue 组件中的 data 必须是函数\n        components: &#123;\n            Left,\n            right\n        &#125;\n    &#125;\n&lt;/script&gt;\n</code></pre>\n<p>上面这种注册的是私有子组件 注册全局组件要在main.js里面 通过Vue.component()方法   </p>\n<pre><code class=\"js\">//导入需要的全局注册的组件\nimport Count form &#39;@/component/Count.vue&#39;\n//参数1: 字符串 声明组件的注册名称 参数2 需要被全局注册的组件\nVue.component(&#39;MyCount&#39;,Count)\n//props 是组件的自定义属性，在封装通用组件的时候，合理地使用 props 可以极大的提高组件的复用性！\nexports default&#123;\n    props:[&#39;init&#39;,&#39;age&#39;]\n    //vue 规定：组件中封装的自定义属性是只读的，程序员不能直接修改 props 的值。否则会直接报错：\n    //要想修改 props 的值，可以把 props 的值转存到 data 中，因为 data 中的数据都是可读可写的！\n    data()&#123;\n        return&#123;\n            count:this.init\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>定义默认值时 <code>props</code>要改为对象模式</strong></p>\n<pre><code class=\"js\">export default&#123;\n    props:&#123;\n        default:0,\n        type:Number,\n        //多个可能的类型\n        //type:[Number,String]\n        required:true\n    &#125;\n&#125;\n</code></pre>\n<p>vue文件所有内容都要被解析成js才能渲染在浏览器中<br>Count组件只有使用的时候才会生成实例</p>\n<p><strong>组件样式之间会有冲突时 给style节点添加<code>scoped</code>属性</strong><br>给HTML的dom节点添加一个不重复的data属性(例如: data-v-5558831a)来唯一标识这个dom 元素<br>在每句css选择器的末尾(编译后生成的css语句)加一个当前组件的data属性选择器(例如：[data-v-5558831a])来私有化样式<br><strong>但是scoped对子组件是不生效的 要让某些样式对子组件生效 可以在其选择器前面加<code>/deep/</code></strong><br>通过 v-html 创建的 DOM 内容不受 scoped 样式影响，但是你仍然可以通过深度作用选择器来为他们设置样式。</p>\n<h2 id=\"04\"><a href=\"#04\" class=\"headerlink\" title=\"04\"></a>04</h2><p>生命周期<br><strong>生命周期（Life Cycle）是指一个组件从创建 -&gt; 运行 -&gt; 销毁的整个阶段，强调的是一个时间段。</strong><br>生命周期函数：是由 vue 框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行。<br>注意：生命周期强调的是时间段，生命周期函数强调的是时间点。<br>beforeCreate不重要<br><strong><code>created</code>重要 经常在created阶段发起axios请求 因为可以最早发起请求 然后把请求到的数据转存在data里 但是这时不能操作DOM 因为模板结构尚未创建</strong><br>beforeMount也还操作不了DOM 不重要<br><strong><code>mounted</code>已经把DOM结构渲染到页面中了 在这可以最早操作DOM结构</strong><br>beforeUpdate这时DOM结构还是旧的 但是数据是最新的<br><strong><code>updated</code>数据和结构都是最新的 在这可以操作最新的DOM结构</strong><br>updated数据变化时就会触发 使用动态组件来回切换组件会触发两次 </p>\n<h3 id=\"组件间的数据关系\"><a href=\"#组件间的数据关系\" class=\"headerlink\" title=\"组件间的数据关系\"></a>组件间的数据关系</h3><pre><code class=\"js\">父组件向子组件共享数据需要使用自定义属性props 不建议修改props的值\n04-9\n子组件向父组件共享数据使用自定义事件 \n04-10\n在 vue2.x 中 兄弟组件之间数据共享的方案是 EventBus\n04-11\n在数据的发送方定义要发送的数据 在数据的接收方定义要接收的数据\n创建eventBus.js 就是new一个Vue的实例 然后向外共享\n发送方和接收方都导入eventBus 发送方绑定$emit 接收方绑定$on事件\n发送方methods:&#123;\n    sendMsg()&#123;\n        //第一个参数是自定义事件名 第二个是要处理的数据\n        bus.$emit(&#39;share&#39;,this.msg)\n    &#125;\n&#125;\n接收方created()&#123;\n    bus.$on(&#39;share&#39;,val=&gt;&#123;\n        this.msgFromLeft=val;\n    &#125;)\n&#125;\n</code></pre>\n<h3 id=\"ref引用\"><a href=\"#ref引用\" class=\"headerlink\" title=\"ref引用\"></a>ref引用</h3><p>在vue中获取DOM元素使用ref</p>\n<pre><code class=\"js\">给想要操作的DOM元素添加ref属性 然后可以通过this.$refs.属性值来获取\nref除了引用DOM 还可以引用组件\n在父组件中要去调子组件的值用ref是最简单的\nthis.$refs.ww.dialogVisible\nthis.$refs.ipt.focus()\n$nextTick可以解决数据更新都是DOM结构还没有更新导致的报错\nthis.$nextTick(func)\n组件的 $nextTick(cb) 方法，会把 cb 回调推迟到下一个 DOM 更新周期之后执行。\n通俗的理解是：等组件的DOM 更新完成之后，再执行 cb 回调函数。从而能保证 cb 回调函数可以操作到最新的 DOM 元素。\n</code></pre>\n<h3 id=\"ES6中的数组方法\"><a href=\"#ES6中的数组方法\" class=\"headerlink\" title=\"ES6中的数组方法\"></a>ES6中的数组方法</h3><pre><code class=\"js\">some \nconst arr=[1,2,3,4,5]\nforEach可以实现查找数组的某一元素但是forEach一旦开始无法停止 性能较差\narr.some((item,index)=&gt;&#123;\n    if(item===&#39;xx&#39;) return true\n&#125;)\nsome在找到对应的项之后可以通过return true来终止some循环\n\nevery \n需求:判断数组中 每一项的状态是否都为true\narr.every(item=&gt;item.state)  把item.state===true简写\narr.filter(item =&gt; item.id == 1) return item.id==1的\narr.filter(item =&gt; item.id ) return 有item.id这个属性的\nreduce\n需求:把购物车数组中 已勾选的水果 总价累加起来\nlet amt = 0;\narr.filter(item=&gt;item.state).forEach(item=&gt;&#123;\n   amt += item.price * item count\n&#125;)\nfilter\narr.filter(item=&gt;item.state).reduce((累加的结果,当前循环项)=&gt;&#123;&#125;,初始值)\nconst result = arr.filter(item=&gt;item.state).reduce((amt,item)=&gt;&#123;\n    retuen amt +=item.price * item.count\n    //return的值会作为第二次累加的初始值\n&#125;,0)\narr.filter(item=&gt;item.state).reduce((amt,item)=&gt;amt+=item.price * item.count,0)\n简写代码会把那一行代码默认作为return的返回值\n</code></pre>\n<h2 id=\"05动态组件\"><a href=\"#05动态组件\" class=\"headerlink\" title=\"05动态组件\"></a>05动态组件</h2><p><strong>vue 提供了一个内置的<code> &lt;component :is=&quot;comName&quot; include=&quot;aside&quot;&gt;</code> 组件，专门用来实现动态组件的渲染</strong><br>通过&lt;button @click=”comName=’Left”&gt;</button>&lt;button @click=”comName=’Right”&gt;</button>来切换组件<br><strong>默认情况下，切换动态组件时无法保持组件的状态-即会重新加载。此时可以使用 vue 内置的 <code>&lt;keep-alive&gt; </code>组件保持动态组件的状态。</strong><br>用keep-alive包住动态组件 keep-alive 对应的生命周期函数<br>当组件被缓存时，会自动触发组件的 deactivated 生命周期函数。<br>当组件被激活时，会自动触发组件的 activated 生命周期函数。<br><strong>当组件第一次被创建的时候，会先执行created 生命周期，再会执行activated 生命周期</strong><br><strong>当组件被激活的时候，只会触发 activated 生命周期，不再触发 created。因为组件没有被重新创建</strong><br>include 属性用来指定：只有名称匹配的组件会被缓存，不匹配的会销毁。多个组件名之间使用英文的逗号分隔<br>exclude 指定组件不被缓存 两个属性不能同时使用<br>如果在“声明组件”的时候，没有为组件指定 name名称，则组件的名称默认就是“注册时候的名称”<br>当提供了name属性之后，组件的名称，就是name属性的值 在开发中一般都会指定name 首字母大写<br>根节点就xxx-container xxx就组件名<br>对比:<br>1.组件的“注册名称”的主要应用场景是:以标签的形式，把注册好的组件，渲染和使用到页面结构之中<br>2.组件声明时候的“name”名称的主要应用场景:结合<keep-alive>标签实现组件缓存功能;以及在调试工具中看到组件的name名称</p>\n<pre><code class=\"js\">&lt;keep-alive include=&quot;Myleft,Myright&quot;&gt;\n    &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;&gt;\n&lt;/keep-alive&gt;\n&lt;button @click=&quot;comName=&#39;Left&quot;&gt;&lt;/button&gt;\n&lt;button @click=&quot;comName=&#39;Right&quot;&gt;&lt;/button&gt;\n</code></pre>\n<h3 id=\"插槽slot\"><a href=\"#插槽slot\" class=\"headerlink\" title=\"插槽slot\"></a>插槽slot</h3><p>是在组件里的一部分 可以把插槽认为是组件封装期间，为用户预留的内容的占位符<br>可以通过 <strong><code>&lt;slot&gt;</code></strong> 元素定义插槽，从而为用户预留内容占位符。<br>封装组件时，可以为预留的 <slot> 插槽提供后备内容,直接写在slot标签里面。如果组件的使用者没有为插槽提供任何内容，则后备内容会生效。<br>如果在封装组件时需要预留多个插槽节点，则需要为每个 <slot> 插槽指定具体的 name 名称。这种带有具体名称的插槽叫做 <strong><code>具名插槽</code></strong><br>没有指定 name 名称的插槽，会有隐含的名称叫做 “default”<br>在向具名插槽提供内容的时候，我们可以在一个 <template> 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称。<br>v-slot后面要跟上插槽的名字 v-slot不能直接使用在元素身上 必须用在template或者组件上<br>template只起到一个包裹的作用 不会渲染成任何元素<br><strong>v-slot:可以简写为<code>#</code></strong><br>在封装组件的过程中，可以为预留的 <slot> 插槽绑定 props 数据，这种带有 props 数据的 <slot> 叫做 <strong><code>“作用域插槽”</code></strong><br>通过#content=”scope”接收作用域插槽对外提供的数据<code> &#123;&#123;scope.msg&#125;&#125;</code><br>可以在接收的时候直接解构<code>#content=&quot;&#123;msg,user&#125;&quot; &#123;&#123;msg&#125;&#125;</code><br>声明组件:</p>\n<pre><code class=\"js\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;slot&gt;&lt;/slot&gt;\n        &lt;!-- 具名插槽 --&gt;\n        &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;\n        &lt;!-- 作用域插槽 --&gt;\n        &lt;slot :user=&quot;username&quot;&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<p>调用组件:</p>\n<pre><code class=\"js\">&lt;Nav&gt;\n    &lt;!-- 对应默认插槽 --&gt;\n    &lt;p&gt;123&lt;/p&gt;\n    &lt;!-- 对应具名插槽 --&gt;\n    &lt;template #header&gt;\n        &lt;h1&gt;456&lt;/h1&gt;\n    &lt;/template&gt;\n    &lt;!-- 对应作用域插槽 --&gt;\n    &lt;template #default=&quot;scope&quot;&gt;\n        &lt;p&gt;&#123;\\&#123; scope &#125;&#125;&lt;/p&gt;\n    &lt;/template&gt;\n&lt;/Nav&gt;\n</code></pre>\n<p>table组件</p>\n<pre><code class=\"js\">&lt;template&gt;\n    &lt;table class=&quot;table table-bordered table-striped&quot;&gt;\n        &lt;thead&gt;\n            &lt;tr&gt;\n                &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;\n            &lt;/tr&gt;\n        &lt;/thead&gt;\n        &lt;!-- 表格的主体区域 --&gt;\n        &lt;tbody&gt;\n            &lt;!-- 使用 v-for 指令，循环渲染表格的数据行 --&gt;\n            &lt;tr v-for=&quot;(item, index) in data&quot; :key=&quot;item.id&quot;&gt;\n                &lt;!-- 为数据行的 td 预留的“作用域插槽” --&gt;\n                &lt;slot name=&quot;body&quot; :row=&quot;item&quot; :index=&quot;index&quot;&gt;&lt;/slot&gt;\n            &lt;/tr&gt;\n        &lt;/tbody&gt;\n    &lt;/table&gt;\n&lt;/template&gt;\n</code></pre>\n<p>使用表格组件</p>\n<pre><code class=\"js\">&lt;!-- 使用表格组件 --&gt;\n&lt;!-- 在 MyTable.vue 组件的 props 节点中声明表格的 data 数据源： --&gt;\n&lt;!-- 在使用 MyTable.vue 组件时，通过属性绑定的形式为表格指定 data 数据源： --&gt;\n&lt;my-table :data=&quot;goodslist&quot;&gt;\n    &lt;!-- 表格的标题 --&gt;\n\n    &lt;template v-slot:header&gt;\n        &lt;th&gt;#&lt;/th&gt;\n        &lt;th&gt;商品名称&lt;/th&gt;\n        &lt;th&gt;价格&lt;/th&gt;\n        &lt;th&gt;标签&lt;/th&gt;\n        &lt;th&gt;操作&lt;/th&gt;\n    &lt;/template&gt;\n\n​    &lt;!-- 表格每行的单元格 --&gt;\n\n    &lt;template v-slot:body=&quot;&#123; row, index &#125;&quot;&gt;\n        &lt;td&gt;&#123;\\&#123; index + 1 &#125;&#125;&lt;/td&gt;\n        &lt;td&gt;&#123;\\&#123; row.goods_name &#125;&#125;&lt;/td&gt;\n        &lt;td&gt;￥&#123;\\&#123; row.goods_price &#125;&#125;&lt;/td&gt;\n        &lt;td&gt;&#123;\\&#123; row.tags &#125;&#125;&lt;/td&gt;\n        &lt;td&gt;\n            &lt;button type=&quot;button&quot; class=&quot;btn btn-danger btn-sm&quot;&gt;删除\n            &lt;/button&gt;\n        &lt;/td&gt;\n    &lt;/template&gt;\n\n&lt;/my-table&gt;\n</code></pre>\n<h3 id=\"自定义指令\"><a href=\"#自定义指令\" class=\"headerlink\" title=\"自定义指令\"></a>自定义指令</h3><pre><code class=\"js\">在directives节点下声明私有自定义指令\nv-color:opacity=&quot;&#123; color: &#39;white&#39;, text: &#39;hello!&#39; &#125;&quot;\ndirectives&#123;\n    color:&#123;\n        bind(el)&#123;\n            el.style.color=&#39;red&#39;\n        &#125;\n        update(el,binding)&#123;\n            el.style.color=binging.value\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>在使用自定义指令时，需要加上 v- 前缀 声明时不需要<br>在 template 结构中使用自定义指令时，可以通过等号（=）的方式，为当前指令动态绑定参数值<br>在声明自定义指令时，可以通过形参中的第二个参数binding来接收指令的参数值：<br>通过binding对象的.value属性获取动态的参数值 el.style.color=binding.value<br>bind函数只调用 1 次：当指令第一次绑定到元素时调用 当DOM更新时bind函数不会被触发<br>update函数第一次不会调用 但会在每次DOM更新时被调用</p>\n<pre><code class=\"js\">函数简写 bind和update的逻辑相同时 可以简写为以下形式\ncolor(el,binging)&#123;\n    el.style.color=binging.value\n&#125;\n全局自定义指令 一般都定义全局\nVue.directive(&#39;color&#39;,function(el,binging)&#123;\n    el.style.color=binging.value\n&#125;)\n</code></pre>\n<h2 id=\"06\"><a href=\"#06\" class=\"headerlink\" title=\"06\"></a>06</h2><p>location.href返回#哈希地址 哈希地址会产生前进后退<br>简易路由</p>\n<pre><code class=\"js\">window.onhashchange=()=&gt;&#123;\n    console.log(location.hash)\n    switch(location.hash)&#123;\n        case &#39;#/home&#39;:\n            this.comName=&#39;Home&#39;\n            break\n        case &#39;#/movie&#39;:\n            this.comName=&#39;movie&#39;\n            break\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"vue-router插件\"><a href=\"#vue-router插件\" class=\"headerlink\" title=\"vue.router插件\"></a>vue.router插件</h3><p>使用方法:</p>\n<pre><code class=\"js\">npm i vue-router@3.5.2 -S\n1.导入Vue和VueRouter 2.Vue.use(VueRouter)\n3.new一个实例 const router =new VueRouter()\n4.向外共享 export default router\n然后在main.js中导入router\nnew Vue(&#123;\n    render:h=&gt;(App),\n    router\n&#125;).$mount(&#39;$app&#39;)\n</code></pre>\n<p>以后使用时可以一键生成<br><strong><code>this.$route是路由对象</code><br><code>this.$router是导航对象</code></strong><br>路由链接<br>使用 vue-router 提供的 <router-link to=\"/home\">(不用加#)和 <router-view> 声明路由链接和占位符：</p>\n<pre><code class=\"js\">const router =new VueRouter(&#123;\n    routes:[\n        &#123;path:&#39;/home&#39;,component:Home&#125;\n        &#123;path:&#39;/movie&#39;,component:Movie&#125;\n        &#123;path:&#39;/about&#39;,component:About&#125;\n    ]\n&#125;)\n</code></pre>\n<p>路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 C ，从而展示特定的组件页面。<br>通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便地设置路由的重定向<code>&#123;path:&#39;/&#39;,redirect:&#39;/home&#39;&#125;</code></p>\n<p><strong>嵌套路由 套娃</strong><br>通过 children 属性声明子路由规则</p>\n<pre><code class=\"js\">&#123;\n    path:&#39;/about&#39;,\n    component:About,\n    &lt;!-- redirect:&#39;/about/tab1&#39; --&gt;\n    children:[\n    &lt;!-- 默认子路由 在children数组中如果path为空字符串 则这条路由就是默认子路由 就不用重定向 --&gt;\n    &lt;!-- 子路由不用/开头 --&gt;\n        &#123;path:&#39;&#39;,component:Tab1&#125;\n        &lt;!-- &#123;path:&#39;tab1&#39;,component:Tab1&#125; --&gt;\n        &#123;path:&#39;tab2&#39;,component:Tab2&#125;\n    ]\n&#125;\n</code></pre>\n<p><strong>动态路由 :id</strong><br><code>&#123;path:&#39;/movie/:id&#39;,component:Movie&#125;</code></p>\n<pre><code class=\"js\">在Movie组件中获取id可以通过$route.params.id\n也可以使用 props 接收路由参数 在组件的props中声明id变量\n&#123;path:&#39;/movie/:id&#39;,component:Movie,props:true&#125;\n通过$route.query来获取查询参数 就是url?后面的值 fullPath是完整路径\n</code></pre>\n<p>声明式导航 链接 &amp; 编程式导航 (js)</p>\n<pre><code class=\"js\">this.$router\n1 this.$router.push(&#39;hash 地址&#39;)\n跳转到指定 hash 地址，并增加一条历史记录\n2 this.$router.replace(&#39;hash 地址&#39;)  \n跳转到指定的 hash 地址，并替换掉当前的历史记录\n3 this.$router.go(数值 n)\nthis.$router.back()/forward()\n</code></pre>\n<p>实现导航历史前进、后退 如果超过上限则不动<br>在行内使用编程式导航跳转的时候, <strong>this 必要省略</strong>,否则报错</p>\n<p><strong>全局前置守卫</strong><br><code>router.beforeEach((to,from,next)=&gt;&#123;&#125;)</code><br>每次发生路由的导航跳转时，都会触发全局前置守卫<br><strong>必须调用next()</strong> </p>\n<ol>\n<li>当前用户拥有后台主页的访问权限，直接放行：next()</li>\n<li>当前用户没有后台主页的访问权限，强制其跳转到登录页面：next(‘/login’)</li>\n<li>当前用户没有后台主页的访问权限，不允许跳转到后台主页 停留在当前页面：next(false)</li>\n</ol>\n<pre><code class=\"js\">router.beforeEach((to,from,next)=&gt;&#123;\n    if(to.path===&#39;/main&#39;)&#123;\n        const token = localStorage,getItem(&#39;key&#39;);\n        if(token)&#123;\n            next()\n        &#125;else&#123;\n            next(&#39;/login&#39;)\n        &#125;\n    &#125;else&#123;\n        next();\n    &#125;\n&#125;)\n</code></pre>\n<h2 id=\"07-other\"><a href=\"#07-other\" class=\"headerlink\" title=\"07 other\"></a>07 other</h2><h3 id=\"Vant\"><a href=\"#Vant\" class=\"headerlink\" title=\"Vant\"></a>Vant</h3><pre><code class=\"js\">npm install vant -S\n全引入\nimport Vue from &#39;vue&#39;;\nimport Vant from &#39;vant&#39;;\nimport &#39;vant/lib/index.css&#39;;\n\nVue.use(Vant);\n1.创建项目\n2.初始化\n3.加组件\n4.实现功能\n</code></pre>\n<h3 id=\"axios请求改进\"><a href=\"#axios请求改进\" class=\"headerlink\" title=\"axios请求改进\"></a>axios请求改进</h3><pre><code class=\"js\">导入request模块\nimport axios from &#39;axios&#39;\n\nconst request = axios.create(&#123;\n  baseURL: &#39;https://www.escook.cn&#39;\n&#125;)\n\nexport default request\n\n调用方法请求参数\n//改进前\nmethods: &#123;\n    async initArticleList() &#123;\n        const &#123; data: res &#125; = await request.get(&#39;/articles&#39;, &#123;\n            params: &#123;\n                _page: this.page,\n                _limit: this.limit\n            &#125;\n        &#125;)\n        console.log(res)\n    &#125;\n&#125;,\ncreated() &#123;\n    this.initArticleList()\n&#125;\n如果请求多个服务器可以封装request来创建多个axios来对应服务器\n如果多个页面要调用同一个接口会导致重复\n就封装一个api 请求就封装到api中\n//改进后\n//导入axios\nimport request from &#39;@/utils/request.js&#39;\n//返回封装的API\nexport const getArticleListAPI = (_page, _limit) =&gt; &#123;\n    return request.get(&#39;/article&#39;, &#123;\n        params: &#123;\n            _page,\n            _limit\n        &#125;\n    &#125;)\n&#125;\n//按需导入API接口\nimport &#123; getArticleListAPI &#125; from &#39;@/api/articleAPI.js&#39;\n\nmethods: &#123;\n    async initArticleList() &#123;\n        const &#123; data: res &#125; = await getArticleListAPI(this.page,this.limit)\n        console.log(res)\n    &#125;\n&#125;,\n</code></pre>\n<h3 id=\"覆盖第三方组件的样式\"><a href=\"#覆盖第三方组件的样式\" class=\"headerlink\" title=\"覆盖第三方组件的样式\"></a>覆盖第三方组件的样式</h3><pre><code class=\"js\">单页面\n.home-container&#123;\n    padding: 46px 0 50px 0;\n    *&#123;\n        background-color: red;\n    &#125;\n    /deep/ *&#123;\n        color: blue;\n    &#125;\n&#125;\n全局 定制主题\n//覆盖默认的less变量\nimport &#39;vant/lib/index.less&#39;\n// 这个文件是 vue-cli 创建出来的项目的配置文件\n// 在 vue.config.js 这个配置文件中，可以对整个项目的打包、构建进行全局性的配置\n\n// webpack 在进行打包的时候，底层用到了 node.js\n// 因此,在 vue.config.js 配置文件中，可以导入并使用 node.js 中的核心模块\nconst path = require(&#39;path&#39;)\nconst themePath = path.join(__dirname, &#39;./src/theme.less&#39;)\n\nmodule.exports = &#123;\n    publicPath: &#39;./&#39;,\n    css: &#123;\n        loaderOptions: &#123;\n            less: &#123;\n                modifyVars: &#123;\n                    // 直接覆盖变量\n                    // &#39;nav-bar-background-color&#39;: &#39;orange&#39;\n                    // 或者可以通过 less 文件覆盖（文件路径为绝对路径）\n                    // ../ ./ theme.less\n                    // 从盘符开始的路径，叫做绝对路径 C:\\\\Users\\liulongbin\\\\theme.less\n                    hack: `true; @import &quot;$&#123;themePath&#125;&quot;;`\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"配置vscode\"><a href=\"#配置vscode\" class=\"headerlink\" title=\"配置vscode\"></a>配置vscode</h3><pre><code class=\"js\">下载eslint和prettier插件\n&quot;editor.formatOnSave&quot;: true,\n//ESLint插件的配置\n&quot;editor.codeActionsOnSave&quot;: &#123;\n&quot;source.fixAll&quot;: true,\n&#125;,\n\n//.prettierrc文件里写&#123;semi: false, singleQuote: true, printWidth: 300&#125;\n&quot;prettier.configPath&quot;: &quot;C:\\\\Users\\\\Admin\\\\.prettierrc&quot;,\n&quot;eslint.alwaysShowStatus&quot;: true,\n&quot;prettier.trailingComma&quot;: &quot;none&quot;,\n&quot;prettier.semi&quot;: false,\n// 每行文字个数超出此限制将会被迫换行\n&quot;prettier.printWidth&quot;: 300,\n// 使用单引号替换双引号\n&quot;prettier.singleQuote&quot;: true,\n&quot;prettier.arrowParens&quot;: &quot;avoid&quot;,\n// 设置 .vue 文件中，HTML代码的格式化插件\n&quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;,\n&quot;vetur.ignoreProjectWarning&quot;: true,\n&quot;vetur.format.defaultFormatterOptions&quot;: &#123;\n&quot;js-beautify-html&quot;: &#123;\n&quot;wrap_attributes&quot;: false\n&#125;,\n&quot;prettier&quot;: &#123;\n&quot;printWidth&quot;: 300,\n&quot;trailingComma&quot;: &quot;none&quot;,\n&quot;semi&quot;: false,\n&quot;singleQuote&quot;: true,\n&quot;arrowParens&quot;: &quot;avoid&quot;\n&#125;\n&#125;js ,\n</code></pre>\n<h2 id=\"NOTICE\"><a href=\"#NOTICE\" class=\"headerlink\" title=\"NOTICE\"></a>NOTICE</h2><ol>\n<li>views放路由的组件 component放其他组件</li>\n<li>路由规则和地址要一一对应</li>\n<li>使用插件或者库想要实现更多功能先查看官方文档 尽量不要手写</li>\n<li>属性值默认值为false 想改为true 直接写属性名就可以</li>\n<li>提高axios请求的复用性 const axios1=axios.create({baseURL:’xx’})</li>\n<li>如果重复调用接口 可以封装到模块中 放在API文件夹下</li>\n<li>获取数据的函数函数名以init开头 API函数以API结尾</li>\n<li>在使用组件的时候，如果某个属性名是“小驼峰”形式，则绑定属性的时候,建议改写成“连字符”格式 </li>\n<li>例如cmtCount建议写成cmt-count props里面就接着写成cmtCount</li>\n<li>eslint在porps中有有默认值的对象时 默认值为{}会报错 通过不设或者工厂函数来解决</li>\n<li>在v-for中没id可以用索引 但是前面有复选框时必须用id</li>\n<li>触发load事件时loading变为true就不会重复触发 在初始化请求数据时也会触发一次</li>\n<li>所以一开始设置为true 在created中重新设为false</li>\n<li>通过判断请求数据来判断是否到底</li>\n<li>实现上拉加载 1.加页码 再请求 2.[…arr,…arr1]数据拼接 3.判断是否为最后一页</li>\n<li>不在main.js中use(Vuex)在store.js中use(Vuex)就不会报错</li>\n</ol>\n<h2 id=\"after\"><a href=\"#after\" class=\"headerlink\" title=\"after\"></a>after</h2><p>element-ui</p>\n<p>more axios</p>\n<pre><code class=\"js\">// 全局配置 axios\naxios.defaults.baseURL = &#39;https://www.escook.cn&#39;\nVue.prototype.\\$http = axios\nproxy跨域代理\naxios.defaults.baseURL = &#39;http://localhost:1245&#39;\nmodule.exports = &#123;\n    devServer: &#123;\n        port: 1245,\n        open: true,\n        proxy: &#39;https://www.escook.cn&#39;\n    &#125;\n&#125;\n拦截器\nlet loadingInstance = null\naxios.interceptors.request.use(config =&gt; &#123;\n    config.header.Authorization=&#39;Bearer xxx&#39;\n    loadingInstance = Loading.service(&#123; fullscreen: true &#125;)\n    return config\n&#125;)\n\naxios.interceptors.response.use(response =&gt; &#123;\n    loadingInstance.close()\n    return response\n&#125;)\n</code></pre>\n",
            "tags": [
                "前端",
                "Vue",
                "前端",
                "Vue"
            ]
        },
        {
            "id": "https://1234cas.github.io/1234cas.github.io/reading-minutes/%E5%85%B3%E4%BA%8E%E8%AF%BB%E4%B9%A6/",
            "url": "https://1234cas.github.io/1234cas.github.io/reading-minutes/%E5%85%B3%E4%BA%8E%E8%AF%BB%E4%B9%A6/",
            "title": "关于读书",
            "date_published": "2022-03-27T09:11:30.787Z",
            "content_html": "<p>TBR:<br>1, 卡尔维诺<br>《分成两半的子爵》《树上的男爵》《不存在的骑士》《美国讲稿》<br>2, 弗朗西斯福山<br>《我们的后人类未来：生物技术革命的后果》《身份政治：对尊严与认同的渴求》<br>4，纪实&amp;人文<br>《梦瘾》</p>\n<p>准备笔（铅笔或者其他） 标签贴（ 标记重点或者注意的点）<br>便利贴（随时记录自己的想法 也可以贴在第一页来记录阅读感想） 书签 水（多喝水）<br>读完回顾 建立读书笔记和感想 （印象笔记）电脑打字或者拍照<br>感想贴在首页或者写进读书报告<br>BV1VW411d78p</p>\n",
            "tags": [
                "读书笔记",
                "读书笔记"
            ]
        },
        {
            "id": "https://1234cas.github.io/1234cas.github.io/qianduan/Vue/vuex/",
            "url": "https://1234cas.github.io/1234cas.github.io/qianduan/Vue/vuex/",
            "title": "vuex",
            "date_published": "2022-03-27T09:02:49.300Z",
            "content_html": "<h1 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h1><p>vuex是vue的<strong>状态管理模式</strong>。集中管理数据。</p>\n<p>为此，<code>Vue</code>为这些被多个组件频繁使用的值提供了一个统一管理的工具——<code>Vuex</code>。</p>\n<h2 id=\"一、内容\"><a href=\"#一、内容\" class=\"headerlink\" title=\"一、内容\"></a>一、内容</h2><h3 id=\"1-state\"><a href=\"#1-state\" class=\"headerlink\" title=\"1.state\"></a><strong>1.state</strong></h3><p>state：{ </p>\n<p>​    count：1</p>\n<p>​    要设置的全局访问的state对象和初始值 </p>\n<p>}</p>\n<p>this.$store.state.count来取得store中的值</p>\n<p>mapState辅助函数</p>\n<pre><code>// 在单独构建的版本中辅助函数为 Vuex.mapState\nimport &#123; mapState &#125; from &#39;vuex&#39;\n\nexport default &#123;\n  // ...\n  computed: mapState(&#123;\n    // 箭头函数可使代码更简练\n    count: state =&gt; state.count,\n\n    // 传字符串参数 &#39;count&#39; 等同于 `state =&gt; state.count`\n    countAlias: &#39;count&#39;,\n\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) &#123;\n      return state.count + this.localCount\n    &#125;\n  &#125;)\n&#125;\n当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。\ncomputed: mapState([\n  // 映射 this.count 为 store.state.count\n  &#39;count&#39;\n])\nmapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？\ncomputed: &#123;\n  localComputed () &#123; /* ... */ &#125;,\n  // 使用对象展开运算符将此对象混入到外部对象中\n  ...mapState(&#123;\n    // ...\n  &#125;)\n&#125;\n</code></pre>\n<h3 id=\"2-getter\"><a href=\"#2-getter\" class=\"headerlink\" title=\"2.getter\"></a><strong>2.getter</strong></h3><p>相当于store的计算属性</p>\n<p>getter：{ </p>\n<p>​    add（state）{</p>\n<p>​        return state.count+1    </p>\n<p>​    }</p>\n<p> }</p>\n<p>可以对state中的成员加工后传递给外界</p>\n<p>Getters中的方法有两个默认参数</p>\n<ul>\n<li>state 当前Vuex对象中的状态对象</li>\n<li>getters 当前getters对象，用于将getters下的其他getter拿来用</li>\n</ul>\n<p>this.$store.getter.add或者this.￥store.getter.add()来取得getter中的值</p>\n<p><strong><code>mapGetters</code> 辅助函数</strong></p>\n<p><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p>\n<pre><code class=\"js\">import &#123; mapGetters &#125; from &#39;vuex&#39;\n\nexport default &#123;\n  // ...\n  computed: &#123;\n  // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n      &#39;doneTodosCount&#39;,\n      &#39;anotherGetter&#39;,\n      // ...\n    ])\n  &#125;\n&#125;\n如果你想将一个 getter 属性另取一个名字，使用对象形式：\n...mapGetters(&#123;\n  // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n  doneCount: &#39;doneTodosCount&#39;\n&#125;)\n</code></pre>\n<p>要修改store的值只能通过提交<strong>mutations</strong>来修改</p>\n<h3 id=\"3-Mutations\"><a href=\"#3-Mutations\" class=\"headerlink\" title=\"3.Mutations\"></a><strong>3.Mutations</strong></h3><p><strong>Mutation 必须是同步函数</strong></p>\n<p><code>mutations</code>方法都有默认的形参：</p>\n<p>(<strong>[state]</strong> <strong>[,payload]</strong>)</p>\n<ul>\n<li><code>state</code>是当前<code>Vuex</code>对象中的<code>state</code></li>\n<li><code>payload</code>是该方法在被调用时传递参数使用的</li>\n</ul>\n<p>在组件中this.$store.commit(‘edit’)</p>\n<p>mutation 里面存放回调函数 里面的方法必须要store.commit调用 在methods里面定义方法来调用mutation的方法</p>\n<ul>\n<li><p>以新对象替换老对象。例如，利用对象展开运算符我们可以这样写：</p>\n<pre><code class=\"js\">state.obj = &#123; ...state.obj, newProp: 123 &#125;\n</code></pre>\n</li>\n</ul>\n<pre><code class=\"js\">import &#123; mapMutations &#125; from &#39;vuex&#39;\n\nexport default &#123;\n  // ...\n  methods: &#123;\n    ...mapMutations([\n      &#39;increment&#39;, // 将 `this.increment()` 映射为 `this.$store.commit(&#39;increment&#39;)`\n\n      // `mapMutations` 也支持载荷：\n      &#39;incrementBy&#39; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#39;incrementBy&#39;, amount)`\n    ]),\n    ...mapMutations(&#123;\n      add: &#39;increment&#39; // 将 `this.add()` 映射为 `this.$store.commit(&#39;increment&#39;)`\n    &#125;)\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"4-actions\"><a href=\"#4-actions\" class=\"headerlink\" title=\"4.actions\"></a><strong>4.actions</strong></h3><p>由于直接在<code>mutation</code>方法中进行异步操作，将会引起数据失效。所以提供了Actions来专门进行异步操作，最终提交<code>mutation</code>方法。</p>\n<p><code>Actions</code>中的方法有两个默认参数</p>\n<ul>\n<li><code>context</code> 上下文(相当于箭头函数中的this)对象</li>\n<li><code>payload</code> 挂载参数 </li>\n</ul>\n<p>Action 提交的是 mutation，而不是直接变更状态。</p>\n<p>Action 可以包含任意异步操作。</p>\n<p><img data-src=\"https://upload-images.jianshu.io/upload_images/16550832-20d0ad3c60a99111.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/701/format/webp\" alt=\"img\"></p>\n<pre><code>import &#123; mapActions &#125; from &#39;vuex&#39;\n\nexport default &#123;\n  // ...\n  methods: &#123;\n    ...mapActions([\n      &#39;increment&#39;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&#39;increment&#39;)`\n\n      // `mapActions` 也支持载荷：\n      &#39;incrementBy&#39; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#39;incrementBy&#39;, amount)`\n    ]),\n    ...mapActions(&#123;\n      add: &#39;increment&#39; // 将 `this.add()` 映射为 `this.$store.dispatch(&#39;increment&#39;)`\n    &#125;)\n  &#125;\n&#125;\n</code></pre>\n<p>action 里面也存放着回调函数 里面的方法必须要store.dispatch调用 接受一个context对象</p>\n<p>我们可以如下组合 action：</p>\n<pre><code class=\"js\">// 假设 getData() 和 getOtherData() 返回的是 Promise\n\nactions: &#123;\n  async actionA (&#123; commit &#125;) &#123;\n    commit(&#39;gotData&#39;, await getData())\n  &#125;,\n  async actionB (&#123; dispatch, commit &#125;) &#123;\n    await dispatch(&#39;actionA&#39;) // 等待 actionA 完成\n    commit(&#39;gotOtherData&#39;, await getOtherData())\n  &#125;\n&#125;\n详看vuex的actions\n</code></pre>\n<h4 id=\"5-模块的细节\"><a href=\"#5-模块的细节\" class=\"headerlink\" title=\"5. 模块的细节\"></a><strong>5. 模块的细节</strong></h4><ul>\n<li><p>模块中<code>mutations</code>和<code>getters</code>中的方法接受的第一个参数是自身局部模块内部的<code>state</code></p>\n<pre><code class=\"js\">modules:&#123;\n    a:&#123;\n        state:&#123;key:5&#125;,\n        mutations:&#123;\n            editKey(state)&#123;\n                state.key = 9\n            &#125;\n        &#125;,\n        ....\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p><code>getters</code>中方法的第三个参数是根节点状态</p>\n<pre><code class=\"js\">modules:&#123;\n    a:&#123;\n        state:&#123;key:5&#125;,\n        getters:&#123;\n            getKeyCount(state,getter,rootState)&#123;\n                return  rootState.key + state.key\n            &#125;\n        &#125;,\n        ....\n    &#125;\n&#125;\n</code></pre>\n</li>\n<li><p><code>actions</code>中方法获取局部模块状态是<code>context.state</code>,根节点状态是<code>context.rootState</code></p>\n<pre><code class=\"js\">modules:&#123;\n    a:&#123;\n        state:&#123;key:5&#125;,\n        actions:&#123;\n            aEidtKey(context)&#123;\n                if(context.state.key === context.rootState.key)&#123;\n                    context.commit(&#39;editKey&#39;)\n                &#125;\n            &#125;\n        &#125;,\n        ....\n    &#125;\n&#125;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"二、规范目录结构\"><a href=\"#二、规范目录结构\" class=\"headerlink\" title=\"二、规范目录结构\"></a><strong>二、规范目录结构</strong></h2><p>Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：</p>\n<ol>\n<li>应用层级的状态应该集中到单个 store 对象中。</li>\n<li>提交 <strong>mutation</strong> 是更改状态的唯一方法，并且这个过程是同步的。</li>\n<li>异步逻辑都应该封装到 <strong>action</strong> 里面。</li>\n</ol>\n<p>只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。</p>\n<p>对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：</p>\n<pre><code class=\"bash\">├── index.html\n├── main.js\n├── api\n│   └── ... # 抽取出API请求\n├── components\n│   ├── App.vue\n│   └── ...\n└── store\n    ├── index.js          # 我们组装模块并导出 store 的地方\n    ├── actions.js        # 根级别的 action\n    ├── mutations.js      # 根级别的 mutation\n    └── modules\n        ├── cart.js       # 购物车模块\n        └── products.js   # 产品模块\n</code></pre>\n<h2 id=\"三、例子\"><a href=\"#三、例子\" class=\"headerlink\" title=\"三、例子\"></a>三、例子</h2><p>在store中引入vue和vuex vue.use(Vuex)</p>\n<p>在main.js中引入并且挂载stroe</p>\n<p>在store中export default new Vuex.store({<strong>state</strong>：{ 要设置的全局访问的state对象和初始值 }})</p>\n<pre><code>state\n// 在单独构建的版本中辅助函数为 Vuex.mapState\nimport &#123; mapState &#125; from &#39;vuex&#39;\n\nexport default &#123;\n  // ...\n  computed: mapState(&#123;\n    // 箭头函数可使代码更简练\n    count: state =&gt; state.count,\n\n    // 传字符串参数 &#39;count&#39; 等同于 `state =&gt; state.count`\n    countAlias: &#39;count&#39;,\n\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) &#123;\n      return state.count + this.localCount\n    &#125;\n  &#125;)\n&#125;\nconst store = new Vuex.Store(&#123;\n  state: &#123;\n    todos: [\n      &#123; id: 1, text: &#39;...&#39;, done: true &#125;,\n      &#123; id: 2, text: &#39;...&#39;, done: false &#125;\n    ]\n  &#125;,\n  getters: &#123;\n    doneTodos: state =&gt; &#123;\n      return state.todos.filter(todo =&gt; todo.done)\n    &#125;\n  &#125;\n&#125;)\n</code></pre>\n<h2 id=\"四、原版\"><a href=\"#四、原版\" class=\"headerlink\" title=\"四、原版\"></a>四、原版</h2><p>和store有相同的方法和属性 可以是任意异步函数 而mutation必须是同步函数<br>有两种写法和两种使用方法</p>\n<p>通过挂载到vue实例上 就可以在全局用$来调用<br>组件用到哪个状态就讲哪个声明为计算属性<br>可以用mapState函数来辅助 mapState返回的是一个对象 不能和局部计算函数混用 但是用…可以直接用<br>如果一个变量只会在一个组件中就声明局部变量<br>getting就是state的计算属性 通过属性来访问<br>getting接受state做为第一个参数 其他getting作为第二参数 结果缓存<br>如果需要传参就通过方法来调用 结果不缓存<br>mapGetting映射 把store中的getter映射到局部的计算属性中<br>mutation更像是事件注册 由类型和回调函数组成 接受state作为第一个参数 调用需要用对应的类型调用store.commit方法<br>commit可以传入额外参数payload 最好是对象<br>也可以在commit时传对象直接把type包括在内<br>提前在store初始化所有变量 注意添加新属性<br>使用常量来替代mutation事件类型<br>…mapMutation（【映射】）<br>…mapMutation（{可以重命名}）<br>必须是同步的<br>action是异步的 支持同样的载荷方式和对象形式进行分发 但是接受context 调用context.commit来提交一个mutation 可以用参数解构来简写<br>…mapStation映射到组件<br>action通过store.dispatch来触发 处理actions处理函数处理返回的promise 并且仍然放回promise</p>\n<p>单元测试export const mutations={}</p>\n<p>映射之后就不用this.调用</p>\n",
            "tags": [
                "前端",
                "Vue",
                "前端",
                "Vue"
            ]
        },
        {
            "id": "https://1234cas.github.io/1234cas.github.io/qianduan/Vue/vue-router/",
            "url": "https://1234cas.github.io/1234cas.github.io/qianduan/Vue/vue-router/",
            "title": "Vue router",
            "date_published": "2022-03-27T09:02:29.125Z",
            "content_html": "<h2 id=\"Vue-Router\"><a href=\"#Vue-Router\" class=\"headerlink\" title=\"Vue Router\"></a>Vue Router</h2><p><strong>官方例子<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1yb3V0ZXIvdHJlZS9kZXYvZXhhbXBsZXM=\">https://github.com/vuejs/vue-router/tree/dev/examples</span></strong></p>\n<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><p><strong>基础的router/index.js文件</strong></p>\n<pre><code class=\"js\">import Vue from &#39;vue&#39; \nimport VueRouter from &#39;vue-router&#39;\n// 导入需要的路由组件\nimport Home from &#39;@/views/Home.vue&#39;\n\nVue.use(VueRouter)\n\nconst router = new VueRouter(&#123;\n    routes:[&#123;\n        &#123; path: &#39;&#39;, component: Home, name: &#39;home&#39; &#125;,\n        &#123; path: &#39;/home&#39;, component: Home &#125;\n    &#125;]\n&#125;)\n\nexport default router\n</code></pre>\n<p>必要的内容：</p>\n<ul>\n<li>引入vue和vue-router</li>\n<li>使用Vue.use(Router)</li>\n<li>配置路由</li>\n<li>对外开放router</li>\n</ul>\n<p>可以通过vue-cli创建项目时一键生成</p>\n<p>还需要在main.js入口文件中导入挂载</p>\n<pre><code class=\"js\">import router from &#39;./router&#39;\nnew Vue(&#123;\n  router,\n  render: h =&gt; h(App)\n&#125;).$mount(&#39;#app&#39;)\n</code></pre>\n<p>同样也可以一键生成</p>\n<hr>\n<h4 id=\"动态路由匹配\"><a href=\"#动态路由匹配\" class=\"headerlink\" title=\"动态路由匹配\"></a>动态路由匹配</h4><pre><code class=\"js\">    &#123; path: &#39;/user/:id&#39;, component: User &#125;\n</code></pre>\n<p>可以通过<code>$route.params</code>来获取</p>\n<p>注意，当使用路由参数时，例如从 <code>/user/foo</code> 导航到 <code>/user/bar</code>，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会再被调用</strong>。</p>\n<p>可以使用 watch (监测变化) <code>$route</code> 对象：</p>\n<pre><code class=\"js\">watch: &#123;\n    $route(to, from) &#123;\n    // 对路由变化作出响应...\n    &#125;\n&#125;\n</code></pre>\n<p>或者使用beforeRouterUpadte导航守卫</p>\n<pre><code class=\"js\">beforeRouteUpdate(to, from, next) &#123;\n    // react to route changes...\n    // don&#39;t forget to call next()\n&#125;\n</code></pre>\n<p>如果想匹配<strong>任意路径</strong>，我们可以使用通配符 (<code>*</code>)：</p>\n<pre><code class=\"js\">&#123; path: &#39;*&#39; &#125;\n&#123; path: &#39;user/*&#39; &#125;\n</code></pre>\n<p>含有<em>通配符</em>的路由应该放在最后。路由 <code>&#123; path: &#39;*&#39; &#125;</code> 通常用于客户端 404 错误。</p>\n<p>当使用一个<em>通配符</em>时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数。它包含了 URL 通过<em>通配符</em>被匹配的部分：</p>\n<pre><code class=\"js\">// 给出一个路由 &#123; path: &#39;/user-*&#39; &#125;\nthis.$router.push(&#39;/user-admin&#39;)\nthis.$route.params.pathMatch // &#39;admin&#39;\n// 给出一个路由 &#123; path: &#39;*&#39; &#125;\nthis.$router.push(&#39;/non-existing&#39;)\nthis.$route.params.pathMatch // &#39;/non-existing&#39;\n</code></pre>\n<p><strong><code>vue-router</code> 使用 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3BpbGxhcmpzL3BhdGgtdG8tcmVnZXhwL3RyZWUvdjEuNy4w\">path-to-regexp (opens new window)</span>作为路径匹配引擎</strong></p>\n<p><strong>路由定义得越早，优先级就越高。</strong></p>\n<hr>\n<h4 id=\"嵌套路由-子路由\"><a href=\"#嵌套路由-子路由\" class=\"headerlink\" title=\"嵌套路由(子路由)\"></a>嵌套路由(子路由)</h4><p>在 <code>VueRouter</code> 的参数中使用 <code>children</code> 配置：</p>\n<pre><code class=\"js\">routes:[\n    &#123; \n        path: &#39;/home&#39;, \n        component: Home,\n        children:[\n            &#123; path: &#39;left&#39;, component: Left &#125;,\n            //基于上面的配置，当我们访问`/home`时，不会渲染任何东西，得添加一个空的子路由\n            &#123; path: &#39;&#39;, component: Home &#125;,\n        ]    \n    &#125;,\n]\n</code></pre>\n<p><strong>注意，以 <code>/</code> 开头的嵌套路径会被当作根路径，因此不要在子路由中用 <code>/</code></strong></p>\n<p>可套娃</p>\n<hr>\n<h4 id=\"编程式导航\"><a href=\"#编程式导航\" class=\"headerlink\" title=\"编程式导航\"></a>编程式导航</h4><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现</p>\n<p><code>router.push(location, onComplete?, onAbort?)</code></p>\n<p>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code>。</p>\n<table>\n<thead>\n<tr>\n<th>声明式</th>\n<th>编程式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>\n<td><code>router.push(...)</code></td>\n</tr>\n</tbody></table>\n<p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如</p>\n<pre><code class=\"js\">// 字符串\nrouter.push(&#39;home&#39;)\n\n// 对象\nrouter.push(&#123; path: &#39;home&#39; &#125;)\n\n// 命名的路由\nrouter.push(&#123; name: &#39;user&#39;, params: &#123; userId: &#39;123&#39; &#125;&#125;)\n\n// 带查询参数，变成 /register?plan=private\nrouter.push(&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;)\n</code></pre>\n<p><strong>注意：如果提供了<code>path</code>，<code>params</code>会被忽略，而查询参数<code>query</code>不会</strong></p>\n<pre><code class=\"js\">const userId = &#39;123&#39;\nrouter.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;) // -&gt; /user/123\nrouter.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123\n// 这里的 params 不生效\nrouter.push(&#123; path: &#39;/user&#39;, params: &#123; userId &#125;&#125;) // -&gt; /user\n</code></pre>\n<p>所以要么使用<code>name</code>加params要么<code>path</code>用模板字符串手写完整路径</p>\n<p>同样的规则也适用于 <code>router-link</code> 组件的 <code>to</code> 属性。</p>\n<p><code>router.replace(location, onComplete?, onAbort?)</code></p>\n<p>跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p>\n<table>\n<thead>\n<tr>\n<th>声明式</th>\n<th>编程式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td>\n<td><code>router.replace(...)</code></td>\n</tr>\n</tbody></table>\n<p><code>router.go(n)</code></p>\n<p>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 <code>window.history.go(n)</code>。</p>\n<hr>\n<h4 id=\"同级多视图\"><a href=\"#同级多视图\" class=\"headerlink\" title=\"同级多视图\"></a>同级多视图</h4><p>用命名视图和命名路由一一对应 components要带上s</p>\n<pre><code class=\"html\">&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;\n&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;\n&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt;\n</code></pre>\n<pre><code class=\"js\">const router = new VueRouter(&#123;\n  routes: [\n    &#123;\n      path: &#39;/&#39;,\n      components: &#123;\n        default: Foo,\n        a: Bar,\n        b: Baz\n      &#125;\n    &#125;\n  ]\n&#125;)\n</code></pre>\n<hr>\n<h4 id=\"重定向和别名\"><a href=\"#重定向和别名\" class=\"headerlink\" title=\"重定向和别名\"></a>重定向和别名</h4><p>当用户访问 <code>/a</code>时，URL 将会被替换成 <code>/b</code>，然后匹配路由为 <code>/b</code></p>\n<p>重定向也是通过 <code>routes</code> 配置来完成，下面例子是从 <code>/a</code> 重定向到 <code>/b</code>：</p>\n<pre><code class=\"js\">const router = new VueRouter(&#123;\n  routes: [\n    &#123; path: &#39;/a&#39;, redirect: &#39;/b&#39; &#125;\n    &#123; path: &#39;/a&#39;, redirect: &#123; name: &#39;foo&#39; &#125;&#125;\n    &#123; path: &#39;/a&#39;, redirect: to =&gt; &#123;\n      // 方法接收 目标路由 作为参数\n      // return 重定向的 字符串路径/路径对象\n    &#125;&#125;\n  ]\n&#125;)\n</code></pre>\n<p>问题？这里加导航守卫是a生效还是b生效</p>\n<p><code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，URL 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。即实际访问内容被替换问<code>/a</code></p>\n<pre><code class=\"js\">const router = new VueRouter(&#123;\n  routes: [\n    &#123; path: &#39;/a&#39;, component: A, alias: &#39;/b&#39; &#125;\n  ]\n&#125;)\n</code></pre>\n<hr>\n<h4 id=\"路由组件传参\"><a href=\"#路由组件传参\" class=\"headerlink\" title=\"路由组件传参\"></a>路由组件传参</h4><p>在组件中使用 <code>$route</code> 会使之与其对应路由形成高度耦合(即$route.params.id)，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。</p>\n<p>使用 <code>props</code> 将组件和路由解耦：</p>\n<pre><code class=\"js\">    &#123; path: &#39;/user/:id&#39;, component: User, props: true &#125;,\n    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：\n    &#123;\n      path: &#39;/user/:id&#39;,\n      components: &#123; default: User, sidebar: Sidebar &#125;,\n      props: &#123; default: true, sidebar: false &#125;\n    &#125;\n</code></pre>\n<hr>\n<h4 id=\"HTML5-History-模式\"><a href=\"#HTML5-History-模式\" class=\"headerlink\" title=\"HTML5 History 模式\"></a>HTML5 History 模式</h4><p><code>vue-router</code> 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</p>\n<p>如果不想要很丑的 hash，我们可以用路由的 <strong>history 模式</strong>，这种模式充分利用 <code>history.pushState</code> API 来完成 URL 跳转而无须重新加载页面。</p>\n<pre><code class=\"js\">const router = new VueRouter(&#123;\n  mode: &#39;history&#39;,\n  routes: [...]\n&#125;)\n</code></pre>\n<hr>\n<h3 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h3><h4 id=\"导航守卫\"><a href=\"#导航守卫\" class=\"headerlink\" title=\"导航守卫\"></a>导航守卫</h4><p>记住<strong>参数或查询的改变并不会触发进入/离开的导航守卫</strong>。你可以通过<strong>watch<code>$route</code>对象</strong>来应对这些变化，或使用 <code>beforeRouteUpdate</code> 的组件内守卫</p>\n<p><strong>全局前置守卫</strong></p>\n<pre><code class=\"js\">router.beforeEach((to, from, next) =&gt; &#123;\n  // ...\n&#125;)\n</code></pre>\n<p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 <strong>等待中</strong>。即跳转会等到所有守卫结束后进行</p>\n<p>每个守卫方法接收三个参数：</p>\n<ul>\n<li><p><strong><code>to: Route</code></strong>: 即将要进入的目标 路由对象</p>\n</li>\n<li><p><strong><code>from: Route</code></strong>: 当前导航正要离开的路由</p>\n</li>\n<li><p><strong><code>next: Function</code></strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。</p>\n<ul>\n<li><strong><code>next()</code></strong>: 进行管道中的下一个钩子，即放行。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> (确认的)。</li>\n<li><strong><code>next(false)</code></strong>: 中断当前的导航，即不动。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li>\n<li><strong><code>next(&#39;/&#39;)</code> 或者 <code>next(&#123; path: &#39;/&#39; &#125;)</code></strong>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <a href=\"https://router.vuejs.org/zh/api/#to\"><code>router-link</code> 的 <code>to</code> prop</a> 或 <a href=\"https://router.vuejs.org/zh/api/#router-push\"><code>router.push</code></a> 中的选项。</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意，要确保<code>next</code>函数至少能够调用一次，也可以调用多次，但是只能在逻辑路径不重叠的情况下</strong></p>\n<p><strong>全局解析守卫</strong></p>\n<p><code>router.beforeResolve</code>和 <code>router.beforeEach</code> 类似，区别是在导航被确认之前，<strong>同时在所有组件内守卫和异步路由组件被解析之后</strong>，解析守卫就被调用。即在跳转前最后调用</p>\n<p><strong>全局后置钩子</strong></p>\n<p>这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p>\n<pre><code class=\"js\">router.afterEach((to, from) =&gt; &#123;\n  // ...\n&#125;)\n</code></pre>\n<p><strong>路由独享的守卫</strong></p>\n<p>可以在路由配置上直接定义 <code>beforeEnter</code> 守卫，和全局前置守卫的方法参数是一样的：</p>\n<pre><code class=\"js\">const router = new VueRouter(&#123;\n  routes: [\n    &#123;\n      path: &#39;/foo&#39;,\n      component: Foo,\n      beforeEnter: (to, from, next) =&gt; &#123;\n        // ...\n      &#125;\n    &#125;\n  ]\n&#125;)\n</code></pre>\n<p><strong>组件内的守卫</strong></p>\n<p>你可以在路由组件内直接定义以下路由导航守卫：</p>\n<ul>\n<li><code>beforeRouteEnter</code></li>\n<li><code>beforeRouteUpdate</code></li>\n<li><code>beforeRouteLeave</code></li>\n</ul>\n<pre><code class=\"js\">&lt;script&gt;\nexport default &#123;\n  // 和data同级\n  data()&#123;&#125;,  \n  beforeRouteEnter(to, from, next) &#123;\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不！能！获取组件实例 `this`\n    // 因为当守卫执行前，组件实例还没被创建\n  &#125;,\n  beforeRouteUpdate(to, from, next) &#123;\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  &#125;,\n  beforeRouteLeave(to, from, next) &#123;\n    // 导航离开该组件的对应路由时调用\n    // 可以访问组件实例 `this`\n  &#125;\n&#125;\n&lt;/script&gt;\n</code></pre>\n<p><strong>完整的导航解析流程</strong></p>\n<ol>\n<li>导航被触发。</li>\n<li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li>\n<li>调用全局的 <code>beforeEach</code> 守卫。</li>\n<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫。</li>\n<li>在路由配置里调用 <code>beforeEnter</code>。</li>\n<li>解析异步路由组件。</li>\n<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>\n<li>调用全局的 <code>beforeResolve</code> 守卫。</li>\n<li>导航被确认。</li>\n<li>调用全局的 <code>afterEach</code> 钩子。</li>\n<li>触发 DOM 更新。</li>\n<li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li>\n</ol>\n<hr>\n<h4 id=\"路由元信息\"><a href=\"#路由元信息\" class=\"headerlink\" title=\"路由元信息\"></a>路由元信息</h4><p>定义路由的时候可以配置 <code>meta</code> 字段：</p>\n<pre><code class=\"js\">&#123;\n    path: &#39;bar&#39;,\n    component: Bar,\n    // a meta field\n    meta: &#123; requiresAuth: true &#125;\n&#125;\n</code></pre>\n<p>那么如何访问这个 <code>meta</code> 字段呢？</p>\n<p>一个路由匹配到的所有路由记录会暴露为 <code>$route</code> 对象 (还有在导航守卫中的路由对象) 的 <code>$route.matched</code> 数组。因此，我们需要遍历 <code>$route.matched</code> 来检查路由记录中的 <code>meta</code> 字段。<code>$route.matched.some(record =&gt; record.meta.requiresAuth)</code></p>\n<pre><code class=\"js\">router.beforeEach((to, from, next) =&gt; &#123;\n  if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123;\n    // this route requires auth, check if logged in\n    // if not, redirect to login page.\n    if (!auth.loggedIn()) &#123;\n      next(&#123;\n        path: &#39;/login&#39;,\n        query: &#123; redirect: to.fullPath &#125;\n      &#125;)\n    &#125; else &#123;\n      next()\n    &#125;\n  &#125; else &#123;\n    next() // 确保一定要调用 next()\n  &#125;\n&#125;)\n</code></pre>\n<hr>\n<h4 id=\"过渡动画\"><a href=\"#过渡动画\" class=\"headerlink\" title=\"过渡动画\"></a>过渡动画</h4><p><code>&lt;router-view&gt;</code> 是基本的动态组件，所以我们可以用 <code>&lt;transition&gt;</code> 组件给它添加一些过渡效果：</p>\n<pre><code class=\"html\">&lt;transition&gt;\n  &lt;router-view&gt;&lt;/router-view&gt;\n&lt;/transition&gt;\n</code></pre>\n<p><strong>单个路由的过渡</strong></p>\n<p>上面的用法会给所有路由设置一样的过渡效果，如果你想让每个路由组件有各自的过渡效果，可以在各路由组件内使用 <code>&lt;transition&gt;</code> 并设置不同的 name</p>\n<pre><code class=\"js\">&lt;transition name=&quot;slide&quot;&gt;\n    &lt;div class=&quot;foo&quot;&gt;...&lt;/div&gt;\n&lt;/transition&gt;\n&lt;transition name=&quot;fade&quot;&gt;\n    &lt;div class=&quot;bar&quot;&gt;...&lt;/div&gt;\n&lt;/transition&gt;\n</code></pre>\n<p><strong>基于路由的动态过渡</strong></p>\n<p>还可以基于当前路由与目标路由的变化关系，动态设置过渡效果：</p>\n<pre><code class=\"html\">&lt;!-- 使用动态的 transition name --&gt;\n&lt;transition :name=&quot;transitionName&quot;&gt;\n  &lt;router-view&gt;&lt;/router-view&gt;\n&lt;/transition&gt;\n</code></pre>\n<pre><code class=\"js\">// 接着在父组件内\n// watch $route 决定使用哪种过渡\nwatch: &#123;\n  &#39;$route&#39; (to, from) &#123;\n    const toDepth = to.path.split(&#39;/&#39;).length\n    const fromDepth = from.path.split(&#39;/&#39;).length\n    this.transitionName = toDepth &lt; fromDepth ? &#39;slide-right&#39; : &#39;slide-left&#39;\n  &#125;\n&#125;\n</code></pre>\n<hr>\n<h4 id=\"数据获取\"><a href=\"#数据获取\" class=\"headerlink\" title=\"数据获取\"></a>数据获取</h4><p>在进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：</p>\n<ul>\n<li><strong>导航完成之后获取</strong>：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。</li>\n<li><strong>导航完成之前获取</strong>：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。</li>\n</ul>\n<p><strong>导航完成后获取数据</strong></p>\n<p>当使用这种方式时，会马上导航和渲染组件，然后在组件的 <code>created</code> 钩子中获取数据。这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。</p>\n<pre><code class=\"js\">export default &#123;\n  data () &#123;\n    return &#123;\n      loading: false,\n      post: null,\n      error: null\n    &#125;\n  &#125;,\n  created () &#123;\n    // 组件创建完后获取数据，\n    // 此时 data 已经被 observed 了\n    this.fetchData()\n  &#125;,\n  watch: &#123;\n    // 如果路由有变化，会再次执行该方法\n    &#39;$route&#39;: &#39;fetchData&#39;\n  &#125;,\n  methods: &#123;\n    fetchData () &#123;\n      this.error = this.post = null\n      this.loading = true\n      // replace getPost with your data fetching util / API wrapper\n      getPost(this.$route.params.id, (err, post) =&gt; &#123;\n        this.loading = false\n        if (err) &#123;\n          this.error = err.toString()\n        &#125; else &#123;\n          this.post = post\n        &#125;\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p><strong>在导航完成前获取数据</strong></p>\n<p>通过这种方式，我们在导航转入新的路由前获取数据，会在原页面短暂停留。我们可以在接下来的组件的 <code>beforeRouteEnter</code> 守卫中获取数据，当数据获取成功后只调用 <code>next</code> 方法。</p>\n<pre><code class=\"js\">export default &#123;\n  data () &#123;\n    return &#123;\n      post: null,\n      error: null\n    &#125;\n  &#125;,\n  beforeRouteEnter (to, from, next) &#123;\n    getPost(to.params.id, (err, post) =&gt; &#123;\n      next(vm =&gt; vm.setData(err, post))\n    &#125;)\n  &#125;,\n  // 路由改变前，组件就已经渲染完了\n  // 逻辑稍稍不同\n  beforeRouteUpdate (to, from, next) &#123;\n    this.post = null\n    getPost(to.params.id, (err, post) =&gt; &#123;\n      this.setData(err, post)\n      next()\n    &#125;)\n  &#125;,\n  methods: &#123;\n    setData (err, post) &#123;\n      if (err) &#123;\n        this.error = err.toString()\n      &#125; else &#123;\n        this.post = post\n      &#125;\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p>在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条或者别的指示。如果数据获取失败，同样有必要展示一些全局的错误提醒。</p>\n<hr>\n<h4 id=\"滚动行为（不明白）\"><a href=\"#滚动行为（不明白）\" class=\"headerlink\" title=\"滚动行为（不明白）\"></a>滚动行为（不明白）</h4><p>使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 <code>vue-router</code> 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。</p>\n<p><strong>注意: 这个功能只在支持 <code>history.pushState</code> 的浏览器中可用。</strong></p>\n<p>当创建一个 Router 实例，你可以提供一个 <code>scrollBehavior</code> 方法：</p>\n<pre><code class=\"js\">const router = new VueRouter(&#123;\n  routes: [...],\n  scrollBehavior (to, from, savedPosition) &#123;\n    // return 期望滚动到哪个的位置\n  &#125;\n&#125;)\n</code></pre>\n<p><code>scrollBehavior</code> 方法接收 <code>to</code> 和 <code>from</code> 路由对象。第三个参数 <code>savedPosition</code> 当且仅当 <code>popstate</code> 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。</p>\n<p>这个方法返回滚动位置的对象信息，长这样：</p>\n<ul>\n<li><code>&#123; x: number, y: number &#125;</code></li>\n<li><code>&#123; selector: string, offset? : &#123; x: number, y: number &#125;&#125;</code> (offset 只在 2.6.0+ 支持)</li>\n</ul>\n<p>如果返回一个 falsy (译者注：falsy 不是 <code>false</code>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9GYWxzeQ==\">参考这里 (opens new window)</span>)的值，或者是一个空对象，那么不会发生滚动。</p>\n<p>举例：</p>\n<pre><code class=\"js\">scrollBehavior (to, from, savedPosition) &#123;\n  return &#123; x: 0, y: 0 &#125;\n&#125;\n</code></pre>\n<p>对于所有路由导航，简单地让页面滚动到顶部。</p>\n<p>返回 <code>savedPosition</code>，在按下 后退/前进 按钮时，就会像浏览器的原生表现那样：</p>\n<pre><code class=\"js\">scrollBehavior (to, from, savedPosition) &#123;\n  if (savedPosition) &#123;\n    return savedPosition\n  &#125; else &#123;\n    return &#123; x: 0, y: 0 &#125;\n  &#125;\n&#125;\n</code></pre>\n<p>如果你要模拟“滚动到锚点”的行为：</p>\n<pre><code class=\"js\">scrollBehavior (to, from, savedPosition) &#123;\n  if (to.hash) &#123;\n    return &#123;\n      selector: to.hash\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p>查看完整例子请<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1yb3V0ZXIvYmxvYi9kZXYvZXhhbXBsZXMvc2Nyb2xsLWJlaGF2aW9yL2FwcC5qcw==\">移步这里</span></p>\n<p><strong>异步滚动</strong></p>\n<blockquote>\n<p>2.8.0 新增</p>\n</blockquote>\n<p>你也可以返回一个 Promise 来得出预期的位置描述：</p>\n<pre><code class=\"js\">scrollBehavior (to, from, savedPosition) &#123;\n  return new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n      resolve(&#123; x: 0, y: 0 &#125;)\n    &#125;, 500)\n  &#125;)\n&#125;\n</code></pre>\n<p>将其挂载到从页面级别的过渡组件的事件上，令其滚动行为和页面过渡一起良好运行是可能的。但是考虑到用例的多样性和复杂性，我们仅提供这个原始的接口，以支持不同用户场景的具体实现。</p>\n<p><strong>平滑滚动</strong></p>\n<p>只需将 <code>behavior</code> 选项添加到 <code>scrollBehavior</code> 内部返回的对象中，就可以为<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Njcm9sbFRvT3B0aW9ucy9iZWhhdmlvcg==\">支持它的浏览器 (opens new window)</span>启用原生平滑滚动：</p>\n<pre><code class=\"js\">scrollBehavior (to, from, savedPosition) &#123;\n  if (to.hash) &#123;\n    return &#123;\n      selector: to.hash,\n      behavior: &#39;smooth&#39;,\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<hr>\n<h4 id=\"路由懒加载（不明白）\"><a href=\"#路由懒加载（不明白）\" class=\"headerlink\" title=\"路由懒加载（不明白）\"></a>路由懒加载（不明白）</h4><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了</p>\n<pre><code>// 将\n// import UserDetails from &#39;./views/UserDetails&#39;\n// 替换成\nconst UserDetails = () =&gt; import(&#39;./views/UserDetails&#39;)\n\nconst router = createRouter(&#123;\n  // ...\n  routes: [&#123; path: &#39;/users/:id&#39;, component: UserDetails &#125;],\n&#125;)\n</code></pre>\n<p>结合 Vue 的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy1keW5hbWljLWFzeW5jLmh0bWwjJUU1JUJDJTgyJUU2JUFEJUE1JUU3JUJCJTg0JUU0JUJCJUI2\">异步组件 (opens new window)</span>和 Webpack 的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2Mud2VicGFjay1jaGluYS5vcmcvZ3VpZGVzL2NvZGUtc3BsaXR0aW5nLWFzeW5jLyNyZXF1aXJlLWVuc3VyZS0v\">代码分割功能 (opens new window)</span>，轻松实现路由组件的懒加载。</p>\n<p>首先，可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)：</p>\n<pre><code class=\"js\">const Foo = () =&gt;\n  Promise.resolve(&#123;\n    /* 组件定义对象 */\n  &#125;)\n</code></pre>\n<p>第二，在 Webpack 2 中，我们可以使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZHluYW1pYy1pbXBvcnQ=\">动态 import (opens new window)</span>语法来定义代码分块点 (split point)：</p>\n<pre><code class=\"js\">import(&#39;./Foo.vue&#39;) // 返回 Promise\n</code></pre>\n<p>结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件。</p>\n<pre><code class=\"js\">const Foo = () =&gt; import(&#39;./Foo.vue&#39;)\n</code></pre>\n<p>在路由配置中什么都不需要改变，只需要像往常一样使用 <code>Foo</code>：</p>\n<pre><code class=\"js\">const router = new VueRouter(&#123;\n  routes: [&#123; path: &#39;/foo&#39;, component: Foo &#125;]\n&#125;)\n</code></pre>\n<p><strong>把组件按组分块</strong></p>\n<p>有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9ndWlkZXMvY29kZS1zcGxpdHRpbmctcmVxdWlyZS8jY2h1bmtuYW1l\">命名 chunk (opens new window)</span>，一个特殊的注释语法来提供 chunk name (需要 Webpack &gt; 2.4)。</p>\n<pre><code class=\"js\">const Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Foo.vue&#39;)\nconst Bar = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Bar.vue&#39;)\nconst Baz = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Baz.vue&#39;)\n</code></pre>\n<p>Webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。</p>\n<p>主要参考Vue Router官方文档</p>\n",
            "tags": [
                "前端",
                "Vue",
                "前端",
                "Vue"
            ]
        },
        {
            "id": "https://1234cas.github.io/1234cas.github.io/qianduan/ES6/ES6%E4%B8%8B/",
            "url": "https://1234cas.github.io/1234cas.github.io/qianduan/ES6/ES6%E4%B8%8B/",
            "title": "ES6下",
            "date_published": "2022-03-27T08:52:28.924Z",
            "content_html": "<h3 id=\"14、-Proxy\"><a href=\"#14、-Proxy\" class=\"headerlink\" title=\"14、 Proxy\"></a>14、 Proxy</h3><hr>\n<h4 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h4><p><strong>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</strong></p>\n<p><strong>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</strong></p>\n<pre><code class=\"javascript\">var obj = new Proxy(&#123;&#125;, &#123;\n  get: function (target, propKey, receiver) &#123;\n    console.log(`getting $&#123;propKey&#125;!`);\n    return Reflect.get(target, propKey, receiver);\n  &#125;,\n  set: function (target, propKey, value, receiver) &#123;\n    console.log(`setting $&#123;propKey&#125;!`);\n    return Reflect.set(target, propKey, value, receiver);\n  &#125;\n&#125;);\n</code></pre>\n<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p>\n<pre><code class=\"javascript\">obj.count = 1\n//  setting count!\n++obj.count\n//  getting count!\n//  setting count!\n//  2\n</code></pre>\n<p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p>\n<p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>\n<pre><code class=\"javascript\">var proxy = new Proxy(target, handler);\n</code></pre>\n<p><strong>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</strong></p>\n<p>下面是另一个拦截读取属性行为的例子。</p>\n<pre><code class=\"javascript\">var proxy = new Proxy(&#123;&#125;, &#123;\n  get: function(target, propKey) &#123;\n    return 35;\n  &#125;\n&#125;);\n\nproxy.time // 35\nproxy.name // 35\nproxy.title // 35\n</code></pre>\n<p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p>\n<p><strong>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</strong></p>\n<p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p>\n<pre><code class=\"javascript\">var target = &#123;&#125;;\nvar handler = &#123;&#125;;\nvar proxy = new Proxy(target, handler);\nproxy.a = &#39;b&#39;;\ntarget.a // &quot;b&quot;\n</code></pre>\n<p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>proxy</code>就等同于访问<code>target</code>。</p>\n<p>一个技巧是将 Proxy 对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。</p>\n<pre><code class=\"javascript\">var object = &#123; proxy: new Proxy(target, handler) &#125;;\n</code></pre>\n<p>Proxy 实例也可以作为其他对象的原型对象。</p>\n<pre><code class=\"javascript\">var proxy = new Proxy(&#123;&#125;, &#123;\n  get: function(target, propKey) &#123;\n    return 35;\n  &#125;\n&#125;);\n\nlet obj = Object.create(proxy);\nobj.time // 35\n</code></pre>\n<p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p>\n<p>同一个拦截器函数，可以设置拦截多个操作。</p>\n<pre><code class=\"javascript\">var handler = &#123;\n  get: function(target, name) &#123;\n    if (name === &#39;prototype&#39;) &#123;\n      return Object.prototype;\n    &#125;\n    return &#39;Hello, &#39; + name;\n  &#125;,\n\n  apply: function(target, thisBinding, args) &#123;\n    return args[0];\n  &#125;,\n\n  construct: function(target, args) &#123;\n    return &#123;value: args[1]&#125;;\n  &#125;\n&#125;;\n\nvar fproxy = new Proxy(function(x, y) &#123;\n  return x + y;\n&#125;, handler);\n\nfproxy(1, 2) // 1\nnew fproxy(1, 2) // &#123;value: 2&#125;\nfproxy.prototype === Object.prototype // true\nfproxy.foo === &quot;Hello, foo&quot; // true\n</code></pre>\n<p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>\n<p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p>\n<ul>\n<li>**get(target, propKey, receiver)**：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li>\n<li>**set(target, propKey, value, receiver)**：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li>\n<li>**has(target, propKey)**：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li>\n<li>**deleteProperty(target, propKey)**：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li>\n<li>**ownKeys(target)**：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li>\n<li>**getOwnPropertyDescriptor(target, propKey)**：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li>\n<li>**defineProperty(target, propKey, propDesc)**：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li>\n<li>**preventExtensions(target)**：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li>\n<li>**getPrototypeOf(target)**：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li>\n<li>**isExtensible(target)**：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li>\n<li>**setPrototypeOf(target, proto)**：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>\n<li>**apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li>\n<li>**construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li>\n</ul>\n<hr>\n<h4 id=\"2-Proxy-实例的方法\"><a href=\"#2-Proxy-实例的方法\" class=\"headerlink\" title=\"2. Proxy 实例的方法\"></a>2. Proxy 实例的方法</h4><p><strong>get</strong>()</p>\n<p><strong><code>get</code>方法用于拦截某个属性的读取操作</strong>，可以接受三个参数，<strong>依次为目标对象、属性名和 proxy 实例本身</strong>（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p>\n<p><code>get</code>方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p>\n<pre><code class=\"javascript\">var person = &#123;\n  name: &quot;张三&quot;\n&#125;;\n\nvar proxy = new Proxy(person, &#123;\n  get: function(target, propKey) &#123;\n    if (propKey in target) &#123;\n      return target[propKey];\n    &#125; else &#123;\n      throw new ReferenceError(&quot;Prop name \\&quot;&quot; + propKey + &quot;\\&quot; does not exist.&quot;);\n    &#125;\n  &#125;\n&#125;);\n\nproxy.name // &quot;张三&quot;\nproxy.age // 抛出一个错误\n</code></pre>\n<p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回<code>undefined</code>。</p>\n<p><code>get</code>方法可以继承。</p>\n<pre><code class=\"javascript\">let proto = new Proxy(&#123;&#125;, &#123;\n  get(target, propertyKey, receiver) &#123;\n    console.log(&#39;GET &#39; + propertyKey);\n    return target[propertyKey];\n  &#125;\n&#125;);\n\nlet obj = Object.create(proto);\nobj.foo // &quot;GET foo&quot;\n</code></pre>\n<p>上面代码中，拦截操作定义在<code>Prototype</code>对象上面，所以如果读取<code>obj</code>对象继承的属性时，拦截会生效。</p>\n<p>下面的例子使用<code>get</code>拦截，实现数组读取负数的索引。</p>\n<pre><code class=\"javascript\">function createArray(...elements) &#123;\n  let handler = &#123;\n    get(target, propKey, receiver) &#123;\n      let index = Number(propKey);\n      if (index &lt; 0) &#123;\n        propKey = String(target.length + index);\n      &#125;\n      return Reflect.get(target, propKey, receiver);\n    &#125;\n  &#125;;\n\n  let target = [];\n  target.push(...elements);\n  return new Proxy(target, handler);\n&#125;\n\nlet arr = createArray(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);\narr[-1] // c\n</code></pre>\n<p>上面代码中，数组的位置参数是<code>-1</code>，就会输出数组的倒数第一个成员。</p>\n<p><strong>利用 Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</strong></p>\n<pre><code class=\"javascript\">var pipe = function (value) &#123;\n  var funcStack = [];\n  var oproxy = new Proxy(&#123;&#125; , &#123;\n    get : function (pipeObject, fnName) &#123;\n      if (fnName === &#39;get&#39;) &#123;\n        return funcStack.reduce(function (val, fn) &#123;\n          return fn(val);\n        &#125;,value);\n      &#125;\n      funcStack.push(window[fnName]);\n      return oproxy;\n    &#125;\n  &#125;);\n\n  return oproxy;\n&#125;\n\nvar double = n =&gt; n * 2;\nvar pow    = n =&gt; n * n;\nvar reverseInt = n =&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;\n\npipe(3).double.pow.reverseInt.get; // 63\n</code></pre>\n<p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</p>\n<p>下面的例子则是利用<code>get</code>拦截，实现一个生成各种 DOM 节点的通用函数<code>dom</code>。</p>\n<pre><code class=\"javascript\">const dom = new Proxy(&#123;&#125;, &#123;\n  get(target, property) &#123;\n    return function(attrs = &#123;&#125;, ...children) &#123;\n      const el = document.createElement(property);\n      for (let prop of Object.keys(attrs)) &#123;\n        el.setAttribute(prop, attrs[prop]);\n      &#125;\n      for (let child of children) &#123;\n        if (typeof child === &#39;string&#39;) &#123;\n          child = document.createTextNode(child);\n        &#125;\n        el.appendChild(child);\n      &#125;\n      return el;\n    &#125;\n  &#125;\n&#125;);\n\nconst el = dom.div(&#123;&#125;,\n  &#39;Hello, my name is &#39;,\n  dom.a(&#123;href: &#39;//example.com&#39;&#125;, &#39;Mark&#39;),\n  &#39;. I like:&#39;,\n  dom.ul(&#123;&#125;,\n    dom.li(&#123;&#125;, &#39;The web&#39;),\n    dom.li(&#123;&#125;, &#39;Food&#39;),\n    dom.li(&#123;&#125;, &#39;…actually that\\&#39;s it&#39;)\n  )\n);\n\ndocument.body.appendChild(el);\n</code></pre>\n<p>下面是一个<code>get</code>方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</p>\n<pre><code class=\"javascript\">const proxy = new Proxy(&#123;&#125;, &#123;\n  get: function(target, key, receiver) &#123;\n    return receiver;\n  &#125;\n&#125;);\nproxy.getReceiver === proxy // true\n</code></pre>\n<p>上面代码中，**<code>proxy</code>对象的<code>getReceiver</code>属性是由<code>proxy</code>对象提供的，所以<code>receiver</code>指向<code>proxy</code>对象。**</p>\n<pre><code class=\"javascript\">const proxy = new Proxy(&#123;&#125;, &#123;\n  get: function(target, key, receiver) &#123;\n    return receiver;\n  &#125;\n&#125;);\n\nconst d = Object.create(proxy);\nd.a === d // true\n</code></pre>\n<p>上面代码中，<code>d</code>对象本身没有<code>a</code>属性，所以读取<code>d.a</code>的时候，会去<code>d</code>的原型<code>proxy</code>对象找。这时，<code>receiver</code>就指向<code>d</code>，代表原始的读操作所在的那个对象。</p>\n<p><strong>如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</strong></p>\n<pre><code class=\"javascript\">const target = Object.defineProperties(&#123;&#125;, &#123;\n  foo: &#123;\n    value: 123,\n    writable: false,\n    configurable: false\n  &#125;,\n&#125;);\n\nconst handler = &#123;\n  get(target, propKey) &#123;\n    return &#39;abc&#39;;\n  &#125;\n&#125;;\n\nconst proxy = new Proxy(target, handler);\n\nproxy.foo\n// TypeError: Invariant check failed\n</code></pre>\n<hr>\n<p><strong>set()</strong></p>\n<p><strong><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</strong></p>\n<p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求。</p>\n<pre><code class=\"javascript\">let validator = &#123;\n  set: function(obj, prop, value) &#123;\n    if (prop === &#39;age&#39;) &#123;\n      if (!Number.isInteger(value)) &#123;\n        throw new TypeError(&#39;The age is not an integer&#39;);\n      &#125;\n      if (value &gt; 200) &#123;\n        throw new RangeError(&#39;The age seems invalid&#39;);\n      &#125;\n    &#125;\n\n    // 对于满足条件的 age 属性以及其他属性，直接保存\n    obj[prop] = value;\n    return true;\n  &#125;\n&#125;;\n\nlet person = new Proxy(&#123;&#125;, validator);\n\nperson.age = 100;\n\nperson.age // 100\nperson.age = &#39;young&#39; // 报错\nperson.age = 300 // 报错\n</code></pre>\n<p>上面代码中，由于设置了存值函数<code>set</code>，任何不符合要求的<code>age</code>属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。<strong>利用<code>set</code>方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</strong></p>\n<p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合<code>get</code>和<code>set</code>方法，就可以做到防止这些内部属性被外部读写。</p>\n<pre><code class=\"javascript\">const handler = &#123;\n  get (target, key) &#123;\n    invariant(key, &#39;get&#39;);\n    return target[key];\n  &#125;,\n  set (target, key, value) &#123;\n    invariant(key, &#39;set&#39;);\n    target[key] = value;\n    return true;\n  &#125;\n&#125;;\nfunction invariant (key, action) &#123;\n  if (key[0] === &#39;_&#39;) &#123;\n    throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`);\n  &#125;\n&#125;\nconst target = &#123;&#125;;\nconst proxy = new Proxy(target, handler);\nproxy._prop\n// Error: Invalid attempt to get private &quot;_prop&quot; property\nproxy._prop = &#39;c&#39;\n// Error: Invalid attempt to set private &quot;_prop&quot; property\n</code></pre>\n<p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p>\n<p>下面是<code>set</code>方法第四个参数的例子。</p>\n<pre><code class=\"javascript\">const handler = &#123;\n  set: function(obj, prop, value, receiver) &#123;\n    obj[prop] = receiver;\n    return true;\n  &#125;\n&#125;;\nconst proxy = new Proxy(&#123;&#125;, handler);\nproxy.foo = &#39;bar&#39;;\nproxy.foo === proxy // true\n</code></pre>\n<p>上面代码中，<code>set</code>方法的第四个参数<code>receiver</code>，指的是原始的操作行为所在的那个对象，一般情况下是<code>proxy</code>实例本身，请看下面的例子。</p>\n<pre><code class=\"javascript\">const handler = &#123;\n  set: function(obj, prop, value, receiver) &#123;\n    obj[prop] = receiver;\n    return true;\n  &#125;\n&#125;;\nconst proxy = new Proxy(&#123;&#125;, handler);\nconst myObj = &#123;&#125;;\nObject.setPrototypeOf(myObj, proxy);\n\nmyObj.foo = &#39;bar&#39;;\nmyObj.foo === myObj // true\n</code></pre>\n<p>上面代码中，设置<code>myObj.foo</code>属性的值时，<code>myObj</code>并没有<code>foo</code>属性，因此引擎会到<code>myObj</code>的原型链去找<code>foo</code>属性。<code>myObj</code>的原型对象<code>proxy</code>是一个 Proxy 实例，设置它的<code>foo</code>属性会触发<code>set</code>方法。这时，第四个参数<code>receiver</code>就指向原始赋值行为所在的对象<code>myObj</code>。</p>\n<p><strong>注意，如果目标对象自身的某个属性不可写，那么<code>set</code>方法将不起作用。</strong></p>\n<pre><code class=\"javascript\">const obj = &#123;&#125;;\nObject.defineProperty(obj, &#39;foo&#39;, &#123;\n  value: &#39;bar&#39;,\n  writable: false\n&#125;);\n\nconst handler = &#123;\n  set: function(obj, prop, value, receiver) &#123;\n    obj[prop] = &#39;baz&#39;;\n    return true;\n  &#125;\n&#125;;\n\nconst proxy = new Proxy(obj, handler);\nproxy.foo = &#39;baz&#39;;\nproxy.foo // &quot;bar&quot;\n</code></pre>\n<p>上面代码中，<code>obj.foo</code>属性不可写，Proxy 对这个属性的<code>set</code>代理将不会生效。</p>\n<p><strong>注意，<code>set</code>代理应当返回一个布尔值。严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错。</strong></p>\n<pre><code class=\"javascript\">&#39;use strict&#39;;\nconst handler = &#123;\n  set: function(obj, prop, value, receiver) &#123;\n    obj[prop] = receiver;\n    // 无论有没有下面这一行，都会报错\n    return false;\n  &#125;\n&#125;;\nconst proxy = new Proxy(&#123;&#125;, handler);\nproxy.foo = &#39;bar&#39;;\n// TypeError: &#39;set&#39; on proxy: trap returned falsish for property &#39;foo&#39;\n</code></pre>\n<p>上面代码中，严格模式下，<code>set</code>代理返回<code>false</code>或者<code>undefined</code>，都会报错。</p>\n<hr>\n<p><strong>apply()</strong></p>\n<p><strong><code>apply</code>方法拦截函数的调用、<code>call</code>和<code>apply</code>操作。</strong>**</p>\n<p><strong><code>apply</code>方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</strong></p>\n<pre><code class=\"javascript\">var handler = &#123;\n  apply (target, ctx, args) &#123;\n    return Reflect.apply(...arguments);\n  &#125;\n&#125;;\n</code></pre>\n<p>下面是一个例子。</p>\n<pre><code class=\"javascript\">var target = function () &#123; return &#39;I am the target&#39;; &#125;;\nvar handler = &#123;\n  apply: function () &#123;\n    return &#39;I am the proxy&#39;;\n  &#125;\n&#125;;\n\nvar p = new Proxy(target, handler);\n\np()\n// &quot;I am the proxy&quot;\n</code></pre>\n<p>上面代码中，变量<code>p</code>是 Proxy 的实例，当它作为函数调用时（<code>p()</code>），就会被<code>apply</code>方法拦截，返回一个字符串。</p>\n<p>下面是另外一个例子。</p>\n<pre><code class=\"javascript\">var twice = &#123;\n  apply (target, ctx, args) &#123;\n    return Reflect.apply(...arguments) * 2;\n  &#125;\n&#125;;\nfunction sum (left, right) &#123;\n  return left + right;\n&#125;;\nvar proxy = new Proxy(sum, twice);\nproxy(1, 2) // 6\nproxy.call(null, 5, 6) // 22\nproxy.apply(null, [7, 8]) // 30\n</code></pre>\n<p>上面代码中，每当执行<code>proxy</code>函数（直接调用或<code>call</code>和<code>apply</code>调用），就会被<code>apply</code>方法拦截。</p>\n<p>另外，直接调用<code>Reflect.apply</code>方法，也会被拦截。</p>\n<pre><code class=\"javascript\">Reflect.apply(proxy, null, [9, 10]) // 38\n</code></pre>\n<hr>\n<p><strong>has()</strong></p>\n<p><strong><code>has()</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</strong></p>\n<p><strong><code>has()</code>方法可以接受两个参数，分别是目标对象、需查询的属性名。</strong></p>\n<p>下面的例子使用<code>has()</code>方法隐藏某些属性，不被<code>in</code>运算符发现。</p>\n<pre><code class=\"javascript\">var handler = &#123;\n  has (target, key) &#123;\n    if (key[0] === &#39;_&#39;) &#123;\n      return false;\n    &#125;\n    return key in target;\n  &#125;\n&#125;;\nvar target = &#123; _prop: &#39;foo&#39;, prop: &#39;foo&#39; &#125;;\nvar proxy = new Proxy(target, handler);\n&#39;_prop&#39; in proxy // false\n</code></pre>\n<p>上面代码中，如果原对象的属性名的第一个字符是下划线，<code>proxy.has()</code>就会返回<code>false</code>，从而不会被<code>in</code>运算符发现。</p>\n<p><strong>如果原对象不可配置或者禁止扩展，这时<code>has()</code>拦截会报错。</strong></p>\n<pre><code class=\"javascript\">var obj = &#123; a: 10 &#125;;\nObject.preventExtensions(obj);\n\nvar p = new Proxy(obj, &#123;\n  has: function(target, prop) &#123;\n    return false;\n  &#125;\n&#125;);\n\n&#39;a&#39; in p // TypeError is thrown\n</code></pre>\n<p>上面代码中，<code>obj</code>对象禁止扩展，结果使用<code>has</code>拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则<code>has()</code>方法就不得“隐藏”（即返回<code>false</code>）目标对象的该属性。</p>\n<p><strong>值得注意的是，<code>has()</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has()</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</strong></p>\n<p><strong>另外，虽然<code>for...in</code>循环也用到了<code>in</code>运算符，但是<code>has()</code>拦截对<code>for...in</code>循环不生效。</strong></p>\n<pre><code class=\"javascript\">let stu1 = &#123;name: &#39;张三&#39;, score: 59&#125;;\nlet stu2 = &#123;name: &#39;李四&#39;, score: 99&#125;;\n\nlet handler = &#123;\n  has(target, prop) &#123;\n    if (prop === &#39;score&#39; &amp;&amp; target[prop] &lt; 60) &#123;\n      console.log(`$&#123;target.name&#125; 不及格`);\n      return false;\n    &#125;\n    return prop in target;\n  &#125;\n&#125;\n\nlet oproxy1 = new Proxy(stu1, handler);\nlet oproxy2 = new Proxy(stu2, handler);\n\n&#39;score&#39; in oproxy1\n// 张三 不及格\n// false\n\n&#39;score&#39; in oproxy2\n// true\n\nfor (let a in oproxy1) &#123;\n  console.log(oproxy1[a]);\n&#125;\n// 张三\n// 59\n\nfor (let b in oproxy2) &#123;\n  console.log(oproxy2[b]);\n&#125;\n// 李四\n// 99\n</code></pre>\n<p>上面代码中，<code>has()</code>拦截只对<code>in</code>运算符生效，对<code>for...in</code>循环不生效，导致不符合要求的属性没有被<code>for...in</code>循环所排除。</p>\n<p><strong>construct()</strong></p>\n<p><strong><code>construct()</code>方法用于拦截<code>new</code>命令</strong>，下面是拦截对象的写法。</p>\n<pre><code class=\"javascript\">const handler = &#123;\n  construct (target, args, newTarget) &#123;\n    return new target(...args);\n  &#125;\n&#125;;\n</code></pre>\n<p><code>construct()</code>方法可以接受三个参数。</p>\n<ul>\n<li><code>target</code>：目标对象。</li>\n<li><code>args</code>：构造函数的参数数组。</li>\n<li><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的<code>p</code>）。</li>\n</ul>\n<pre><code class=\"javascript\">const p = new Proxy(function () &#123;&#125;, &#123;\n  construct: function(target, args) &#123;\n    console.log(&#39;called: &#39; + args.join(&#39;, &#39;));\n    return &#123; value: args[0] * 10 &#125;;\n  &#125;\n&#125;);\n\n(new p(1)).value\n// &quot;called: 1&quot;\n// 10\n</code></pre>\n<p><strong><code>construct()</code>方法返回的必须是一个对象，否则会报错。</strong></p>\n<pre><code class=\"javascript\">const p = new Proxy(function() &#123;&#125;, &#123;\n  construct: function(target, argumentsList) &#123;\n    return 1;\n  &#125;\n&#125;);\n\nnew p() // 报错\n// Uncaught TypeError: &#39;construct&#39; on proxy: trap returned non-object (&#39;1&#39;)\n</code></pre>\n<p><strong>另外，由于<code>construct()</code>拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。</strong></p>\n<pre><code class=\"javascript\">const p = new Proxy(&#123;&#125;, &#123;\n  construct: function(target, argumentsList) &#123;\n    return &#123;&#125;;\n  &#125;\n&#125;);\n\nnew p() // 报错\n// Uncaught TypeError: p is not a constructor\n</code></pre>\n<p>上面例子中，拦截的目标对象不是一个函数，而是一个对象（<code>new Proxy()</code>的第一个参数），导致报错。</p>\n<p><strong>注意，<code>construct()</code>方法中的<code>this</code>指向的是<code>handler</code>，而不是实例对象。</strong></p>\n<pre><code class=\"javascript\">const handler = &#123;\n  construct: function(target, args) &#123;\n    console.log(this === handler);\n    return new target(...args);\n  &#125;\n&#125;\n\nlet p = new Proxy(function () &#123;&#125;, handler);\nnew p() // true\n</code></pre>\n<p><strong>deleteProperty()</strong></p>\n<p><strong><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</strong></p>\n<pre><code class=\"javascript\">var handler = &#123;\n  deleteProperty (target, key) &#123;\n    invariant(key, &#39;delete&#39;);\n    delete target[key];\n    return true;\n  &#125;\n&#125;;\nfunction invariant (key, action) &#123;\n  if (key[0] === &#39;_&#39;) &#123;\n    throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`);\n  &#125;\n&#125;\n\nvar target = &#123; _prop: &#39;foo&#39; &#125;;\nvar proxy = new Proxy(target, handler);\ndelete proxy._prop\n// Error: Invalid attempt to delete private &quot;_prop&quot; property\n</code></pre>\n<p>上面代码中，<code>deleteProperty</code>方法拦截了<code>delete</code>操作符，删除第一个字符为下划线的属性会报错。</p>\n<p><strong>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错。</strong></p>\n<hr>\n<p><strong>defineProperty()</strong></p>\n<p><strong><code>defineProperty()</code>方法拦截了<code>Object.defineProperty()</code>操作。</strong></p>\n<pre><code class=\"javascript\">var handler = &#123;\n  defineProperty (target, key, descriptor) &#123;\n    return false;\n  &#125;\n&#125;;\nvar target = &#123;&#125;;\nvar proxy = new Proxy(target, handler);\nproxy.foo = &#39;bar&#39; // 不会生效\n</code></pre>\n<p>上面代码中，<code>defineProperty()</code>方法内部没有任何操作，只返回<code>false</code>，导致添加新属性总是无效。注意，这里的<code>false</code>只是用来提示操作失败，本身并不能阻止添加新属性。</p>\n<p><strong>注意，如果目标对象不可扩展（non-extensible），则<code>defineProperty()</code>不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则<code>defineProperty()</code>方法不得改变这两个设置。</strong></p>\n<hr>\n<p><strong>getOwnPropertyDescriptor()</strong></p>\n<p><strong><code>getOwnPropertyDescriptor()</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个属性描述对象或者<code>undefined</code>。</strong></p>\n<pre><code class=\"javascript\">var handler = &#123;\n  getOwnPropertyDescriptor (target, key) &#123;\n    if (key[0] === &#39;_&#39;) &#123;\n      return;\n    &#125;\n    return Object.getOwnPropertyDescriptor(target, key);\n  &#125;\n&#125;;\nvar target = &#123; _foo: &#39;bar&#39;, baz: &#39;tar&#39; &#125;;\nvar proxy = new Proxy(target, handler);\nObject.getOwnPropertyDescriptor(proxy, &#39;wat&#39;)\n// undefined\nObject.getOwnPropertyDescriptor(proxy, &#39;_foo&#39;)\n// undefined\nObject.getOwnPropertyDescriptor(proxy, &#39;baz&#39;)\n// &#123; value: &#39;tar&#39;, writable: true, enumerable: true, configurable: true &#125;\n</code></pre>\n<p>上面代码中，<code>handler.getOwnPropertyDescriptor()</code>方法对于第一个字符为下划线的属性名会返回<code>undefined</code>。</p>\n<hr>\n<p><strong>getPrototypeOf()</strong></p>\n<p><strong><code>getPrototypeOf()</code>方法主要用来拦截获取对象原型</strong>。具体来说，拦截下面这些操作。</p>\n<ul>\n<li><code>Object.prototype.__proto__</code></li>\n<li><code>Object.prototype.isPrototypeOf()</code></li>\n<li><code>Object.getPrototypeOf()</code></li>\n<li><code>Reflect.getPrototypeOf()</code></li>\n<li><code>instanceof</code></li>\n</ul>\n<p>下面是一个例子。</p>\n<pre><code class=\"javascript\">var proto = &#123;&#125;;\nvar p = new Proxy(&#123;&#125;, &#123;\n  getPrototypeOf(target) &#123;\n    return proto;\n  &#125;\n&#125;);\nObject.getPrototypeOf(p) === proto // true\n</code></pre>\n<p>上面代码中，<code>getPrototypeOf()</code>方法拦截<code>Object.getPrototypeOf()</code>，返回<code>proto</code>对象。</p>\n<p><strong>注意，<code>getPrototypeOf()</code>方法的返回值必须是对象或者<code>null</code>，否则报错。另外，如果目标对象不可扩展（non-extensible）， <code>getPrototypeOf()</code>方法必须返回目标对象的原型对象。</strong></p>\n<hr>\n<p><strong>isExtensible()</strong></p>\n<p><strong><code>isExtensible()</code>方法拦截<code>Object.isExtensible()</code>操作。</strong></p>\n<pre><code class=\"javascript\">var p = new Proxy(&#123;&#125;, &#123;\n  isExtensible: function(target) &#123;\n    console.log(&quot;called&quot;);\n    return true;\n  &#125;\n&#125;);\n\nObject.isExtensible(p)\n// &quot;called&quot;\n// true\n</code></pre>\n<p>上面代码设置了<code>isExtensible()</code>方法，在调用<code>Object.isExtensible</code>时会输出<code>called</code>。</p>\n<p><strong>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</strong></p>\n<p><strong>这个方法有一个强限制，它的返回值必须与目标对象的<code>isExtensible</code>属性保持一致，否则就会抛出错误。</strong></p>\n<pre><code class=\"javascript\">Object.isExtensible(proxy) === Object.isExtensible(target)\n</code></pre>\n<p>下面是一个例子。</p>\n<pre><code class=\"javascript\">var p = new Proxy(&#123;&#125;, &#123;\n  isExtensible: function(target) &#123;\n    return false;\n  &#125;\n&#125;);\n\nObject.isExtensible(p)\n// Uncaught TypeError: &#39;isExtensible&#39; on proxy: trap result does not reflect extensibility of proxy target (which is &#39;true&#39;)\n</code></pre>\n<hr>\n<p><strong>ownKeys()</strong></p>\n<p><strong><code>ownKeys()</code>方法用来拦截对象自身属性的读取操作。</strong>具体来说，拦截以下操作。</p>\n<ul>\n<li><code>Object.getOwnPropertyNames()</code></li>\n<li><code>Object.getOwnPropertySymbols()</code></li>\n<li><code>Object.keys()</code></li>\n<li><code>for...in</code>循环</li>\n</ul>\n<p>下面是拦截<code>Object.keys()</code>的例子。</p>\n<pre><code class=\"javascript\">let target = &#123;\n  a: 1,\n  b: 2,\n  c: 3\n&#125;;\n\nlet handler = &#123;\n  ownKeys(target) &#123;\n    return [&#39;a&#39;];\n  &#125;\n&#125;;\n\nlet proxy = new Proxy(target, handler);\n\nObject.keys(proxy)\n// [ &#39;a&#39; ]\n</code></pre>\n<p>上面代码拦截了对于<code>target</code>对象的<code>Object.keys()</code>操作，只返回<code>a</code>、<code>b</code>、<code>c</code>三个属性之中的<code>a</code>属性。</p>\n<p>下面的例子是拦截第一个字符为下划线的属性名。</p>\n<pre><code class=\"javascript\">let target = &#123;\n  _bar: &#39;foo&#39;,\n  _prop: &#39;bar&#39;,\n  prop: &#39;baz&#39;\n&#125;;\n\nlet handler = &#123;\n  ownKeys (target) &#123;\n    return Reflect.ownKeys(target).filter(key =&gt; key[0] !== &#39;_&#39;);\n  &#125;\n&#125;;\n\nlet proxy = new Proxy(target, handler);\nfor (let key of Object.keys(proxy)) &#123;\n  console.log(target[key]);\n&#125;\n// &quot;baz&quot;\n</code></pre>\n<p><strong>注意，使用<code>Object.keys()</code>方法时，有三类属性会被<code>ownKeys()</code>方法自动过滤，不会返回。</strong></p>\n<ul>\n<li>目标对象上不存在的属性</li>\n<li>属性名为 Symbol 值</li>\n<li>不可遍历（<code>enumerable</code>）的属性</li>\n</ul>\n<pre><code class=\"javascript\">let target = &#123;\n  a: 1,\n  b: 2,\n  c: 3,\n  [Symbol.for(&#39;secret&#39;)]: &#39;4&#39;,\n&#125;;\n\nObject.defineProperty(target, &#39;key&#39;, &#123;\n  enumerable: false,\n  configurable: true,\n  writable: true,\n  value: &#39;static&#39;\n&#125;);\n\nlet handler = &#123;\n  ownKeys(target) &#123;\n    return [&#39;a&#39;, &#39;d&#39;, Symbol.for(&#39;secret&#39;), &#39;key&#39;];\n  &#125;\n&#125;;\n\nlet proxy = new Proxy(target, handler);\n\nObject.keys(proxy)\n// [&#39;a&#39;]\n</code></pre>\n<p>上面代码中，<code>ownKeys()</code>方法之中，显式返回不存在的属性（<code>d</code>）、Symbol 值（<code>Symbol.for(&#39;secret&#39;)</code>）、不可遍历的属性（<code>key</code>），结果都被自动过滤掉。</p>\n<p><strong><code>ownKeys()</code>方法还可以拦截<code>Object.getOwnPropertyNames()</code>。</strong></p>\n<pre><code class=\"javascript\">var p = new Proxy(&#123;&#125;, &#123;\n  ownKeys: function(target) &#123;\n    return [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];\n  &#125;\n&#125;);\n\nObject.getOwnPropertyNames(p)\n// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]\n</code></pre>\n<p><strong><code>for...in</code>循环也受到<code>ownKeys()</code>方法的拦截。</strong></p>\n<pre><code class=\"javascript\">const obj = &#123; hello: &#39;world&#39; &#125;;\nconst proxy = new Proxy(obj, &#123;\n  ownKeys: function () &#123;\n    return [&#39;a&#39;, &#39;b&#39;];\n  &#125;\n&#125;);\n\nfor (let key in proxy) &#123;\n  console.log(key); // 没有任何输出\n&#125;\n</code></pre>\n<p>上面代码中，<code>ownkeys()</code>指定只返回<code>a</code>和<code>b</code>属性，由于<code>obj</code>没有这两个属性，因此<code>for...in</code>循环不会有任何输出。</p>\n<p><strong><code>ownKeys()</code>方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</strong></p>\n<pre><code class=\"javascript\">var obj = &#123;&#125;;\n\nvar p = new Proxy(obj, &#123;\n  ownKeys: function(target) &#123;\n    return [123, true, undefined, null, &#123;&#125;, []];\n  &#125;\n&#125;);\n\nObject.getOwnPropertyNames(p)\n// Uncaught TypeError: 123 is not a valid property name\n</code></pre>\n<p>上面代码中，<code>ownKeys()</code>方法虽然返回一个数组，但是每一个数组成员都不是字符串或 Symbol 值，因此就报错了。</p>\n<p><strong>如果目标对象自身包含不可配置的属性，则该属性必须被<code>ownKeys()</code>方法返回，否则报错。</strong></p>\n<pre><code class=\"javascript\">var obj = &#123;&#125;;\nObject.defineProperty(obj, &#39;a&#39;, &#123;\n  configurable: false,\n  enumerable: true,\n  value: 10 &#125;\n);\n\nvar p = new Proxy(obj, &#123;\n  ownKeys: function(target) &#123;\n    return [&#39;b&#39;];\n  &#125;\n&#125;);\n\nObject.getOwnPropertyNames(p)\n// Uncaught TypeError: &#39;ownKeys&#39; on proxy: trap result did not include &#39;a&#39;\n</code></pre>\n<p>上面代码中，<code>obj</code>对象的<code>a</code>属性是不可配置的，这时<code>ownKeys()</code>方法返回的数组之中，必须包含<code>a</code>，否则会报错。</p>\n<p><strong>另外，如果目标对象是不可扩展的（non-extensible），这时<code>ownKeys()</code>方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</strong></p>\n<pre><code class=\"javascript\">var obj = &#123;\n  a: 1\n&#125;;\n\nObject.preventExtensions(obj);\n\nvar p = new Proxy(obj, &#123;\n  ownKeys: function(target) &#123;\n    return [&#39;a&#39;, &#39;b&#39;];\n  &#125;\n&#125;);\n\nObject.getOwnPropertyNames(p)\n// Uncaught TypeError: &#39;ownKeys&#39; on proxy: trap returned extra keys but proxy target is non-extensible\n</code></pre>\n<p>上面代码中，<code>obj</code>对象是不可扩展的，这时<code>ownKeys()</code>方法返回的数组之中，包含了<code>obj</code>对象的多余属性<code>b</code>，所以导致了报错。</p>\n<hr>\n<p><strong>preventExtensions()</strong></p>\n<p><strong><code>preventExtensions()</code>方法拦截<code>Object.preventExtensions()</code>。该方法必须返回一个布尔值，否则会被自动转为布尔值。</strong></p>\n<p>这个方法有一个限制，只有目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>），<code>proxy.preventExtensions</code>才能返回<code>true</code>，否则会报错。</p>\n<pre><code class=\"javascript\">var proxy = new Proxy(&#123;&#125;, &#123;\n  preventExtensions: function(target) &#123;\n    return true;\n  &#125;\n&#125;);\n\nObject.preventExtensions(proxy)\n// Uncaught TypeError: &#39;preventExtensions&#39; on proxy: trap returned truish but the proxy target is extensible\n</code></pre>\n<p>上面代码中，<code>proxy.preventExtensions()</code>方法返回<code>true</code>，但这时<code>Object.isExtensible(proxy)</code>会返回<code>true</code>，因此报错。</p>\n<p><strong>为了防止出现这个问题，通常要在<code>proxy.preventExtensions()</code>方法里面，调用一次<code>Object.preventExtensions()</code>。</strong></p>\n<pre><code class=\"javascript\">var proxy = new Proxy(&#123;&#125;, &#123;\n  preventExtensions: function(target) &#123;\n    console.log(&#39;called&#39;);\n    Object.preventExtensions(target);\n    return true;\n  &#125;\n&#125;);\n\nObject.preventExtensions(proxy)\n// &quot;called&quot;\n// Proxy &#123;&#125;\n</code></pre>\n<p><strong>setPrototypeOf()</strong></p>\n<p><strong><code>setPrototypeOf()</code>方法主要用来拦截<code>Object.setPrototypeOf()</code>方法。</strong></p>\n<p>下面是一个例子。</p>\n<pre><code class=\"javascript\">var handler = &#123;\n  setPrototypeOf (target, proto) &#123;\n    throw new Error(&#39;Changing the prototype is forbidden&#39;);\n  &#125;\n&#125;;\nvar proto = &#123;&#125;;\nvar target = function () &#123;&#125;;\nvar proxy = new Proxy(target, handler);\nObject.setPrototypeOf(proxy, proto);\n// Error: Changing the prototype is forbidden\n</code></pre>\n<p>上面代码中，只要修改<code>target</code>的原型对象，就会报错。</p>\n<p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），<code>setPrototypeOf()</code>方法不得改变目标对象的原型。</p>\n<hr>\n<h4 id=\"3-Proxy-revocable\"><a href=\"#3-Proxy-revocable\" class=\"headerlink\" title=\"3. Proxy.revocable()\"></a>3. Proxy.revocable()</h4><p><strong><code>Proxy.revocable()</code>方法返回一个可取消的 Proxy 实例。</strong></p>\n<pre><code class=\"javascript\">let target = &#123;&#125;;\nlet handler = &#123;&#125;;\n\nlet &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);\n\nproxy.foo = 123;\nproxy.foo // 123\n\nrevoke();\nproxy.foo // TypeError: Revoked\n</code></pre>\n<p><code>Proxy.revocable()</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p>\n<p><strong><code>Proxy.revocable()</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</strong></p>\n<hr>\n<h4 id=\"4-this-问题\"><a href=\"#4-this-问题\" class=\"headerlink\" title=\"4. this 问题\"></a>4. this 问题</h4><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，<strong>即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</strong></p>\n<pre><code class=\"javascript\">const target = &#123;\n  m: function () &#123;\n    console.log(this === proxy);\n  &#125;\n&#125;;\nconst handler = &#123;&#125;;\n\nconst proxy = new Proxy(target, handler);\n\ntarget.m() // false\nproxy.m()  // true\n</code></pre>\n<p>上面代码中，一旦<code>proxy</code>代理<code>target</code>，<code>target.m()</code>内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p>\n<p>下面是一个例子，由于<code>this</code>指向的变化，导致 Proxy 无法代理目标对象。</p>\n<pre><code class=\"javascript\">const _name = new WeakMap();\n\nclass Person &#123;\n  constructor(name) &#123;\n    _name.set(this, name);\n  &#125;\n  get name() &#123;\n    return _name.get(this);\n  &#125;\n&#125;\n\nconst jane = new Person(&#39;Jane&#39;);\njane.name // &#39;Jane&#39;\n\nconst proxy = new Proxy(jane, &#123;&#125;);\nproxy.name // undefined\n</code></pre>\n<p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p>\n<p><strong>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</strong></p>\n<pre><code class=\"javascript\">const target = new Date();\nconst handler = &#123;&#125;;\nconst proxy = new Proxy(target, handler);\n\nproxy.getDate();\n// TypeError: this is not a Date object.\n</code></pre>\n<p>上面代码中，<code>getDate()</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。<strong>这时，<code>this</code>绑定原始对象，就可以解决这个问题。</strong></p>\n<pre><code class=\"javascript\">const target = new Date(&#39;2015-01-01&#39;);\nconst handler = &#123;\n  get(target, prop) &#123;\n    if (prop === &#39;getDate&#39;) &#123;\n      return target.getDate.bind(target);\n    &#125;\n    return Reflect.get(target, prop);\n  &#125;\n&#125;;\nconst proxy = new Proxy(target, handler);\n\nproxy.getDate() // 1\n</code></pre>\n<p><strong>另外，Proxy 拦截函数内部的<code>this</code>，指向的是<code>handler</code>对象。</strong></p>\n<pre><code class=\"javascript\">const handler = &#123;\n  get: function (target, key, receiver) &#123;\n    console.log(this === handler);\n    return &#39;Hello, &#39; + key;\n  &#125;,\n  set: function (target, key, value) &#123;\n    console.log(this === handler);\n    target[key] = value;\n    return true;\n  &#125;\n&#125;;\n\nconst proxy = new Proxy(&#123;&#125;, handler);\n\nproxy.foo\n// true\n// Hello, foo\n\nproxy.foo = 1\n// true\n</code></pre>\n<p>上面例子中，<code>get()</code>和<code>set()</code>拦截函数内部的<code>this</code>，指向的都是<code>handler</code>对象。</p>\n<hr>\n<h4 id=\"5-实例：Web-服务的客户端\"><a href=\"#5-实例：Web-服务的客户端\" class=\"headerlink\" title=\"5. 实例：Web 服务的客户端\"></a>5. 实例：Web 服务的客户端</h4><p>Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。</p>\n<pre><code class=\"javascript\">const service = createWebService(&#39;http://example.com/data&#39;);\n\nservice.employees().then(json =&gt; &#123;\n  const employees = JSON.parse(json);\n  // ···\n&#125;);\n</code></pre>\n<p>上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。</p>\n<pre><code class=\"javascript\">function createWebService(baseUrl) &#123;\n  return new Proxy(&#123;&#125;, &#123;\n    get(target, propKey, receiver) &#123;\n      return () =&gt; httpGet(baseUrl + &#39;/&#39; + propKey);\n    &#125;\n  &#125;);\n&#125;\n</code></pre>\n<p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p>\n<h3 id=\"15、-Reflect\"><a href=\"#15、-Reflect\" class=\"headerlink\" title=\"15、 Reflect\"></a>15、 Reflect</h3><hr>\n<h4 id=\"1-概述-1\"><a href=\"#1-概述-1\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h4><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>\n<p><strong>（1） 将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</strong>移动</p>\n<p><strong>（2） 修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</strong>修改</p>\n<pre><code class=\"javascript\">// 老写法\ntry &#123;\n  Object.defineProperty(target, property, attributes);\n  // success\n&#125; catch (e) &#123;\n  // failure\n&#125;\n\n// 新写法\nif (Reflect.defineProperty(target, property, attributes)) &#123;\n  // success\n&#125; else &#123;\n  // failure\n&#125;\n</code></pre>\n<p><strong>（3） 让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</strong>函数</p>\n<pre><code class=\"javascript\">// 老写法\n&#39;assign&#39; in Object // true\n\n// 新写法\nReflect.has(Object, &#39;assign&#39;) // true\n</code></pre>\n<p><strong>（4）<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</strong>proxy</p>\n<pre><code class=\"javascript\">Proxy(target, &#123;\n  set: function(target, name, value, receiver) &#123;\n    var success = Reflect.set(target, name, value, receiver);\n    if (success) &#123;\n      console.log(&#39;property &#39; + name + &#39; on &#39; + target + &#39; set to &#39; + value);\n    &#125;\n    return success;\n  &#125;\n&#125;);\n</code></pre>\n<p>上面代码中，<code>Proxy</code>方法拦截<code>target</code>对象的属性赋值行为。它采用<code>Reflect.set</code>方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。</p>\n<p>下面是另一个例子。</p>\n<pre><code class=\"javascript\">var loggedObj = new Proxy(obj, &#123;\n  get(target, name) &#123;\n    console.log(&#39;get&#39;, target, name);\n    return Reflect.get(target, name);\n  &#125;,\n  deleteProperty(target, name) &#123;\n    console.log(&#39;delete&#39; + name);\n    return Reflect.deleteProperty(target, name);\n  &#125;,\n  has(target, name) &#123;\n    console.log(&#39;has&#39; + name);\n    return Reflect.has(target, name);\n  &#125;\n&#125;);\n</code></pre>\n<p>上面代码中，每一个<code>Proxy</code>对象的拦截操作（<code>get</code>、<code>delete</code>、<code>has</code>），内部都调用对应的<code>Reflect</code>方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p>\n<p>有了<code>Reflect</code>对象以后，很多操作会更易读。</p>\n<pre><code class=\"javascript\">// 老写法\nFunction.prototype.apply.call(Math.floor, undefined, [1.75]) // 1\n\n// 新写法\nReflect.apply(Math.floor, undefined, [1.75]) // 1\n</code></pre>\n<hr>\n<h4 id=\"2-静态方法\"><a href=\"#2-静态方法\" class=\"headerlink\" title=\"2.静态方法\"></a>2.静态方法</h4><p><code>Reflect</code>对象一共有 13 个静态方法。</p>\n<ul>\n<li>Reflect.apply(target, thisArg, args)</li>\n<li>Reflect.construct(target, args)</li>\n<li>Reflect.get(target, name, receiver)</li>\n<li>Reflect.set(target, name, value, receiver)</li>\n<li>Reflect.defineProperty(target, name, desc)</li>\n<li>Reflect.deleteProperty(target, name)</li>\n<li>Reflect.has(target, name)</li>\n<li>Reflect.ownKeys(target)</li>\n<li>Reflect.isExtensible(target)</li>\n<li>Reflect.preventExtensions(target)</li>\n<li>Reflect.getOwnPropertyDescriptor(target, name)</li>\n<li>Reflect.getPrototypeOf(target)</li>\n<li>Reflect.setPrototypeOf(target, prototype)</li>\n</ul>\n<p>上面这些方法的作用，大部分与<code>Object</code>对象的同名方法的作用都是相同的，而且它与<code>Proxy</code>对象的方法是一一对应的。下面是对它们的解释。</p>\n<p><strong>如果第一个参数不是对象，<code>Reflect</code>的这些方法会报错。</strong></p>\n<hr>\n<p><strong>Reflect.get(target, name, receiver)</strong></p>\n<p><strong><code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code>。</strong></p>\n<pre><code class=\"javascript\">var myObject = &#123;\n  foo: 1,\n  bar: 2,\n  get baz() &#123;\n    return this.foo + this.bar;\n  &#125;,\n&#125;\n\nReflect.get(myObject, &#39;foo&#39;) // 1\nReflect.get(myObject, &#39;bar&#39;) // 2\nReflect.get(myObject, &#39;baz&#39;) // 3\n</code></pre>\n<p><strong>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定<code>receiver</code>。</strong></p>\n<pre><code class=\"javascript\">var myObject = &#123;\n  foo: 1,\n  bar: 2,\n  get baz() &#123;\n    return this.foo + this.bar;\n  &#125;,\n&#125;;\n\nvar myReceiverObject = &#123;\n  foo: 4,\n  bar: 4,\n&#125;;\n\nReflect.get(myObject, &#39;baz&#39;, myReceiverObject) // 8\n</code></pre>\n<p>如果第一个参数不是对象，<code>Reflect.get</code>方法会报错。</p>\n<pre><code class=\"javascript\">Reflect.get(1, &#39;foo&#39;) // 报错\nReflect.get(false, &#39;foo&#39;) // 报错\n</code></pre>\n<hr>\n<p><strong>Reflect.set(target, name, value, receiver)</strong></p>\n<p><strong><code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code>。</strong></p>\n<pre><code class=\"javascript\">var myObject = &#123;\n  foo: 1,\n  set bar(value) &#123;\n    return this.foo = value;\n  &#125;,\n&#125;\n\nmyObject.foo // 1\n\nReflect.set(myObject, &#39;foo&#39;, 2);\nmyObject.foo // 2\n\nReflect.set(myObject, &#39;bar&#39;, 3)\nmyObject.foo // 3\n</code></pre>\n<p><strong>如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定<code>receiver</code>。</strong></p>\n<pre><code class=\"javascript\">var myObject = &#123;\n  foo: 4,\n  set bar(value) &#123;\n    return this.foo = value;\n  &#125;,\n&#125;;\n\nvar myReceiverObject = &#123;\n  foo: 0,\n&#125;;\n\nReflect.set(myObject, &#39;bar&#39;, 1, myReceiverObject);\nmyObject.foo // 4\nmyReceiverObject.foo // 1\n</code></pre>\n<p>注意，如果 <code>Proxy</code>对象和 <code>Reflect</code>对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了<code>receiver</code>，那么<code>Reflect.set</code>会触发<code>Proxy.defineProperty</code>拦截。</p>\n<pre><code class=\"javascript\">let p = &#123;\n  a: &#39;a&#39;\n&#125;;\n\nlet handler = &#123;\n  set(target, key, value, receiver) &#123;\n    console.log(&#39;set&#39;);\n    Reflect.set(target, key, value, receiver)\n  &#125;,\n  defineProperty(target, key, attribute) &#123;\n    console.log(&#39;defineProperty&#39;);\n    Reflect.defineProperty(target, key, attribute);\n  &#125;\n&#125;;\n\nlet obj = new Proxy(p, handler);\nobj.a = &#39;A&#39;;\n// set\n// defineProperty\n</code></pre>\n<p>上面代码中，<code>Proxy.set</code>拦截里面使用了<code>Reflect.set</code>，而且传入了<code>receiver</code>，导致触发<code>Proxy.defineProperty</code>拦截。这是因为<code>Proxy.set</code>的<code>receiver</code>参数总是指向当前的 <code>Proxy</code>实例（即上例的<code>obj</code>），而<code>Reflect.set</code>一旦传入<code>receiver</code>，就会将属性赋值到<code>receiver</code>上面（即<code>obj</code>），导致触发<code>defineProperty</code>拦截。<strong>如果<code>Reflect.set</code>没有传入<code>receiver</code>，那么就不会触发<code>defineProperty</code>拦w截。</strong></p>\n<pre><code class=\"javascript\">let p = &#123;\n  a: &#39;a&#39;\n&#125;;\n\nlet handler = &#123;\n  set(target, key, value, receiver) &#123;\n    console.log(&#39;set&#39;);\n    Reflect.set(target, key, value)\n  &#125;,\n  defineProperty(target, key, attribute) &#123;\n    console.log(&#39;defineProperty&#39;);\n    Reflect.defineProperty(target, key, attribute);\n  &#125;\n&#125;;\n\nlet obj = new Proxy(p, handler);\nobj.a = &#39;A&#39;;\n// set\n</code></pre>\n<p>如果第一个参数不是对象，<code>Reflect.set</code>会报错。</p>\n<pre><code class=\"javascript\">Reflect.set(1, &#39;foo&#39;, &#123;&#125;) // 报错\nReflect.set(false, &#39;foo&#39;, &#123;&#125;) // 报错\n</code></pre>\n<hr>\n<p><strong>Reflect.has(obj, name)</strong></p>\n<p><strong><code>Reflect.has</code>方法对应<code>name in obj</code>里面的<code>in</code>运算符。</strong></p>\n<pre><code class=\"javascript\">var myObject = &#123;\n  foo: 1,\n&#125;;\n\n// 旧写法\n&#39;foo&#39; in myObject // true\n\n// 新写法\nReflect.has(myObject, &#39;foo&#39;) // true\n</code></pre>\n<p>如果<code>Reflect.has()</code>方法的第一个参数不是对象，会报错。</p>\n<hr>\n<p><strong>Reflect.deleteProperty(obj, name)</strong></p>\n<p><strong><code>Reflect.deleteProperty</code>方法等同于<code>delete obj[name]</code>，用于删除对象的属性。</strong></p>\n<pre><code class=\"javascript\">const myObj = &#123; foo: &#39;bar&#39; &#125;;\n\n// 旧写法\ndelete myObj.foo;\n\n// 新写法\nReflect.deleteProperty(myObj, &#39;foo&#39;);\n</code></pre>\n<p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回<code>true</code>；删除失败，被删除的属性依然存在，返回<code>false</code>。</p>\n<p>如果<code>Reflect.deleteProperty()</code>方法的第一个参数不是对象，会报错。</p>\n<hr>\n<p><strong>Reflect.construct(target, args)</strong></p>\n<p><code>Reflect.construct</code>方法等同于<code>new target(...args)</code>，这提供了一种不使用<code>new</code>，来调用构造函数的方法。</p>\n<pre><code class=\"javascript\">function Greeting(name) &#123;\n  this.name = name;\n&#125;\n\n// new 的写法\nconst instance = new Greeting(&#39;张三&#39;);\n\n// Reflect.construct 的写法\nconst instance = Reflect.construct(Greeting, [&#39;张三&#39;]);\n</code></pre>\n<p>如果<code>Reflect.construct()</code>方法的第一个参数不是函数，会报错。</p>\n<hr>\n<p><strong>Reflect.getPrototypeOf(obj)</strong></p>\n<p><code>Reflect.getPrototypeOf</code>方法用于读取对象的<code>__proto__</code>属性，对应<code>Object.getPrototypeOf(obj)</code>。</p>\n<pre><code class=\"javascript\">const myObj = new FancyThing();\n\n// 旧写法\nObject.getPrototypeOf(myObj) === FancyThing.prototype;\n\n// 新写法\nReflect.getPrototypeOf(myObj) === FancyThing.prototype;\n</code></pre>\n<p><code>Reflect.getPrototypeOf</code>和<code>Object.getPrototypeOf</code>的一个区别是，如果参数不是对象，<code>Object.getPrototypeOf</code>会将这个参数转为对象，然后再运行，而<code>Reflect.getPrototypeOf</code>会报错。</p>\n<pre><code class=\"javascript\">Object.getPrototypeOf(1) // Number &#123;[[PrimitiveValue]]: 0&#125;\nReflect.getPrototypeOf(1) // 报错\n</code></pre>\n<hr>\n<p><strong>Reflect.setPrototypeOf(obj, newProto)</strong></p>\n<p><code>Reflect.setPrototypeOf</code>方法用于设置目标对象的原型（prototype），对应<code>Object.setPrototypeOf(obj, newProto)</code>方法。它返回一个布尔值，表示是否设置成功。</p>\n<pre><code class=\"javascript\">const myObj = &#123;&#125;;\n\n// 旧写法\nObject.setPrototypeOf(myObj, Array.prototype);\n\n// 新写法\nReflect.setPrototypeOf(myObj, Array.prototype);\n\nmyObj.length // 0\n</code></pre>\n<p><strong>如果无法设置目标对象的原型（比如，目标对象禁止扩展），<code>Reflect.setPrototypeOf</code>方法返回<code>false</code>。</strong></p>\n<pre><code class=\"javascript\">Reflect.setPrototypeOf(&#123;&#125;, null)\n// true\nReflect.setPrototypeOf(Object.freeze(&#123;&#125;), null)\n// false\n</code></pre>\n<p>如果第一个参数不是对象，<code>Object.setPrototypeOf</code>会返回第一个参数本身，而<code>Reflect.setPrototypeOf</code>会报错。</p>\n<pre><code class=\"javascript\">Object.setPrototypeOf(1, &#123;&#125;)\n// 1\n\nReflect.setPrototypeOf(1, &#123;&#125;)\n// TypeError: Reflect.setPrototypeOf called on non-object\n</code></pre>\n<p>如果第一个参数是<code>undefined</code>或<code>null</code>，<code>Object.setPrototypeOf</code>和<code>Reflect.setPrototypeOf</code>都会报错。</p>\n<pre><code class=\"javascript\">Object.setPrototypeOf(null, &#123;&#125;)\n// TypeError: Object.setPrototypeOf called on null or undefined\n\nReflect.setPrototypeOf(null, &#123;&#125;)\n// TypeError: Reflect.setPrototypeOf called on non-object\n</code></pre>\n<hr>\n<p><strong>Reflect.apply(func, thisArg, args)</strong></p>\n<p><code>Reflect.apply</code>方法等同于<code>Function.prototype.apply.call(func, thisArg, args)</code>，用于绑定<code>this</code>对象后执行给定函数。</p>\n<p>一般来说，如果要绑定一个函数的<code>this</code>对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的<code>apply</code>方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用<code>Reflect</code>对象可以简化这种操作。</p>\n<pre><code class=\"javascript\">const ages = [11, 33, 12, 54, 18, 96];\n\n// 旧写法\nconst youngest = Math.min.apply(Math, ages);\nconst oldest = Math.max.apply(Math, ages);\nconst type = Object.prototype.toString.call(youngest);\n\n// 新写法\nconst youngest = Reflect.apply(Math.min, Math, ages);\nconst oldest = Reflect.apply(Math.max, Math, ages);\nconst type = Reflect.apply(Object.prototype.toString, youngest, []);\n</code></pre>\n<hr>\n<p><strong>Reflect.defineProperty(target, propertyKey, attributes)</strong></p>\n<p><code>Reflect.defineProperty</code>方法基本等同于<code>Object.defineProperty</code>，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用<code>Reflect.defineProperty</code>代替它。</p>\n<pre><code class=\"javascript\">function MyDate() &#123;\n  /*…*/\n&#125;\n\n// 旧写法\nObject.defineProperty(MyDate, &#39;now&#39;, &#123;\n  value: () =&gt; Date.now()\n&#125;);\n\n// 新写法\nReflect.defineProperty(MyDate, &#39;now&#39;, &#123;\n  value: () =&gt; Date.now()\n&#125;);\n</code></pre>\n<p>如果<code>Reflect.defineProperty</code>的第一个参数不是对象，就会抛出错误，比如<code>Reflect.defineProperty(1, &#39;foo&#39;)</code>。</p>\n<p>这个方法可以与<code>Proxy.defineProperty</code>配合使用。</p>\n<pre><code class=\"javascript\">const p = new Proxy(&#123;&#125;, &#123;\n  defineProperty(target, prop, descriptor) &#123;\n    console.log(descriptor);\n    return Reflect.defineProperty(target, prop, descriptor);\n  &#125;\n&#125;);\n\np.foo = &#39;bar&#39;;\n// &#123;value: &quot;bar&quot;, writable: true, enumerable: true, configurable: true&#125;\n\np.foo // &quot;bar&quot;\n</code></pre>\n<p>上面代码中，<code>Proxy.defineProperty</code>对属性赋值设置了拦截，然后使用<code>Reflect.defineProperty</code>完成了赋值。</p>\n<hr>\n<p><strong>Reflect.getOwnPropertyDescriptor(target, propertyKey)</strong></p>\n<p><code>Reflect.getOwnPropertyDescriptor</code>基本等同于<code>Object.getOwnPropertyDescriptor</code>，用于得到指定属性的描述对象，将来会替代掉后者。</p>\n<pre><code class=\"javascript\">var myObject = &#123;&#125;;\nObject.defineProperty(myObject, &#39;hidden&#39;, &#123;\n  value: true,\n  enumerable: false,\n&#125;);\n\n// 旧写法\nvar theDescriptor = Object.getOwnPropertyDescriptor(myObject, &#39;hidden&#39;);\n\n// 新写法\nvar theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, &#39;hidden&#39;);\n</code></pre>\n<p><code>Reflect.getOwnPropertyDescriptor</code>和<code>Object.getOwnPropertyDescriptor</code>的一个区别是，如果第一个参数不是对象，<code>Object.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>不报错，返回<code>undefined</code>，而<code>Reflect.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>会抛出错误，表示参数非法。</p>\n<hr>\n<p><strong>Reflect.isExtensible (target)</strong></p>\n<p><code>Reflect.isExtensible</code>方法对应<code>Object.isExtensible</code>，返回一个布尔值，表示当前对象是否可扩展。</p>\n<pre><code class=\"javascript\">const myObject = &#123;&#125;;\n\n// 旧写法\nObject.isExtensible(myObject) // true\n\n// 新写法\nReflect.isExtensible(myObject) // true\n</code></pre>\n<p>如果参数不是对象，<code>Object.isExtensible</code>会返回<code>false</code>，因为非对象本来就是不可扩展的，而<code>Reflect.isExtensible</code>会报错。</p>\n<pre><code class=\"javascript\">Object.isExtensible(1) // false\nReflect.isExtensible(1) // 报错\n</code></pre>\n<hr>\n<p><strong>Reflect.preventExtensions(target)</strong></p>\n<p><code>Reflect.preventExtensions</code>对应<code>Object.preventExtensions</code>方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</p>\n<pre><code class=\"javascript\">var myObject = &#123;&#125;;\n\n// 旧写法\nObject.preventExtensions(myObject) // Object &#123;&#125;\n\n// 新写法\nReflect.preventExtensions(myObject) // true\n</code></pre>\n<p>如果参数不是对象，<code>Object.preventExtensions</code>在 ES5 环境报错，在 ES6 环境返回传入的参数，而<code>Reflect.preventExtensions</code>会报错。</p>\n<pre><code class=\"javascript\">// ES5 环境\nObject.preventExtensions(1) // 报错\n\n// ES6 环境\nObject.preventExtensions(1) // 1\n\n// 新写法\nReflect.preventExtensions(1) // 报错\n</code></pre>\n<hr>\n<p><strong>Reflect.ownKeys (target)</strong></p>\n<p><code>Reflect.ownKeys</code>方法用于返回对象的所有属性，基本等同于<code>Object.getOwnPropertyNames</code>与<code>Object.getOwnPropertySymbols</code>之和。</p>\n<pre><code class=\"javascript\">var myObject = &#123;\n  foo: 1,\n  bar: 2,\n  [Symbol.for(&#39;baz&#39;)]: 3,\n  [Symbol.for(&#39;bing&#39;)]: 4,\n&#125;;\n\n// 旧写法\nObject.getOwnPropertyNames(myObject)\n// [&#39;foo&#39;, &#39;bar&#39;]\n\nObject.getOwnPropertySymbols(myObject)\n//[Symbol(baz), Symbol(bing)]\n\n// 新写法\nReflect.ownKeys(myObject)\n// [&#39;foo&#39;, &#39;bar&#39;, Symbol(baz), Symbol(bing)]\n</code></pre>\n<p>如果<code>Reflect.ownKeys()</code>方法的第一个参数不是对象，会报错。</p>\n<hr>\n<h4 id=\"3-实例：使用-Proxy-实现观察者模式\"><a href=\"#3-实例：使用-Proxy-实现观察者模式\" class=\"headerlink\" title=\"3. 实例：使用 Proxy 实现观察者模式\"></a>3. 实例：使用 Proxy 实现观察者模式</h4><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p>\n<pre><code class=\"javascript\">const person = observable(&#123;\n  name: &#39;张三&#39;,\n  age: 20\n&#125;);\n\nfunction print() &#123;\n  console.log(`$&#123;person.name&#125;, $&#123;person.age&#125;`)\n&#125;\n\nobserve(print);\nperson.name = &#39;李四&#39;;\n// 输出\n// 李四, 20\n</code></pre>\n<p>上面代码中，数据对象<code>person</code>是观察目标，函数<code>print</code>是观察者。一旦数据对象发生变化，<code>print</code>就会自动执行。</p>\n<p>下面，使用 Proxy 写一个观察者模式的最简单实现，即实现<code>observable</code>和<code>observe</code>这两个函数。思路是<code>observable</code>函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。</p>\n<pre><code class=\"javascript\">const queuedObservers = new Set();\n\nconst observe = fn =&gt; queuedObservers.add(fn);\nconst observable = obj =&gt; new Proxy(obj, &#123;set&#125;);\n\nfunction set(target, key, value, receiver) &#123;\n  const result = Reflect.set(target, key, value, receiver);\n  queuedObservers.forEach(observer =&gt; observer());\n  return result;\n&#125;\n</code></pre>\n<p>上面代码中，<strong>先定义了一个<code>Set</code>集合，所有观察者函数都放进这个集合。然后，<code>observable</code>函数返回原始对象的代理，拦截赋值操作。拦截函数<code>set</code>之中，会自动执行所有观察者。</strong></p>\n<h3 id=\"16、-Promise-对象\"><a href=\"#16、-Promise-对象\" class=\"headerlink\" title=\"16、 Promise 对象\"></a>16、 Promise 对象</h3><hr>\n<h4 id=\"1-Promise-的含义\"><a href=\"#1-Promise-的含义\" class=\"headerlink\" title=\"1. Promise 的含义\"></a>1. Promise 的含义</h4><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>\n<p><strong>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</strong></p>\n<p><code>Promise</code>对象有以下两个特点。</p>\n<p>（1）<strong>对象的状态不受外界影响</strong>。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>\n<p>（2）<strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果。</strong><code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n<p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p>\n<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>\n<p><code>Promise</code>也有一些缺点。<strong>首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。</strong>其次，<strong>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部</strong>。第三，<strong>当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</strong>。</p>\n<p>如果某些事件不断地反复发生，一般来说，使用 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbA==\">Stream</span> 模式是比部署<code>Promise</code>更好的选择。</p>\n<h4 id=\"2-基本用法\"><a href=\"#2-基本用法\" class=\"headerlink\" title=\"2. 基本用法\"></a>2. 基本用法</h4><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>\n<p>下面代码创造了一个<code>Promise</code>实例。</p>\n<pre><code class=\"javascript\">const promise = new Promise(function(resolve, reject) &#123;\n  // ... some code\n\n  if (/* 异步操作成功 */)&#123;\n    resolve(value);\n  &#125; else &#123;\n    reject(error);\n  &#125;\n&#125;);\n</code></pre>\n<p>**<code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>**。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>\n<p><strong><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”</strong>（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；**<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”**（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>\n<p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>\n<pre><code class=\"javascript\">promise.then(function(value) &#123;\n  // success\n&#125;, function(error) &#123;\n  // failure\n&#125;);\n</code></pre>\n<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。这两个函数都是可选的，不一定要提供。它们都接受<code>Promise</code>对象传出的值作为参数。</p>\n<p>下面是一个<code>Promise</code>对象的简单例子。</p>\n<pre><code class=\"javascript\">function timeout(ms) &#123;\n  return new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(resolve, ms, &#39;done&#39;);\n  &#125;);\n&#125;\n\ntimeout(100).then((value) =&gt; &#123;\n  console.log(value);\n&#125;);\n</code></pre>\n<p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p>\n<p>Promise 新建后就会立即执行。</p>\n<pre><code class=\"javascript\">let promise = new Promise(function(resolve, reject) &#123;\n  console.log(&#39;Promise&#39;);\n  resolve();\n&#125;);\n\npromise.then(function() &#123;\n  console.log(&#39;resolved.&#39;);\n&#125;);\n\nconsole.log(&#39;Hi!&#39;);\n\n// Promise\n// Hi!\n// resolved\n</code></pre>\n<p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p>\n<p>下面是异步加载图片的例子。</p>\n<pre><code class=\"javascript\">function loadImageAsync(url) &#123;\n  return new Promise(function(resolve, reject) &#123;\n    const image = new Image();\n\n    image.onload = function() &#123;\n      resolve(image);\n    &#125;;\n\n    image.onerror = function() &#123;\n      reject(new Error(&#39;Could not load image at &#39; + url));\n    &#125;;\n\n    image.src = url;\n  &#125;);\n&#125;\n</code></pre>\n<p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p>\n<p>下面是一个用<code>Promise</code>对象实现的 Ajax 操作的例子。</p>\n<pre><code class=\"javascript\">const getJSON = function(url) &#123;\n  const promise = new Promise(function(resolve, reject)&#123;\n    const handler = function() &#123;\n      if (this.readyState !== 4) &#123;\n        return;\n      &#125;\n      if (this.status === 200) &#123;\n        resolve(this.response);\n      &#125; else &#123;\n        reject(new Error(this.statusText));\n      &#125;\n    &#125;;\n    const client = new XMLHttpRequest();\n    client.open(&quot;GET&quot;, url);\n    client.onreadystatechange = handler;\n    client.responseType = &quot;json&quot;;\n    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);\n    client.send();\n\n  &#125;);\n\n  return promise;\n&#125;;\n\ngetJSON(&quot;/posts.json&quot;).then(function(json) &#123;\n  console.log(&#39;Contents: &#39; + json);\n&#125;, function(error) &#123;\n  console.error(&#39;出错了&#39;, error);\n&#125;);\n</code></pre>\n<p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p>\n<p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>\n<pre><code class=\"javascript\">const p1 = new Promise(function (resolve, reject) &#123;\n  // ...\n&#125;);\n\nconst p2 = new Promise(function (resolve, reject) &#123;\n  // ...\n  resolve(p1);\n&#125;)\n</code></pre>\n<p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p>\n<p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p>\n<pre><code class=\"javascript\">const p1 = new Promise(function (resolve, reject) &#123;\n  setTimeout(() =&gt; reject(new Error(&#39;fail&#39;)), 3000)\n&#125;)\n\nconst p2 = new Promise(function (resolve, reject) &#123;\n  setTimeout(() =&gt; resolve(p1), 1000)\n&#125;)\n\np2\n  .then(result =&gt; console.log(result))\n  .catch(error =&gt; console.log(error))\n// Error: fail\n</code></pre>\n<p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p>\n<p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p>\n<pre><code class=\"javascript\">new Promise((resolve, reject) =&gt; &#123;\n  resolve(1);\n  console.log(2);\n&#125;).then(r =&gt; &#123;\n  console.log(r);\n&#125;);\n// 2\n// 1\n</code></pre>\n<p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>\n<p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p>\n<pre><code class=\"javascript\">new Promise((resolve, reject) =&gt; &#123;\n  return resolve(1);\n  // 后面的语句不会执行\n  console.log(2);\n&#125;)\n</code></pre>\n<h4 id=\"3-Promise-prototype-then\"><a href=\"#3-Promise-prototype-then\" class=\"headerlink\" title=\"3. Promise.prototype.then()\"></a>3. Promise.prototype.then()</h4><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数，它们都是可选的。</p>\n<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>\n<pre><code class=\"javascript\">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;\n  return json.post;\n&#125;).then(function(post) &#123;\n  // ...\n&#125;);\n</code></pre>\n<p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>\n<p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p>\n<pre><code class=\"javascript\">getJSON(&quot;/post/1.json&quot;).then(function(post) &#123;\n  return getJSON(post.commentURL);\n&#125;).then(function (comments) &#123;\n  console.log(&quot;resolved: &quot;, comments);\n&#125;, function (err)&#123;\n  console.log(&quot;rejected: &quot;, err);\n&#125;);\n</code></pre>\n<p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p>\n<p>如果采用箭头函数，上面的代码可以写得更简洁。</p>\n<pre><code class=\"javascript\">getJSON(&quot;/post/1.json&quot;).then(\n  post =&gt; getJSON(post.commentURL)\n).then(\n  comments =&gt; console.log(&quot;resolved: &quot;, comments),\n  err =&gt; console.log(&quot;rejected: &quot;, err)\n);\n</code></pre>\n<hr>\n<h4 id=\"4-Promise-prototype-catch\"><a href=\"#4-Promise-prototype-catch\" class=\"headerlink\" title=\"4. Promise.prototype.catch()\"></a>4. Promise.prototype.catch()</h4><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>\n<pre><code class=\"javascript\">getJSON(&#39;/posts.json&#39;).then(function(posts) &#123;\n  // ...\n&#125;).catch(function(error) &#123;\n  // 处理 getJSON 和 前一个回调函数运行时发生的错误\n  console.log(&#39;发生错误！&#39;, error);\n&#125;);\n</code></pre>\n<p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象，<strong>如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</strong></p>\n<pre><code class=\"javascript\">p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))\n  .catch((err) =&gt; console.log(&#39;rejected&#39;, err));\n\n// 等同于\np.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))\n  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));\n</code></pre>\n<p>下面是一个例子。</p>\n<pre><code class=\"javascript\">const promise = new Promise(function(resolve, reject) &#123;\n  throw new Error(&#39;test&#39;);\n&#125;);\npromise.catch(function(error) &#123;\n  console.log(error);\n&#125;);\n// Error: test\n</code></pre>\n<p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p>\n<pre><code class=\"javascript\">// 写法一\nconst promise = new Promise(function(resolve, reject) &#123;\n  try &#123;\n    throw new Error(&#39;test&#39;);\n  &#125; catch(e) &#123;\n    reject(e);\n  &#125;\n&#125;);\npromise.catch(function(error) &#123;\n  console.log(error);\n&#125;);\n\n// 写法二\nconst promise = new Promise(function(resolve, reject) &#123;\n  reject(new Error(&#39;test&#39;));\n&#125;);\npromise.catch(function(error) &#123;\n  console.log(error);\n&#125;);\n</code></pre>\n<p>比较上面两种写法，<strong>可以发现<code>reject()</code>方法的作用，等同于抛出错误。</strong></p>\n<p>如果 Promise 状态已经变成<code>resolved</code>，再抛出错误是无效的。</p>\n<pre><code class=\"javascript\">const promise = new Promise(function(resolve, reject) &#123;\n  resolve(&#39;ok&#39;);\n  throw new Error(&#39;test&#39;);\n&#125;);\npromise\n  .then(function(value) &#123; console.log(value) &#125;)\n  .catch(function(error) &#123; console.log(error) &#125;);\n// ok\n</code></pre>\n<p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p>\n<p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p>\n<pre><code class=\"javascript\">getJSON(&#39;/post/1.json&#39;).then(function(post) &#123;\n  return getJSON(post.commentURL);\n&#125;).then(function(comments) &#123;\n  // some code\n&#125;).catch(function(error) &#123;\n  // 处理前面三个Promise产生的错误\n&#125;);\n</code></pre>\n<p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p>\n<p><strong>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</strong></p>\n<pre><code class=\"javascript\">// bad\npromise\n  .then(function(data) &#123;\n    // success\n  &#125;, function(err) &#123;\n    // error\n  &#125;);\n\n// good\npromise\n  .then(function(data) &#123; //cb\n    // success\n  &#125;)\n  .catch(function(err) &#123;\n    // error\n  &#125;);\n</code></pre>\n<p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</p>\n<p><strong>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</strong></p>\n<pre><code class=\"javascript\">const someAsyncThing = function() &#123;\n  return new Promise(function(resolve, reject) &#123;\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  &#125;);\n&#125;;\n\nsomeAsyncThing().then(function() &#123;\n  console.log(&#39;everything is great&#39;);\n&#125;);\n\nsetTimeout(() =&gt; &#123; console.log(123) &#125;, 2000);\n// Uncaught (in promise) ReferenceError: x is not defined\n// 123\n</code></pre>\n<p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程、终止脚本执行，2 秒之后还是会输出<code>123</code>。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p>\n<p>这个脚本放在服务器执行，退出码就是<code>0</code>（即表示执行成功）。不过，Node.js 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p>\n<pre><code class=\"javascript\">process.on(&#39;unhandledRejection&#39;, function (err, p) &#123;\n  throw err;\n&#125;);\n</code></pre>\n<p>上面代码中，<code>unhandledRejection</code>事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</p>\n<p>注意，Node 有计划在未来废除<code>unhandledRejection</code>事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p>\n<p>再看下面的例子。</p>\n<pre><code class=\"javascript\">const promise = new Promise(function (resolve, reject) &#123;\n  resolve(&#39;ok&#39;);\n  setTimeout(function () &#123; throw new Error(&#39;test&#39;) &#125;, 0)\n&#125;);\npromise.then(function (value) &#123; console.log(value) &#125;);\n// ok\n// Uncaught Error: test\n</code></pre>\n<p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p>\n<p><strong>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。</strong><code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p>\n<pre><code class=\"javascript\">const someAsyncThing = function() &#123;\n  return new Promise(function(resolve, reject) &#123;\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  &#125;);\n&#125;;\n\nsomeAsyncThing()\n.catch(function(error) &#123;\n  console.log(&#39;oh no&#39;, error);\n&#125;)\n.then(function() &#123;\n  console.log(&#39;carry on&#39;);\n&#125;);\n// oh no [ReferenceError: x is not defined]\n// carry on\n</code></pre>\n<p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。如果没有报错，则会跳过<code>catch()</code>方法。</p>\n<pre><code class=\"javascript\">Promise.resolve()\n.catch(function(error) &#123;\n  console.log(&#39;oh no&#39;, error);\n&#125;)\n.then(function() &#123;\n  console.log(&#39;carry on&#39;);\n&#125;);\n// carry on\n</code></pre>\n<p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p>\n<p><code>catch()</code>方法之中，还能再抛出错误。</p>\n<pre><code class=\"javascript\">const someAsyncThing = function() &#123;\n  return new Promise(function(resolve, reject) &#123;\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  &#125;);\n&#125;;\n\nsomeAsyncThing().then(function() &#123;\n  return someOtherAsyncThing();\n&#125;).catch(function(error) &#123;\n  console.log(&#39;oh no&#39;, error);\n  // 下面一行会报错，因为 y 没有声明\n  y + 2;\n&#125;).then(function() &#123;\n  console.log(&#39;carry on&#39;);\n&#125;);\n// oh no [ReferenceError: x is not defined]\n</code></pre>\n<p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p>\n<pre><code class=\"javascript\">someAsyncThing().then(function() &#123;\n  return someOtherAsyncThing();\n&#125;).catch(function(error) &#123;\n  console.log(&#39;oh no&#39;, error);\n  // 下面一行会报错，因为y没有声明\n  y + 2;\n&#125;).catch(function(error) &#123;\n  console.log(&#39;carry on&#39;, error);\n&#125;);\n// oh no [ReferenceError: x is not defined]\n// carry on [ReferenceError: y is not defined]\n</code></pre>\n<p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p>\n<hr>\n<h4 id=\"5-Promise-prototype-finally\"><a href=\"#5-Promise-prototype-finally\" class=\"headerlink\" title=\"5. Promise.prototype.finally()\"></a>5. Promise.prototype.finally()</h4><p><strong><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</strong></p>\n<pre><code class=\"javascript\">promise\n.then(result =&gt; &#123;···&#125;)\n.catch(error =&gt; &#123;···&#125;)\n.finally(() =&gt; &#123;···&#125;);\n</code></pre>\n<p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>\n<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p>\n<pre><code class=\"javascript\">server.listen(port)\n  .then(function () &#123;\n    // ...\n  &#125;)\n  .finally(server.stop);\n</code></pre>\n<p><strong><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果</strong>。</p>\n<p><code>finally</code>本质上是<code>then</code>方法的特例。</p>\n<pre><code class=\"javascript\">promise\n.finally(() =&gt; &#123;\n  // 语句\n&#125;);\n\n// 等同于\npromise\n.then(\n  result =&gt; &#123;\n    // 语句\n    return result;\n  &#125;,\n  error =&gt; &#123;\n    // 语句\n    throw error;\n  &#125;\n);\n</code></pre>\n<p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p>\n<p>它的实现也很简单。</p>\n<pre><code class=\"javascript\">Promise.prototype.finally = function (callback) &#123;\n  let P = this.constructor;\n  return this.then(\n    value  =&gt; P.resolve(callback()).then(() =&gt; value),\n    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)\n  );\n&#125;;\n</code></pre>\n<p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p>\n<p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值。</p>\n<pre><code class=\"javascript\">// resolve 的值是 undefined\nPromise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)\n\n// resolve 的值是 2\nPromise.resolve(2).finally(() =&gt; &#123;&#125;)\n\n// reject 的值是 undefined\nPromise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)\n\n// reject 的值是 3\nPromise.reject(3).finally(() =&gt; &#123;&#125;)\n</code></pre>\n<hr>\n<h4 id=\"6-Promise-all\"><a href=\"#6-Promise-all\" class=\"headerlink\" title=\"6. Promise.all()\"></a>6. Promise.all()</h4><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>\n<pre><code class=\"javascript\">const p = Promise.all([p1, p2, p3]);\n</code></pre>\n<p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，<strong>如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例</strong>，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p>\n<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>\n<p><strong>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</strong></p>\n<p><strong>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</strong></p>\n<p>下面是一个具体的例子。</p>\n<pre><code class=\"javascript\">// 生成一个Promise对象的数组\nconst promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123;\n  return getJSON(&#39;/post/&#39; + id + &quot;.json&quot;);\n&#125;);\n\nPromise.all(promises).then(function (posts) &#123;\n  // ...\n&#125;).catch(function(reason)&#123;\n  // ...\n&#125;);\n</code></pre>\n<p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>\n<p>下面是另一个例子。</p>\n<pre><code class=\"javascript\">const databasePromise = connectDatabase();\n\nconst booksPromise = databasePromise\n  .then(findAllBooks);\n\nconst userPromise = databasePromise\n  .then(getCurrentUser);\n\nPromise.all([\n  booksPromise,\n  userPromise\n])\n.then(([books, user]) =&gt; pickTopRecommendations(books, user));\n</code></pre>\n<p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p>\n<p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p>\n<pre><code class=\"javascript\">const p1 = new Promise((resolve, reject) =&gt; &#123;\n  resolve(&#39;hello&#39;);\n&#125;)\n.then(result =&gt; result)\n.catch(e =&gt; e);\n\nconst p2 = new Promise((resolve, reject) =&gt; &#123;\n  throw new Error(&#39;报错了&#39;);\n&#125;)\n.then(result =&gt; result)\n.catch(e =&gt; e);\n\nPromise.all([p1, p2])\n.then(result =&gt; console.log(result))\n.catch(e =&gt; console.log(e));\n// [&quot;hello&quot;, Error: 报错了]\n</code></pre>\n<p>上面代码中，<code>p1</code>会<code>resolved</code>，**<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>**，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p>\n<p><strong>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</strong></p>\n<pre><code class=\"javascript\">const p1 = new Promise((resolve, reject) =&gt; &#123;\n  resolve(&#39;hello&#39;);\n&#125;)\n.then(result =&gt; result);\n\nconst p2 = new Promise((resolve, reject) =&gt; &#123;\n  throw new Error(&#39;报错了&#39;);\n&#125;)\n.then(result =&gt; result);\n\nPromise.all([p1, p2])\n.then(result =&gt; console.log(result))\n.catch(e =&gt; console.log(e));\n// Error: 报错了\n</code></pre>\n<hr>\n<h4 id=\"7-Promise-race\"><a href=\"#7-Promise-race\" class=\"headerlink\" title=\"7. Promise.race()\"></a>7. Promise.race()</h4><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>\n<pre><code class=\"javascript\">const p = Promise.race([p1, p2, p3]);\n</code></pre>\n<p>上面代码中<strong>，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</strong></p>\n<p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p>\n<p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p>\n<pre><code class=\"javascript\">const p = Promise.race([\n  fetch(&#39;/resource-that-may-take-a-while&#39;),\n  new Promise(function (resolve, reject) &#123;\n    setTimeout(() =&gt; reject(new Error(&#39;request timeout&#39;)), 5000)\n  &#125;)\n]);\n\np\n.then(console.log)\n.catch(console.error);\n</code></pre>\n<p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>\n<hr>\n<h4 id=\"8-Promise-allSettled\"><a href=\"#8-Promise-allSettled\" class=\"headerlink\" title=\"8. Promise.allSettled()\"></a>8. Promise.allSettled()</h4><p>有时候，我们希望等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。但是，现有的 Promise 方法很难实现这个要求。</p>\n<p><code>Promise.all()</code>方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求。</p>\n<pre><code class=\"javascript\">const urls = [url_1, url_2, url_3];\nconst requests = urls.map(x =&gt; fetch(x));\n\ntry &#123;\n  await Promise.all(requests);\n  console.log(&#39;所有请求都成功。&#39;);\n&#125; catch &#123;\n  console.log(&#39;至少一个请求失败，其他请求可能还没结束。&#39;);\n&#125;\n</code></pre>\n<p>上面示例中，<code>Promise.all()</code>可以确定所有请求都成功了，但是只要有一个请求失败，它就会报错，而不管另外的请求是否结束。</p>\n<p>为了解决这个问题，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS1hbGxTZXR0bGVk\">ES2020</span> 引入了<code>Promise.allSettled()</code>方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。</p>\n<p><code>Promise.allSettled()</code>方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。<strong>只有等到参数数组的所有 Promise 对象都发生状态变更（不管是<code>fulfilled</code>还是<code>rejected</code>），返回的 Promise 对象才会发生状态变更。</strong></p>\n<pre><code class=\"javascript\">const promises = [\n  fetch(&#39;/api-1&#39;),\n  fetch(&#39;/api-2&#39;),\n  fetch(&#39;/api-3&#39;),\n];\n\nawait Promise.allSettled(promises);\nremoveLoadingIndicator();\n</code></pre>\n<p>上面示例中，数组<code>promises</code>包含了三个请求，只有等到这三个请求都结束了（不管请求成功还是失败），<code>removeLoadingIndicator()</code>才会执行。</p>\n<p>该方法返回的新的 Promise 实例，一旦发生状态变更，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。</p>\n<pre><code class=\"javascript\">const resolved = Promise.resolve(42);\nconst rejected = Promise.reject(-1);\n\nconst allSettledPromise = Promise.allSettled([resolved, rejected]);\n\nallSettledPromise.then(function (results) &#123;\n  console.log(results);\n&#125;);\n// [\n//    &#123; status: &#39;fulfilled&#39;, value: 42 &#125;,\n//    &#123; status: &#39;rejected&#39;, reason: -1 &#125;\n// ]\n</code></pre>\n<p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。它的回调函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应传入<code>Promise.allSettled()</code>的数组里面的两个 Promise 对象。</p>\n<p><code>results</code>的每个成员是一个对象，对象的格式是固定的，对应异步操作的结果。</p>\n<pre><code class=\"javascript\">// 异步操作成功时\n&#123;status: &#39;fulfilled&#39;, value: value&#125;\n\n// 异步操作失败时\n&#123;status: &#39;rejected&#39;, reason: reason&#125;\n</code></pre>\n<p>成员对象的<code>status</code>属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>，用来区分异步操作是成功还是失败。如果是成功（<code>fulfilled</code>），对象会有<code>value</code>属性，如果是失败（<code>rejected</code>），会有<code>reason</code>属性，对应两种状态时前面异步操作的返回值。</p>\n<p>下面是返回值的用法例子。</p>\n<pre><code class=\"javascript\">const promises = [ fetch(&#39;index.html&#39;), fetch(&#39;https://does-not-exist/&#39;) ];\nconst results = await Promise.allSettled(promises);\n\n// 过滤出成功的请求\nconst successfulPromises = results.filter(p =&gt; p.status === &#39;fulfilled&#39;);\n\n// 过滤出失败的请求，并输出原因\nconst errors = results\n  .filter(p =&gt; p.status === &#39;rejected&#39;)\n  .map(p =&gt; p.reason);\n</code></pre>\n<hr>\n<h4 id=\"9-Promise-any\"><a href=\"#9-Promise-any\" class=\"headerlink\" title=\"9. Promise.any()\"></a>9. Promise.any()</h4><p>ES2021 引入了<a href=\"https://github.com/tc39/proposal-promise-any\"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。</p>\n<pre><code class=\"javascript\">Promise.any([\n  fetch(&#39;https://v8.dev/&#39;).then(() =&gt; &#39;home&#39;),\n  fetch(&#39;https://v8.dev/blog&#39;).then(() =&gt; &#39;blog&#39;),\n  fetch(&#39;https://v8.dev/docs&#39;).then(() =&gt; &#39;docs&#39;)\n]).then((first) =&gt; &#123;  // 只要有一个 fetch() 请求成功\n  console.log(first);\n&#125;).catch((error) =&gt; &#123; // 所有三个 fetch() 全部请求失败\n  console.log(error);\n&#125;);\n</code></pre>\n<p><strong>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</strong></p>\n<p><strong><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是<code>Promise.any()</code>不会因为某个 Promise 变成<code>rejected</code>状态而结束，必须等到所有参数 Promise 变成<code>rejected</code>状态才会结束。</strong></p>\n<p>下面是<code>Promise()</code>与<code>await</code>命令结合使用的例子。</p>\n<pre><code class=\"javascript\">const promises = [\n  fetch(&#39;/endpoint-a&#39;).then(() =&gt; &#39;a&#39;),\n  fetch(&#39;/endpoint-b&#39;).then(() =&gt; &#39;b&#39;),\n  fetch(&#39;/endpoint-c&#39;).then(() =&gt; &#39;c&#39;),\n];\n\ntry &#123;\n  const first = await Promise.any(promises);\n  console.log(first);\n&#125; catch (error) &#123;\n  console.log(error);\n&#125;\n</code></pre>\n<p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p>\n<p><code>Promise.any()</code>抛出的错误，不是一个一般的 Error 错误对象，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p>\n<pre><code class=\"javascript\">// new AggregateError() extends Array\n\nconst err = new AggregateError();\nerr.push(new Error(&quot;first error&quot;));\nerr.push(new Error(&quot;second error&quot;));\n// ...\nthrow err;\n</code></pre>\n<p>下面是一个例子。</p>\n<pre><code class=\"javascript\">var resolved = Promise.resolve(42);\nvar rejected = Promise.reject(-1);\nvar alsoRejected = Promise.reject(Infinity);\n\nPromise.any([resolved, rejected, alsoRejected]).then(function (result) &#123;\n  console.log(result); // 42\n&#125;);\n\nPromise.any([rejected, alsoRejected]).catch(function (results) &#123;\n  console.log(results); // [-1, Infinity]\n&#125;);\n</code></pre>\n<hr>\n<h4 id=\"10-Promise-resolve\"><a href=\"#10-Promise-resolve\" class=\"headerlink\" title=\"10. Promise.resolve()\"></a>10. Promise.resolve()</h4><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p>\n<pre><code class=\"javascript\">const jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;));\n</code></pre>\n<p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p>\n<p><code>Promise.resolve()</code>等价于下面的写法。</p>\n<pre><code class=\"javascript\">Promise.resolve(&#39;foo&#39;)\n// 等价于\nnew Promise(resolve =&gt; resolve(&#39;foo&#39;))\n</code></pre>\n<p><code>Promise.resolve()</code>方法的参数分成四种情况。</p>\n<p><strong>（1）参数是一个 Promise 实例</strong></p>\n<p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p>\n<p><strong>（2）参数是一个<code>thenable</code>对象</strong></p>\n<p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p>\n<pre><code class=\"javascript\">let thenable = &#123;\n  then: function(resolve, reject) &#123;\n    resolve(42);\n  &#125;\n&#125;;\n</code></pre>\n<p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p>\n<pre><code class=\"javascript\">let thenable = &#123;\n  then: function(resolve, reject) &#123;\n    resolve(42);\n  &#125;\n&#125;;\n\nlet p1 = Promise.resolve(thenable);\np1.then(function (value) &#123;\n  console.log(value);  // 42\n&#125;);\n</code></pre>\n<p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出42。</p>\n<p><strong>（3）参数不是具有<code>then()</code>方法的对象，或根本就不是对象</strong></p>\n<p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p>\n<pre><code class=\"javascript\">const p = Promise.resolve(&#39;Hello&#39;);\n\np.then(function (s) &#123;\n  console.log(s)\n&#125;);\n// Hello\n</code></pre>\n<p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve()</code>方法的参数，会同时传给回调函数。</p>\n<p><strong>（4）不带有任何参数</strong></p>\n<p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p>\n<p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p>\n<pre><code class=\"javascript\">const p = Promise.resolve();\n\np.then(function () &#123;\n  // ...\n&#125;);\n</code></pre>\n<p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p>\n<p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p>\n<pre><code class=\"javascript\">setTimeout(function () &#123;\n  console.log(&#39;three&#39;);\n&#125;, 0);\n\nPromise.resolve().then(function () &#123;\n  console.log(&#39;two&#39;);\n&#125;);\n\nconsole.log(&#39;one&#39;);\n\n// one\n// two\n// three\n</code></pre>\n<p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p>\n<hr>\n<h4 id=\"11-Promise-reject\"><a href=\"#11-Promise-reject\" class=\"headerlink\" title=\"11. Promise.reject()\"></a>11. Promise.reject()</h4><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p>\n<pre><code class=\"javascript\">const p = Promise.reject(&#39;出错了&#39;);\n// 等同于\nconst p = new Promise((resolve, reject) =&gt; reject(&#39;出错了&#39;))\n\np.then(null, function (s) &#123;\n  console.log(s)\n&#125;);\n// 出错了\n</code></pre>\n<p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p>\n<p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p>\n<pre><code class=\"javascript\">Promise.reject(&#39;出错了&#39;)\n.catch(e =&gt; &#123;\n  console.log(e === &#39;出错了&#39;)\n&#125;)\n// true\n</code></pre>\n<p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p>\n<hr>\n<h4 id=\"12-应用\"><a href=\"#12-应用\" class=\"headerlink\" title=\"12. 应用\"></a>12. 应用</h4><p><strong>加载图片</strong></p>\n<p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p>\n<pre><code class=\"javascript\">const preloadImage = function (path) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    const image = new Image();\n    image.onload  = resolve;\n    image.onerror = reject;\n    image.src = path;\n  &#125;);\n&#125;;\n</code></pre>\n<p><strong>Generator 函数与 Promise 的结合</strong></p>\n<p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p>\n<pre><code class=\"javascript\">function getFoo () &#123;\n  return new Promise(function (resolve, reject)&#123;\n    resolve(&#39;foo&#39;);\n  &#125;);\n&#125;\n\nconst g = function* () &#123;\n  try &#123;\n    const foo = yield getFoo();\n    console.log(foo);\n  &#125; catch (e) &#123;\n    console.log(e);\n  &#125;\n&#125;;\n\nfunction run (generator) &#123;\n  const it = generator();\n\n  function go(result) &#123;\n    if (result.done) return result.value;\n\n    return result.value.then(function (value) &#123;\n      return go(it.next(value));\n    &#125;, function (error) &#123;\n      return go(it.throw(error));\n    &#125;);\n  &#125;\n\n  go(it.next());\n&#125;\n\nrun(g);\n</code></pre>\n<p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p>\n<hr>\n<h4 id=\"13-Promise-try\"><a href=\"#13-Promise-try\" class=\"headerlink\" title=\"13. Promise.try()\"></a>13. Promise.try()</h4><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p>\n<pre><code class=\"javascript\">Promise.resolve().then(f)\n</code></pre>\n<p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p>\n<pre><code class=\"javascript\">const f = () =&gt; console.log(&#39;now&#39;);\nPromise.resolve().then(f);\nconsole.log(&#39;next&#39;);\n// next\n// now\n</code></pre>\n<p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p>\n<p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用<code>async</code>函数来写。</p>\n<pre><code class=\"javascript\">const f = () =&gt; console.log(&#39;now&#39;);\n(async () =&gt; f())();\nconsole.log(&#39;next&#39;);\n// now\n// next\n</code></pre>\n<p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p>\n<pre><code class=\"javascript\">(async () =&gt; f())()\n.then(...)\n</code></pre>\n<p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p>\n<pre><code class=\"javascript\">(async () =&gt; f())()\n.then(...)\n.catch(...)\n</code></pre>\n<p>第二种写法是使用<code>new Promise()</code>。</p>\n<pre><code class=\"javascript\">const f = () =&gt; console.log(&#39;now&#39;);\n(\n  () =&gt; new Promise(\n    resolve =&gt; resolve(f())\n  )\n)();\nconsole.log(&#39;next&#39;);\n// now\n// next\n</code></pre>\n<p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p>\n<p>鉴于这是一个很常见的需求，所以现在有一个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1wcm9taXNlLXRyeQ==\">提案</span>，提供<code>Promise.try</code>方法替代上面的写法。</p>\n<pre><code class=\"javascript\">const f = () =&gt; console.log(&#39;now&#39;);\nPromise.try(f);\nconsole.log(&#39;next&#39;);\n// now\n// next\n</code></pre>\n<p>事实上，<code>Promise.try</code>存在已久，Promise 库<a href=\"http://bluebirdjs.com/docs/api/promise.try.html\"><code>Bluebird</code></a>、<a href=\"https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs\"><code>Q</code></a>和<a href=\"https://github.com/cujojs/when/blob/master/docs/api.md#whentry\"><code>when</code></a>，早就提供了这个方法。</p>\n<p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<span class=\"exturl\" data-url=\"aHR0cDovL2NyeXRvLm5ldC9+am9lcGllOTEvYmxvZy8yMDE2LzA1LzExL3doYXQtaXMtcHJvbWlzZS10cnktYW5kLXdoeS1kb2VzLWl0LW1hdHRlci8=\">许多好处</span>，其中一点就是可以更好地管理异常。</p>\n<pre><code class=\"javascript\">function getUsername(userId) &#123;\n  return database.users.get(&#123;id: userId&#125;)\n  .then(function(user) &#123;\n    return user.name;\n  &#125;);\n&#125;\n</code></pre>\n<p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p>\n<pre><code class=\"javascript\">database.users.get(&#123;id: userId&#125;)\n.then(...)\n.catch(...)\n</code></pre>\n<p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p>\n<pre><code class=\"javascript\">try &#123;\n  database.users.get(&#123;id: userId&#125;)\n  .then(...)\n  .catch(...)\n&#125; catch (e) &#123;\n  // ...\n&#125;\n</code></pre>\n<p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p>\n<pre><code class=\"javascript\">Promise.try(() =&gt; database.users.get(&#123;id: userId&#125;))\n  .then(...)\n  .catch(...)\n</code></pre>\n<p><strong>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</strong></p>\n<h3 id=\"17、-Iterator-和-for…of-循环\"><a href=\"#17、-Iterator-和-for…of-循环\" class=\"headerlink\" title=\"17、 Iterator 和 for…of 循环\"></a>17、 Iterator 和 for…of 循环</h3><h4 id=\"1-Iterator（遍历器）的概念\"><a href=\"#1-Iterator（遍历器）的概念\" class=\"headerlink\" title=\"1. Iterator（遍历器）的概念\"></a>1. Iterator（遍历器）的概念</h4><p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>\n<p><strong>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</strong></p>\n<p>Iterator 的作用有三个：<strong>一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</strong></p>\n<p>Iterator 的遍历过程是这样的。</p>\n<p><strong>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</strong></p>\n<p><strong>（2）第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</strong></p>\n<p>（3）第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</p>\n<p>（4）不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p>\n<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，<strong>就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</strong></p>\n<p>下面是一个模拟<code>next</code>方法返回值的例子。</p>\n<pre><code class=\"javascript\">var it = makeIterator([&#39;a&#39;, &#39;b&#39;]);\n\nit.next() // &#123; value: &quot;a&quot;, done: false &#125;\nit.next() // &#123; value: &quot;b&quot;, done: false &#125;\nit.next() // &#123; value: undefined, done: true &#125;\n\nfunction makeIterator(array) &#123;\n  var nextIndex = 0;\n  return &#123;\n    next: function() &#123;\n      return nextIndex &lt; array.length ?\n        &#123;value: array[nextIndex++], done: false&#125; :\n        &#123;value: undefined, done: true&#125;;\n    &#125;\n  &#125;;\n&#125;\n</code></pre>\n<p>上面代码定义了一个<code>makeIterator</code>函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组<code>[&#39;a&#39;, &#39;b&#39;]</code>执行这个函数，就会返回该数组的遍历器对象（即指针对象）<code>it</code>。</p>\n<p>指针对象的<code>next</code>方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用<code>next</code>方法，指针就会指向数组的下一个成员。第一次调用，指向<code>a</code>；第二次调用，指向<code>b</code>。</p>\n<p><code>next</code>方法返回一个对象，表示当前数据成员的信息。这个对象具有<code>value</code>和<code>done</code>两个属性，<code>value</code>属性返回当前位置的成员，<code>done</code>属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用<code>next</code>方法。</p>\n<p>总之，调用指针对象的<code>next</code>方法，就可以遍历事先给定的数据结构。</p>\n<p>对于遍历器对象来说，<code>done: false</code>和<code>value: undefined</code>属性都是可以省略的，因此上面的<code>makeIterator</code>函数可以简写成下面的形式。</p>\n<pre><code class=\"javascript\">function makeIterator(array) &#123;\n  var nextIndex = 0;\n  return &#123;\n    next: function() &#123;\n      return nextIndex &lt; array.length ?\n        &#123;value: array[nextIndex++]&#125; :\n        &#123;done: true&#125;;\n    &#125;\n  &#125;;\n&#125;\n</code></pre>\n<p>由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。</p>\n<pre><code class=\"javascript\">var it = idMaker();\n\nit.next().value // 0\nit.next().value // 1\nit.next().value // 2\n// ...\n\nfunction idMaker() &#123;\n  var index = 0;\n\n  return &#123;\n    next: function() &#123;\n      return &#123;value: index++, done: false&#125;;\n    &#125;\n  &#125;;\n&#125;\n</code></pre>\n<p>上面的例子中，遍历器生成函数<code>idMaker</code>，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。</p>\n<p>如果使用 TypeScript 的写法，遍历器接口（Iterable）、指针对象（Iterator）和<code>next</code>方法返回值的规格可以描述如下。</p>\n<pre><code class=\"javascript\">interface Iterable &#123;\n  [Symbol.iterator]() : Iterator,\n&#125;\n\ninterface Iterator &#123;\n  next(value?: any) : IterationResult,\n&#125;\n\ninterface IterationResult &#123;\n  value: any,\n  done: boolean,\n&#125;\n</code></pre>\n<hr>\n<h4 id=\"2-默认-Iterator-接口\"><a href=\"#2-默认-Iterator-接口\" class=\"headerlink\" title=\"2. 默认 Iterator 接口\"></a>2. 默认 Iterator 接口</h4><p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环（详见下文）。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p>\n<p><strong>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</strong></p>\n<p>ES6 规定，默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名<code>Symbol.iterator</code>，它是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见《Symbol》一章）。</p>\n<pre><code class=\"javascript\">const obj = &#123;\n  [Symbol.iterator] : function () &#123;\n    return &#123;\n      next: function () &#123;\n        return &#123;\n          value: 1,\n          done: true\n        &#125;;\n      &#125;\n    &#125;;\n  &#125;\n&#125;;\n</code></pre>\n<p>上面代码中，对象<code>obj</code>是可遍历的（iterable），因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有<code>next</code>方法。每次调用<code>next</code>方法，都会返回一个代表当前成员的信息对象，具有<code>value</code>和<code>done</code>两个属性。</p>\n<p>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被<code>for...of</code>循环遍历。原因在于，这些数据结构原生部署了<code>Symbol.iterator</code>属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p>\n<p>原生具备 Iterator 接口的数据结构如下。</p>\n<ul>\n<li>Array</li>\n<li>Map</li>\n<li>Set</li>\n<li>String</li>\n<li>TypedArray</li>\n<li>函数的 arguments 对象</li>\n<li>NodeList 对象</li>\n</ul>\n<p>下面的例子是数组的<code>Symbol.iterator</code>属性。</p>\n<pre><code class=\"javascript\">let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];\nlet iter = arr[Symbol.iterator]();\n\niter.next() // &#123; value: &#39;a&#39;, done: false &#125;\niter.next() // &#123; value: &#39;b&#39;, done: false &#125;\niter.next() // &#123; value: &#39;c&#39;, done: false &#125;\niter.next() // &#123; value: undefined, done: true &#125;\n</code></pre>\n<p>上面代码中，变量<code>arr</code>是一个数组，原生就具有遍历器接口，部署在<code>arr</code>的<code>Symbol.iterator</code>属性上面。所以，调用这个属性，就得到遍历器对象。</p>\n<p>对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code>循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在<code>Symbol.iterator</code>属性上面部署，这样才会被<code>for...of</code>循环遍历。</p>\n<p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。</p>\n<p>一个对象如果要具备可被<code>for...of</code>循环调用的 Iterator 接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p>\n<pre><code class=\"javascript\">class RangeIterator &#123;\n  constructor(start, stop) &#123;\n    this.value = start;\n    this.stop = stop;\n  &#125;\n\n  [Symbol.iterator]() &#123; return this; &#125;\n\n  next() &#123;\n    var value = this.value;\n    if (value &lt; this.stop) &#123;\n      this.value++;\n      return &#123;done: false, value: value&#125;;\n    &#125;\n    return &#123;done: true, value: undefined&#125;;\n  &#125;\n&#125;\n\nfunction range(start, stop) &#123;\n  return new RangeIterator(start, stop);\n&#125;\n\nfor (var value of range(0, 3)) &#123;\n  console.log(value); // 0, 1, 2\n&#125;\n</code></pre>\n<p>上面代码是一个类部署 Iterator 接口的写法。<code>Symbol.iterator</code>属性对应一个函数，执行后返回当前对象的遍历器对象。</p>\n<p>下面是通过遍历器实现“链表”结构的例子。</p>\n<pre><code class=\"javascript\">function Obj(value) &#123;\n  this.value = value;\n  this.next = null;\n&#125;\n\nObj.prototype[Symbol.iterator] = function() &#123;\n  var iterator = &#123; next: next &#125;;\n\n  var current = this;\n\n  function next() &#123;\n    if (current) &#123;\n      var value = current.value;\n      current = current.next;\n      return &#123; done: false, value: value &#125;;\n    &#125;\n    return &#123; done: true &#125;;\n  &#125;\n  return iterator;\n&#125;\n\nvar one = new Obj(1);\nvar two = new Obj(2);\nvar three = new Obj(3);\n\none.next = two;\ntwo.next = three;\n\nfor (var i of one)&#123;\n  console.log(i); // 1, 2, 3\n&#125;\n</code></pre>\n<p>上面代码首先在构造函数的原型链上部署<code>Symbol.iterator</code>方法，调用该方法会返回遍历器对象<code>iterator</code>，调用该对象的<code>next</code>方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p>\n<p>下面是另一个为对象添加 Iterator 接口的例子。</p>\n<pre><code class=\"javascript\">let obj = &#123;\n  data: [ &#39;hello&#39;, &#39;world&#39; ],\n  [Symbol.iterator]() &#123;\n    const self = this;\n    let index = 0;\n    return &#123;\n      next() &#123;\n        if (index &lt; self.data.length) &#123;\n          return &#123;\n            value: self.data[index++],\n            done: false\n          &#125;;\n        &#125;\n        return &#123; value: undefined, done: true &#125;;\n      &#125;\n    &#125;;\n  &#125;\n&#125;;\n</code></pre>\n<p>对于类似数组的对象（存在数值键名和<code>length</code>属性），部署 Iterator 接口，有一个简便方法，就是<code>Symbol.iterator</code>方法直接引用数组的 Iterator 接口。</p>\n<pre><code class=\"javascript\">NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];\n// 或者\nNodeList.prototype[Symbol.iterator] = [][Symbol.iterator];\n\n[...document.querySelectorAll(&#39;div&#39;)] // 可以执行了\n</code></pre>\n<p>NodeList 对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的<code>Symbol.iterator</code>属性，可以看到没有任何影响。</p>\n<p>下面是另一个类似数组的对象调用数组的<code>Symbol.iterator</code>方法的例子。</p>\n<pre><code class=\"javascript\">let iterable = &#123;\n  0: &#39;a&#39;,\n  1: &#39;b&#39;,\n  2: &#39;c&#39;,\n  length: 3,\n  [Symbol.iterator]: Array.prototype[Symbol.iterator]\n&#125;;\nfor (let item of iterable) &#123;\n  console.log(item); // &#39;a&#39;, &#39;b&#39;, &#39;c&#39;\n&#125;\n</code></pre>\n<p>注意，普通对象部署数组的<code>Symbol.iterator</code>方法，并无效果。</p>\n<pre><code class=\"javascript\">let iterable = &#123;\n  a: &#39;a&#39;,\n  b: &#39;b&#39;,\n  c: &#39;c&#39;,\n  length: 3,\n  [Symbol.iterator]: Array.prototype[Symbol.iterator]\n&#125;;\nfor (let item of iterable) &#123;\n  console.log(item); // undefined, undefined, undefined\n&#125;\n</code></pre>\n<p>如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。</p>\n<pre><code class=\"javascript\">var obj = &#123;&#125;;\n\nobj[Symbol.iterator] = () =&gt; 1;\n\n[...obj] // TypeError: [] is not a function\n</code></pre>\n<p>上面代码中，变量<code>obj</code>的<code>Symbol.iterator</code>方法对应的不是遍历器生成函数，因此报错。</p>\n<p>有了遍历器接口，数据结构就可以用<code>for...of</code>循环遍历（详见下文），也可以使用<code>while</code>循环遍历。</p>\n<pre><code class=\"javascript\">var $iterator = ITERABLE[Symbol.iterator]();\nvar $result = $iterator.next();\nwhile (!$result.done) &#123;\n  var x = $result.value;\n  // ...\n  $result = $iterator.next();\n&#125;\n</code></pre>\n<p>上面代码中，<code>ITERABLE</code>代表某种可遍历的数据结构，<code>$iterator</code>是它的遍历器对象。遍历器对象每次移动指针（<code>next</code>方法），都检查一下返回值的<code>done</code>属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（<code>next</code>方法），不断循环。</p>\n<hr>\n<h4 id=\"3-调用-Iterator-接口的场合\"><a href=\"#3-调用-Iterator-接口的场合\" class=\"headerlink\" title=\"3. 调用 Iterator 接口的场合\"></a>3. 调用 Iterator 接口的场合</h4><p>有一些场合会默认调用 Iterator 接口（即<code>Symbol.iterator</code>方法），除了下文会介绍的<code>for...of</code>循环，还有几个别的场合。</p>\n<p><strong>（1）解构赋值</strong></p>\n<p>对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p>\n<pre><code class=\"javascript\">let set = new Set().add(&#39;a&#39;).add(&#39;b&#39;).add(&#39;c&#39;)                                                                                              \nlet [x,y] = set;\n// x=&#39;a&#39;; y=&#39;b&#39;\n\nlet [first, ...rest] = set;\n// first=&#39;a&#39;; rest=[&#39;b&#39;,&#39;c&#39;];\n</code></pre>\n<p><strong>（2）扩展运算符</strong></p>\n<p>扩展运算符（…）也会调用默认的 Iterator 接口。</p>\n<pre><code class=\"javascript\">// 例一\nvar str = &#39;hello&#39;;\n[...str] //  [&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;]\n\n// 例二\nlet arr = [&#39;b&#39;, &#39;c&#39;];\n[&#39;a&#39;, ...arr, &#39;d&#39;]\n// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]\n</code></pre>\n<p>上面代码的扩展运算符内部就调用 Iterator 接口。</p>\n<p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，<strong>只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</strong></p>\n<pre><code class=\"javascript\">let arr = [...iterable];\n</code></pre>\n<p><strong>（3）yield*</strong></p>\n<p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>\n<pre><code class=\"javascript\">let generator = function* () &#123;\n  yield 1;\n  yield* [2,3,4];\n  yield 5;\n&#125;;\n\nvar iterator = generator();\n\niterator.next() // &#123; value: 1, done: false &#125;\niterator.next() // &#123; value: 2, done: false &#125;\niterator.next() // &#123; value: 3, done: false &#125;\niterator.next() // &#123; value: 4, done: false &#125;\niterator.next() // &#123; value: 5, done: false &#125;\niterator.next() // &#123; value: undefined, done: true &#125;\n</code></pre>\n<p><strong>（4）其他场合</strong></p>\n<p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p>\n<ul>\n<li>for…of</li>\n<li>Array.from()</li>\n<li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li>\n<li>Promise.all()</li>\n<li>Promise.race()</li>\n</ul>\n<hr>\n<h4 id=\"4-字符串的-Iterator-接口\"><a href=\"#4-字符串的-Iterator-接口\" class=\"headerlink\" title=\"4. 字符串的 Iterator 接口\"></a>4. 字符串的 Iterator 接口</h4><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。</p>\n<pre><code class=\"javascript\">var someString = &quot;hi&quot;;\ntypeof someString[Symbol.iterator]\n// &quot;function&quot;\n\nvar iterator = someString[Symbol.iterator]();\n\niterator.next()  // &#123; value: &quot;h&quot;, done: false &#125;\niterator.next()  // &#123; value: &quot;i&quot;, done: false &#125;\niterator.next()  // &#123; value: undefined, done: true &#125;\n</code></pre>\n<p>上面代码中，调用<code>Symbol.iterator</code>方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。</p>\n<p>可以覆盖原生的<code>Symbol.iterator</code>方法，达到修改遍历器行为的目的。</p>\n<pre><code class=\"javascript\">var str = new String(&quot;hi&quot;);\n\n[...str] // [&quot;h&quot;, &quot;i&quot;]\n\nstr[Symbol.iterator] = function() &#123;\n  return &#123;\n    next: function() &#123;\n      if (this._first) &#123;\n        this._first = false;\n        return &#123; value: &quot;bye&quot;, done: false &#125;;\n      &#125; else &#123;\n        return &#123; done: true &#125;;\n      &#125;\n    &#125;,\n    _first: true\n  &#125;;\n&#125;;\n\n[...str] // [&quot;bye&quot;]\nstr // &quot;hi&quot;\n</code></pre>\n<p>上面代码中，字符串 str 的<code>Symbol.iterator</code>方法被修改了，所以扩展运算符（<code>...</code>）返回的值变成了<code>bye</code>，而字符串本身还是<code>hi</code>。</p>\n<hr>\n<h4 id=\"5-Iterator-接口与-Generator-函数\"><a href=\"#5-Iterator-接口与-Generator-函数\" class=\"headerlink\" title=\"5. Iterator 接口与 Generator 函数\"></a>5. Iterator 接口与 Generator 函数</h4><p><strong><code>Symbol.iterator()</code>方法的最简单实现</strong>，还是使用下一章要介绍的 Generator 函数。</p>\n<pre><code class=\"javascript\">let myIterable = &#123;\n  [Symbol.iterator]: function* () &#123;\n    yield 1;\n    yield 2;\n    yield 3;\n  &#125;\n&#125;;\n[...myIterable] // [1, 2, 3]\n\n// 或者采用下面的简洁写法\n\nlet obj = &#123;\n  * [Symbol.iterator]() &#123;\n    yield &#39;hello&#39;;\n    yield &#39;world&#39;;\n  &#125;\n&#125;;\n\nfor (let x of obj) &#123;\n  console.log(x);\n&#125;\n// &quot;hello&quot;\n// &quot;world&quot;\n</code></pre>\n<p>上面代码中，<code>Symbol.iterator()</code>方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。</p>\n<hr>\n<h4 id=\"6-遍历器对象的-return-，throw\"><a href=\"#6-遍历器对象的-return-，throw\" class=\"headerlink\" title=\"6. 遍历器对象的 return()，throw()\"></a>6. 遍历器对象的 return()，throw()</h4><p>遍历器对象除了具有<code>next()</code>方法，还可以具有<code>return()</code>方法和<code>throw()</code>方法。如果你自己写遍历器对象生成函数，那么<code>next()</code>方法是必须部署的，<code>return()</code>方法和<code>throw()</code>方法是否部署是可选的。</p>\n<p><code>return()</code>方法的使用场合是，如果<code>for...of</code>循环提前退出（通常是因为出错，或者有<code>break</code>语句），就会调用<code>return()</code>方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署<code>return()</code>方法。</p>\n<pre><code class=\"javascript\">function readLinesSync(file) &#123;\n  return &#123;\n    [Symbol.iterator]() &#123;\n      return &#123;\n        next() &#123;\n          return &#123; done: false &#125;;\n        &#125;,\n        return() &#123;\n          file.close();\n          return &#123; done: true &#125;;\n        &#125;\n      &#125;;\n    &#125;,\n  &#125;;\n&#125;\n</code></pre>\n<p>上面代码中，函数<code>readLinesSync</code>接受一个文件对象作为参数，返回一个遍历器对象，其中除了<code>next()</code>方法，还部署了<code>return()</code>方法。下面的两种情况，都会触发执行<code>return()</code>方法。</p>\n<pre><code class=\"javascript\">// 情况一\nfor (let line of readLinesSync(fileName)) &#123;\n  console.log(line);\n  break;\n&#125;\n\n// 情况二\nfor (let line of readLinesSync(fileName)) &#123;\n  console.log(line);\n  throw new Error();\n&#125;\n</code></pre>\n<p>上面代码中，情况一输出文件的第一行以后，就会执行<code>return()</code>方法，关闭这个文件；情况二会在执行<code>return()</code>方法关闭文件之后，再抛出错误。</p>\n<p>注意，<code>return()</code>方法必须返回一个对象，这是 Generator 语法决定的。</p>\n<p><code>throw()</code>方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。请参阅《Generator 函数》一章。</p>\n<hr>\n<h4 id=\"7-for…of-循环\"><a href=\"#7-for…of-循环\" class=\"headerlink\" title=\"7. for…of 循环\"></a>7. for…of 循环</h4><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了<code>for...of</code>循环，作为遍历所有数据结构的统一的方法。</p>\n<p><strong>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</strong></p>\n<p><code>for...of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p>\n<hr>\n<p><strong>数组</strong></p>\n<p>数组原生具备<code>iterator</code>接口（即默认部署了<code>Symbol.iterator</code>属性），<code>for...of</code>循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p>\n<pre><code class=\"javascript\">const arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;];\n\nfor(let v of arr) &#123;\n  console.log(v); // red green blue\n&#125;\n\nconst obj = &#123;&#125;;\nobj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);\n\nfor(let v of obj) &#123;\n  console.log(v); // red green blue\n&#125;\n</code></pre>\n<p>上面代码中，空对象<code>obj</code>部署了数组<code>arr</code>的<code>Symbol.iterator</code>属性，结果<code>obj</code>的<code>for...of</code>循环，产生了与<code>arr</code>完全一样的结果。</p>\n<p><code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法。</p>\n<pre><code class=\"javascript\">const arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;];\n\narr.forEach(function (element, index) &#123;\n  console.log(element); // red green blue\n  console.log(index);   // 0 1 2\n&#125;);\n</code></pre>\n<p>JavaScript 原有的<code>for...in</code>循环，只能获得对象的键名，不能直接获取键值。ES6 提供<code>for...of</code>循环，允许遍历获得键值。</p>\n<pre><code class=\"javascript\">var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;];\n\nfor (let a in arr) &#123;\n  console.log(a); // 0 1 2 3\n&#125;\n\nfor (let a of arr) &#123;\n  console.log(a); // a b c d\n&#125;\n</code></pre>\n<p>上面代码表明，<code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。如果要通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法（参见《数组的扩展》一章）。</p>\n<p><strong><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</strong></p>\n<pre><code class=\"javascript\">let arr = [3, 5, 7];\narr.foo = &#39;hello&#39;;\n\nfor (let i in arr) &#123;\n  console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;\n&#125;\n\nfor (let i of arr) &#123;\n  console.log(i); //  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;\n&#125;\n</code></pre>\n<p>上面代码中，<code>for...of</code>循环不会返回数组<code>arr</code>的<code>foo</code>属性。</p>\n<hr>\n<p><strong>Set 和 Map 结构</strong></p>\n<p>Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用<code>for...of</code>循环。</p>\n<pre><code class=\"javascript\">var engines = new Set([&quot;Gecko&quot;, &quot;Trident&quot;, &quot;Webkit&quot;, &quot;Webkit&quot;]);\nfor (var e of engines) &#123;\n  console.log(e);\n&#125;\n// Gecko\n// Trident\n// Webkit\n\nvar es6 = new Map();\nes6.set(&quot;edition&quot;, 6);\nes6.set(&quot;committee&quot;, &quot;TC39&quot;);\nes6.set(&quot;standard&quot;, &quot;ECMA-262&quot;);\nfor (var [name, value] of es6) &#123;\n  console.log(name + &quot;: &quot; + value);\n&#125;\n// edition: 6\n// committee: TC39\n// standard: ECMA-262\n</code></pre>\n<p>上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。</p>\n<pre><code class=\"javascript\">let map = new Map().set(&#39;a&#39;, 1).set(&#39;b&#39;, 2);\nfor (let pair of map) &#123;\n  console.log(pair);\n&#125;\n// [&#39;a&#39;, 1]\n// [&#39;b&#39;, 2]\n\nfor (let [key, value] of map) &#123;\n  console.log(key + &#39; : &#39; + value);\n&#125;\n// a : 1\n// b : 2\n</code></pre>\n<hr>\n<p><strong>计算生成的数据结构</strong></p>\n<p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。</p>\n<ul>\n<li><code>entries()</code> 返回一个遍历器对象，用来遍历<code>[键名, 键值]</code>组成的数组。<strong>对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用<code>entries</code>方法。</strong></li>\n<li><code>keys()</code> 返回一个遍历器对象，用来遍历所有的键名。</li>\n<li><code>values()</code> 返回一个遍历器对象，用来遍历所有的键值。</li>\n</ul>\n<p>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p>\n<pre><code class=\"javascript\">let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];\nfor (let pair of arr.entries()) &#123;\n  console.log(pair);\n&#125;\n// [0, &#39;a&#39;]\n// [1, &#39;b&#39;]\n// [2, &#39;c&#39;]\n</code></pre>\n<hr>\n<p><strong>类似数组的对象</strong></p>\n<p>类似数组的对象包括好几类。下面是<code>for...of</code>循环用于字符串、DOM NodeList 对象、<code>arguments</code>对象的例子。</p>\n<pre><code class=\"javascript\">// 字符串\nlet str = &quot;hello&quot;;\n\nfor (let s of str) &#123;\n  console.log(s); // h e l l o\n&#125;\n\n// DOM NodeList对象\nlet paras = document.querySelectorAll(&quot;p&quot;);\n\nfor (let p of paras) &#123;\n  p.classList.add(&quot;test&quot;);\n&#125;\n\n// arguments对象\nfunction printArgs() &#123;\n  for (let x of arguments) &#123;\n    console.log(x);\n  &#125;\n&#125;\nprintArgs(&#39;a&#39;, &#39;b&#39;);\n// &#39;a&#39;\n// &#39;b&#39;\n</code></pre>\n<p><strong>对于字符串来说，<code>for...of</code>循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。</strong></p>\n<pre><code class=\"javascript\">for (let x of &#39;a\\uD83D\\uDC0A&#39;) &#123;\n  console.log(x);\n&#125;\n// &#39;a&#39;\n// &#39;\\uD83D\\uDC0A&#39;\n</code></pre>\n<p><strong>并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用<code>Array.from</code>方法将其转为数组。</strong></p>\n<pre><code class=\"javascript\">let arrayLike = &#123; length: 2, 0: &#39;a&#39;, 1: &#39;b&#39; &#125;;\n\n// 报错\nfor (let x of arrayLike) &#123;\n  console.log(x);\n&#125;\n\n// 正确\nfor (let x of Array.from(arrayLike)) &#123;\n  console.log(x);\n&#125;\n</code></pre>\n<hr>\n<p><strong>对象</strong></p>\n<p><strong>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，<code>for...in</code>循环依然可以用来遍历键名。</strong></p>\n<pre><code class=\"javascript\">let es6 = &#123;\n  edition: 6,\n  committee: &quot;TC39&quot;,\n  standard: &quot;ECMA-262&quot;\n&#125;;\n\nfor (let e in es6) &#123;\n  console.log(e);\n&#125;\n// edition\n// committee\n// standard\n\nfor (let e of es6) &#123;\n  console.log(e);\n&#125;\n// TypeError: es6[Symbol.iterator] is not a function\n</code></pre>\n<p>上面代码表示，对于普通的对象，<code>for...in</code>循环可以遍历键名，<code>for...of</code>循环会报错。</p>\n<p><strong>一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</strong></p>\n<pre><code class=\"javascript\">for (var key of Object.keys(someObject)) &#123;\n  console.log(key + &#39;: &#39; + someObject[key]);\n&#125;\n</code></pre>\n<p><strong>另一个方法是使用 Generator 函数将对象重新包装一下。</strong></p>\n<pre><code class=\"javascript\">const obj = &#123; a: 1, b: 2, c: 3 &#125;\n\nfunction* entries(obj) &#123;\n  for (let key of Object.keys(obj)) &#123;\n    yield [key, obj[key]];\n  &#125;\n&#125;\n\nfor (let [key, value] of entries(obj)) &#123;\n  console.log(key, &#39;-&gt;&#39;, value);\n&#125;\n// a -&gt; 1\n// b -&gt; 2\n// c -&gt; 3\n</code></pre>\n<hr>\n<p><strong>与其他遍历语法的比较</strong></p>\n<p>以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是<code>for</code>循环。</p>\n<pre><code class=\"javascript\">for (var index = 0; index &lt; myArray.length; index++) &#123;\n  console.log(myArray[index]);\n&#125;\n</code></pre>\n<p>这种写法比较麻烦，因此数组提供内置的<code>forEach</code>方法。</p>\n<pre><code class=\"javascript\">myArray.forEach(function (value) &#123;\n  console.log(value);\n&#125;);\n</code></pre>\n<p>这种写法的问题在于，无法中途跳出<code>forEach</code>循环，<code>break</code>命令或<code>return</code>命令都不能奏效。</p>\n<p><code>for...in</code>循环可以遍历数组的键名。</p>\n<pre><code class=\"javascript\">for (var index in myArray) &#123;\n  console.log(myArray[index]);\n&#125;\n</code></pre>\n<p><code>for...in</code>循环有几个缺点。</p>\n<ul>\n<li>数组的键名是数字，但是<code>for...in</code>循环是以字符串作为键名“0”、“1”、“2”等等。</li>\n<li><code>for...in</code>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li>\n<li>某些情况下，<code>for...in</code>循环会以任意顺序遍历键名。</li>\n</ul>\n<p>总之，<code>for...in</code>循环主要是为遍历对象而设计的，不适用于遍历数组。</p>\n<p><code>for...of</code>循环相比上面几种做法，有一些显著的优点。</p>\n<pre><code class=\"javascript\">for (let value of myArray) &#123;\n  console.log(value);\n&#125;\n</code></pre>\n<ul>\n<li><strong>有着同<code>for...in</code>一样的简洁语法，但是没有<code>for...in</code>那些缺点。</strong></li>\n<li><strong>不同于<code>forEach</code>方法，它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用。</strong></li>\n<li><strong>提供了遍历所有数据结构的统一操作接口。</strong></li>\n</ul>\n<p>下面是一个使用 break 语句，跳出<code>for...of</code>循环的例子。</p>\n<pre><code class=\"javascript\">for (var n of fibonacci) &#123;\n  if (n &gt; 1000)\n    break;\n  console.log(n);\n&#125;\n</code></pre>\n<p>上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用<code>break</code>语句跳出<code>for...of</code>循环。</p>\n<h3 id=\"18、-Generator-函数的语法\"><a href=\"#18、-Generator-函数的语法\" class=\"headerlink\" title=\"18、 Generator 函数的语法\"></a>18、 Generator 函数的语法</h3><hr>\n<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p><strong>基本概念</strong></p>\n<p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p>\n<p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>\n<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>\n<p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</p>\n<pre><code class=\"javascript\">function* helloWorldGenerator() &#123;\n  yield &#39;hello&#39;;\n  yield &#39;world&#39;;\n  return &#39;ending&#39;;\n&#125;\n\nvar hw = helloWorldGenerator();\n</code></pre>\n<p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p>\n<p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p>\n<p>下一步，<strong>必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态</strong>。也就是说，<strong>每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止</strong>。换言之，<strong>Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</strong></p>\n<pre><code class=\"javascript\">hw.next()\n// &#123; value: &#39;hello&#39;, done: false &#125;\n\nhw.next()\n// &#123; value: &#39;world&#39;, done: false &#125;\n\nhw.next()\n// &#123; value: &#39;ending&#39;, done: true &#125;\n\nhw.next()\n// &#123; value: undefined, done: true &#125;\n</code></pre>\n<p>上面代码一共调用了四次<code>next</code>方法。</p>\n<p>第一次调用，Generator 函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>\n<p>第二次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到下一个<code>yield</code>表达式。<code>next</code>方法返回的对象的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>world</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p>\n<p>第三次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到<code>return</code>语句（如果没有<code>return</code>语句，就执行到函数结束）。<code>next</code>方法返回的对象的<code>value</code>属性，就是紧跟在<code>return</code>语句后面的表达式的值（如果没有<code>return</code>语句，则<code>value</code>属性的值为<code>undefined</code>），<code>done</code>属性的值<code>true</code>，表示遍历已经结束。</p>\n<p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code>方法返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code>属性为<code>true</code>。以后再调用<code>next</code>方法，返回的都是这个值。</p>\n<p><strong>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</strong></p>\n<p>ES6 没有规定，<code>function</code>关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</p>\n<pre><code class=\"javascript\">function * foo(x, y) &#123; ··· &#125;\nfunction *foo(x, y) &#123; ··· &#125;\nfunction* foo(x, y) &#123; ··· &#125;\nfunction*foo(x, y) &#123; ··· &#125;\n</code></pre>\n<p>由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在<code>function</code>关键字后面。本书也采用这种写法。</p>\n<hr>\n<p><strong>yield 表达式</strong></p>\n<p>由于 Generator 函数返回的遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态，<strong>所以其实提供了一种可以暂停执行的函数。<code>yield</code>表达式就是暂停标志。</strong></p>\n<p>遍历器对象的<code>next</code>方法的运行逻辑如下。</p>\n<p>（1）遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</p>\n<p>（2）下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</p>\n<p>（3）如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</p>\n<p>（4）如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</p>\n<p>需要注意的是，**<code>yield</code>表达式后面的表达式，只有当调用<code>next</code>方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。**</p>\n<pre><code class=\"javascript\">function* gen() &#123;\n  yield  123 + 456;\n&#125;\n</code></pre>\n<p>上面代码中，<code>yield</code>后面的表达式<code>123 + 456</code>，不会立即求值，只会在<code>next</code>方法将指针移到这一句时，才会求值。</p>\n<p><code>yield</code>表达式与<code>return</code>语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到<code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而<code>return</code>语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）<code>return</code>语句，但是可以执行多次（或者说多个）<code>yield</code>表达式。正常函数只能返回一个值，因为只能执行一次<code>return</code>；Generator 函数可以返回一系列的值，因为可以有任意多个<code>yield</code>。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。</p>\n<p>Generator 函数可以不用<code>yield</code>表达式，这时就变成了一个单纯的暂缓执行函数。</p>\n<pre><code class=\"javascript\">function* f() &#123;\n  console.log(&#39;执行了！&#39;)\n&#125;\n\nvar generator = f();\n\nsetTimeout(function () &#123;\n  generator.next()\n&#125;, 2000);\n</code></pre>\n<p>上面代码中，函数<code>f</code>如果是普通函数，在为变量<code>generator</code>赋值时就会执行。但是，函数<code>f</code>是一个 Generator 函数，就变成只有调用<code>next</code>方法时，函数<code>f</code>才会执行。</p>\n<p><strong>另外需要注意，<code>yield</code>表达式只能用在 Generator 函数里面，用在其他地方都会报错。</strong></p>\n<pre><code class=\"javascript\">(function ()&#123;\n  yield 1;\n&#125;)()\n// SyntaxError: Unexpected number\n</code></pre>\n<p>上面代码在一个普通函数中使用<code>yield</code>表达式，结果产生一个句法错误。</p>\n<p>下面是另外一个例子。</p>\n<pre><code class=\"javascript\">var arr = [1, [[2, 3], 4], [5, 6]];\n\nvar flat = function* (a) &#123;\n  a.forEach(function (item) &#123;\n    if (typeof item !== &#39;number&#39;) &#123;\n      yield* flat(item);\n    &#125; else &#123;\n      yield item;\n    &#125;\n  &#125;);\n&#125;;\n\nfor (var f of flat(arr))&#123;\n  console.log(f);\n&#125;\n</code></pre>\n<p><strong>上面代码也会产生句法错误，因为<code>forEach</code>方法的参数是一个普通函数，但是在里面使用了<code>yield</code>表达式</strong>（这个函数里面还使用了<code>yield*</code>表达式，详细介绍见后文）。<strong>一种修改方法是改用<code>for</code>循环。</strong></p>\n<pre><code class=\"javascript\">var arr = [1, [[2, 3], 4], [5, 6]];\n\nvar flat = function* (a) &#123;\n  var length = a.length;\n  for (var i = 0; i &lt; length; i++) &#123;\n    var item = a[i];\n    if (typeof item !== &#39;number&#39;) &#123;\n      yield* flat(item);\n    &#125; else &#123;\n      yield item;\n    &#125;\n  &#125;\n&#125;;\n\nfor (var f of flat(arr)) &#123;\n  console.log(f);\n&#125;\n// 1, 2, 3, 4, 5, 6\n</code></pre>\n<p><strong>另外，<code>yield</code>表达式如果用在另一个表达式之中，必须放在圆括号里面。</strong></p>\n<pre><code class=\"javascript\">function* demo() &#123;\n  console.log(&#39;Hello&#39; + yield); // SyntaxError\n  console.log(&#39;Hello&#39; + yield 123); // SyntaxError\n\n  console.log(&#39;Hello&#39; + (yield)); // OK\n  console.log(&#39;Hello&#39; + (yield 123)); // OK\n&#125;\n</code></pre>\n<p><strong><code>yield</code>表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</strong></p>\n<pre><code class=\"javascript\">function* demo() &#123;\n  foo(yield &#39;a&#39;, yield &#39;b&#39;); // OK\n  let input = yield; // OK\n&#125;\n</code></pre>\n<hr>\n<p><strong>与 Iterator 接口的关系</strong></p>\n<p>上一章说过，任意一个对象的<code>Symbol.iterator</code>方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p>\n<p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有 Iterator 接口。</p>\n<pre><code class=\"javascript\">var myIterable = &#123;&#125;;\nmyIterable[Symbol.iterator] = function* () &#123;\n  yield 1;\n  yield 2;\n  yield 3;\n&#125;;\n\n[...myIterable] // [1, 2, 3]\n</code></pre>\n<p>上面代码中，Generator 函数赋值给<code>Symbol.iterator</code>属性，从而使得<code>myIterable</code>对象具有了 Iterator 接口，可以被<code>...</code>运算符遍历了。</p>\n<p><strong>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有<code>Symbol.iterator</code>属性，执行后返回自身。</strong></p>\n<pre><code class=\"javascript\">function* gen()&#123;\n  // some code\n&#125;\n\nvar g = gen();\n\ng[Symbol.iterator]() === g\n// true\n</code></pre>\n<p>上面代码中，<code>gen</code>是一个 Generator 函数，调用它会生成一个遍历器对象<code>g</code>。它的<code>Symbol.iterator</code>属性，也是一个遍历器对象生成函数，执行后返回它自己。</p>\n<hr>\n<h4 id=\"2-next-方法的参数\"><a href=\"#2-next-方法的参数\" class=\"headerlink\" title=\"2. next 方法的参数\"></a>2. next 方法的参数</h4><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。**<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。**</p>\n<pre><code class=\"javascript\">function* f() &#123;\n  for(var i = 0; true; i++) &#123;\n    var reset = yield i;\n    if(reset) &#123; i = -1; &#125;\n  &#125;\n&#125;\n\nvar g = f();\n\ng.next() // &#123; value: 0, done: false &#125;\ng.next() // &#123; value: 1, done: false &#125;\ng.next(true) // &#123; value: 0, done: false &#125;\n</code></pre>\n<p>上面代码先定义了一个可以无限运行的 Generator 函数<code>f</code>，如果<code>next</code>方法没有参数，每次运行到<code>yield</code>表达式，变量<code>reset</code>的值总是<code>undefined</code>。当<code>next</code>方法带一个参数<code>true</code>时，变量<code>reset</code>就被重置为这个参数（即<code>true</code>），因此<code>i</code>会等于<code>-1</code>，下一轮循环就会从<code>-1</code>开始递增。</p>\n<p>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过<code>next</code>方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，<strong>可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</strong></p>\n<p>再看一个例子。</p>\n<pre><code class=\"javascript\">function* foo(x) &#123;\n  var y = 2 * (yield (x + 1));\n  var z = yield (y / 3);\n  return (x + y + z);\n&#125;\n\nvar a = foo(5);\na.next() // Object&#123;value:6, done:false&#125;\na.next() // Object&#123;value:NaN, done:false&#125;\na.next() // Object&#123;value:NaN, done:true&#125;\n\nvar b = foo(5);\nb.next() // &#123; value:6, done:false &#125;\nb.next(12) // &#123; value:8, done:false &#125;\nb.next(13) // &#123; value:42, done:true &#125;\n</code></pre>\n<p>上面代码中，第二次运行<code>next</code>方法的时候不带参数，导致 y 的值等于<code>2 * undefined</code>（即<code>NaN</code>），除以 3 以后还是<code>NaN</code>，因此返回对象的<code>value</code>属性也等于<code>NaN</code>。第三次运行<code>Next</code>方法的时候不带参数，所以<code>z</code>等于<code>undefined</code>，返回对象的<code>value</code>属性等于<code>5 + NaN + undefined</code>，即<code>NaN</code>。</p>\n<p>如果向<code>next</code>方法提供参数，返回结果就完全不一样了。上面代码第一次调用<code>b</code>的<code>next</code>方法时，返回<code>x+1</code>的值<code>6</code>；第二次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>12</code>，因此<code>y</code>等于<code>24</code>，返回<code>y / 3</code>的值<code>8</code>；第三次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>13</code>，因此<code>z</code>等于<code>13</code>，这时<code>x</code>等于<code>5</code>，<code>y</code>等于<code>24</code>，所以<code>return</code>语句的值等于<code>42</code>。</p>\n<p>注意，由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的。V8 引擎直接忽略第一次使用<code>next</code>方法时的参数，只有从第二次使用<code>next</code>方法开始，参数才是有效的。从语义上讲，第一个<code>next</code>方法用来启动遍历器对象，所以不用带有参数。</p>\n<p>再看一个通过<code>next</code>方法的参数，向 Generator 函数内部输入值的例子。</p>\n<pre><code class=\"javascript\">function* dataConsumer() &#123;\n  console.log(&#39;Started&#39;);\n  console.log(`1. $&#123;yield&#125;`);\n  console.log(`2. $&#123;yield&#125;`);\n  return &#39;result&#39;;\n&#125;\n\nlet genObj = dataConsumer();\ngenObj.next();\n// Started\ngenObj.next(&#39;a&#39;)\n// 1. a\ngenObj.next(&#39;b&#39;)\n// 2. b\n</code></pre>\n<p>上面代码是一个很直观的例子，每次通过<code>next</code>方法向 Generator 函数输入值，然后打印出来。</p>\n<p><strong>如果想要第一次调用<code>next</code>方法时，就能够输入值，可以在 Generator 函数外面再包一层。</strong></p>\n<pre><code class=\"javascript\">function wrapper(generatorFunction) &#123;\n  return function (...args) &#123;\n    let generatorObject = generatorFunction(...args);\n    generatorObject.next();\n    return generatorObject;\n  &#125;;\n&#125;\n\nconst wrapped = wrapper(function* () &#123;\n  console.log(`First input: $&#123;yield&#125;`);\n  return &#39;DONE&#39;;\n&#125;);\n\nwrapped().next(&#39;hello!&#39;)\n// First input: hello!\n</code></pre>\n<p>上面代码中，Generator 函数如果不用<code>wrapper</code>先包一层，是无法第一次调用<code>next</code>方法，就输入参数的。</p>\n<hr>\n<h4 id=\"3-for…of-循环\"><a href=\"#3-for…of-循环\" class=\"headerlink\" title=\"3. for…of 循环\"></a>3. for…of 循环</h4><p><strong><code>for...of</code>循环可以自动遍历 Generator 函数运行时生成的<code>Iterator</code>对象，且此时不再需要调用<code>next</code>方法。</strong></p>\n<pre><code class=\"javascript\">function* foo() &#123;\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n  yield 5;\n  return 6;\n&#125;\n\nfor (let v of foo()) &#123;\n  console.log(v);\n&#125;\n// 1 2 3 4 5\n</code></pre>\n<p>上面代码使用<code>for...of</code>循环，依次显示 5 个<code>yield</code>表达式的值。这里需要注意，一旦<code>next</code>方法的返回对象的<code>done</code>属性为<code>true</code>，<code>for...of</code>循环就会中止，且不包含该返回对象，<strong>所以上面代码的<code>return</code>语句返回的<code>6</code>，不包括在<code>for...of</code>循环之中。</strong></p>\n<p>下面是一个利用 Generator 函数和<code>for...of</code>循环，实现斐波那契数列的例子。</p>\n<pre><code class=\"javascript\">function* fibonacci() &#123;\n  let [prev, curr] = [0, 1];\n  for (;;) &#123;\n    yield curr;\n    [prev, curr] = [curr, prev + curr];\n  &#125;\n&#125;\n\nfor (let n of fibonacci()) &#123;\n  if (n &gt; 1000) break;\n  console.log(n);\n&#125;\n</code></pre>\n<p>从上面代码可见，使用<code>for...of</code>语句时不需要使用<code>next</code>方法。</p>\n<p>利用<code>for...of</code>循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用<code>for...of</code>循环，<strong>通过 Generator 函数为它加上这个接口，就可以用了。</strong></p>\n<pre><code class=\"javascript\">function* objectEntries(obj) &#123;\n  let propKeys = Reflect.ownKeys(obj);\n\n  for (let propKey of propKeys) &#123;\n    yield [propKey, obj[propKey]];\n  &#125;\n&#125;\n\nlet jane = &#123; first: &#39;Jane&#39;, last: &#39;Doe&#39; &#125;;\n\nfor (let [key, value] of objectEntries(jane)) &#123;\n  console.log(`$&#123;key&#125;: $&#123;value&#125;`);\n&#125;\n// first: Jane\n// last: Doe\n</code></pre>\n<p>上面代码中，对象<code>jane</code>原生不具备 Iterator 接口，无法用<code>for...of</code>遍历。这时，我们通过 Generator 函数<code>objectEntries</code>为它加上遍历器接口，就可以用<code>for...of</code>遍历了。加上遍历器接口的另一种写法是，<strong>将 Generator 函数加到对象的<code>Symbol.iterator</code>属性上面。</strong></p>\n<pre><code class=\"javascript\">function* objectEntries() &#123;\n  let propKeys = Object.keys(this);\n\n  for (let propKey of propKeys) &#123;\n    yield [propKey, this[propKey]];\n  &#125;\n&#125;\n\nlet jane = &#123; first: &#39;Jane&#39;, last: &#39;Doe&#39; &#125;;\n\njane[Symbol.iterator] = objectEntries;\n\nfor (let [key, value] of jane) &#123;\n  console.log(`$&#123;key&#125;: $&#123;value&#125;`);\n&#125;\n// first: Jane\n// last: Doe\n</code></pre>\n<p><strong>除了<code>for...of</code>循环以外，扩展运算符（<code>...</code>）、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。</strong></p>\n<pre><code class=\"javascript\">function* numbers () &#123;\n  yield 1\n  yield 2\n  return 3\n  yield 4\n&#125;\n\n// 扩展运算符\n[...numbers()] // [1, 2]\n\n// Array.from 方法\nArray.from(numbers()) // [1, 2]\n\n// 解构赋值\nlet [x, y] = numbers();\nx // 1\ny // 2\n\n// for...of 循环\nfor (let n of numbers()) &#123;\n  console.log(n)\n&#125;\n// 1\n// 2\n</code></pre>\n<hr>\n<h4 id=\"4-Generator-prototype-throw\"><a href=\"#4-Generator-prototype-throw\" class=\"headerlink\" title=\"4. Generator.prototype.throw()\"></a>4. Generator.prototype.throw()</h4><p>Generator 函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p>\n<pre><code class=\"javascript\">var g = function* () &#123;\n  try &#123;\n    yield;\n  &#125; catch (e) &#123;\n    console.log(&#39;内部捕获&#39;, e);\n  &#125;\n&#125;;\n\nvar i = g();\ni.next();\n\ntry &#123;\n  i.throw(&#39;a&#39;);\n  i.throw(&#39;b&#39;);\n&#125; catch (e) &#123;\n  console.log(&#39;外部捕获&#39;, e);\n&#125;\n// 内部捕获 a\n// 外部捕获 b\n</code></pre>\n<p>上面代码中，遍历器对象<code>i</code>连续抛出两个错误。第一个错误被 Generator 函数体内的<code>catch</code>语句捕获。**<code>i</code>第二次抛出错误，由于 Generator 函数内部的<code>catch</code>语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的<code>catch</code>语句捕获。**</p>\n<p><strong><code>throw</code>方法可以接受一个参数，该参数会被<code>catch</code>语句接收，建议抛出<code>Error</code>对象的实例。</strong></p>\n<pre><code class=\"javascript\">var g = function* () &#123;\n  try &#123;\n    yield;\n  &#125; catch (e) &#123;\n    console.log(e);\n  &#125;\n&#125;;\n\nvar i = g();\ni.next();\ni.throw(new Error(&#39;出错了！&#39;));\n// Error: 出错了！(…)\n</code></pre>\n<p>注意，不要混淆遍历器对象的<code>throw</code>方法和全局的<code>throw</code>命令。上面代码的错误，是用遍历器对象的<code>throw</code>方法抛出的，而不是用<code>throw</code>命令抛出的。<strong>后者只能被函数体外的<code>catch</code>语句捕获。</strong></p>\n<pre><code class=\"javascript\">var g = function* () &#123;\n  while (true) &#123;\n    try &#123;\n      yield;\n    &#125; catch (e) &#123;\n      if (e != &#39;a&#39;) throw e;\n      console.log(&#39;内部捕获&#39;, e);\n    &#125;\n  &#125;\n&#125;;\n\nvar i = g();\ni.next();\n\ntry &#123;\n  throw new Error(&#39;a&#39;);\n  throw new Error(&#39;b&#39;);\n&#125; catch (e) &#123;\n  console.log(&#39;外部捕获&#39;, e);\n&#125;\n// 外部捕获 [Error: a]\n</code></pre>\n<p>上面代码之所以只捕获了<code>a</code>，是因为函数体外的<code>catch</code>语句块，捕获了抛出的<code>a</code>错误以后，就不会再继续<code>try</code>代码块里面剩余的语句了。</p>\n<p>如果 Generator 函数内部没有部署<code>try...catch</code>代码块，那么<code>throw</code>方法抛出的错误，将被外部<code>try...catch</code>代码块捕获。</p>\n<pre><code class=\"javascript\">var g = function* () &#123;\n  while (true) &#123;\n    yield;\n    console.log(&#39;内部捕获&#39;, e);\n  &#125;\n&#125;;\n\nvar i = g();\ni.next();\n\ntry &#123;\n  i.throw(&#39;a&#39;);\n  i.throw(&#39;b&#39;);\n&#125; catch (e) &#123;\n  console.log(&#39;外部捕获&#39;, e);\n&#125;\n// 外部捕获 a\n</code></pre>\n<p>上面代码中，Generator 函数<code>g</code>内部没有部署<code>try...catch</code>代码块，所以抛出的错误直接被外部<code>catch</code>代码块捕获。</p>\n<p>如果 Generator 函数内部和外部，都没有部署<code>try...catch</code>代码块，那么程序将报错，直接中断执行。</p>\n<pre><code class=\"javascript\">var gen = function* gen()&#123;\n  yield console.log(&#39;hello&#39;);\n  yield console.log(&#39;world&#39;);\n&#125;\n\nvar g = gen();\ng.next();\ng.throw();\n// hello\n// Uncaught undefined\n</code></pre>\n<p>上面代码中，<code>g.throw</code>抛出错误以后，没有任何<code>try...catch</code>代码块可以捕获这个错误，导致程序报错，中断执行。</p>\n<p><code>throw</code>方法抛出的错误要被内部捕获，前提是必须至少执行过一次<code>next</code>方法。</p>\n<pre><code class=\"javascript\">function* gen() &#123;\n  try &#123;\n    yield 1;\n  &#125; catch (e) &#123;\n    console.log(&#39;内部捕获&#39;);\n  &#125;\n&#125;\n\nvar g = gen();\ng.throw(1);\n// Uncaught 1\n</code></pre>\n<p>上面代码中，<code>g.throw(1)</code>执行时，<code>next</code>方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行<code>next</code>方法，等同于启动执行 Generator 函数的内部代码，否则 Generator 函数还没有开始执行，这时<code>throw</code>方法抛错只可能抛出在函数外部。</p>\n<p><strong><code>throw</code>方法被捕获以后，会附带执行下一条<code>yield</code>表达式。也就是说，会附带执行一次<code>next</code>方法。</strong></p>\n<pre><code class=\"javascript\">var gen = function* gen()&#123;\n  try &#123;\n    yield console.log(&#39;a&#39;);\n  &#125; catch (e) &#123;\n    // ...\n  &#125;\n  yield console.log(&#39;b&#39;);\n  yield console.log(&#39;c&#39;);\n&#125;\n\nvar g = gen();\ng.next() // a\ng.throw() // b\ng.next() // c\n</code></pre>\n<p>上面代码中，<code>g.throw</code>方法被捕获以后，自动执行了一次<code>next</code>方法，所以会打印<code>b</code>。另外，也可以看到，<strong>只要 Generator 函数内部部署了<code>try...catch</code>代码块，那么遍历器的<code>throw</code>方法抛出的错误，不影响下一次遍历。</strong></p>\n<p>另外，<code>throw</code>命令与<code>g.throw</code>方法是无关的，两者互不影响。</p>\n<pre><code class=\"javascript\">var gen = function* gen()&#123;\n  yield console.log(&#39;hello&#39;);\n  yield console.log(&#39;world&#39;);\n&#125;\n\nvar g = gen();\ng.next();\n\ntry &#123;\n  throw new Error();\n&#125; catch (e) &#123;\n  g.next();\n&#125;\n// hello\n// world\n</code></pre>\n<p>上面代码中，<code>throw</code>命令抛出的错误不会影响到遍历器的状态，所以两次执行<code>next</code>方法，都进行了正确的操作。</p>\n<p>这种函数体内捕获错误的机制，大大方便了对错误的处理。多个<code>yield</code>表达式，可以只用一个<code>try...catch</code>代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次<code>catch</code>语句就可以了。</p>\n<p>Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的<code>catch</code>捕获。</p>\n<pre><code class=\"javascript\">function* foo() &#123;\n  var x = yield 3;\n  var y = x.toUpperCase();\n  yield y;\n&#125;\n\nvar it = foo();\n\nit.next(); // &#123; value:3, done:false &#125;\n\ntry &#123;\n  it.next(42);\n&#125; catch (err) &#123;\n  console.log(err);\n&#125;\n</code></pre>\n<p>上面代码中，第二个<code>next</code>方法向函数体内传入一个参数 42，数值是没有<code>toUpperCase</code>方法的，所以会抛出一个 TypeError 错误，被函数体外的<code>catch</code>捕获。</p>\n<p><strong>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了</strong>。如果此后还调用<code>next</code>方法，将返回一个<code>value</code>属性等于<code>undefined</code>、<code>done</code>属性等于<code>true</code>的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</p>\n<pre><code class=\"javascript\">function* g() &#123;\n  yield 1;\n  console.log(&#39;throwing an exception&#39;);\n  throw new Error(&#39;generator broke!&#39;);\n  yield 2;\n  yield 3;\n&#125;\n\nfunction log(generator) &#123;\n  var v;\n  console.log(&#39;starting generator&#39;);\n  try &#123;\n    v = generator.next();\n    console.log(&#39;第一次运行next方法&#39;, v);\n  &#125; catch (err) &#123;\n    console.log(&#39;捕捉错误&#39;, v);\n  &#125;\n  try &#123;\n    v = generator.next();\n    console.log(&#39;第二次运行next方法&#39;, v);\n  &#125; catch (err) &#123;\n    console.log(&#39;捕捉错误&#39;, v);\n  &#125;\n  try &#123;\n    v = generator.next();\n    console.log(&#39;第三次运行next方法&#39;, v);\n  &#125; catch (err) &#123;\n    console.log(&#39;捕捉错误&#39;, v);\n  &#125;\n  console.log(&#39;caller done&#39;);\n&#125;\n\nlog(g());\n// starting generator\n// 第一次运行next方法 &#123; value: 1, done: false &#125;\n// throwing an exception\n// 捕捉错误 &#123; value: 1, done: false &#125;\n// 第三次运行next方法 &#123; value: undefined, done: true &#125;\n// caller done\n</code></pre>\n<p>上面代码一共三次运行<code>next</code>方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator 函数就已经结束了，不再执行下去了。</p>\n<hr>\n<h4 id=\"5-Generator-prototype-return\"><a href=\"#5-Generator-prototype-return\" class=\"headerlink\" title=\"5. Generator.prototype.return()\"></a>5. Generator.prototype.return()</h4><p>Generator 函数返回的遍历器对象，<strong>还有一个<code>return()</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</strong></p>\n<pre><code class=\"javascript\">function* gen() &#123;\n  yield 1;\n  yield 2;\n  yield 3;\n&#125;\n\nvar g = gen();\n\ng.next()        // &#123; value: 1, done: false &#125;\ng.return(&#39;foo&#39;) // &#123; value: &quot;foo&quot;, done: true &#125;\ng.next()        // &#123; value: undefined, done: true &#125;\n</code></pre>\n<p>上面代码中，遍历器对象<code>g</code>调用<code>return()</code>方法后，返回值的<code>value</code>属性就是<code>return()</code>方法的参数<code>foo</code>。并且，Generator 函数的遍历就终止了，返回值的<code>done</code>属性为<code>true</code>，以后再调用<code>next()</code>方法，<code>done</code>属性总是返回<code>true</code>。</p>\n<p>如果<code>return()</code>方法调用时，不提供参数，则返回值的<code>value</code>属性为<code>undefined</code>。</p>\n<pre><code class=\"javascript\">function* gen() &#123;\n  yield 1;\n  yield 2;\n  yield 3;\n&#125;\n\nvar g = gen();\n\ng.next() // &#123; value: 1, done: false &#125;\ng.return() // &#123; value: undefined, done: true &#125;\n</code></pre>\n<p><strong>如果 Generator 函数内部有<code>try...finally</code>代码块，且正在执行<code>try</code>代码块，那么<code>return()</code>方法会导致立刻进入<code>finally</code>代码块，执行完以后，整个函数才会结束。</strong></p>\n<pre><code class=\"javascript\">function* numbers () &#123;\n  yield 1;\n  try &#123;\n    yield 2;\n    yield 3;\n  &#125; finally &#123;\n    yield 4;\n    yield 5;\n  &#125;\n  yield 6;\n&#125;\nvar g = numbers();\ng.next() // &#123; value: 1, done: false &#125;\ng.next() // &#123; value: 2, done: false &#125;\ng.return(7) // &#123; value: 4, done: false &#125;\ng.next() // &#123; value: 5, done: false &#125;\ng.next() // &#123; value: 7, done: true &#125;\n</code></pre>\n<p>上面代码中，<strong>调用<code>return()</code>方法后，就开始执行<code>finally</code>代码块，不执行<code>try</code>里面剩下的代码了，然后等到<code>finally</code>代码块执行完，再返回<code>return()</code>方法指定的返回值。</strong></p>\n<hr>\n<h4 id=\"6-next-、throw-、return-的共同点\"><a href=\"#6-next-、throw-、return-的共同点\" class=\"headerlink\" title=\"6. next()、throw()、return() 的共同点\"></a>6. next()、throw()、return() 的共同点</h4><p><code>next()</code>、<code>throw()</code>、<code>return()</code>这三个方法本质上是同一件事，可以放在一起理解。<strong>它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式。</strong></p>\n<p><code>next()</code>是将<code>yield</code>表达式替换成一个值。</p>\n<pre><code class=\"javascript\">const g = function* (x, y) &#123;\n  let result = yield x + y;\n  return result;\n&#125;;\n\nconst gen = g(1, 2);\ngen.next(); // Object &#123;value: 3, done: false&#125;\n\ngen.next(1); // Object &#123;value: 1, done: true&#125;\n// 相当于将 let result = yield x + y\n// 替换成 let result = 1;\n</code></pre>\n<p>上面代码中，第二个<code>next(1)</code>方法就相当于将<code>yield</code>表达式替换成一个值<code>1</code>。如果<code>next</code>方法没有参数，就相当于替换成<code>undefined</code>。</p>\n<p><code>throw()</code>是将<code>yield</code>表达式替换成一个<code>throw</code>语句。</p>\n<pre><code class=\"javascript\">gen.throw(new Error(&#39;出错了&#39;)); // Uncaught Error: 出错了\n// 相当于将 let result = yield x + y\n// 替换成 let result = throw(new Error(&#39;出错了&#39;));\n</code></pre>\n<p><code>return()</code>是将<code>yield</code>表达式替换成一个<code>return</code>语句。</p>\n<pre><code class=\"javascript\">gen.return(2); // Object &#123;value: 2, done: true&#125;\n// 相当于将 let result = yield x + y\n// 替换成 let result = return 2;\n</code></pre>\n<hr>\n<h4 id=\"7-yield-表达式\"><a href=\"#7-yield-表达式\" class=\"headerlink\" title=\"7. yield* 表达式\"></a>7. yield* 表达式</h4><p>如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。</p>\n<pre><code class=\"javascript\">function* foo() &#123;\n  yield &#39;a&#39;;\n  yield &#39;b&#39;;\n&#125;\n\nfunction* bar() &#123;\n  yield &#39;x&#39;;\n  // 手动遍历 foo()\n  for (let i of foo()) &#123;\n    console.log(i);\n  &#125;\n  yield &#39;y&#39;;\n&#125;\n\nfor (let v of bar())&#123;\n  console.log(v);\n&#125;\n// x\n// a\n// b\n// y\n</code></pre>\n<p>上面代码中，<code>foo</code>和<code>bar</code>都是 Generator 函数，在<code>bar</code>里面调用<code>foo</code>，就需要手动遍历<code>foo</code>。如果有多个 Generator 函数嵌套，写起来就非常麻烦。</p>\n<p><strong>ES6 提供了<code>yield*</code>表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。</strong></p>\n<pre><code class=\"javascript\">function* bar() &#123;\n  yield &#39;x&#39;;\n  yield* foo();\n  yield &#39;y&#39;;\n&#125;\n\n// 等同于\nfunction* bar() &#123;\n  yield &#39;x&#39;;\n  yield &#39;a&#39;;\n  yield &#39;b&#39;;\n  yield &#39;y&#39;;\n&#125;\n\n// 等同于\nfunction* bar() &#123;\n  yield &#39;x&#39;;\n  for (let v of foo()) &#123;\n    yield v;\n  &#125;\n  yield &#39;y&#39;;\n&#125;\n\nfor (let v of bar())&#123;\n  console.log(v);\n&#125;\n// &quot;x&quot;\n// &quot;a&quot;\n// &quot;b&quot;\n// &quot;y&quot;\n</code></pre>\n<p>再来看一个对比的例子。</p>\n<pre><code class=\"javascript\">function* inner() &#123;\n  yield &#39;hello!&#39;;\n&#125;\n\nfunction* outer1() &#123;\n  yield &#39;open&#39;;\n  yield inner();\n  yield &#39;close&#39;;\n&#125;\n\nvar gen = outer1()\ngen.next().value // &quot;open&quot;\ngen.next().value // 返回一个遍历器对象\ngen.next().value // &quot;close&quot;\n\nfunction* outer2() &#123;\n  yield &#39;open&#39;\n  yield* inner()\n  yield &#39;close&#39;\n&#125;\n\nvar gen = outer2()\ngen.next().value // &quot;open&quot;\ngen.next().value // &quot;hello!&quot;\ngen.next().value // &quot;close&quot;\n</code></pre>\n<p>上面例子中，**<code>outer2</code>使用了<code>yield*</code>，<code>outer1</code>没使用。结果就是，<code>outer1</code>返回一个遍历器对象，<code>outer2</code>返回该遍历器对象的内部值。**</p>\n<p>从语法角度看，如果<code>yield</code>表达式后面跟的是一个遍历器对象，需要在<code>yield</code>表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为<code>yield*</code>表达式。</p>\n<pre><code class=\"javascript\">let delegatedIterator = (function* () &#123;\n  yield &#39;Hello!&#39;;\n  yield &#39;Bye!&#39;;\n&#125;());\n\nlet delegatingIterator = (function* () &#123;\n  yield &#39;Greetings!&#39;;\n  yield* delegatedIterator;\n  yield &#39;Ok, bye.&#39;;\n&#125;());\n\nfor(let value of delegatingIterator) &#123;\n  console.log(value);\n&#125;\n// &quot;Greetings!\n// &quot;Hello!&quot;\n// &quot;Bye!&quot;\n// &quot;Ok, bye.&quot;\n</code></pre>\n<p>上面代码中，<code>delegatingIterator</code>是代理者，<code>delegatedIterator</code>是被代理者。由于<code>yield* delegatedIterator</code>语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个 Generator 函数，有递归的效果。</p>\n<p><code>yield*</code>后面的 Generator 函数（没有<code>return</code>语句时），等同于在 Generator 函数内部，部署一个<code>for...of</code>循环。</p>\n<pre><code class=\"javascript\">function* concat(iter1, iter2) &#123;\n  yield* iter1;\n  yield* iter2;\n&#125;\n\n// 等同于\n\nfunction* concat(iter1, iter2) &#123;\n  for (var value of iter1) &#123;\n    yield value;\n  &#125;\n  for (var value of iter2) &#123;\n    yield value;\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码说明，<code>yield*</code>后面的 Generator 函数（没有<code>return</code>语句时），不过是<code>for...of</code>的一种简写形式，完全可以用后者替代前者。反之，在有<code>return</code>语句时，则需要用<code>var value = yield* iterator</code>的形式获取<code>return</code>语句的值。</p>\n<p>如果<code>yield*</code>后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</p>\n<pre><code class=\"javascript\">function* gen()&#123;\n  yield* [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\n&#125;\n\ngen().next() // &#123; value:&quot;a&quot;, done:false &#125;\n</code></pre>\n<p><strong>上面代码中，<code>yield</code>命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。</strong></p>\n<p><strong>实际上，任何数据结构只要有 Iterator 接口，就可以被<code>yield*</code>遍历。</strong></p>\n<pre><code class=\"javascript\">let read = (function* () &#123;\n  yield &#39;hello&#39;;\n  yield* &#39;hello&#39;;\n&#125;)();\n\nread.next().value // &quot;hello&quot;\nread.next().value // &quot;h&quot;\n</code></pre>\n<p>上面代码中，<code>yield</code>表达式返回整个字符串，<code>yield*</code>语句返回单个字符。因为字符串具有 Iterator 接口，所以被<code>yield*</code>遍历。</p>\n<p>如果被代理的 Generator 函数有<code>return</code>语句，那么就可以向代理它的 Generator 函数返回数据。</p>\n<pre><code class=\"javascript\">function* foo() &#123;\n  yield 2;\n  yield 3;\n  return &quot;foo&quot;;\n&#125;\n\nfunction* bar() &#123;\n  yield 1;\n  var v = yield* foo();\n  console.log(&quot;v: &quot; + v);\n  yield 4;\n&#125;\n\nvar it = bar();\n\nit.next()\n// &#123;value: 1, done: false&#125;\nit.next()\n// &#123;value: 2, done: false&#125;\nit.next()\n// &#123;value: 3, done: false&#125;\nit.next();\n// &quot;v: foo&quot;\n// &#123;value: 4, done: false&#125;\nit.next()\n// &#123;value: undefined, done: true&#125;\n</code></pre>\n<p>上面代码在第四次调用<code>next</code>方法的时候，屏幕上会有输出，这是因为函数<code>foo</code>的<code>return</code>语句，向函数<code>bar</code>提供了返回值。</p>\n<p>再看一个例子。</p>\n<pre><code class=\"javascript\">function* genFuncWithReturn() &#123;\n  yield &#39;a&#39;;\n  yield &#39;b&#39;;\n  return &#39;The result&#39;;\n&#125;\nfunction* logReturned(genObj) &#123;\n  let result = yield* genObj;\n  console.log(result);\n&#125;\n\n[...logReturned(genFuncWithReturn())]\n// The result\n// 值为 [ &#39;a&#39;, &#39;b&#39; ]\n</code></pre>\n<p>上面代码中，存在两次遍历。第一次是扩展运算符遍历函数<code>logReturned</code>返回的遍历器对象，第二次是<code>yield*</code>语句遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。所以，最后的数据表达式得到的值等于<code>[ &#39;a&#39;, &#39;b&#39; ]</code>。但是，函数<code>genFuncWithReturn</code>的<code>return</code>语句的返回值<code>The result</code>，会返回给函数<code>logReturned</code>内部的<code>result</code>变量，因此会有终端输出。</p>\n<p><code>yield*</code>命令可以很方便地取出嵌套数组的所有成员。</p>\n<pre><code class=\"javascript\">function* iterTree(tree) &#123;\n  if (Array.isArray(tree)) &#123;\n    for(let i=0; i &lt; tree.length; i++) &#123;\n      yield* iterTree(tree[i]);\n    &#125;\n  &#125; else &#123;\n    yield tree;\n  &#125;\n&#125;\n\nconst tree = [ &#39;a&#39;, [&#39;b&#39;, &#39;c&#39;], [&#39;d&#39;, &#39;e&#39;] ];\n\nfor(let x of iterTree(tree)) &#123;\n  console.log(x);\n&#125;\n// a\n// b\n// c\n// d\n// e\n</code></pre>\n<p>由于扩展运算符<code>...</code>默认调用 Iterator 接口，所以上面这个函数也可以用于嵌套数组的平铺。</p>\n<pre><code class=\"javascript\">[...iterTree(tree)] // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]\n</code></pre>\n<p>下面是一个稍微复杂的例子，使用<code>yield*</code>语句遍历完全二叉树。</p>\n<pre><code class=\"javascript\">// 下面是二叉树的构造函数，\n// 三个参数分别是左树、当前节点和右树\nfunction Tree(left, label, right) &#123;\n  this.left = left;\n  this.label = label;\n  this.right = right;\n&#125;\n\n// 下面是中序（inorder）遍历函数。\n// 由于返回的是一个遍历器，所以要用generator函数。\n// 函数体内采用递归算法，所以左树和右树要用yield*遍历\nfunction* inorder(t) &#123;\n  if (t) &#123;\n    yield* inorder(t.left);\n    yield t.label;\n    yield* inorder(t.right);\n  &#125;\n&#125;\n\n// 下面生成二叉树\nfunction make(array) &#123;\n  // 判断是否为叶节点\n  if (array.length == 1) return new Tree(null, array[0], null);\n  return new Tree(make(array[0]), array[1], make(array[2]));\n&#125;\nlet tree = make([[[&#39;a&#39;], &#39;b&#39;, [&#39;c&#39;]], &#39;d&#39;, [[&#39;e&#39;], &#39;f&#39;, [&#39;g&#39;]]]);\n\n// 遍历二叉树\nvar result = [];\nfor (let node of inorder(tree)) &#123;\n  result.push(node);\n&#125;\n\nresult\n// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]\n</code></pre>\n<hr>\n<h4 id=\"8-作为对象属性的-Generator-函数\"><a href=\"#8-作为对象属性的-Generator-函数\" class=\"headerlink\" title=\"8. 作为对象属性的 Generator 函数\"></a>8. 作为对象属性的 Generator 函数</h4><p><strong>如果一个对象的属性是 Generator 函数，可以简写成下面的形式。</strong></p>\n<pre><code class=\"javascript\">let obj = &#123;\n  * myGeneratorMethod() &#123;\n    ···\n  &#125;\n&#125;;\n</code></pre>\n<p>上面代码中，<code>myGeneratorMethod</code>属性前面有一个星号，表示这个属性是一个 Generator 函数。</p>\n<p>它的完整形式如下，与上面的写法是等价的。</p>\n<pre><code class=\"javascript\">let obj = &#123;\n  myGeneratorMethod: function* () &#123;\n    // ···\n  &#125;\n&#125;;\n</code></pre>\n<hr>\n<h4 id=\"9-Generator-函数的this\"><a href=\"#9-Generator-函数的this\" class=\"headerlink\" title=\"9. Generator 函数的this\"></a>9. Generator 函数的this</h4><p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的<code>prototype</code>对象上的方法。</p>\n<pre><code class=\"javascript\">function* g() &#123;&#125;\n\ng.prototype.hello = function () &#123;\n  return &#39;hi!&#39;;\n&#125;;\n\nlet obj = g();\n\nobj instanceof g // true\nobj.hello() // &#39;hi!&#39;\n</code></pre>\n<p>上面代码表明，Generator 函数<code>g</code>返回的遍历器<code>obj</code>，是<code>g</code>的实例，而且继承了<code>g.prototype</code>。但是，如果把<code>g</code>当作普通的构造函数，并不会生效，因为<code>g</code>返回的总是遍历器对象，而不是<code>this</code>对象。</p>\n<pre><code class=\"javascript\">function* g() &#123;\n  this.a = 11;\n&#125;\n\nlet obj = g();\nobj.next();\nobj.a // undefined\n</code></pre>\n<p>上面代码中，Generator 函数<code>g</code>在<code>this</code>对象上面添加了一个属性<code>a</code>，但是<code>obj</code>对象拿不到这个属性。</p>\n<p><strong>Generator 函数也不能跟<code>new</code>命令一起用，会报错。</strong></p>\n<pre><code class=\"javascript\">function* F() &#123;\n  yield this.x = 2;\n  yield this.y = 3;\n&#125;\n\nnew F()\n// TypeError: F is not a constructor\n</code></pre>\n<p>上面代码中，<code>new</code>命令跟构造函数<code>F</code>一起使用，结果报错，因为<code>F</code>不是构造函数。</p>\n<p><strong>那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用<code>next</code>方法，又可以获得正常的<code>this</code>？</strong></p>\n<p><strong>下面是一个变通方法。首先，生成一个空对象，使用<code>call</code>方法绑定 Generator 函数内部的<code>this</code>。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。</strong></p>\n<pre><code class=\"javascript\">function* F() &#123;\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n&#125;\nvar obj = &#123;&#125;;\nvar f = F.call(obj);\n\nf.next();  // Object &#123;value: 2, done: false&#125;\nf.next();  // Object &#123;value: 3, done: false&#125;\nf.next();  // Object &#123;value: undefined, done: true&#125;\n\nobj.a // 1\nobj.b // 2\nobj.c // 3\n</code></pre>\n<p>上面代码中，首先是<code>F</code>内部的<code>this</code>对象绑定<code>obj</code>对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次<code>next</code>方法（因为<code>F</code>内部有两个<code>yield</code>表达式），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在<code>obj</code>对象上了，因此<code>obj</code>对象也就成了<code>F</code>的实例。</p>\n<p>上面代码中，执行的是遍历器对象<code>f</code>，但是生成的对象实例是<code>obj</code>，有没有办法将这两个对象统一呢？</p>\n<p>一个办法就是将<code>obj</code>换成<code>F.prototype</code>。</p>\n<pre><code class=\"javascript\">function* F() &#123;\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n&#125;\nvar f = F.call(F.prototype);\n\nf.next();  // Object &#123;value: 2, done: false&#125;\nf.next();  // Object &#123;value: 3, done: false&#125;\nf.next();  // Object &#123;value: undefined, done: true&#125;\n\nf.a // 1\nf.b // 2\nf.c // 3\n</code></pre>\n<p>再将<code>F</code>改成构造函数，就可以对它执行<code>new</code>命令了。</p>\n<pre><code class=\"javascript\">function* gen() &#123;\n  this.a = 1;\n  yield this.b = 2;\n  yield this.c = 3;\n&#125;\n\nfunction F() &#123;\n  return gen.call(gen.prototype);\n&#125;\n\nvar f = new F();\n\nf.next();  // Object &#123;value: 2, done: false&#125;\nf.next();  // Object &#123;value: 3, done: false&#125;\nf.next();  // Object &#123;value: undefined, done: true&#125;\n\nf.a // 1\nf.b // 2\nf.c // 3\n</code></pre>\n<hr>\n<h4 id=\"10-含义\"><a href=\"#10-含义\" class=\"headerlink\" title=\"10. 含义\"></a>10. 含义</h4><p><strong>Generator 与状态机</strong></p>\n<p>Generator 是实现状态机的最佳结构。比如，下面的<code>clock</code>函数就是一个状态机。</p>\n<pre><code class=\"javascript\">var ticking = true;\nvar clock = function() &#123;\n  if (ticking)\n    console.log(&#39;Tick!&#39;);\n  else\n    console.log(&#39;Tock!&#39;);\n  ticking = !ticking;\n&#125;\n</code></pre>\n<p>上面代码的<code>clock</code>函数一共有两种状态（<code>Tick</code>和<code>Tock</code>），每运行一次，就改变一次状态。这个函数如果用 Generator 实现，就是下面这样。</p>\n<pre><code class=\"javascript\">var clock = function* () &#123;\n  while (true) &#123;\n    console.log(&#39;Tick!&#39;);\n    yield;\n    console.log(&#39;Tock!&#39;);\n    yield;\n  &#125;\n&#125;;\n</code></pre>\n<p>上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量<code>ticking</code>，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p>\n<p><strong>Generator 与协程</strong></p>\n<p>协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p>\n<p><strong>（1）协程与子例程的差异</strong></p>\n<p><strong>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数</strong>。<strong>协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended）</strong>，线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p>\n<p>从实现上看，<strong>在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</strong></p>\n<p><strong>（2）协程与普通线程的差异</strong></p>\n<p>不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p>\n<p>由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p>\n<p>Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p>\n<p>如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用<code>yield</code>表达式交换控制权。</p>\n<hr>\n<p><strong>Generator 与上下文</strong></p>\n<p>JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。</p>\n<p><strong>这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。</strong></p>\n<p><strong>Generator 函数不是这样，它执行产生的上下文环境，一旦遇到<code>yield</code>命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行<code>next</code>命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。</strong></p>\n<pre><code class=\"javascript\">function* gen() &#123;\n  yield 1;\n  return 2;\n&#125;\n\nlet g = gen();\n\nconsole.log(\n  g.next().value,\n  g.next().value,\n);\n</code></pre>\n<p>上面代码中，第一次执行<code>g.next()</code>时，Generator 函数<code>gen</code>的上下文会加入堆栈，即开始运行<code>gen</code>内部的代码。等遇到<code>yield 1</code>时，<code>gen</code>上下文退出堆栈，内部状态冻结。第二次执行<code>g.next()</code>时，<code>gen</code>上下文重新加入堆栈，变成当前的上下文，重新恢复执行。</p>\n<hr>\n<h4 id=\"11-应用\"><a href=\"#11-应用\" class=\"headerlink\" title=\"11. 应用\"></a>11. 应用</h4><p>Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。</p>\n<p><strong>（1）异步操作的同步化表达</strong></p>\n<p>Generator 函数的暂停执行的效果，意味着可以把异步操作写在<code>yield</code>表达式里面，等到调用<code>next</code>方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在<code>yield</code>表达式下面，反正要等到调用<code>next</code>方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p>\n<pre><code class=\"javascript\">function* loadUI() &#123;\n  showLoadingScreen();\n  yield loadUIDataAsynchronously();\n  hideLoadingScreen();\n&#125;\nvar loader = loadUI();\n// 加载UI\nloader.next()\n\n// 卸载UI\nloader.next()\n</code></pre>\n<p>上面代码中，第一次调用<code>loadUI</code>函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用<code>next</code>方法，则会显示<code>Loading</code>界面（<code>showLoadingScreen</code>），并且异步加载数据（<code>loadUIDataAsynchronously</code>）。等到数据加载完成，再一次使用<code>next</code>方法，则会隐藏<code>Loading</code>界面。可以看到，这种写法的好处是所有<code>Loading</code>界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p>\n<p><strong>Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。</strong></p>\n<pre><code class=\"javascript\">function* main() &#123;\n  var result = yield request(&quot;http://some.url&quot;);\n  var resp = JSON.parse(result);\n    console.log(resp.value);\n&#125;\n\nfunction request(url) &#123;\n  makeAjaxCall(url, function(response)&#123;\n    it.next(response);\n  &#125;);\n&#125;\n\nvar it = main();\nit.next();\n</code></pre>\n<p>上面代码的<code>main</code>函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个<code>yield</code>，它几乎与同步操作的写法完全一样。注意，**<code>makeAjaxCall</code>函数中的<code>next</code>方法，必须加上<code>response</code>参数，因为<code>yield</code>表达式，本身是没有值的，总是等于<code>undefined</code>。**</p>\n<p>下面是另一个例子，通过 Generator 函数逐行读取文本文件。</p>\n<pre><code class=\"javascript\">function* numbers() &#123;\n  let file = new FileReader(&quot;numbers.txt&quot;);\n  try &#123;\n    while(!file.eof) &#123;\n      yield parseInt(file.readLine(), 10);\n    &#125;\n  &#125; finally &#123;\n    file.close();\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码打开文本文件，使用<code>yield</code>表达式可以手动逐行读取文件。</p>\n<hr>\n<p><strong>（2）控制流管理</strong></p>\n<p>如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p>\n<pre><code class=\"javascript\">step1(function (value1) &#123;\n  step2(value1, function(value2) &#123;\n    step3(value2, function(value3) &#123;\n      step4(value3, function(value4) &#123;\n        // Do something with value4\n      &#125;);\n    &#125;);\n  &#125;);\n&#125;);\n</code></pre>\n<p>采用 Promise 改写上面的代码。</p>\n<pre><code class=\"javascript\">Promise.resolve(step1)\n  .then(step2)\n  .then(step3)\n  .then(step4)\n  .then(function (value4) &#123;\n    // Do something with value4\n  &#125;, function (error) &#123;\n    // Handle any error from step1 through step4\n  &#125;)\n  .done();\n</code></pre>\n<p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。</p>\n<pre><code class=\"javascript\">function* longRunningTask(value1) &#123;\n  try &#123;\n    var value2 = yield step1(value1);\n    var value3 = yield step2(value2);\n    var value4 = yield step3(value3);\n    var value5 = yield step4(value4);\n    // Do something with value4\n  &#125; catch (e) &#123;\n    // Handle any error from step1 through step4\n  &#125;\n&#125;\n</code></pre>\n<p>然后，使用一个函数，按次序自动执行所有步骤。</p>\n<pre><code class=\"javascript\">scheduler(longRunningTask(initialValue));\n\nfunction scheduler(task) &#123;\n  var taskObj = task.next(task.value);\n  // 如果Generator函数未结束，就继续调用\n  if (!taskObj.done) &#123;\n    task.value = taskObj.value\n    scheduler(task);\n  &#125;\n&#125;\n</code></pre>\n<p>注意，上面这种做法，只适合同步操作，即所有的<code>task</code>都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。</p>\n<p>下面，利用<code>for...of</code>循环会自动依次执行<code>yield</code>命令的特性，提供一种更一般的控制流管理的方法。</p>\n<pre><code class=\"javascript\">let steps = [step1Func, step2Func, step3Func];\n\nfunction* iterateSteps(steps)&#123;\n  for (var i=0; i&lt; steps.length; i++)&#123;\n    var step = steps[i];\n    yield step();\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，数组<code>steps</code>封装了一个任务的多个步骤，Generator 函数<code>iterateSteps</code>则是依次为这些步骤加上<code>yield</code>命令。</p>\n<p>将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。</p>\n<pre><code class=\"javascript\">let jobs = [job1, job2, job3];\n\nfunction* iterateJobs(jobs)&#123;\n  for (var i=0; i&lt; jobs.length; i++)&#123;\n    var job = jobs[i];\n    yield* iterateSteps(job.steps);\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，数组<code>jobs</code>封装了一个项目的多个任务，Generator 函数<code>iterateJobs</code>则是依次为这些任务加上<code>yield*</code>命令。</p>\n<p>最后，就可以用<code>for...of</code>循环一次性依次执行所有任务的所有步骤。</p>\n<pre><code class=\"javascript\">for (var step of iterateJobs(jobs))&#123;\n  console.log(step.id);\n&#125;\n</code></pre>\n<p>再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。</p>\n<p><code>for...of</code>的本质是一个<code>while</code>循环，所以上面的代码实质上执行的是下面的逻辑。</p>\n<pre><code class=\"javascript\">var it = iterateJobs(jobs);\nvar res = it.next();\n\nwhile (!res.done)&#123;\n  var result = res.value;\n  // ...\n  res = it.next();\n&#125;\n</code></pre>\n<hr>\n<p><strong>（3）部署 Iterator 接口</strong></p>\n<p>利用 Generator 函数，可以在任意对象上部署 Iterator 接口。</p>\n<pre><code class=\"javascript\">function* iterEntries(obj) &#123;\n  let keys = Object.keys(obj);\n  for (let i=0; i &lt; keys.length; i++) &#123;\n    let key = keys[i];\n    yield [key, obj[key]];\n  &#125;\n&#125;\n\nlet myObj = &#123; foo: 3, bar: 7 &#125;;\n\nfor (let [key, value] of iterEntries(myObj)) &#123;\n  console.log(key, value);\n&#125;\n\n// foo 3\n// bar 7\n</code></pre>\n<p>上述代码中，<code>myObj</code>是一个普通对象，通过<code>iterEntries</code>函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署<code>next</code>方法。</p>\n<p>下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口。</p>\n<pre><code class=\"javascript\">function* makeSimpleGenerator(array)&#123;\n  var nextIndex = 0;\n\n  while(nextIndex &lt; array.length)&#123;\n    yield array[nextIndex++];\n  &#125;\n&#125;\n\nvar gen = makeSimpleGenerator([&#39;yo&#39;, &#39;ya&#39;]);\n\ngen.next().value // &#39;yo&#39;\ngen.next().value // &#39;ya&#39;\ngen.next().done  // true\n</code></pre>\n<hr>\n<p><strong>（4）作为数据结构</strong></p>\n<p>Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。</p>\n<pre><code class=\"javascript\">function* doStuff() &#123;\n  yield fs.readFile.bind(null, &#39;hello.txt&#39;);\n  yield fs.readFile.bind(null, &#39;world.txt&#39;);\n  yield fs.readFile.bind(null, &#39;and-such.txt&#39;);\n&#125;\n</code></pre>\n<p>上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。</p>\n<pre><code class=\"javascript\">for (task of doStuff()) &#123;\n  // task是一个函数，可以像回调函数那样使用它\n&#125;\n</code></pre>\n<p>实际上，如果用 ES5 表达，完全可以用数组模拟 Generator 的这种用法。</p>\n<pre><code class=\"javascript\">function doStuff() &#123;\n  return [\n    fs.readFile.bind(null, &#39;hello.txt&#39;),\n    fs.readFile.bind(null, &#39;world.txt&#39;),\n    fs.readFile.bind(null, &#39;and-such.txt&#39;)\n  ];\n&#125;\n</code></pre>\n<p>上面的函数，可以用一模一样的<code>for...of</code>循环处理！两相一比较，就不难看出 Generator 使得数据或者操作，具备了类似数组的接口。</p>\n<h3 id=\"19、-Generator-函数的异步应用\"><a href=\"#19、-Generator-函数的异步应用\" class=\"headerlink\" title=\"19、 Generator 函数的异步应用\"></a>19、 Generator 函数的异步应用</h3><hr>\n<h4 id=\"1-传统方法\"><a href=\"#1-传统方法\" class=\"headerlink\" title=\"1. 传统方法\"></a>1. 传统方法</h4><p>ES6 诞生以前，异步编程的方法，大概有下面四种。</p>\n<ul>\n<li>回调函数</li>\n<li>事件监听</li>\n<li>发布/订阅</li>\n<li>Promise 对象</li>\n</ul>\n<p>Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。</p>\n<hr>\n<h4 id=\"2-基本概念\"><a href=\"#2-基本概念\" class=\"headerlink\" title=\"2. 基本概念\"></a>2. 基本概念</h4><p><strong>异步</strong></p>\n<p>所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>\n<p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p>\n<p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>\n<hr>\n<p><strong>回调函数</strong></p>\n<p>JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字<code>callback</code>，直译过来就是”重新调用”。</p>\n<p>读取文件进行处理，是这样写的。</p>\n<pre><code class=\"javascript\">fs.readFile(&#39;/etc/passwd&#39;, &#39;utf-8&#39;, function (err, data) &#123;\n  if (err) throw err;\n  console.log(data);\n&#125;);\n</code></pre>\n<p>上面代码中，<code>readFile</code>函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p>\n<p><strong>一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象<code>err</code>（如果没有错误，该参数就是<code>null</code>）？</strong></p>\n<p><strong>原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。</strong></p>\n<hr>\n<p><strong>Promise</strong></p>\n<p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取<code>A</code>文件之后，再读取<code>B</code>文件，代码如下。</p>\n<pre><code class=\"javascript\">fs.readFile(fileA, &#39;utf-8&#39;, function (err, data) &#123;\n  fs.readFile(fileB, &#39;utf-8&#39;, function (err, data) &#123;\n    // ...\n  &#125;);\n&#125;);\n</code></pre>\n<p>不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为”回调函数地狱”（callback hell）。</p>\n<p>Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。</p>\n<pre><code class=\"javascript\">var readFile = require(&#39;fs-readfile-promise&#39;);\n\nreadFile(fileA)\n.then(function (data) &#123;\n  console.log(data.toString());\n&#125;)\n.then(function () &#123;\n  return readFile(fileB);\n&#125;)\n.then(function (data) &#123;\n  console.log(data.toString());\n&#125;)\n.catch(function (err) &#123;\n  console.log(err);\n&#125;);\n</code></pre>\n<p>上面代码中，我使用了<code>fs-readfile-promise</code>模块，它的作用就是返回一个 Promise 版本的<code>readFile</code>函数。Promise 提供<code>then</code>方法加载回调函数，<code>catch</code>方法捕捉执行过程中抛出的错误。</p>\n<p><strong>可以看到，Promise 的写法只是回调函数的改进，使用<code>then</code>方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</strong></p>\n<p><strong>Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆<code>then</code>，原来的语义变得很不清楚。</strong></p>\n<p>那么，有没有更好的写法呢？</p>\n<hr>\n<h4 id=\"3-Generator-函数\"><a href=\"#3-Generator-函数\" class=\"headerlink\" title=\"3. Generator 函数\"></a>3. Generator 函数</h4><p><strong>协程</strong></p>\n<p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。</p>\n<p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p>\n<ul>\n<li>第一步，协程<code>A</code>开始执行。</li>\n<li>第二步，协程<code>A</code>执行到一半，进入暂停，执行权转移到协程<code>B</code>。</li>\n<li>第三步，（一段时间后）协程<code>B</code>交还执行权。</li>\n<li>第四步，协程<code>A</code>恢复执行。</li>\n</ul>\n<p>上面流程的协程<code>A</code>，就是异步任务，因为它分成两段（或多段）执行。</p>\n<p>举例来说，读取文件的协程写法如下。</p>\n<pre><code class=\"javascript\">function* asyncJob() &#123;\n  // ...其他代码\n  var f = yield readFile(fileA);\n  // ...其他代码\n&#125;\n</code></pre>\n<p>上面代码的函数<code>asyncJob</code>是一个协程，它的奥妙就在其中的<code>yield</code>命令。它表示执行到此处，执行权将交给其他协程。也就是说，<code>yield</code>命令是异步两个阶段的分界线。</p>\n<p>协程遇到<code>yield</code>命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除<code>yield</code>命令，简直一模一样。</p>\n<hr>\n<p><strong>协程的 Generator 函数实现</strong></p>\n<p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>\n<p>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用<code>yield</code>语句注明。Generator 函数的执行方法如下。</p>\n<pre><code class=\"javascript\">function* gen(x) &#123;\n  var y = yield x + 2;\n  return y;\n&#125;\n\nvar g = gen(1);\ng.next() // &#123; value: 3, done: false &#125;\ng.next() // &#123; value: undefined, done: true &#125;\n</code></pre>\n<p>上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）<code>g</code>。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针<code>g</code>的<code>next</code>方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的<code>yield</code>语句，上例是执行到<code>x + 2</code>为止。</p>\n<p>换言之，<code>next</code>方法的作用是分阶段执行<code>Generator</code>函数。每次调用<code>next</code>方法，会返回一个对象，表示当前阶段的信息（<code>value</code>属性和<code>done</code>属性）。<code>value</code>属性是<code>yield</code>语句后面表达式的值，表示当前阶段的值；<code>done</code>属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p>\n<hr>\n<p><strong>Generator 函数的数据交换和错误处理</strong></p>\n<p><strong>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因</strong>。除此之外，<strong>它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</strong></p>\n<p><strong><code>next</code>返回值的 value 属性，是 Generator 函数向外输出数据；<code>next</code>方法还可以接受参数，向 Generator 函数体内输入数据。</strong></p>\n<pre><code class=\"javascript\">function* gen(x)&#123;\n  var y = yield x + 2;\n  return y;\n&#125;\n\nvar g = gen(1);\ng.next() // &#123; value: 3, done: false &#125;\ng.next(2) // &#123; value: 2, done: true &#125;\n</code></pre>\n<p>上面代码中，第一个<code>next</code>方法的<code>value</code>属性，返回表达式<code>x + 2</code>的值<code>3</code>。第二个<code>next</code>方法带有参数<code>2</code>，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量<code>y</code>接收。因此，这一步的<code>value</code>属性，返回的就是<code>2</code>（变量<code>y</code>的值）。</p>\n<p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p>\n<pre><code class=\"javascript\">function* gen(x)&#123;\n  try &#123;\n    var y = yield x + 2;\n  &#125; catch (e)&#123;\n    console.log(e);\n  &#125;\n  return y;\n&#125;\n\nvar g = gen(1);\ng.next();\ng.throw(&#39;出错了&#39;);\n// 出错了\n</code></pre>\n<p>上面代码的最后一行，Generator 函数体外，使用指针对象的<code>throw</code>方法抛出的错误，可以被函数体内的<code>try...catch</code>代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p>\n<hr>\n<p><strong>异步任务的封装</strong></p>\n<p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p>\n<pre><code class=\"javascript\">var fetch = require(&#39;node-fetch&#39;);\n\nfunction* gen()&#123;\n  var url = &#39;https://api.github.com/users/github&#39;;\n  var result = yield fetch(url);\n  console.log(result.bio);\n&#125;\n</code></pre>\n<p>上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了<code>yield</code>命令。</p>\n<p>执行这段代码的方法如下。</p>\n<pre><code class=\"javascript\">var g = gen();\nvar result = g.next();\n\nresult.value.then(function(data)&#123;\n  return data.json();\n&#125;).then(function(data)&#123;\n  g.next(data);\n&#125;);\n</code></pre>\n<p>上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用<code>next</code>方法（第二行），执行异步任务的第一阶段。由于<code>Fetch</code>模块返回的是一个 Promise 对象，因此要用<code>then</code>方法调用下一个<code>next</code>方法。</p>\n<p>可以看到，<strong>虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</strong></p>\n<hr>\n<h4 id=\"4-Thunk-函数\"><a href=\"#4-Thunk-函数\" class=\"headerlink\" title=\"4. Thunk 函数\"></a>4. Thunk 函数</h4><p>Thunk 函数是自动执行 Generator 函数的一种方法。</p>\n<p><strong>参数的求值策略</strong></p>\n<p>Thunk 函数早在上个世纪 60 年代就诞生了。</p>\n<p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底应该何时求值。</p>\n<pre><code class=\"javascript\">var x = 1;\n\nfunction f(m) &#123;\n  return m * 2;\n&#125;\n\nf(x + 5)\n</code></pre>\n<p>上面代码先定义函数<code>f</code>，然后向它传入表达式<code>x + 5</code>。请问，这个表达式应该何时求值？</p>\n<p><strong>一种意见是”传值调用”（call by value），即在进入函数体之前，就计算<code>x + 5</code>的值（等于 6），再将这个值传入函数<code>f</code>。C 语言就采用这种策略。</strong></p>\n<pre><code class=\"javascript\">f(x + 5)\n// 传值调用时，等同于\nf(6)\n</code></pre>\n<p><strong>另一种意见是“传名调用”（call by name），即直接将表达式<code>x + 5</code>传入函数体，只在用到它的时候求值。Haskell 语言采用这种策略。</strong></p>\n<pre><code class=\"javascript\">f(x + 5)\n// 传名调用时，等同于\n(x + 5) * 2\n</code></pre>\n<p>传值调用和传名调用，哪一种比较好？</p>\n<p>回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p>\n<pre><code class=\"javascript\">function f(a, b)&#123;\n  return b;\n&#125;\n\nf(3 * x * x - 2 * x - 1, x);\n</code></pre>\n<p>上面代码中，函数<code>f</code>的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于”传名调用”，即只在执行时求值。</p>\n<hr>\n<p><strong>Thunk 函数的含义</strong></p>\n<p>编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。</p>\n<pre><code class=\"javascript\">function f(m) &#123;\n  return m * 2;\n&#125;\n\nf(x + 5);\n\n// 等同于\n\nvar thunk = function () &#123;\n  return x + 5;\n&#125;;\n\nfunction f(thunk) &#123;\n  return thunk() * 2;\n&#125;\n</code></pre>\n<p>上面代码中，函数 f 的参数<code>x + 5</code>被一个函数替换了。凡是用到原参数的地方，对<code>Thunk</code>函数求值即可。</p>\n<p>这就是 Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。</p>\n<hr>\n<p><strong>JavaScript 语言的 Thunk 函数</strong></p>\n<p><strong>JavaScript 语言是传值调用</strong>，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，<strong>Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</strong></p>\n<pre><code class=\"javascript\">// 正常版本的readFile（多参数版本）\nfs.readFile(fileName, callback);\n\n// Thunk版本的readFile（单参数版本）\nvar Thunk = function (fileName) &#123;\n  return function (callback) &#123;\n    return fs.readFile(fileName, callback);\n  &#125;;\n&#125;;\n\nvar readFileThunk = Thunk(fileName);\nreadFileThunk(callback);\n</code></pre>\n<p>上面代码中，<code>fs</code>模块的<code>readFile</code>方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。</p>\n<p>任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。</p>\n<pre><code class=\"javascript\">// ES5版本\nvar Thunk = function(fn)&#123;\n  return function ()&#123;\n    var args = Array.prototype.slice.call(arguments);\n    return function (callback)&#123;\n      args.push(callback);\n      return fn.apply(this, args);\n    &#125;\n  &#125;;\n&#125;;\n\n// ES6版本\nconst Thunk = function(fn) &#123;\n  return function (...args) &#123;\n    return function (callback) &#123;\n      return fn.call(this, ...args, callback);\n    &#125;\n  &#125;;\n&#125;;\n</code></pre>\n<p>使用上面的转换器，生成<code>fs.readFile</code>的 Thunk 函数。</p>\n<pre><code class=\"javascript\">var readFileThunk = Thunk(fs.readFile);\nreadFileThunk(fileA)(callback);\n</code></pre>\n<p>下面是另一个完整的例子。</p>\n<pre><code class=\"javascript\">function f(a, cb) &#123;\n  cb(a);\n&#125;\nconst ft = Thunk(f);\n\nft(1)(console.log) // 1\n</code></pre>\n<hr>\n<p><strong>Thunkify 模块</strong></p>\n<p>生产环境的转换器，建议使用 Thunkify 模块。</p>\n<p>首先是安装。</p>\n<pre><code class=\"bash\">$ npm install thunkify\n</code></pre>\n<p>使用方式如下。</p>\n<pre><code class=\"javascript\">var thunkify = require(&#39;thunkify&#39;);\nvar fs = require(&#39;fs&#39;);\n\nvar read = thunkify(fs.readFile);\nread(&#39;package.json&#39;)(function(err, str)&#123;\n  // ...\n&#125;);\n</code></pre>\n<p>Thunkify 的源码与上一节那个简单的转换器非常像。</p>\n<pre><code class=\"javascript\">function thunkify(fn) &#123;\n  return function() &#123;\n    var args = new Array(arguments.length);\n    var ctx = this;\n\n    for (var i = 0; i &lt; args.length; ++i) &#123;\n      args[i] = arguments[i];\n    &#125;\n\n    return function (done) &#123;\n      var called;\n\n      args.push(function () &#123;\n        if (called) return;\n        called = true;\n        done.apply(null, arguments);\n      &#125;);\n\n      try &#123;\n        fn.apply(ctx, args);\n      &#125; catch (err) &#123;\n        done(err);\n      &#125;\n    &#125;\n  &#125;\n&#125;;\n</code></pre>\n<p>它的源码主要多了一个检查机制，变量<code>called</code>确保回调函数只运行一次。这样的设计与下文的 Generator 函数相关。请看下面的例子。</p>\n<pre><code class=\"javascript\">function f(a, b, callback)&#123;\n  var sum = a + b;\n  callback(sum);\n  callback(sum);\n&#125;\n\nvar ft = thunkify(f);\nvar print = console.log.bind(console);\nft(1, 2)(print);\n// 3\n</code></pre>\n<p>上面代码中，由于<code>thunkify</code>只允许回调函数执行一次，所以只输出一行结果。</p>\n<hr>\n<p><strong>Generator 函数的流程管理</strong></p>\n<p>你可能会问， Thunk 函数有什么用？回答是以前确实没什么用，但是 ES6 有了 Generator 函数，Thunk 函数现在可以用于 Generator 函数的自动流程管理。</p>\n<p>Generator 函数可以自动执行。</p>\n<pre><code class=\"javascript\">function* gen() &#123;\n  // ...\n&#125;\n\nvar g = gen();\nvar res = g.next();\n\nwhile(!res.done)&#123;\n  console.log(res.value);\n  res = g.next();\n&#125;\n</code></pre>\n<p>上面代码中，Generator 函数<code>gen</code>会自动执行完所有步骤。</p>\n<p>但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk 函数就能派上用处。以读取文件为例。下面的 Generator 函数封装了两个异步操作。</p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\nvar thunkify = require(&#39;thunkify&#39;);\nvar readFileThunk = thunkify(fs.readFile);\n\nvar gen = function* ()&#123;\n  var r1 = yield readFileThunk(&#39;/etc/fstab&#39;);\n  console.log(r1.toString());\n  var r2 = yield readFileThunk(&#39;/etc/shells&#39;);\n  console.log(r2.toString());\n&#125;;\n</code></pre>\n<p><strong>上面代码中，<code>yield</code>命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。</strong></p>\n<p><strong>这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。为了便于理解，我们先看如何手动执行上面这个 Generator 函数。</strong></p>\n<pre><code class=\"javascript\">var g = gen();\n\nvar r1 = g.next();\nr1.value(function (err, data) &#123;\n  if (err) throw err;\n  var r2 = g.next(data);\n  r2.value(function (err, data) &#123;\n    if (err) throw err;\n    g.next(data);\n  &#125;);\n&#125;);\n</code></pre>\n<p>上面代码中，变量<code>g</code>是 Generator 函数的内部指针，表示目前执行到哪一步。<code>next</code>方法负责将指针移动到下一步，并返回该步的信息（<code>value</code>属性和<code>done</code>属性）。</p>\n<p>仔细查看上面的代码，可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入<code>next</code>方法的<code>value</code>属性。这使得我们可以用递归来自动完成这个过程。</p>\n<p><strong>Thunk 函数的自动流程管理</strong></p>\n<p>Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。</p>\n<pre><code class=\"javascript\">function run(fn) &#123;\n  var gen = fn();\n\n  function next(err, data) &#123;\n    var result = gen.next(data);\n    if (result.done) return;\n    result.value(next);\n  &#125;\n\n  next();\n&#125;\n\nfunction* g() &#123;\n  // ...\n&#125;\n\nrun(g);\n</code></pre>\n<p>上面代码的<code>run</code>函数，就是一个 Generator 函数的自动执行器。内部的<code>next</code>函数就是 Thunk 的回调函数。<code>next</code>函数先将指针移到 Generator 函数的下一步（<code>gen.next</code>方法），然后判断 Generator 函数是否结束（<code>result.done</code>属性），如果没结束，就将<code>next</code>函数再传入 Thunk 函数（<code>result.value</code>属性），否则就直接退出。</p>\n<p>有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入<code>run</code>函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在<code>yield</code>命令后面的必须是 Thunk 函数。</p>\n<pre><code class=\"javascript\">var g = function* ()&#123;\n  var f1 = yield readFileThunk(&#39;fileA&#39;);\n  var f2 = yield readFileThunk(&#39;fileB&#39;);\n  // ...\n  var fn = yield readFileThunk(&#39;fileN&#39;);\n&#125;;\n\nrun(g);\n</code></pre>\n<p>上面代码中，函数<code>g</code>封装了<code>n</code>个异步的读取文件操作，只要执行<code>run</code>函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p>\n<p>Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p>\n<hr>\n<h4 id=\"5-co-模块\"><a href=\"#5-co-模块\" class=\"headerlink\" title=\"5. co 模块\"></a>5. co 模块</h4><p><strong>基本用法</strong></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RqL2Nv\">co 模块</span>是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行。</p>\n<p>下面是一个 Generator 函数，用于依次读取两个文件。</p>\n<pre><code class=\"javascript\">var gen = function* () &#123;\n  var f1 = yield readFile(&#39;/etc/fstab&#39;);\n  var f2 = yield readFile(&#39;/etc/shells&#39;);\n  console.log(f1.toString());\n  console.log(f2.toString());\n&#125;;\n</code></pre>\n<p>co 模块可以让你不用编写 Generator 函数的执行器。</p>\n<pre><code class=\"javascript\">var co = require(&#39;co&#39;);\nco(gen);\n</code></pre>\n<p>上面代码中，Generator 函数只要传入<code>co</code>函数，就会自动执行。</p>\n<p><code>co</code>函数返回一个<code>Promise</code>对象，因此可以用<code>then</code>方法添加回调函数。</p>\n<pre><code class=\"javascript\">co(gen).then(function ()&#123;\n  console.log(&#39;Generator 函数执行完成&#39;);\n&#125;);\n</code></pre>\n<p>上面代码中，等到 Generator 函数执行结束，就会输出一行提示。</p>\n<hr>\n<p><strong>co 模块的原理</strong></p>\n<p>为什么 co 可以自动执行 Generator 函数？</p>\n<p>前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>\n<p>两种方法可以做到这一点。</p>\n<p>（1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</p>\n<p>（2）Promise 对象。将异步操作包装成 Promise 对象，用<code>then</code>方法交回执行权。</p>\n<p>co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的<code>yield</code>命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co，详见后文的例子。</p>\n<p>上一节已经介绍了基于 Thunk 函数的自动执行器。下面来看，基于 Promise 对象的自动执行器。这是理解 co 模块必须的。</p>\n<hr>\n<p><strong>基于 Promise 对象的自动执行</strong></p>\n<p>还是沿用上面的例子。首先，把<code>fs</code>模块的<code>readFile</code>方法包装成一个 Promise 对象。</p>\n<pre><code class=\"javascript\">var fs = require(&#39;fs&#39;);\n\nvar readFile = function (fileName)&#123;\n  return new Promise(function (resolve, reject)&#123;\n    fs.readFile(fileName, function(error, data)&#123;\n      if (error) return reject(error);\n      resolve(data);\n    &#125;);\n  &#125;);\n&#125;;\n\nvar gen = function* ()&#123;\n  var f1 = yield readFile(&#39;/etc/fstab&#39;);\n  var f2 = yield readFile(&#39;/etc/shells&#39;);\n  console.log(f1.toString());\n  console.log(f2.toString());\n&#125;;\n</code></pre>\n<p>然后，手动执行上面的 Generator 函数。</p>\n<pre><code class=\"javascript\">var g = gen();\n\ng.next().value.then(function(data)&#123;\n  g.next(data).value.then(function(data)&#123;\n    g.next(data);\n  &#125;);\n&#125;);\n</code></pre>\n<p>手动执行其实就是用<code>then</code>方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p>\n<pre><code class=\"javascript\">function run(gen)&#123;\n  var g = gen();\n\n  function next(data)&#123;\n    var result = g.next(data);\n    if (result.done) return result.value;\n    result.value.then(function(data)&#123;\n      next(data);\n    &#125;);\n  &#125;\n\n  next();\n&#125;\n\nrun(gen);\n</code></pre>\n<p>上面代码中，只要 Generator 函数还没执行到最后一步，<code>next</code>函数就调用自身，以此实现自动执行。</p>\n<hr>\n<p><strong>co 模块的源码</strong></p>\n<p>co 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p>\n<p>首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。</p>\n<pre><code class=\"javascript\">function co(gen) &#123;\n  var ctx = this;\n\n  return new Promise(function(resolve, reject) &#123;\n  &#125;);\n&#125;\n</code></pre>\n<p>在返回的 Promise 对象里面，co 先检查参数<code>gen</code>是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为<code>resolved</code>。</p>\n<pre><code class=\"javascript\">function co(gen) &#123;\n  var ctx = this;\n\n  return new Promise(function(resolve, reject) &#123;\n    if (typeof gen === &#39;function&#39;) gen = gen.call(ctx);\n    if (!gen || typeof gen.next !== &#39;function&#39;) return resolve(gen);\n  &#125;);\n&#125;\n</code></pre>\n<p>接着，co 将 Generator 函数的内部指针对象的<code>next</code>方法，包装成<code>onFulfilled</code>函数。这主要是为了能够捕捉抛出的错误。</p>\n<pre><code class=\"javascript\">function co(gen) &#123;\n  var ctx = this;\n\n  return new Promise(function(resolve, reject) &#123;\n    if (typeof gen === &#39;function&#39;) gen = gen.call(ctx);\n    if (!gen || typeof gen.next !== &#39;function&#39;) return resolve(gen);\n\n    onFulfilled();\n    function onFulfilled(res) &#123;\n      var ret;\n      try &#123;\n        ret = gen.next(res);\n      &#125; catch (e) &#123;\n        return reject(e);\n      &#125;\n      next(ret);\n    &#125;\n  &#125;);\n&#125;\n</code></pre>\n<p>最后，就是关键的<code>next</code>函数，它会反复调用自身。</p>\n<pre><code class=\"javascript\">function next(ret) &#123;\n  if (ret.done) return resolve(ret.value);\n  var value = toPromise.call(ctx, ret.value);\n  if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);\n  return onRejected(\n    new TypeError(\n      &#39;You may only yield a function, promise, generator, array, or object, &#39;\n      + &#39;but the following object was passed: &quot;&#39;\n      + String(ret.value)\n      + &#39;&quot;&#39;\n    )\n  );\n&#125;\n</code></pre>\n<p>上面代码中，<code>next</code>函数的内部代码，一共只有四行命令。</p>\n<p>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p>\n<p>第二行，确保每一步的返回值，是 Promise 对象。</p>\n<p>第三行，使用<code>then</code>方法，为返回值加上回调函数，然后通过<code>onFulfilled</code>函数再次调用<code>next</code>函数。</p>\n<p>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为<code>rejected</code>，从而终止执行。</p>\n<hr>\n<p><strong>处理并发的异步操作</strong></p>\n<p>co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>\n<p>这时，要把并发的操作都放在数组或对象里面，跟在<code>yield</code>语句后面。</p>\n<pre><code class=\"javascript\">// 数组的写法\nco(function* () &#123;\n  var res = yield [\n    Promise.resolve(1),\n    Promise.resolve(2)\n  ];\n  console.log(res);\n&#125;).catch(onerror);\n\n// 对象的写法\nco(function* () &#123;\n  var res = yield &#123;\n    1: Promise.resolve(1),\n    2: Promise.resolve(2),\n  &#125;;\n  console.log(res);\n&#125;).catch(onerror);\n</code></pre>\n<p>下面是另一个例子。</p>\n<pre><code class=\"javascript\">co(function* () &#123;\n  var values = [n1, n2, n3];\n  yield values.map(somethingAsync);\n&#125;);\n\nfunction* somethingAsync(x) &#123;\n  // do something async\n  return y\n&#125;\n</code></pre>\n<p>上面的代码允许并发三个<code>somethingAsync</code>异步操作，等到它们全部完成，才会进行下一步。</p>\n<hr>\n<p><strong>实例：处理 Stream</strong></p>\n<p>Node 提供 Stream 模式读写数据，特点是一次只处理数据的一部分，数据分成一块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。Stream 模式使用 EventEmitter API，会释放三个事件。</p>\n<ul>\n<li><code>data</code>事件：下一块数据块已经准备好了。</li>\n<li><code>end</code>事件：整个“数据流”处理完了。</li>\n<li><code>error</code>事件：发生错误。</li>\n</ul>\n<p>使用<code>Promise.race()</code>函数，可以判断这三个事件之中哪一个最先发生，只有当<code>data</code>事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一个<code>while</code>循环，完成所有数据的读取。</p>\n<pre><code class=\"javascript\">const co = require(&#39;co&#39;);\nconst fs = require(&#39;fs&#39;);\n\nconst stream = fs.createReadStream(&#39;./les_miserables.txt&#39;);\nlet valjeanCount = 0;\n\nco(function*() &#123;\n  while(true) &#123;\n    const res = yield Promise.race([\n      new Promise(resolve =&gt; stream.once(&#39;data&#39;, resolve)),\n      new Promise(resolve =&gt; stream.once(&#39;end&#39;, resolve)),\n      new Promise((resolve, reject) =&gt; stream.once(&#39;error&#39;, reject))\n    ]);\n    if (!res) &#123;\n      break;\n    &#125;\n    stream.removeAllListeners(&#39;data&#39;);\n    stream.removeAllListeners(&#39;end&#39;);\n    stream.removeAllListeners(&#39;error&#39;);\n    valjeanCount += (res.toString().match(/valjean/ig) || []).length;\n  &#125;\n  console.log(&#39;count:&#39;, valjeanCount); // count: 1120\n&#125;);\n</code></pre>\n<p>上面代码采用 Stream 模式读取《悲惨世界》的文本文件，对于每个数据块都使用<code>stream.once</code>方法，在<code>data</code>、<code>end</code>、<code>error</code>三个事件上添加一次性回调函数。变量<code>res</code>只有在<code>data</code>事件发生时才有值，然后累加每个数据块之中<code>valjean</code>这个词出现的次数。</p>\n<h3 id=\"20、-async-函数\"><a href=\"#20、-async-函数\" class=\"headerlink\" title=\"20、 async 函数\"></a>20、 async 函数</h3><hr>\n<h4 id=\"1-含义\"><a href=\"#1-含义\" class=\"headerlink\" title=\"1. 含义\"></a>1. 含义</h4><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\n<p><strong>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</strong></p>\n<p>前文有一个 Generator 函数，依次读取两个文件。</p>\n<pre><code class=\"javascript\">const fs = require(&#39;fs&#39;);\n\nconst readFile = function (fileName) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    fs.readFile(fileName, function(error, data) &#123;\n      if (error) return reject(error);\n      resolve(data);\n    &#125;);\n  &#125;);\n&#125;;\n\nconst gen = function* () &#123;\n  const f1 = yield readFile(&#39;/etc/fstab&#39;);\n  const f2 = yield readFile(&#39;/etc/shells&#39;);\n  console.log(f1.toString());\n  console.log(f2.toString());\n&#125;;\n</code></pre>\n<p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样。</p>\n<pre><code class=\"javascript\">const asyncReadFile = async function () &#123;\n  const f1 = await readFile(&#39;/etc/fstab&#39;);\n  const f2 = await readFile(&#39;/etc/shells&#39;);\n  console.log(f1.toString());\n  console.log(f2.toString());\n&#125;;\n</code></pre>\n<p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p>\n<p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p>\n<p><strong>（1）内置执行器。</strong></p>\n<p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p>\n<pre><code class=\"javascript\">asyncReadFile();\n</code></pre>\n<p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p>\n<p><strong>（2）更好的语义。</strong></p>\n<p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。**<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。**</p>\n<p><strong>（3）更广的适用性。</strong></p>\n<p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p>\n<p><strong>（4）返回值是 Promise。</strong></p>\n<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>\n<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>\n<hr>\n<h4 id=\"2-基本用法-1\"><a href=\"#2-基本用法-1\" class=\"headerlink\" title=\"2. 基本用法\"></a>2. 基本用法</h4><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>\n<p>下面是一个例子。</p>\n<pre><code class=\"javascript\">async function getStockPriceByName(name) &#123;\n  const symbol = await getStockSymbol(name);\n  const stockPrice = await getStockPrice(symbol);\n  return stockPrice;\n&#125;\n\ngetStockPriceByName(&#39;goog&#39;).then(function (result) &#123;\n  console.log(result);\n&#125;);\n</code></pre>\n<p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p>\n<p>下面是另一个例子，指定多少毫秒后输出一个值。</p>\n<pre><code class=\"javascript\">function timeout(ms) &#123;\n  return new Promise((resolve) =&gt; &#123;\n    setTimeout(resolve, ms);\n  &#125;);\n&#125;\n\nasync function asyncPrint(value, ms) &#123;\n  await timeout(ms);\n  console.log(value);\n&#125;\n\nasyncPrint(&#39;hello world&#39;, 50);\n</code></pre>\n<p>上面代码指定 50 毫秒以后，输出<code>hello world</code>。</p>\n<p>由于<code>async</code>函数返回的是 Promise 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p>\n<pre><code class=\"javascript\">async function timeout(ms) &#123;\n  await new Promise((resolve) =&gt; &#123;\n    setTimeout(resolve, ms);\n  &#125;);\n&#125;\n\nasync function asyncPrint(value, ms) &#123;\n  await timeout(ms);\n  console.log(value);\n&#125;\n\nasyncPrint(&#39;hello world&#39;, 50);\n</code></pre>\n<p>async 函数有多种使用形式。</p>\n<pre><code class=\"javascript\">// 函数声明\nasync function foo() &#123;&#125;\n\n// 函数表达式\nconst foo = async function () &#123;&#125;;\n\n// 对象的方法\nlet obj = &#123; async foo() &#123;&#125; &#125;;\nobj.foo().then(...)\n\n// Class 的方法\nclass Storage &#123;\n  constructor() &#123;\n    this.cachePromise = caches.open(&#39;avatars&#39;);\n  &#125;\n\n  async getAvatar(name) &#123;\n    const cache = await this.cachePromise;\n    return cache.match(`/avatars/$&#123;name&#125;.jpg`);\n  &#125;\n&#125;\n\nconst storage = new Storage();\nstorage.getAvatar(&#39;jake&#39;).then(…);\n\n// 箭头函数\nconst foo = async () =&gt; &#123;&#125;;\n</code></pre>\n<hr>\n<h4 id=\"3-语法\"><a href=\"#3-语法\" class=\"headerlink\" title=\"3. 语法\"></a>3. 语法</h4><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p>\n<p><strong>返回 Promise 对象</strong></p>\n<p><code>async</code>函数返回一个 Promise 对象。</p>\n<p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p>\n<pre><code class=\"javascript\">async function f() &#123;\n  return &#39;hello world&#39;;\n&#125;\n\nf().then(v =&gt; console.log(v))\n// &quot;hello world&quot;\n</code></pre>\n<p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p>\n<p><strong><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</strong></p>\n<pre><code class=\"javascript\">async function f() &#123;\n  throw new Error(&#39;出错了&#39;);\n&#125;\n\nf().then(\n  v =&gt; console.log(&#39;resolve&#39;, v),\n  e =&gt; console.log(&#39;reject&#39;, e)\n)\n//reject Error: 出错了\n</code></pre>\n<hr>\n<p><strong>Promise 对象的状态变化</strong></p>\n<p><strong><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</strong></p>\n<p>下面是一个例子。</p>\n<pre><code class=\"javascript\">async function getTitle(url) &#123;\n  let response = await fetch(url);\n  let html = await response.text();\n  return html.match(/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i)[1];\n&#125;\ngetTitle(&#39;https://tc39.github.io/ecma262/&#39;).then(console.log)\n// &quot;ECMAScript 2017 Language Specification&quot;\n</code></pre>\n<p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p>\n<hr>\n<p><strong>await 命令</strong></p>\n<p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p>\n<pre><code class=\"javascript\">async function f() &#123;\n  // 等同于\n  // return 123;\n  return await 123;\n&#125;\n\nf().then(v =&gt; console.log(v))\n// 123\n</code></pre>\n<p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，这时等同于<code>return 123</code>。</p>\n<p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p>\n<pre><code class=\"javascript\">class Sleep &#123;\n  constructor(timeout) &#123;\n    this.timeout = timeout;\n  &#125;\n  then(resolve, reject) &#123;\n    const startTime = Date.now();\n    setTimeout(\n      () =&gt; resolve(Date.now() - startTime),\n      this.timeout\n    );\n  &#125;\n&#125;\n\n(async () =&gt; &#123;\n  const sleepTime = await new Sleep(1000);\n  console.log(sleepTime);\n&#125;)();\n// 1000\n</code></pre>\n<p>上面代码中，<code>await</code>命令后面是一个<code>Sleep</code>对象的实例。这个实例不是 Promise 对象，但是因为定义了<code>then</code>方法，<code>await</code>会将其视为<code>Promise</code>处理。</p>\n<p>这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助<code>await</code>命令就可以让程序停顿指定的时间。下面给出了一个简化的<code>sleep</code>实现。</p>\n<pre><code class=\"javascript\">function sleep(interval) &#123;\n  return new Promise(resolve =&gt; &#123;\n    setTimeout(resolve, interval);\n  &#125;)\n&#125;\n\n// 用法\nasync function one2FiveInAsync() &#123;\n  for(let i = 1; i &lt;= 5; i++) &#123;\n    console.log(i);\n    await sleep(1000);\n  &#125;\n&#125;\n\none2FiveInAsync();\n</code></pre>\n<p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p>\n<pre><code class=\"javascript\">async function f() &#123;\n  await Promise.reject(&#39;出错了&#39;);\n&#125;\n\nf()\n.then(v =&gt; console.log(v))\n.catch(e =&gt; console.log(e))\n// 出错了\n</code></pre>\n<p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p>\n<p><strong>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</strong></p>\n<pre><code class=\"javascript\">async function f() &#123;\n  await Promise.reject(&#39;出错了&#39;);\n  await Promise.resolve(&#39;hello world&#39;); // 不会执行\n&#125;\n</code></pre>\n<p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p>\n<p><strong>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</strong></p>\n<pre><code class=\"javascript\">async function f() &#123;\n  try &#123;\n    await Promise.reject(&#39;出错了&#39;);\n  &#125; catch(e) &#123;\n  &#125;\n  return await Promise.resolve(&#39;hello world&#39;);\n&#125;\n\nf()\n.then(v =&gt; console.log(v))\n// hello world\n</code></pre>\n<p><strong>另一种方法是<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</strong></p>\n<pre><code class=\"javascript\">async function f() &#123;\n  await Promise.reject(&#39;出错了&#39;)\n    .catch(e =&gt; console.log(e));\n  return await Promise.resolve(&#39;hello world&#39;);\n&#125;\n\nf()\n.then(v =&gt; console.log(v))\n// 出错了\n// hello world\n</code></pre>\n<hr>\n<p><strong>错误处理</strong></p>\n<p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p>\n<pre><code class=\"javascript\">async function f() &#123;\n  await new Promise(function (resolve, reject) &#123;\n    throw new Error(&#39;出错了&#39;);\n  &#125;);\n&#125;\n\nf()\n.then(v =&gt; console.log(v))\n.catch(e =&gt; console.log(e))\n// Error：出错了\n</code></pre>\n<p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的 Promise 对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。</p>\n<p><strong>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</strong></p>\n<pre><code class=\"javascript\">async function f() &#123;\n  try &#123;\n    await new Promise(function (resolve, reject) &#123;\n      throw new Error(&#39;出错了&#39;);\n    &#125;);\n  &#125; catch(e) &#123;\n  &#125;\n  return await(&#39;hello world&#39;);\n&#125;\n</code></pre>\n<p><strong>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</strong></p>\n<pre><code class=\"javascript\">async function main() &#123;\n  try &#123;\n    const val1 = await firstStep();\n    const val2 = await secondStep(val1);\n    const val3 = await thirdStep(val1, val2);\n\n    console.log(&#39;Final: &#39;, val3);\n  &#125;\n  catch (err) &#123;\n    console.error(err);\n  &#125;\n&#125;\n</code></pre>\n<p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p>\n<pre><code class=\"javascript\">const superagent = require(&#39;superagent&#39;);\nconst NUM_RETRIES = 3;\n\nasync function test() &#123;\n  let i;\n  for (i = 0; i &lt; NUM_RETRIES; ++i) &#123;\n    try &#123;\n      await superagent.get(&#39;http://google.com/this-throws-an-error&#39;);\n      break;\n    &#125; catch(err) &#123;&#125;\n  &#125;\n  console.log(i); // 3\n&#125;\n\ntest();\n</code></pre>\n<p><strong>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</strong>因为操作失败会直接进入catch不会执行break</p>\n<hr>\n<p><strong>使用注意点</strong></p>\n<p><strong>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</strong>或者后面加个catch</p>\n<pre><code class=\"javascript\">async function myFunction() &#123;\n  try &#123;\n    await somethingThatReturnsAPromise();\n  &#125; catch (err) &#123;\n    console.log(err);\n  &#125;\n&#125;\n\n// 另一种写法\n\nasync function myFunction() &#123;\n  await somethingThatReturnsAPromise()\n  .catch(function (err) &#123;\n    console.log(err);\n  &#125;);\n&#125;\n</code></pre>\n<p><strong>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</strong></p>\n<pre><code class=\"javascript\">let foo = await getFoo();\nlet bar = await getBar();\n</code></pre>\n<p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p>\n<pre><code class=\"javascript\">// 写法一\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n\n// 写法二\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n</code></pre>\n<p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p>\n<p><strong>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</strong></p>\n<pre><code class=\"javascript\">async function dbFuc(db) &#123;\n  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];\n\n  // 报错\n  docs.forEach(function (doc) &#123;\n    await db.post(doc);\n  &#125;);\n&#125;\n</code></pre>\n<p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p>\n<pre><code class=\"javascript\">function dbFuc(db) &#123; //这里不需要 async\n  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];\n\n  // 可能得到错误结果\n  docs.forEach(async function (doc) &#123;\n    await db.post(doc);\n  &#125;);\n&#125;\n</code></pre>\n<p>上面代码可能不会正常工作，原因是这时三个<code>db.post()</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p>\n<pre><code class=\"javascript\">async function dbFuc(db) &#123;\n  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];\n\n  for (let doc of docs) &#123;\n    await db.post(doc);\n  &#125;\n&#125;\n</code></pre>\n<p>另一种方法是使用数组的<code>reduce()</code>方法。</p>\n<pre><code class=\"javascript\">async function dbFuc(db) &#123;\n  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];\n\n  await docs.reduce(async (_, doc) =&gt; &#123;\n    await _;\n    await db.post(doc);\n  &#125;, undefined);\n&#125;\n</code></pre>\n<p>上面例子中，<code>reduce()</code>方法的第一个参数是<code>async</code>函数，导致该函数的第一个参数是前一步操作返回的 Promise 对象，所以必须使用<code>await</code>等待它操作结束。另外，<code>reduce()</code>方法返回的是<code>docs</code>数组最后一个成员的<code>async</code>函数的执行结果，也是一个 Promise 对象，导致在它前面也必须加上<code>await</code>。</p>\n<p>上面的<code>reduce()</code>的参数函数里面没有<code>return</code>语句，原因是这个函数的主要目的是<code>db.post()</code>操作，不是返回值。而且<code>async</code>函数不管有没有<code>return</code>语句，总是返回一个 Promise 对象，所以这里的<code>return</code>是不必要的。</p>\n<p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。当三个请求都会<code>resolved</code>时，下面两种写法效果相同。</p>\n<pre><code class=\"javascript\">async function dbFuc(db) &#123;\n  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];\n  let promises = docs.map((doc) =&gt; db.post(doc));\n\n  let results = await Promise.all(promises);\n  console.log(results);\n&#125;\n\n// 或者使用下面的写法\n\nasync function dbFuc(db) &#123;\n  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];\n  let promises = docs.map((doc) =&gt; db.post(doc));\n\n  let results = [];\n  for (let promise of promises) &#123;\n    results.push(await promise);\n  &#125;\n  console.log(results);\n&#125;\n</code></pre>\n<p><strong>第四点，async 函数可以保留运行堆栈。</strong></p>\n<pre><code class=\"javascript\">const a = () =&gt; &#123;\n  b().then(() =&gt; c());\n&#125;;\n</code></pre>\n<p>上面代码中，函数<code>a</code>内部运行了一个异步任务<code>b()</code>。当<code>b()</code>运行的时候，函数<code>a()</code>不会中断，而是继续执行。等到<code>b()</code>运行结束，可能<code>a()</code>早就运行结束了，<code>b()</code>所在的上下文环境已经消失了。如果<code>b()</code>或<code>c()</code>报错，错误堆栈将不包括<code>a()</code>。</p>\n<p>现在将这个例子改成<code>async</code>函数。</p>\n<pre><code class=\"javascript\">const a = async () =&gt; &#123;\n  await b();\n  c();\n&#125;;\n</code></pre>\n<p>上面代码中，<code>b()</code>运行的时候，<code>a()</code>是暂停执行，上下文环境都保存着。一旦<code>b()</code>或<code>c()</code>报错，错误堆栈将包括<code>a()</code>。</p>\n<hr>\n<h4 id=\"4-async-函数的实现原理\"><a href=\"#4-async-函数的实现原理\" class=\"headerlink\" title=\"4. async 函数的实现原理\"></a>4. async 函数的实现原理</h4><p><strong>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</strong></p>\n<pre><code class=\"javascript\">async function fn(args) &#123;\n  // ...\n&#125;\n\n// 等同于\n\nfunction fn(args) &#123;\n  return spawn(function* () &#123;\n    // ...\n  &#125;);\n&#125;\n</code></pre>\n<p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p>\n<p>下面给出<code>spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p>\n<pre><code class=\"javascript\">function spawn(genF) &#123;\n  return new Promise(function(resolve, reject) &#123;\n    const gen = genF();\n    function step(nextF) &#123;\n      let next;\n      try &#123;\n        next = nextF();\n      &#125; catch(e) &#123;\n        return reject(e);\n      &#125;\n      if(next.done) &#123;\n        return resolve(next.value);\n      &#125;\n      Promise.resolve(next.value).then(function(v) &#123;\n        step(function() &#123; return gen.next(v); &#125;);\n      &#125;, function(e) &#123;\n        step(function() &#123; return gen.throw(e); &#125;);\n      &#125;);\n    &#125;\n    step(function() &#123; return gen.next(undefined); &#125;);\n  &#125;);\n&#125;\n</code></pre>\n<hr>\n<h4 id=\"5-与其他异步处理方法的比较\"><a href=\"#5-与其他异步处理方法的比较\" class=\"headerlink\" title=\"5.  与其他异步处理方法的比较\"></a>5.  与其他异步处理方法的比较</h4><p>我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。</p>\n<p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>\n<p>首先是 Promise 的写法。</p>\n<pre><code class=\"javascript\">function chainAnimationsPromise(elem, animations) &#123;\n\n  // 变量ret用来保存上一个动画的返回值\n  let ret = null;\n\n  // 新建一个空的Promise\n  let p = Promise.resolve();\n\n  // 使用then方法，添加所有动画\n  for(let anim of animations) &#123;\n    p = p.then(function(val) &#123;\n      ret = val;\n      return anim(elem);\n    &#125;);\n  &#125;\n\n  // 返回一个部署了错误捕捉机制的Promise\n  return p.catch(function(e) &#123;\n    /* 忽略错误，继续执行 */\n  &#125;).then(function() &#123;\n    return ret;\n  &#125;);\n\n&#125;\n</code></pre>\n<p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（<code>then</code>、<code>catch</code>等等），操作本身的语义反而不容易看出来。</p>\n<p>接着是 Generator 函数的写法。</p>\n<pre><code class=\"javascript\">function chainAnimationsGenerator(elem, animations) &#123;\n\n  return spawn(function*() &#123;\n    let ret = null;\n    try &#123;\n      for(let anim of animations) &#123;\n        ret = yield anim(elem);\n      &#125;\n    &#125; catch(e) &#123;\n      /* 忽略错误，继续执行 */\n    &#125;\n    return ret;\n  &#125;);\n\n&#125;\n</code></pre>\n<p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在<code>spawn</code>函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，<strong>上面代码的<code>spawn</code>函数就是自动执行器，它返回一个 Promise 对象，而且必须保证<code>yield</code>语句后面的表达式，必须返回一个 Promise。</strong></p>\n<p>最后是 async 函数的写法。</p>\n<pre><code class=\"javascript\">async function chainAnimationsAsync(elem, animations) &#123;\n  let ret = null;\n  try &#123;\n    for(let anim of animations) &#123;\n      ret = await anim(elem);\n    &#125;\n  &#125; catch(e) &#123;\n    /* 忽略错误，继续执行 */\n  &#125;\n  return ret;\n&#125;\n</code></pre>\n<p>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。<strong>如果使用 Generator 写法，自动执行器需要用户自己提供。</strong></p>\n<hr>\n<h4 id=\"6-实例：按顺序完成异步操作\"><a href=\"#6-实例：按顺序完成异步操作\" class=\"headerlink\" title=\"6. 实例：按顺序完成异步操作\"></a>6. 实例：按顺序完成异步操作</h4><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p>\n<p>Promise 的写法如下。</p>\n<pre><code class=\"javascript\">function logInOrder(urls) &#123;\n  // 远程读取所有URL\n  const textPromises = urls.map(url =&gt; &#123;\n    return fetch(url).then(response =&gt; response.text());\n  &#125;);\n\n  // 按次序输出\n  textPromises.reduce((chain, textPromise) =&gt; &#123;\n    return chain.then(() =&gt; textPromise)\n      .then(text =&gt; console.log(text));\n  &#125;, Promise.resolve());\n&#125;\n</code></pre>\n<p>上面代码使用<code>fetch</code>方法，同时远程读取一组 URL。每个<code>fetch</code>操作都返回一个 Promise 对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个 Promise 对象，然后使用<code>then</code>，将所有 Promise 对象连起来，因此就可以依次输出结果。</p>\n<p>这种写法不太直观，可读性比较差。下面是 async 函数实现。</p>\n<pre><code class=\"javascript\">async function logInOrder(urls) &#123;\n  for (const url of urls) &#123;\n    const response = await fetch(url);\n    console.log(await response.text());\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p>\n<pre><code class=\"javascript\">async function logInOrder(urls) &#123;\n  // 并发读取远程URL\n  const textPromises = urls.map(async url =&gt; &#123;\n    const response = await fetch(url);\n    return response.text();\n  &#125;);\n\n  // 按次序输出\n  for (const textPromise of textPromises) &#123;\n    console.log(await textPromise);\n  &#125;\n&#125;\n</code></pre>\n<p><strong>上面代码中，虽然<code>map</code>方法的参数是<code>async</code>函数，但它是并发执行的，因为只有<code>async</code>函数内部是继发执行，外部不受影响。后面的<code>for..of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。</strong></p>\n<hr>\n<h4 id=\"7-顶层-await\"><a href=\"#7-顶层-await\" class=\"headerlink\" title=\"7. 顶层 await\"></a>7. 顶层 await</h4><p>根据语法规格，<code>await</code>命令只能出现在 async 函数内部，否则都会报错。</p>\n<pre><code class=\"javascript\">// 报错\nconst data = await fetch(&#39;https://api.example.com&#39;);\n</code></pre>\n<p>上面代码中，<code>await</code>命令独立使用，没有放在 async 函数里面，就会报错。</p>\n<p>目前，有一个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtdG9wLWxldmVsLWF3YWl0\">语法提案</span>，允许在模块的顶层独立使用<code>await</code>命令，使得上面那行代码不会报错了。这个提案的目的，是借用<code>await</code>解决模块异步加载的问题。</p>\n<pre><code class=\"javascript\">// awaiting.js\nlet output;\nasync function main() &#123;\n  const dynamic = await import(someMission);\n  const data = await fetch(url);\n  output = someProcess(dynamic.default, data);\n&#125;\nmain();\nexport &#123; output &#125;;\n</code></pre>\n<p>上面代码中，模块<code>awaiting.js</code>的输出值<code>output</code>，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量<code>output</code>才会有值，否则就返回<code>undefined</code>。</p>\n<p>上面的代码也可以写成立即执行函数的形式。</p>\n<pre><code class=\"javascript\">// awaiting.js\nlet output;\n(async function main() &#123;\n  const dynamic = await import(someMission);\n  const data = await fetch(url);\n  output = someProcess(dynamic.default, data);\n&#125;)();\nexport &#123; output &#125;;\n</code></pre>\n<p>下面是加载这个模块的写法。</p>\n<pre><code class=\"javascript\">// usage.js\nimport &#123; output &#125; from &quot;./awaiting.js&quot;;\n\nfunction outputPlusValue(value) &#123; return output + value &#125;\n\nconsole.log(outputPlusValue(100));\nsetTimeout(() =&gt; console.log(outputPlusValue(100)), 1000);\n</code></pre>\n<p>上面代码中，<code>outputPlusValue()</code>的执行结果，完全取决于执行的时间。如果<code>awaiting.js</code>里面的异步操作没执行完，加载进来的<code>output</code>的值就是<code>undefined</code>。</p>\n<p>目前的解决方法，就是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束。</p>\n<pre><code class=\"javascript\">// awaiting.js\nlet output;\nexport default (async function main() &#123;\n  const dynamic = await import(someMission);\n  const data = await fetch(url);\n  output = someProcess(dynamic.default, data);\n&#125;)();\nexport &#123; output &#125;;\n</code></pre>\n<p>上面代码中，<code>awaiting.js</code>除了输出<code>output</code>，还默认输出一个 Promise 对象（async 函数立即执行后，返回一个 Promise 对象），从这个对象判断异步操作是否结束。</p>\n<p>下面是加载这个模块的新的写法。</p>\n<pre><code class=\"javascript\">// usage.js\nimport promise, &#123; output &#125; from &quot;./awaiting.js&quot;;\n\nfunction outputPlusValue(value) &#123; return output + value &#125;\n\npromise.then(() =&gt; &#123;\n  console.log(outputPlusValue(100));\n  setTimeout(() =&gt; console.log(outputPlusValue(100)), 1000);\n&#125;);\n</code></pre>\n<p>上面代码中，将<code>awaiting.js</code>对象的输出，放在<code>promise.then()</code>里面，这样就能保证异步操作完成以后，才去读取<code>output</code>。</p>\n<p>这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的<code>usage.js</code>又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载。</p>\n<p>顶层的<code>await</code>命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。</p>\n<pre><code class=\"javascript\">// awaiting.js\nconst dynamic = import(someMission);\nconst data = fetch(url);\nexport const output = someProcess((await dynamic).default, await data);\n</code></pre>\n<p>上面代码中，两个异步操作在输出的时候，都加上了<code>await</code>命令。只有等到异步操作完成，这个模块才会输出值。</p>\n<p>加载这个模块的写法如下。</p>\n<pre><code class=\"javascript\">// usage.js\nimport &#123; output &#125; from &quot;./awaiting.js&quot;;\nfunction outputPlusValue(value) &#123; return output + value &#125;\n\nconsole.log(outputPlusValue(100));\nsetTimeout(() =&gt; console.log(outputPlusValue(100)), 1000);\n</code></pre>\n<p>上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。</p>\n<p>这时，模块的加载会等待依赖模块（上例是<code>awaiting.js</code>）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的<code>output</code>，不会因为加载时机的不同，而得到不一样的值。</p>\n<p><strong>注意，顶层<code>await</code>只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的<code>require()</code>是同步加载，如果有顶层<code>await</code>，就没法处理加载了。</strong></p>\n<p>下面是顶层<code>await</code>的一些使用场景。</p>\n<pre><code class=\"javascript\">// import() 方法加载\nconst strings = await import(`/i18n/$&#123;navigator.language&#125;`);\n\n// 数据库操作\nconst connection = await dbConnector();\n\n// 依赖回滚\nlet jQuery;\ntry &#123;\n  jQuery = await import(&#39;https://cdn-a.com/jQuery&#39;);\n&#125; catch &#123;\n  jQuery = await import(&#39;https://cdn-b.com/jQuery&#39;);\n&#125;\n</code></pre>\n<p>注意，如果加载多个包含顶层<code>await</code>命令的模块，加载命令是同步执行的。</p>\n<pre><code class=\"javascript\">// x.js\nconsole.log(&quot;X1&quot;);\nawait new Promise(r =&gt; setTimeout(r, 1000));\nconsole.log(&quot;X2&quot;);\n\n// y.js\nconsole.log(&quot;Y&quot;);\n\n// z.js\nimport &quot;./x.js&quot;;\nimport &quot;./y.js&quot;;\nconsole.log(&quot;Z&quot;);\n</code></pre>\n<p>上面代码有三个模块，最后的<code>z.js</code>加载<code>x.js</code>和<code>y.js</code>，打印结果是<code>X1</code>、<code>Y</code>、<code>X2</code>、<code>Z</code>。这说明，<code>z.js</code>并没有等待<code>x.js</code>加载完成，再去加载<code>y.js</code>。</p>\n<p><strong>顶层的<code>await</code>命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。</strong></p>\n<h3 id=\"21、-Class-的基本语法\"><a href=\"#21、-Class-的基本语法\" class=\"headerlink\" title=\"21、 Class 的基本语法\"></a>21、 Class 的基本语法</h3><hr>\n<h4 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h4><p><strong>类的由来</strong></p>\n<p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>\n<pre><code class=\"javascript\">function Point(x, y) &#123;\n  this.x = x;\n  this.y = y;\n&#125;\n\nPoint.prototype.toString = function () &#123;\n  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;\n&#125;;\n\nvar p = new Point(1, 2);\n</code></pre>\n<p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p>\n<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</p>\n<p>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p>\n<pre><code class=\"javascript\">class Point &#123;\n  constructor(x, y) &#123;\n    this.x = x;\n    this.y = y;\n  &#125;\n\n  toString() &#123;\n    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;\n  &#125;\n&#125;\n</code></pre>\n<p><strong>上面代码定义了一个“类”，可以看到里面有一个<code>constructor()</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。这种新的 Class 写法，本质上与本章开头的 ES5 的构造函数<code>Point</code>是一致的。</strong></p>\n<p><code>Point</code>类除了构造方法，还定义了一个<code>toString()</code>方法。注意，<strong>定义<code>toString()</code>方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。</strong></p>\n<p>ES6 的类，完全可以看作构造函数的另一种写法。</p>\n<pre><code class=\"javascript\">class Point &#123;\n  // ...\n&#125;\n\ntypeof Point // &quot;function&quot;\nPoint === Point.prototype.constructor // true\n</code></pre>\n<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>\n<p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。</p>\n<pre><code class=\"javascript\">class Bar &#123;\n  doStuff() &#123;\n    console.log(&#39;stuff&#39;);\n  &#125;\n&#125;\n\nconst b = new Bar();\nb.doStuff() // &quot;stuff&quot;\n</code></pre>\n<p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p>\n<pre><code class=\"javascript\">class Point &#123;\n  constructor() &#123;\n    // ...\n  &#125;\n\n  toString() &#123;\n    // ...\n  &#125;\n\n  toValue() &#123;\n    // ...\n  &#125;\n&#125;\n\n// 等同于\n\nPoint.prototype = &#123;\n  constructor() &#123;&#125;,\n  toString() &#123;&#125;,\n  toValue() &#123;&#125;,\n&#125;;\n</code></pre>\n<p>上面代码中，<code>constructor()</code>、<code>toString()</code>、<code>toValue()</code>这三个方法，其实都是定义在<code>Point.prototype</code>上面。</p>\n<p><strong>因此，在类的实例上面调用方法，其实就是调用原型上的方法。</strong></p>\n<pre><code class=\"javascript\">class B &#123;&#125;\nconst b = new B();\n\nb.constructor === B.prototype.constructor // true\n</code></pre>\n<p>上面代码中，<code>b</code>是<code>B</code>类的实例，它的<code>constructor()</code>方法就是<code>B</code>类原型的<code>constructor()</code>方法。</p>\n<p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign()</code>方法可以很方便地一次向类添加多个方法。</p>\n<pre><code class=\"javascript\">class Point &#123;\n  constructor()&#123;\n    // ...\n  &#125;\n&#125;\n\nObject.assign(Point.prototype, &#123;\n  toString()&#123;&#125;,\n  toValue()&#123;&#125;\n&#125;);\n</code></pre>\n<p><code>prototype</code>对象的<code>constructor()</code>属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</p>\n<pre><code class=\"javascript\">Point.prototype.constructor === Point // true\n</code></pre>\n<p><strong>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</strong></p>\n<pre><code class=\"javascript\">class Point &#123;\n  constructor(x, y) &#123;\n    // ...\n  &#125;\n\n  toString() &#123;\n    // ...\n  &#125;\n&#125;\n\nObject.keys(Point.prototype)\n// []\nObject.getOwnPropertyNames(Point.prototype)\n// [&quot;constructor&quot;,&quot;toString&quot;]\n</code></pre>\n<p>上面代码中，<code>toString()</code>方法是<code>Point</code>类内部定义的方法，<strong>它是不可枚举的。这一点与 ES5 的行为不一致。</strong></p>\n<pre><code class=\"javascript\">var Point = function (x, y) &#123;\n  // ...\n&#125;;\n\nPoint.prototype.toString = function () &#123;\n  // ...\n&#125;;\n\nObject.keys(Point.prototype)\n// [&quot;toString&quot;]\nObject.getOwnPropertyNames(Point.prototype)\n// [&quot;constructor&quot;,&quot;toString&quot;]\n</code></pre>\n<p>上面代码采用 ES5 的写法，<code>toString()</code>方法就是可枚举的。</p>\n<hr>\n<p><strong>constructor 方法</strong></p>\n<p><strong><code>constructor()</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的<code>constructor()</code>方法会被默认添加。</strong></p>\n<pre><code class=\"javascript\">class Point &#123;\n&#125;\n\n// 等同于\nclass Point &#123;\n  constructor() &#123;&#125;\n&#125;\n</code></pre>\n<p>上面代码中，定义了一个空的类<code>Point</code>，JavaScript 引擎会自动为它添加一个空的<code>constructor()</code>方法。</p>\n<p><code>constructor()</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</p>\n<pre><code class=\"javascript\">class Foo &#123;\n  constructor() &#123;\n    return Object.create(null);\n  &#125;\n&#125;\n\nnew Foo() instanceof Foo\n// false\n</code></pre>\n<p>上面代码中，<code>constructor()</code>函数返回一个全新的对象，结果导致实例对象不是<code>Foo</code>类的实例。</p>\n<p><strong>类必须使用<code>new</code>调用</strong>，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p>\n<pre><code class=\"javascript\">class Foo &#123;\n  constructor() &#123;\n    return Object.create(null);\n  &#125;\n&#125;\n\nFoo()\n// TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;\n</code></pre>\n<hr>\n<p><strong>类的实例</strong></p>\n<p>生成类的实例的写法，与 ES5 完全一样，也是使用<code>new</code>命令。前面说过，<strong>如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</strong></p>\n<pre><code class=\"javascript\">class Point &#123;\n  // ...\n&#125;\n\n// 报错\nvar point = Point(2, 3);\n\n// 正确\nvar point = new Point(2, 3);\n</code></pre>\n<p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p>\n<pre><code class=\"javascript\">//定义类\nclass Point &#123;\n\n  constructor(x, y) &#123;\n    this.x = x;\n    this.y = y;\n  &#125;\n\n  toString() &#123;\n    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;\n  &#125;\n\n&#125;\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty(&#39;x&#39;) // true\npoint.hasOwnProperty(&#39;y&#39;) // true\npoint.hasOwnProperty(&#39;toString&#39;) // false\npoint.__proto__.hasOwnProperty(&#39;toString&#39;) // true\n</code></pre>\n<p>上面代码中，**<code>x</code>和<code>y</code>都是实例对象<code>point</code>自身的属性（因为定义在<code>this</code>对象上），所以<code>hasOwnProperty()</code>方法返回<code>true</code>，而<code>toString()</code>是原型对象的属性（因为定义在<code>Point</code>类上），所以<code>hasOwnProperty()</code>方法返回<code>false</code>。这些**都与 ES5 的行为保持一致。</p>\n<p>与 ES5 一样，类的所有实例共享一个原型对象。</p>\n<pre><code class=\"javascript\">var p1 = new Point(2,3);\nvar p2 = new Point(3,2);\n\np1.__proto__ === p2.__proto__\n//true\n</code></pre>\n<p>上面代码中，<code>p1</code>和<code>p2</code>都是<code>Point</code>的实例，它们的原型都是<code>Point.prototype</code>，所以<code>__proto__</code>属性是相等的。</p>\n<p>这也意味着，可以通过实例的<code>__proto__</code>属性为“类”添加方法。</p>\n<blockquote>\n<p><code>__proto__</code> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，<strong>但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 <code>Object.getPrototypeOf</code> 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</strong></p>\n</blockquote>\n<pre><code class=\"javascript\">var p1 = new Point(2,3);\nvar p2 = new Point(3,2);\n\np1.__proto__.printName = function () &#123; return &#39;Oops&#39; &#125;;\n\np1.printName() // &quot;Oops&quot;\np2.printName() // &quot;Oops&quot;\n\nvar p3 = new Point(4,2);\np3.printName() // &quot;Oops&quot;\n</code></pre>\n<p>上面代码在<code>p1</code>的原型上添加了一个<code>printName()</code>方法，由于<code>p1</code>的原型就是<code>p2</code>的原型，因此<code>p2</code>也可以调用这个方法。而且，此后新建的实例<code>p3</code>也可以调用这个方法。这意味着，使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p>\n<hr>\n<p><strong>取值函数（getter）和存值函数（setter）</strong></p>\n<p>与 ES5 一样，<strong>在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</strong></p>\n<pre><code class=\"javascript\">class MyClass &#123;\n  constructor() &#123;\n    // ...\n  &#125;\n  get prop() &#123;\n    return &#39;getter&#39;;\n  &#125;\n  set prop(value) &#123;\n    console.log(&#39;setter: &#39;+value);\n  &#125;\n&#125;\n\nlet inst = new MyClass();\n\ninst.prop = 123;\n// setter: 123\n\ninst.prop\n// &#39;getter&#39;\n</code></pre>\n<p>上面代码中，<code>prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>\n<p><strong>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</strong></p>\n<pre><code class=\"javascript\">class CustomHTMLElement &#123;\n  constructor(element) &#123;\n    this.element = element;\n  &#125;\n\n  get html() &#123;\n    return this.element.innerHTML;\n  &#125;\n\n  set html(value) &#123;\n    this.element.innerHTML = value;\n  &#125;\n&#125;\n\nvar descriptor = Object.getOwnPropertyDescriptor(\n  CustomHTMLElement.prototype, &quot;html&quot;\n);\n\n&quot;get&quot; in descriptor  // true\n&quot;set&quot; in descriptor  // true\n</code></pre>\n<p>上面代码中，存值函数和取值函数是定义在<code>html</code>属性的描述对象上面，这与 ES5 完全一致。</p>\n<hr>\n<p><strong>属性表达式</strong></p>\n<p><strong>类的属性名，可以采用表达式。</strong></p>\n<pre><code class=\"javascript\">let methodName = &#39;getArea&#39;;\n\nclass Square &#123;\n  constructor(length) &#123;\n    // ...\n  &#125;\n\n  [methodName]() &#123;\n    // ...\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，<code>Square</code>类的方法名<code>getArea</code>，是从表达式得到的。</p>\n<hr>\n<p><strong>Class 表达式</strong></p>\n<p>与函数一样，类也可以使用表达式的形式定义。</p>\n<pre><code class=\"javascript\">const MyClass = class Me &#123;\n  getClassName() &#123;\n    return Me.name;\n  &#125;\n&#125;;\n</code></pre>\n<p>上面代码使用表达式定义了一个类。需要注意的是，<strong>这个类的名字是<code>Me</code>，但是<code>Me</code>只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用<code>MyClass</code>引用。</strong></p>\n<pre><code class=\"javascript\">let inst = new MyClass();\ninst.getClassName() // Me\nMe.name // ReferenceError: Me is not defined\n</code></pre>\n<p>上面代码表示，<code>Me</code>只在 Class 内部有定义。</p>\n<p><strong>如果类的内部没用到的话，可以省略<code>Me</code>，</strong>也就是可以写成下面的形式。</p>\n<pre><code class=\"javascript\">const MyClass = class &#123; /* ... */ &#125;;\n</code></pre>\n<p><strong>采用 Class 表达式，可以写出立即执行的 Class。</strong></p>\n<pre><code class=\"javascript\">let person = new class &#123;\n  constructor(name) &#123;\n    this.name = name;\n  &#125;\n\n  sayName() &#123;\n    console.log(this.name);\n  &#125;\n&#125;(&#39;张三&#39;);\n\nperson.sayName(); // &quot;张三&quot;\n</code></pre>\n<p>上面代码中，<code>person</code>是一个立即执行的类的实例。</p>\n<hr>\n<p><strong>注意点</strong></p>\n<p><strong>（1）严格模式</strong></p>\n<p><strong>类和模块的内部，默认就是严格模式</strong>，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p>\n<p><strong>（2）不存在提升</strong></p>\n<p><strong>类不存在变量提升（hoist</strong>），这一点与 ES5 完全不同。</p>\n<pre><code class=\"javascript\">new Foo(); // ReferenceError\nclass Foo &#123;&#125;\n</code></pre>\n<p>上面代码中，<code>Foo</code>类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。<strong>这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</strong></p>\n<pre><code class=\"javascript\">&#123;\n  let Foo = class &#123;&#125;;\n  class Bar extends Foo &#123;\n  &#125;\n&#125;\n</code></pre>\n<p>上面的代码不会报错，因为<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>已经有定义了。但是，<strong>如果存在<code>class</code>的提升，上面代码就会报错，因为<code>class</code>会被提升到代码头部，而<code>let</code>命令是不提升的，所以导致<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>还没有定义。</strong></p>\n<p><strong>（3）name 属性</strong></p>\n<p>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被<code>Class</code>继承，包括<code>name</code>属性。</p>\n<pre><code class=\"javascript\">class Point &#123;&#125;\nPoint.name // &quot;Point&quot;\n</code></pre>\n<p><strong><code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</strong></p>\n<p><strong>（4）Generator 方法</strong></p>\n<p><strong>如果某个方法之前加上星号（<code>*</code>），就表示该方法是一个 Generator 函数。</strong></p>\n<pre><code class=\"javascript\">class Foo &#123;\n  constructor(...args) &#123;\n    this.args = args;\n  &#125;\n  * [Symbol.iterator]() &#123;\n    for (let arg of this.args) &#123;\n      yield arg;\n    &#125;\n  &#125;\n&#125;\n\nfor (let x of new Foo(&#39;hello&#39;, &#39;world&#39;)) &#123;\n  console.log(x);\n&#125;\n// hello\n// world\n</code></pre>\n<p>上面代码中，<code>Foo</code>类的<code>Symbol.iterator</code>方法前有一个星号，表示该方法是一个 Generator 函数。<code>Symbol.iterator</code>方法返回一个<code>Foo</code>类的默认遍历器，<code>for...of</code>循环会自动调用这个遍历器。</p>\n<p><strong>（5）this 的指向</strong></p>\n<p><strong>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</strong></p>\n<pre><code class=\"javascript\">class Logger &#123;\n  printName(name = &#39;there&#39;) &#123;\n    this.print(`Hello $&#123;name&#125;`);\n  &#125;\n\n  print(text) &#123;\n    console.log(text);\n  &#125;\n&#125;\n\nconst logger = new Logger();\nconst &#123; printName &#125; = logger;\nprintName(); // TypeError: Cannot read property &#39;print&#39; of undefined\n</code></pre>\n<p>上面代码中，<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，<strong>如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到<code>print</code>方法而报错。</strong></p>\n<p><strong>一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</strong></p>\n<pre><code class=\"javascript\">class Logger &#123;\n  constructor() &#123;\n    this.printName = this.printName.bind(this);\n  &#125;\n\n  // ...\n&#125;\n</code></pre>\n<p><strong>另一种解决方法是使用箭头函数。</strong></p>\n<pre><code class=\"javascript\">class Obj &#123;\n  constructor() &#123;\n    this.getThis = () =&gt; this;\n  &#125;\n&#125;\n\nconst myObj = new Obj();\nmyObj.getThis() === myObj // true\n</code></pre>\n<p>箭头函数内部的<code>this</code>总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以<code>this</code>会总是指向实例对象。</p>\n<p><strong>还有一种解决方法是使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code>。</strong></p>\n<pre><code class=\"javascript\">function selfish (target) &#123;\n  const cache = new WeakMap();\n  const handler = &#123;\n    get (target, key) &#123;\n      const value = Reflect.get(target, key);\n      if (typeof value !== &#39;function&#39;) &#123;\n        return value;\n      &#125;\n      if (!cache.has(value)) &#123;\n        cache.set(value, value.bind(target));\n      &#125;\n      return cache.get(value);\n    &#125;\n  &#125;;\n  const proxy = new Proxy(target, handler);\n  return proxy;\n&#125;\n\nconst logger = selfish(new Logger());\n</code></pre>\n<hr>\n<h4 id=\"2-静态方法-1\"><a href=\"#2-静态方法-1\" class=\"headerlink\" title=\"2. 静态方法\"></a>2. 静态方法</h4><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。<strong>如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</strong></p>\n<pre><code class=\"javascript\">class Foo &#123;\n  static classMethod() &#123;\n    return &#39;hello&#39;;\n  &#125;\n&#125;\n\nFoo.classMethod() // &#39;hello&#39;\n\nvar foo = new Foo();\nfoo.classMethod()\n// TypeError: foo.classMethod is not a function\n</code></pre>\n<p>上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用（<code>Foo.classMethod()</code>），而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>\n<p>注意，如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</p>\n<pre><code class=\"javascript\">class Foo &#123;\n  static bar() &#123;\n    this.baz();\n  &#125;\n  static baz() &#123;\n    console.log(&#39;hello&#39;);\n  &#125;\n  baz() &#123;\n    console.log(&#39;world&#39;);\n  &#125;\n&#125;\n\nFoo.bar() // hello\n</code></pre>\n<p>上面代码中，静态方法<code>bar</code>调用了<code>this.baz</code>，这里的<code>this</code>指的是<code>Foo</code>类，而不是<code>Foo</code>的实例，等同于调用<code>Foo.baz</code>。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p>\n<p><strong>父类的静态方法，可以被子类继承。</strong></p>\n<pre><code class=\"javascript\">class Foo &#123;\n  static classMethod() &#123;\n    return &#39;hello&#39;;\n  &#125;\n&#125;\n\nclass Bar extends Foo &#123;\n&#125;\n\nBar.classMethod() // &#39;hello&#39;\n</code></pre>\n<p>上面代码中，父类<code>Foo</code>有一个静态方法，子类<code>Bar</code>可以调用这个方法。</p>\n<p>静态方法也是可以从<code>super</code>对象上调用的。</p>\n<pre><code class=\"javascript\">class Foo &#123;\n  static classMethod() &#123;\n    return &#39;hello&#39;;\n  &#125;\n&#125;\n\nclass Bar extends Foo &#123;\n  static classMethod() &#123;\n    return super.classMethod() + &#39;, too&#39;;\n  &#125;\n&#125;\n\nBar.classMethod() // &quot;hello, too&quot;\n</code></pre>\n<hr>\n<h4 id=\"3-实例属性的新写法\"><a href=\"#3-实例属性的新写法\" class=\"headerlink\" title=\"3. 实例属性的新写法\"></a>3. 实例属性的新写法</h4><p><strong>实例属性除了定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类的最顶层。</strong></p>\n<pre><code class=\"javascript\">class IncreasingCounter &#123;\n  constructor() &#123;\n    this._count = 0;\n  &#125;\n  get value() &#123;\n    console.log(&#39;Getting the current value!&#39;);\n    return this._count;\n  &#125;\n  increment() &#123;\n    this._count++;\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，<strong>实例属性<code>this._count</code>定义在<code>constructor()</code>方法里面。另一种写法是，这个属性也可以定义在类的最顶层，其他都不变。</strong></p>\n<pre><code class=\"javascript\">class IncreasingCounter &#123;\n  _count = 0;\n  get value() &#123;\n    console.log(&#39;Getting the current value!&#39;);\n    return this._count;\n  &#125;\n  increment() &#123;\n    this._count++;\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，实例属性<code>_count</code>与取值函数<code>value()</code>和<code>increment()</code>方法，处于同一个层级。这时，<strong>不需要在实例属性前面加上<code>this</code>。</strong></p>\n<p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p>\n<pre><code class=\"javascript\">class foo &#123;\n  bar = &#39;hello&#39;;\n  baz = &#39;world&#39;;\n\n  constructor() &#123;\n    // ...\n  &#125;\n&#125;\n</code></pre>\n<p>上面的代码，一眼就能看出，<code>foo</code>类有两个实例属性，一目了然。另外，写起来也比较简洁。</p>\n<hr>\n<h4 id=\"4-静态属性\"><a href=\"#4-静态属性\" class=\"headerlink\" title=\"4. 静态属性\"></a>4. 静态属性</h4><p><strong>静态属性指的是 Class 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性。</strong></p>\n<pre><code class=\"javascript\">class Foo &#123;\n&#125;\n\nFoo.prop = 1;\nFoo.prop // 1\n</code></pre>\n<p>上面的写法为<code>Foo</code>类定义了一个静态属性<code>prop</code>。</p>\n<p><strong>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtY2xhc3MtZmllbGRz\">提案</span>提供了类的静态属性，写法是在实例属性的前面，加上<code>static</code>关键字。</strong></p>\n<pre><code class=\"javascript\">class MyClass &#123;\n  static myStaticProp = 42;\n\n  constructor() &#123;\n    console.log(MyClass.myStaticProp); // 42\n  &#125;\n&#125;\n</code></pre>\n<p>这个新写法大大方便了静态属性的表达。</p>\n<pre><code class=\"javascript\">// 老写法\nclass Foo &#123;\n  // ...\n&#125;\nFoo.prop = 1;\n\n// 新写法\nclass Foo &#123;\n  static prop = 1;\n&#125;\n</code></pre>\n<p>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p>\n<hr>\n<h4 id=\"5-私有方法和私有属性\"><a href=\"#5-私有方法和私有属性\" class=\"headerlink\" title=\"5. 私有方法和私有属性\"></a>5. 私有方法和私有属性</h4><p><strong>现有的解决方案</strong></p>\n<p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。</p>\n<p>一种做法是在命名上加以区别。</p>\n<pre><code class=\"javascript\">class Widget &#123;\n\n  // 公有方法\n  foo (baz) &#123;\n    this._bar(baz);\n  &#125;\n\n  // 私有方法\n  _bar(baz) &#123;\n    return this.snaf = baz;\n  &#125;\n\n  // ...\n&#125;\n</code></pre>\n<p>上面代码中，<code>_bar()</code>方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p>\n<p><strong>另一种方法就是索性将私有方法移出类，因为类内部的所有方法都是对外可见的。</strong></p>\n<pre><code class=\"javascript\">class Widget &#123;\n  foo (baz) &#123;\n    bar.call(this, baz);\n  &#125;\n\n  // ...\n&#125;\n\nfunction bar(baz) &#123;\n  return this.snaf = baz;\n&#125;\n</code></pre>\n<p>上面代码中，**<code>foo</code>是公开方法，内部调用了<code>bar.call(this, baz)</code>。这使得<code>bar()</code>实际上成为了当前类的私有方法。**</p>\n<p><strong>还有一种方法是利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值。</strong></p>\n<pre><code class=\"javascript\">const bar = Symbol(&#39;bar&#39;);\nconst snaf = Symbol(&#39;snaf&#39;);\n\nexport default class myClass&#123;\n\n  // 公有方法\n  foo(baz) &#123;\n    this[bar](baz);\n  &#125;\n\n  // 私有方法\n  [bar](baz) &#123;\n    return this[snaf] = baz;\n  &#125;\n\n  // ...\n&#125;;\n</code></pre>\n<p>上面代码中，<code>bar</code>和<code>snaf</code>都是<code>Symbol</code>值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，<code>Reflect.ownKeys()</code>依然可以拿到它们。</p>\n<pre><code class=\"javascript\">const inst = new myClass();\n\nReflect.ownKeys(myClass.prototype)\n// [ &#39;constructor&#39;, &#39;foo&#39;, Symbol(bar) ]\n</code></pre>\n<p>上面代码中，Symbol 值的属性名依然可以从类的外部拿到。</p>\n<hr>\n<p><strong>私有属性的提案</strong></p>\n<p><strong>目前，有一个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJpdmF0ZS1tZXRob2Rz\">提案</span>，为<code>class</code>加了私有属性。方法是在属性名之前，使用<code>#</code>表示。</strong></p>\n<pre><code class=\"javascript\">class IncreasingCounter &#123;\n  #count = 0;\n  get value() &#123;\n    console.log(&#39;Getting the current value!&#39;);\n    return this.#count;\n  &#125;\n  increment() &#123;\n    this.#count++;\n  &#125;\n&#125;\n</code></pre>\n<p><strong>上面代码中，<code>#count</code>就是私有属性，只能在类的内部使用（<code>this.#count</code>）。如果在类的外部使用，就会报错。</strong></p>\n<pre><code class=\"javascript\">const counter = new IncreasingCounter();\ncounter.#count // 报错\ncounter.#count = 42 // 报错\n</code></pre>\n<p>上面代码在类的外部，读取私有属性，就会报错。</p>\n<p>下面是另一个例子。</p>\n<pre><code class=\"javascript\">class Point &#123;\n  #x;\n\n  constructor(x = 0) &#123;\n    this.#x = +x;\n  &#125;\n\n  get x() &#123;\n    return this.#x;\n  &#125;\n\n  set x(value) &#123;\n    this.#x = +value;\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，<code>#x</code>就是私有属性，在<code>Point</code>类之外是读取不到这个属性的。由于井号<code>#</code>是属性名的一部分，使用时必须带有<code>#</code>一起使用，所以<code>#x</code>和<code>x</code>是两个不同的属性。</p>\n<p>之所以要引入一个新的前缀<code>#</code>表示私有属性，而没有采用<code>private</code>关键字，是因为 JavaScript 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用<code>@</code>表示私有属性，ES6 没有用这个符号而使用<code>#</code>，是因为<code>@</code>已经被留给了 Decorator。</p>\n<p>这种写法不仅可以写私有属性，还可以用来写私有方法。</p>\n<pre><code class=\"javascript\">class Foo &#123;\n  #a;\n  #b;\n  constructor(a, b) &#123;\n    this.#a = a;\n    this.#b = b;\n  &#125;\n  #sum() &#123;\n    return this.#a + this.#b;\n  &#125;\n  printSum() &#123;\n    console.log(this.#sum());\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，<code>#sum()</code>就是一个私有方法。</p>\n<p>另外，私有属性也可以设置 getter 和 setter 方法。</p>\n<pre><code class=\"javascript\">class Counter &#123;\n  #xValue = 0;\n\n  constructor() &#123;\n    super();\n    // ...\n  &#125;\n\n  get #x() &#123; return #xValue; &#125;\n  set #x(value) &#123;\n    this.#xValue = value;\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，<code>#x</code>是一个私有属性，它的读写都通过<code>get #x()</code>和<code>set #x()</code>来完成。</p>\n<p><strong>私有属性不限于从<code>this</code>引用，只要是在类的内部，实例也可以引用私有属性。</strong></p>\n<pre><code class=\"javascript\">class Foo &#123;\n  #privateValue = 42;\n  static getPrivateValue(foo) &#123;\n    return foo.#privateValue;\n  &#125;\n&#125;\n\nFoo.getPrivateValue(new Foo()); // 42\n</code></pre>\n<p>上面代码允许从实例<code>foo</code>上面引用私有属性。</p>\n<p>私有属性和私有方法前面，也可以加上<code>static</code>关键字，表示这是一个静态的私有属性或私有方法。</p>\n<pre><code class=\"javascript\">class FakeMath &#123;\n  static PI = 22 / 7;\n  static #totallyRandomNumber = 4;\n\n  static #computeRandomNumber() &#123;\n    return FakeMath.#totallyRandomNumber;\n  &#125;\n\n  static random() &#123;\n    console.log(&#39;I heard you like random numbers…&#39;)\n    return FakeMath.#computeRandomNumber();\n  &#125;\n&#125;\n\nFakeMath.PI // 3.142857142857143\nFakeMath.random()\n// I heard you like random numbers…\n// 4\nFakeMath.#totallyRandomNumber // 报错\nFakeMath.#computeRandomNumber() // 报错\n</code></pre>\n<p>上面代码中，<code>#totallyRandomNumber</code>是私有属性，<code>#computeRandomNumber()</code>是私有方法，只能在<code>FakeMath</code>这个类的内部调用，外部调用就会报错。</p>\n<hr>\n<p><strong>in 运算符</strong></p>\n<p><code>try...catch</code>结构可以用来判断是否存在某个私有属性。</p>\n<pre><code class=\"javascript\">class A &#123;\n  use(obj) &#123;\n    try &#123;\n      obj.#foo;\n    &#125; catch &#123;\n      // 私有属性 #foo 不存在\n    &#125;\n  &#125;\n&#125;\n\nconst a = new A();\na.use(a); // 报错\n</code></pre>\n<p>上面示例中，类<code>A</code>并不存在私有属性<code>#foo</code>，所以<code>try...catch</code>报错了。</p>\n<p>这样的写法很麻烦，可读性很差，V8 引擎改进了<code>in</code>运算符，使它也可以用来判断私有属性。</p>\n<pre><code class=\"javascript\">class A &#123;\n  use(obj) &#123;\n    if (#foo in obj) &#123;\n      // 私有属性 #foo 存在\n    &#125; else &#123;\n      // 私有属性 #foo 不存在\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p>上面示例中，<code>in</code>运算符判断当前类<code>A</code>的实例，是否有私有属性<code>#foo</code>，如果有返回<code>true</code>，否则返回<code>false</code>。</p>\n<p><strong><code>in</code>也可以跟<code>this</code>一起配合使用。</strong></p>\n<pre><code class=\"javascript\">class A &#123;\n  #foo = 0;\n  m() &#123;\n    console.log(#foo in this); // true\n    console.log(#bar in this); // false\n  &#125;\n&#125;\n</code></pre>\n<p><strong>注意，判断私有属性时，<code>in</code>只能用在定义该私有属性的类的内部。</strong></p>\n<pre><code class=\"javascript\">class A &#123;\n  #foo = 0;\n  static test(obj) &#123;\n    console.log(#foo in obj);\n  &#125;\n&#125;\n\nA.test(new A()) // true\nA.test(&#123;&#125;) // false\n\nclass B &#123;\n  #foo = 0;\n&#125;\n\nA.test(new B()) // false\n</code></pre>\n<p>上面示例中，类<code>A</code>的私有属性<code>#foo</code>，只能在类<code>A</code>内部使用<code>in</code>运算符判断，而且只对<code>A</code>的实例返回<code>true</code>，对于其他对象都返回<code>false</code>。</p>\n<p>子类从父类继承的私有属性，也可以使用<code>in</code>运算符来判断。</p>\n<pre><code class=\"javascript\">class A &#123;\n  #foo = 0;\n  static test(obj) &#123;\n    console.log(#foo in obj);\n  &#125;\n&#125;\n\nclass SubA extends A &#123;&#125;;\n\nA.test(new SubA()) // true\n</code></pre>\n<p>上面示例中，<code>SubA</code>从父类继承了私有属性<code>#foo</code>，<code>in</code>运算符也有效。</p>\n<p>注意，<code>in</code>运算符对于<code>Object.create()</code>、<code>Object.setPrototypeOf</code>形成的继承，是无效的，因为这种继承不会传递私有属性。</p>\n<pre><code class=\"javascript\">class A &#123;\n  #foo = 0;\n  static test(obj) &#123;\n    console.log(#foo in obj);\n  &#125;\n&#125;\nconst a = new A();\n\nconst o1 = Object.create(a);\nA.test(o1) // false\nA.test(o1.__proto__) // true\n\nconst o2 = &#123;&#125;;\nObject.setPrototypeOf(o2, A);\nA.test(o2) // false\nA.test(o2.__proto__) // true\n</code></pre>\n<p>上面示例中，对于修改原型链形成的继承，子类都取不到父类的私有属性，所以<code>in</code>运算符无效。</p>\n<hr>\n<h4 id=\"6-静态块\"><a href=\"#6-静态块\" class=\"headerlink\" title=\"6. 静态块\"></a>6. 静态块</h4><p><strong>静态属性的一个问题是，它的初始化要么写在类的外部，要么写在<code>constructor()</code>方法里面。</strong></p>\n<pre><code class=\"javascript\">class C &#123;\n  static x = 234;\n  static y;\n  static z;\n&#125;\n\ntry &#123;\n  const obj = doSomethingWith(C.x);\n  C.y = obj.y\n  C.z = obj.z;\n&#125; catch &#123;\n  C.y = ...;\n  C.z = ...;\n&#125;\n</code></pre>\n<p>上面示例中，静态属性<code>y</code>和<code>z</code>的值依赖静态属性<code>x</code>，它们的初始化写在类的外部（上例的<code>try...catch</code>代码块）。另一种方法是写到类的<code>constructor()</code>方法里面。这两种方法都不是很理想，前者是将类的内部逻辑写到了外部，后者则是每次新建实例都会运行一次。</p>\n<p><strong>为了解决这个问题，ES2022 引入了<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtY2xhc3Mtc3RhdGljLWJsb2Nr\">静态块</span>（static block），允许在类的内部设置一个代码块，在类生成时运行一次，主要作用是对静态属性进行初始化。</strong></p>\n<pre><code class=\"javascript\">class C &#123;\n  static x = ...;\n  static y;\n  static z;\n\n  static &#123;\n    try &#123;\n      const obj = doSomethingWith(this.x);\n      this.y = obj.y;\n      this.z = obj.z;\n    &#125;\n    catch &#123;\n      this.y = ...;\n      this.z = ...;\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p><strong>上面代码中，类的内部有一个 static 代码块，这就是静态块。它的好处是将静态属性<code>y</code>和<code>z</code>的初始化逻辑，写入了类的内部，而且只运行一次。</strong></p>\n<p><strong>每个类只能有一个静态块，在静态属性声明后运行。静态块的内部不能有<code>return</code>语句。</strong></p>\n<p><strong>静态块内部可以使用类名或<code>this</code>，指代当前类。</strong></p>\n<pre><code class=\"c\">class C &#123;\n  static x = 1;\n  static &#123;\n    this.x; // 1\n    // 或者\n    C.x; // 1\n  &#125;\n&#125;\n</code></pre>\n<p>上面示例中，<code>this.x</code>和<code>C.x</code>都能获取静态属性<code>x</code>。</p>\n<p><strong>除了静态属性的初始化，静态块还有一个作用，就是将私有属性与类的外部代码分享。</strong></p>\n<pre><code class=\"javascript\">let getX;\n\nexport class C &#123;\n  #x = 1;\n  static &#123;\n    getX = obj =&gt; obj.#x;\n  &#125;\n&#125;\n\nconsole.log(getX(new C())); // 1\n</code></pre>\n<p>上面示例中，<code>#x</code>是类的私有属性，<strong>如果类外部的<code>getX()</code>方法希望获取这个属性</strong>，以前是要写在类的<code>constructor()</code>方法里面，这样的话，每次新建实例都会定义一次<code>getX()</code>方法。<strong>现在可以写在静态块里面，这样的话，只在类生成时定义一次。</strong></p>\n<hr>\n<h4 id=\"7-new-target-属性\"><a href=\"#7-new-target-属性\" class=\"headerlink\" title=\"7. new.target 属性\"></a>7. new.target 属性</h4><p><strong><code>new</code>是从构造函数生成实例对象的命令。ES6 为<code>new</code>命令引入了一个<code>new.target</code>属性，该属性一般用在构造函数之中，返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令或<code>Reflect.construct()</code>调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</strong></p>\n<pre><code class=\"javascript\">function Person(name) &#123;\n  if (new.target !== undefined) &#123;\n    this.name = name;\n  &#125; else &#123;\n    throw new Error(&#39;必须使用 new 命令生成实例&#39;);\n  &#125;\n&#125;\n\n// 另一种写法\nfunction Person(name) &#123;\n  if (new.target === Person) &#123;\n    this.name = name;\n  &#125; else &#123;\n    throw new Error(&#39;必须使用 new 命令生成实例&#39;);\n  &#125;\n&#125;\n\nvar person = new Person(&#39;张三&#39;); // 正确\nvar notAPerson = Person.call(person, &#39;张三&#39;);  // 报错\n</code></pre>\n<p>上面代码确保构造函数只能通过<code>new</code>命令调用。</p>\n<p>Class 内部调用<code>new.target</code>，返回当前 Class。</p>\n<pre><code class=\"javascript\">class Rectangle &#123;\n  constructor(length, width) &#123;\n    console.log(new.target === Rectangle);\n    this.length = length;\n    this.width = width;\n  &#125;\n&#125;\n\nvar obj = new Rectangle(3, 4); // 输出 true\n</code></pre>\n<p><strong>需要注意的是，子类继承父类时，<code>new.target</code>会返回子类。</strong></p>\n<pre><code class=\"javascript\">class Rectangle &#123;\n  constructor(length, width) &#123;\n    console.log(new.target === Rectangle);\n    // ...\n  &#125;\n&#125;\n\nclass Square extends Rectangle &#123;\n  constructor(length, width) &#123;\n    super(length, width);\n  &#125;\n&#125;\n\nvar obj = new Square(3); // 输出 false\n</code></pre>\n<p>上面代码中，<code>new.target</code>会返回子类。</p>\n<p><strong>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</strong>new.target指向自己就是new 不是的话就可能是call或者extends</p>\n<pre><code class=\"javascript\">class Shape &#123;\n  constructor() &#123;\n    if (new.target === Shape) &#123;\n      throw new Error(&#39;本类不能实例化&#39;);\n    &#125;\n  &#125;\n&#125;\n\nclass Rectangle extends Shape &#123;\n  constructor(length, width) &#123;\n    super();\n    // ...\n  &#125;\n&#125;\n\nvar x = new Shape();  // 报错\nvar y = new Rectangle(3, 4);  // 正确\n</code></pre>\n<p>上面代码中，<code>Shape</code>类不能被实例化，只能用于继承。</p>\n<p>注意，在函数外部，使用<code>new.target</code>会报错。</p>\n<h3 id=\"22、-Class-的继承\"><a href=\"#22、-Class-的继承\" class=\"headerlink\" title=\"22、 Class 的继承\"></a>22、 Class 的继承</h3><hr>\n<h4 id=\"1-简介-1\"><a href=\"#1-简介-1\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h4><p><strong>Class 可以通过<code>extends</code>关键字实现继承，</strong>这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\n<pre><code class=\"javascript\">class Point &#123;\n&#125;\n\nclass ColorPoint extends Point &#123;\n&#125;\n</code></pre>\n<p>上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。下面，我们在<code>ColorPoint</code>内部加上代码。</p>\n<pre><code class=\"javascript\">class ColorPoint extends Point &#123;\n  constructor(x, y, color) &#123;\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  &#125;\n\n  toString() &#123;\n    return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，<strong>都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</strong></p>\n<p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p>\n<pre><code class=\"javascript\">class Point &#123; /* ... */ &#125;\n\nclass ColorPoint extends Point &#123;\n  constructor() &#123;\n  &#125;\n&#125;\n\nlet cp = new ColorPoint(); // ReferenceError\n</code></pre>\n<p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super</code>方法，导致新建实例时报错。</p>\n<p><strong>ES5 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</strong></p>\n<p>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法。</p>\n<pre><code class=\"javascript\">class ColorPoint extends Point &#123;\n&#125;\n\n// 等同于\nclass ColorPoint extends Point &#123;\n  constructor(...args) &#123;\n    super(...args);\n  &#125;\n&#125;\n</code></pre>\n<p>另一个需要注意的地方是，在子类的构造函数中，<strong>只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有<code>super</code>方法才能调用父类实例。</strong></p>\n<pre><code class=\"javascript\">class Point &#123;\n  constructor(x, y) &#123;\n    this.x = x;\n    this.y = y;\n  &#125;\n&#125;\n\nclass ColorPoint extends Point &#123;\n  constructor(x, y, color) &#123;\n    this.color = color; // ReferenceError\n    super(x, y);\n    this.color = color; // 正确\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，子类的<code>constructor</code>方法没有调用<code>super</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super</code>方法之后就是正确的。</p>\n<p>下面是生成子类实例的代码。</p>\n<pre><code class=\"javascript\">let cp = new ColorPoint(25, 8, &#39;green&#39;);\n\ncp instanceof ColorPoint // true\ncp instanceof Point // true\n</code></pre>\n<p>上面代码中，实例对象<code>cp</code>同时是<code>ColorPoint</code>和<code>Point</code>两个类的实例，这与 ES5 的行为完全一致。</p>\n<p>最后，父类的静态方法，也会被子类继承。</p>\n<pre><code class=\"javascript\">class A &#123;\n  static hello() &#123;\n    console.log(&#39;hello world&#39;);\n  &#125;\n&#125;\n\nclass B extends A &#123;\n&#125;\n\nB.hello()  // hello world\n</code></pre>\n<p>上面代码中，<code>hello()</code>是<code>A</code>类的静态方法，<code>B</code>继承<code>A</code>，也继承了<code>A</code>的静态方法。</p>\n<hr>\n<h4 id=\"2-Object-getPrototypeOf\"><a href=\"#2-Object-getPrototypeOf\" class=\"headerlink\" title=\"2. Object.getPrototypeOf()\"></a>2. Object.getPrototypeOf()</h4><p><strong><code>Object.getPrototypeOf</code>方法可以用来从子类上获取父类。</strong></p>\n<pre><code class=\"javascript\">Object.getPrototypeOf(ColorPoint) === Point\n// true\n</code></pre>\n<p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>\n<hr>\n<h4 id=\"3-super-关键字\"><a href=\"#3-super-关键字\" class=\"headerlink\" title=\"3. super 关键字\"></a>3. super 关键字</h4><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>\n<p><strong>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</strong></p>\n<pre><code class=\"javascript\">class A &#123;&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，子类<code>B</code>的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p>\n<p><strong>注意，<code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是<code>B</code>的实例，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</strong></p>\n<pre><code class=\"javascript\">class A &#123;\n  constructor() &#123;\n    console.log(new.target.name);\n  &#125;\n&#125;\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n  &#125;\n&#125;\nnew A() // A\nnew B() // B\n</code></pre>\n<p>上面代码中，<code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。</p>\n<p>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p>\n<pre><code class=\"javascript\">class A &#123;&#125;\n\nclass B extends A &#123;\n  m() &#123;\n    super(); // 报错\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，<code>super()</code>用在<code>B</code>类的<code>m</code>方法之中，就会造成语法错误。</p>\n<p><strong>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</strong></p>\n<pre><code class=\"javascript\">class A &#123;\n  p() &#123;\n    return 2;\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    console.log(super.p()); // 2\n  &#125;\n&#125;\n\nlet b = new B();\n</code></pre>\n<p>上面代码中，<strong>子类<code>B</code>当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。</strong>这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。</p>\n<p><strong>这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</strong></p>\n<pre><code class=\"javascript\">class A &#123;\n  constructor() &#123;\n    this.p = 2;\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  get m() &#123;\n    return super.p;\n  &#125;\n&#125;\n\nlet b = new B();\nb.m // undefined\n</code></pre>\n<p>上面代码中，<code>p</code>是父类<code>A</code>实例的属性，<code>super.p</code>就引用不到它。</p>\n<p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到。</p>\n<pre><code class=\"javascript\">class A &#123;&#125;\nA.prototype.x = 2;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    console.log(super.x) // 2\n  &#125;\n&#125;\n\nlet b = new B();\n</code></pre>\n<p>上面代码中，属性<code>x</code>是定义在<code>A.prototype</code>上面的，所以<code>super.x</code>可以取到它的值。</p>\n<p><strong>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</strong></p>\n<pre><code class=\"javascript\">class A &#123;\n  constructor() &#123;\n    this.x = 1;\n  &#125;\n  print() &#123;\n    console.log(this.x);\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    this.x = 2;\n  &#125;\n  m() &#123;\n    super.print();\n  &#125;\n&#125;\n\nlet b = new B();\nb.m() // 2\n</code></pre>\n<p>上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类<code>B</code>的实例，导致输出的是<code>2</code>，而不是<code>1</code>。也就是说，<strong>实际上执行的是<code>super.print.call(this)</code>。</strong></p>\n<p><strong>由于<code>this</code>指向子类实例，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。</strong></p>\n<pre><code class=\"javascript\">class A &#123;\n  constructor() &#123;\n    this.x = 1;\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    this.x = 2;\n    super.x = 3;\n    console.log(super.x); // undefined\n    console.log(this.x); // 3\n  &#125;\n&#125;\n\nlet b = new B();\n</code></pre>\n<p>上面代码中，<code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p>\n<p><strong>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</strong></p>\n<pre><code class=\"javascript\">class Parent &#123;\n  static myMethod(msg) &#123;\n    console.log(&#39;static&#39;, msg);\n  &#125;\n\n  myMethod(msg) &#123;\n    console.log(&#39;instance&#39;, msg);\n  &#125;\n&#125;\n\nclass Child extends Parent &#123;\n  static myMethod(msg) &#123;\n    super.myMethod(msg);\n  &#125;\n\n  myMethod(msg) &#123;\n    super.myMethod(msg);\n  &#125;\n&#125;\n\nChild.myMethod(1); // static 1\n\nvar child = new Child();\nchild.myMethod(2); // instance 2\n</code></pre>\n<p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p>\n<p>另外，在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</p>\n<pre><code class=\"javascript\">class A &#123;\n  constructor() &#123;\n    this.x = 1;\n  &#125;\n  static print() &#123;\n    console.log(this.x);\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    this.x = 2;\n  &#125;\n  static m() &#123;\n    super.print();\n  &#125;\n&#125;\n\nB.x = 3;\nB.m() // 3\n</code></pre>\n<p>上面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例。</p>\n<p><strong>注意，使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</strong></p>\n<pre><code class=\"javascript\">class A &#123;&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    console.log(super); // 报错\n  &#125;\n&#125;\n</code></pre>\n<p><strong>上面代码中，<code>console.log(super)</code>当中的<code>super</code>，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明<code>super</code>的数据类型，就不会报错。</strong></p>\n<pre><code class=\"javascript\">class A &#123;&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    console.log(super.valueOf() instanceof B); // true\n  &#125;\n&#125;\n\nlet b = new B();\n</code></pre>\n<p>上面代码中，<code>super.valueOf()</code>表明<code>super</code>是一个对象，因此就不会报错。同时，由于<code>super</code>使得<code>this</code>指向<code>B</code>的实例，所以<code>super.valueOf()</code>返回的是一个<code>B</code>的实例。</p>\n<p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</p>\n<pre><code class=\"javascript\">var obj = &#123;\n  toString() &#123;\n    return &quot;MyObject: &quot; + super.toString();\n  &#125;\n&#125;;\n\nobj.toString(); // MyObject: [object Object]\n</code></pre>\n<hr>\n<h4 id=\"4-类的-prototype-属性和-proto-属性\"><a href=\"#4-类的-prototype-属性和-proto-属性\" class=\"headerlink\" title=\"4. 类的 prototype 属性和__proto__属性\"></a>4. 类的 prototype 属性和__proto__属性</h4><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>\n<p><strong>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</strong></p>\n<p><strong>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</strong></p>\n<pre><code class=\"javascript\">class A &#123;\n&#125;\n\nclass B extends A &#123;\n&#125;\n\nB.__proto__ === A // true\nB.prototype.__proto__ === A.prototype // true\n</code></pre>\n<p>上面代码中，子类<code>B</code>的<code>__proto__</code>属性指向父类<code>A</code>，子类<code>B</code>的<code>prototype</code>属性的<code>__proto__</code>属性指向父类<code>A</code>的<code>prototype</code>属性。</p>\n<p>这样的结果是因为，类的继承是按照下面的模式实现的。</p>\n<pre><code class=\"javascript\">class A &#123;\n&#125;\n\nclass B &#123;\n&#125;\n\n// B 的实例继承 A 的实例\nObject.setPrototypeOf(B.prototype, A.prototype);\n\n// B 继承 A 的静态属性\nObject.setPrototypeOf(B, A);\n\nconst b = new B();\n</code></pre>\n<p>《对象的扩展》一章给出过<code>Object.setPrototypeOf</code>方法的实现。</p>\n<pre><code class=\"javascript\">Object.setPrototypeOf = function (obj, proto) &#123;\n  obj.__proto__ = proto;\n  return obj;\n&#125;\n</code></pre>\n<p>因此，就得到了上面的结果。</p>\n<pre><code class=\"javascript\">Object.setPrototypeOf(B.prototype, A.prototype);\n// 等同于\nB.prototype.__proto__ = A.prototype;\n\nObject.setPrototypeOf(B, A);\n// 等同于\nB.__proto__ = A;\n</code></pre>\n<p>这两条继承链，可以这样理解：<strong>作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</strong></p>\n<pre><code class=\"javascript\">B.prototype = Object.create(A.prototype);\n// 等同于\nB.prototype.__proto__ = A.prototype;\n</code></pre>\n<p><strong><code>extends</code>关键字后面可以跟多种类型的值。</strong></p>\n<pre><code class=\"javascript\">class B extends A &#123;\n&#125;\n</code></pre>\n<p>上面代码的<code>A</code>，只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p>\n<p>下面，讨论两种情况。第一种，子类继承<code>Object</code>类。</p>\n<pre><code class=\"javascript\">class A extends Object &#123;\n&#125;\n\nA.__proto__ === Object // true\nA.prototype.__proto__ === Object.prototype // true\n</code></pre>\n<p>这种情况下，**<code>A</code>其实就是构造函数<code>Object</code>的复制，<code>A</code>的实例就是<code>Object</code>的实例。**</p>\n<p>第二种情况，不存在任何继承。</p>\n<pre><code class=\"javascript\">class A &#123;\n&#125;\n\nA.__proto__ === Function.prototype // true\nA.prototype.__proto__ === Object.prototype // true\n</code></pre>\n<p>这种情况下，**<code>A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Function.prototype</code>。但是，<code>A</code>调用后返回一个空对象（即<code>Object</code>实例），所以<code>A.prototype.__proto__</code>指向构造函数（<code>Object</code>）的<code>prototype</code>属性。**</p>\n<hr>\n<p><strong>实例的 proto 属性</strong></p>\n<p><strong>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</strong></p>\n<pre><code class=\"javascript\">var p1 = new Point(2, 3);\nvar p2 = new ColorPoint(2, 3, &#39;red&#39;);\n\np2.__proto__ === p1.__proto__ // false\np2.__proto__.__proto__ === p1.__proto__ // true\n</code></pre>\n<p><strong>上面代码中，<code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型。</strong></p>\n<p>因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</p>\n<pre><code class=\"javascript\">p2.__proto__.__proto__.printName = function () &#123;\n  console.log(&#39;Ha&#39;);\n&#125;;\n\np1.printName() // &quot;Ha&quot;\n</code></pre>\n<p>上面代码在<code>ColorPoint</code>的实例<code>p2</code>上向<code>Point</code>类添加方法，结果影响到了<code>Point</code>的实例<code>p1</code>。</p>\n<hr>\n<h4 id=\"5-原生构造函数的继承\"><a href=\"#5-原生构造函数的继承\" class=\"headerlink\" title=\"5. 原生构造函数的继承\"></a>5. 原生构造函数的继承</h4><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p>\n<ul>\n<li>Boolean()</li>\n<li>Number()</li>\n<li>String()</li>\n<li>Array()</li>\n<li>Date()</li>\n<li>Function()</li>\n<li>RegExp()</li>\n<li>Error()</li>\n<li>Object()</li>\n</ul>\n<p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个<code>Array</code>的子类。</p>\n<pre><code class=\"javascript\">function MyArray() &#123;\n  Array.apply(this, arguments);\n&#125;\n\nMyArray.prototype = Object.create(Array.prototype, &#123;\n  constructor: &#123;\n    value: MyArray,\n    writable: true,\n    configurable: true,\n    enumerable: true\n  &#125;\n&#125;);\n</code></pre>\n<p>上面代码定义了一个继承 Array 的<code>MyArray</code>类。但是，这个类的行为与<code>Array</code>完全不一致。</p>\n<pre><code class=\"javascript\">var colors = new MyArray();\ncolors[0] = &quot;red&quot;;\ncolors.length  // 0\n\ncolors.length = 0;\ncolors[0]  // &quot;red&quot;\n</code></pre>\n<p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过<code>Array.apply()</code>或者分配给原型对象都不行。原生构造函数会忽略<code>apply</code>方法传入的<code>this</code>，也就是说，原生构造函数的<code>this</code>无法绑定，导致拿不到内部属性。</p>\n<p><strong>ES5 是先新建子类的实例对象<code>this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。</strong>比如，<code>Array</code>构造函数有一个内部属性<code>[[DefineOwnProperty]]</code>，用来定义新属性时，更新<code>length</code>属性，这个内部属性无法在子类获取，导致子类的<code>length</code>属性行为不正常。</p>\n<p>下面的例子中，我们想让一个普通对象继承<code>Error</code>对象。</p>\n<pre><code class=\"javascript\">var e = &#123;&#125;;\n\nObject.getOwnPropertyNames(Error.call(e))\n// [ &#39;stack&#39; ]\n\nObject.getOwnPropertyNames(e)\n// []\n</code></pre>\n<p>上面代码中，我们想通过<code>Error.call(e)</code>这种写法，让普通对象<code>e</code>具有<code>Error</code>对象的实例属性。但是，<code>Error.call()</code>完全忽略传入的第一个参数，而是返回一个新对象，<code>e</code>本身没有任何变化。这证明了<code>Error.call(e)</code>这种写法，无法继承原生构造函数。</p>\n<p><strong>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子。</strong></p>\n<pre><code class=\"javascript\">class MyArray extends Array &#123;\n  constructor(...args) &#123;\n    super(...args);\n  &#125;\n&#125;\n\nvar arr = new MyArray();\narr[0] = 12;\narr.length // 1\n\narr.length = 0;\narr[0] // undefined\n</code></pre>\n<p>上面代码定义了一个<code>MyArray</code>类，继承了<code>Array</code>构造函数，因此就可以从<code>MyArray</code>生成数组的实例。这意味着，<strong>ES6 可以自定义原生数据结构（比如<code>Array</code>、<code>String</code>等）的子类，这是 ES5 无法做到的。</strong></p>\n<p>上面这个例子也说明，<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p>\n<pre><code class=\"javascript\">class VersionedArray extends Array &#123;\n  constructor() &#123;\n    super();\n    this.history = [[]];\n  &#125;\n  commit() &#123;\n    this.history.push(this.slice());\n  &#125;\n  revert() &#123;\n    this.splice(0, this.length, ...this.history[this.history.length - 1]);\n  &#125;\n&#125;\n\nvar x = new VersionedArray();\n\nx.push(1);\nx.push(2);\nx // [1, 2]\nx.history // [[]]\n\nx.commit();\nx.history // [[], [1, 2]]\n\nx.push(3);\nx // [1, 2, 3]\nx.history // [[], [1, 2]]\n\nx.revert();\nx // [1, 2]\n</code></pre>\n<p>上面代码中，<code>VersionedArray</code>会通过<code>commit</code>方法，将自己的当前状态生成一个版本快照，存入<code>history</code>属性。<code>revert</code>方法用来将数组重置为最新一次保存的版本。除此之外，<code>VersionedArray</code>依然是一个普通数组，所有原生的数组方法都可以在它上面调用。</p>\n<p>下面是一个自定义<code>Error</code>子类的例子，可以用来定制报错时的行为。</p>\n<pre><code class=\"javascript\">class ExtendableError extends Error &#123;\n  constructor(message) &#123;\n    super();\n    this.message = message;\n    this.stack = (new Error()).stack;\n    this.name = this.constructor.name;\n  &#125;\n&#125;\n\nclass MyError extends ExtendableError &#123;\n  constructor(m) &#123;\n    super(m);\n  &#125;\n&#125;\n\nvar myerror = new MyError(&#39;ll&#39;);\nmyerror.message // &quot;ll&quot;\nmyerror instanceof Error // true\nmyerror.name // &quot;MyError&quot;\nmyerror.stack\n// Error\n//     at MyError.ExtendableError\n//     ...\n</code></pre>\n<p>注意，继承<code>Object</code>的子类，有一个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzYyMDM2MTQvc3VwZXItZG9lcy1ub3QtcGFzcy1hcmd1bWVudHMtd2hlbi1pbnN0YW50aWF0aW5nLWEtY2xhc3MtZXh0ZW5kZWQtZnJvbS1vYmplY3Q=\">行为差异</span>。</p>\n<pre><code class=\"javascript\">class NewObj extends Object&#123;\n  constructor()&#123;\n    super(...arguments);\n  &#125;\n&#125;\nvar o = new NewObj(&#123;attr: true&#125;);\no.attr === true  // false\n</code></pre>\n<p>上面代码中，<code>NewObj</code>继承了<code>Object</code>，但是无法通过<code>super</code>方法向父类<code>Object</code>传参。这<strong>是因为 ES6 改变了<code>Object</code>构造函数的行为，一旦发现<code>Object</code>方法不是通过<code>new Object()</code>这种形式调用，ES6 规定<code>Object</code>构造函数会忽略参数。</strong></p>\n<hr>\n<h4 id=\"6-Mixin-模式的实现\"><a href=\"#6-Mixin-模式的实现\" class=\"headerlink\" title=\"6. Mixin 模式的实现\"></a>6. Mixin 模式的实现</h4><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p>\n<pre><code class=\"javascript\">const a = &#123;\n  a: &#39;a&#39;\n&#125;;\nconst b = &#123;\n  b: &#39;b&#39;\n&#125;;\nconst c = &#123;...a, ...b&#125;; // &#123;a: &#39;a&#39;, b: &#39;b&#39;&#125;\n</code></pre>\n<p>上面代码中，<code>c</code>对象是<code>a</code>对象和<code>b</code>对象的合成，具有两者的接口。</p>\n<p>下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。</p>\n<pre><code class=\"javascript\">function mix(...mixins) &#123;\n  class Mix &#123;\n    constructor() &#123;\n      for (let mixin of mixins) &#123;\n        copyProperties(this, new mixin()); // 拷贝实例属性\n      &#125;\n    &#125;\n  &#125;\n\n  for (let mixin of mixins) &#123;\n    copyProperties(Mix, mixin); // 拷贝静态属性\n    copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性\n  &#125;\n\n  return Mix;\n&#125;\n\nfunction copyProperties(target, source) &#123;\n  for (let key of Reflect.ownKeys(source)) &#123;\n    if ( key !== &#39;constructor&#39;\n      &amp;&amp; key !== &#39;prototype&#39;\n      &amp;&amp; key !== &#39;name&#39;\n    ) &#123;\n      let desc = Object.getOwnPropertyDescriptor(source, key);\n      Object.defineProperty(target, key, desc);\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码的<code>mix</code>函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p>\n<pre><code class=\"javascript\">class DistributedEdit extends mix(Loggable, Serializable) &#123;\n  // ...\n&#125;\n</code></pre>\n<h3 id=\"23、-Module-的语法\"><a href=\"#23、-Module-的语法\" class=\"headerlink\" title=\"23、 Module 的语法\"></a>23、 Module 的语法</h3><hr>\n<h4 id=\"1-概述-2\"><a href=\"#1-概述-2\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h4><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\n<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>\n<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>\n<pre><code class=\"javascript\">// CommonJS模块\nlet &#123; stat, exists, readfile &#125; = require(&#39;fs&#39;);\n\n// 等同于\nlet _fs = require(&#39;fs&#39;);\nlet stat = _fs.stat;\nlet exists = _fs.exists;\nlet readfile = _fs.readfile;\n</code></pre>\n<p>上面代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>\n<p>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</p>\n<pre><code class=\"javascript\">// ES6模块\nimport &#123; stat, exists, readFile &#125; from &#39;fs&#39;;\n</code></pre>\n<p>上面代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>\n<p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p>\n<p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p>\n<ul>\n<li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li>\n<li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li>\n<li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li>\n</ul>\n<p>本章介绍 ES6 模块的语法，下一章介绍如何在浏览器和 Node 之中，加载 ES6 模块。</p>\n<hr>\n<h4 id=\"2-严格模式\"><a href=\"#2-严格模式\" class=\"headerlink\" title=\"2. 严格模式\"></a>2. 严格模式</h4><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p>\n<p>严格模式主要有以下限制。</p>\n<ul>\n<li>变量必须声明后再使用</li>\n<li>函数的参数不能有同名属性，否则报错</li>\n<li>不能使用<code>with</code>语句</li>\n<li>不能对只读属性赋值，否则报错</li>\n<li>不能使用前缀 0 表示八进制数，否则报错</li>\n<li>不能删除不可删除的属性，否则报错</li>\n<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>\n<li><code>eval</code>不会在它的外层作用域引入变量</li>\n<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>\n<li><code>arguments</code>不会自动反映函数参数的变化</li>\n<li>不能使用<code>arguments.callee</code></li>\n<li>不能使用<code>arguments.caller</code></li>\n<li>禁止<code>this</code>指向全局对象</li>\n<li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>\n<li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li>\n</ul>\n<p>上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本书不再详细介绍了。</p>\n<p>其中，尤其需要注意<code>this</code>的限制。<strong>ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code>。</strong></p>\n<hr>\n<h4 id=\"3-export-命令\"><a href=\"#3-export-命令\" class=\"headerlink\" title=\"3. export 命令\"></a>3. export 命令</h4><p><strong>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</strong></p>\n<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量。</p>\n<pre><code class=\"javascript\">// profile.js\nexport var firstName = &#39;Michael&#39;;\nexport var lastName = &#39;Jackson&#39;;\nexport var year = 1958;\n</code></pre>\n<p>上面代码是<code>profile.js</code>文件，保存了用户信息。ES6 将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p>\n<p><code>export</code>的写法，除了像上面这样，还有另外一种。</p>\n<pre><code class=\"javascript\">// profile.js\nvar firstName = &#39;Michael&#39;;\nvar lastName = &#39;Jackson&#39;;\nvar year = 1958;\n\nexport &#123; firstName, lastName, year &#125;;\n</code></pre>\n<p>上面代码在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在<code>var</code>语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p>\n<p><code>export</code>命令除了输出变量，还可以输出函数或类（class）。</p>\n<pre><code class=\"javascript\">export function multiply(x, y) &#123;\n  return x * y;\n&#125;;\n</code></pre>\n<p>上面代码对外输出一个函数<code>multiply</code>。</p>\n<p><strong>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。</strong></p>\n<pre><code class=\"javascript\">function v1() &#123; ... &#125;\nfunction v2() &#123; ... &#125;\n\nexport &#123;\n  v1 as streamV1,\n  v2 as streamV2,\n  v2 as streamLatestVersion\n&#125;;\n</code></pre>\n<p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p>\n<p>需要特别注意的是，<code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p>\n<pre><code class=\"javascript\">// 报错\nexport 1;\n\n// 报错\nvar m = 1;\nexport m;\n</code></pre>\n<p><strong>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量<code>m</code>，还是直接输出 1。<code>1</code>只是一个值，不是接口。得用 {} 包一下或者直接export</strong>。正确的写法是下面这样。</p>\n<pre><code class=\"javascript\">// 写法一\nexport var m = 1;\n\n// 写法二\nvar m = 1;\nexport &#123;m&#125;;\n\n// 写法三\nvar n = 1;\nexport &#123;n as m&#125;;\n</code></pre>\n<p>上面三种写法都是正确的，规定了对外的接口<code>m</code>。其他脚本可以通过这个接口，取到值<code>1</code>。<strong>它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</strong></p>\n<p>同样的，<code>function</code>和<code>class</code>的输出，也必须遵守这样的写法。</p>\n<pre><code class=\"javascript\">// 报错\nfunction f() &#123;&#125;\nexport f;\n\n// 正确\nexport function f() &#123;&#125;;\n\n// 正确\nfunction f() &#123;&#125;\nexport &#123;f&#125;;\n</code></pre>\n<p>另外，**<code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。**</p>\n<pre><code class=\"javascript\">export var foo = &#39;bar&#39;;\nsetTimeout(() =&gt; foo = &#39;baz&#39;, 500);\n</code></pre>\n<p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500 毫秒之后变成<code>baz</code>。</p>\n<p><strong>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新</strong>，详见下文《Module 的加载实现》一节。</p>\n<p>最后，**<code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错**，下一节的<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p>\n<pre><code class=\"javascript\">function foo() &#123;\n  export default &#39;bar&#39; // SyntaxError\n&#125;\nfoo()\n</code></pre>\n<p>上面代码中，<code>export</code>语句放在函数之中，结果报错。</p>\n<hr>\n<h4 id=\"4-import-命令\"><a href=\"#4-import-命令\" class=\"headerlink\" title=\"4. import 命令\"></a>4. import 命令</h4><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p>\n<pre><code class=\"javascript\">// main.js\nimport &#123; firstName, lastName, year &#125; from &#39;./profile.js&#39;;\n\nfunction setName(element) &#123;\n  element.textContent = firstName + &#39; &#39; + lastName;\n&#125;\n</code></pre>\n<p>上面代码的<code>import</code>命令，用于加载<code>profile.js</code>文件，并从中输入变量。<code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p>\n<p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p>\n<pre><code class=\"javascript\">import &#123; lastName as surname &#125; from &#39;./profile.js&#39;;\n</code></pre>\n<p><strong><code>import</code>命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。</strong></p>\n<pre><code class=\"javascript\">import &#123;a&#125; from &#39;./xxx.js&#39;\n\na = &#123;&#125;; // Syntax Error : &#39;a&#39; is read-only;\n</code></pre>\n<p>上面代码中，脚本加载了变量<code>a</code>，对其重新赋值就会报错，因为<code>a</code>是一个只读的接口。但是，如果<code>a</code>是一个对象，改写<code>a</code>的属性是允许的。</p>\n<pre><code class=\"javascript\">import &#123;a&#125; from &#39;./xxx.js&#39;\n\na.foo = &#39;hello&#39;; // 合法操作\n</code></pre>\n<p>上面代码中，<code>a</code>的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，<strong>建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。</strong></p>\n<p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径。如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p>\n<pre><code class=\"javascript\">import &#123; myMethod &#125; from &#39;util&#39;;\n</code></pre>\n<p>上面代码中，<code>util</code>是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p>\n<p><strong>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</strong></p>\n<pre><code class=\"javascript\">foo();\n\nimport &#123; foo &#125; from &#39;my_module&#39;;\n</code></pre>\n<p><strong>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。</strong></p>\n<p><strong>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</strong></p>\n<pre><code class=\"javascript\">// 报错\nimport &#123; &#39;f&#39; + &#39;oo&#39; &#125; from &#39;my_module&#39;;\n\n// 报错\nlet module = &#39;my_module&#39;;\nimport &#123; foo &#125; from module;\n\n// 报错\nif (x === 1) &#123;\n  import &#123; foo &#125; from &#39;module1&#39;;\n&#125; else &#123;\n  import &#123; foo &#125; from &#39;module2&#39;;\n&#125;\n</code></pre>\n<p>上面三种写法都会报错，因为它们用到了表达式、变量和<code>if</code>结构。在静态分析阶段，这些语法都是没法得到值的。</p>\n<p>最后，<code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p>\n<pre><code class=\"javascript\">import &#39;lodash&#39;;\n</code></pre>\n<p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p>\n<p><strong>如果多次重复执行同一句<code>import</code>语句，那么只会执行一次，而不会执行多次。</strong></p>\n<pre><code class=\"javascript\">import &#39;lodash&#39;;\nimport &#39;lodash&#39;;\n</code></pre>\n<p>上面代码加载了两次<code>lodash</code>，但是只会执行一次。</p>\n<pre><code class=\"javascript\">import &#123; foo &#125; from &#39;my_module&#39;;\nimport &#123; bar &#125; from &#39;my_module&#39;;\n\n// 等同于\nimport &#123; foo, bar &#125; from &#39;my_module&#39;;\n</code></pre>\n<p>上面代码中，虽然<code>foo</code>和<code>bar</code>在两个语句中加载，但是它们对应的是同一个<code>my_module</code>模块。也就是说，**<code>import</code>语句是 Singleton 模式。**</p>\n<p>目前阶段，通过 Babel 转码，CommonJS 模块的<code>require</code>命令和 ES6 模块的<code>import</code>命令，可以写在同一个模块里面，但是最好不要这样做。因为<code>import</code>在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</p>\n<pre><code class=\"javascript\">require(&#39;core-js/modules/es6.symbol&#39;);\nrequire(&#39;core-js/modules/es6.promise&#39;);\nimport React from &#39;React&#39;;\n</code></pre>\n<hr>\n<h4 id=\"5-模块的整体加载\"><a href=\"#5-模块的整体加载\" class=\"headerlink\" title=\"5. 模块的整体加载\"></a>5. 模块的整体加载</h4><p><strong>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</strong></p>\n<p>下面是一个<code>circle.js</code>文件，它输出两个方法<code>area</code>和<code>circumference</code>。</p>\n<pre><code class=\"javascript\">// circle.js\n\nexport function area(radius) &#123;\n  return Math.PI * radius * radius;\n&#125;\n\nexport function circumference(radius) &#123;\n  return 2 * Math.PI * radius;\n&#125;\n</code></pre>\n<p>现在，加载这个模块。</p>\n<pre><code class=\"javascript\">// main.js\n\nimport &#123; area, circumference &#125; from &#39;./circle&#39;;\n\nconsole.log(&#39;圆面积：&#39; + area(4));\nconsole.log(&#39;圆周长：&#39; + circumference(14));\n</code></pre>\n<p>上面写法是逐一指定要加载的方法，整体加载的写法如下。</p>\n<pre><code class=\"javascript\">import * as circle from &#39;./circle&#39;;\n\nconsole.log(&#39;圆面积：&#39; + circle.area(4));\nconsole.log(&#39;圆周长：&#39; + circle.circumference(14));\n</code></pre>\n<p><strong>注意，模块整体加载所在的那个对象（上例是<code>circle</code>），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。</strong></p>\n<pre><code class=\"javascript\">import * as circle from &#39;./circle&#39;;\n\n// 下面两行都是不允许的\ncircle.foo = &#39;hello&#39;;\ncircle.area = function () &#123;&#125;;\n</code></pre>\n<hr>\n<h4 id=\"6-export-default-命令\"><a href=\"#6-export-default-命令\" class=\"headerlink\" title=\"6. export default 命令\"></a>6. export default 命令</h4><p>从前面的例子可以看出，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p>\n<p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到**<code>export default</code>命令，为模块指定默认输出。**</p>\n<pre><code class=\"javascript\">// export-default.js\nexport default function () &#123;\n  console.log(&#39;foo&#39;);\n&#125;\n</code></pre>\n<p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p>\n<p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p>\n<pre><code class=\"javascript\">// import-default.js\nimport customName from &#39;./export-default&#39;;\ncustomName(); // &#39;foo&#39;\n</code></pre>\n<p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p>\n<p><code>export default</code>命令用在非匿名函数前，也是可以的。</p>\n<pre><code class=\"javascript\">// export-default.js\nexport default function foo() &#123;\n  console.log(&#39;foo&#39;);\n&#125;\n\n// 或者写成\n\nfunction foo() &#123;\n  console.log(&#39;foo&#39;);\n&#125;\n\nexport default foo;\n</code></pre>\n<p>上面代码中，<code>foo</code>函数的函数名<code>foo</code>，在模块外部是无效的。加载的时候，视同匿名函数加载。</p>\n<p><strong>下面比较一下默认输出和正常输出。</strong></p>\n<pre><code class=\"javascript\">// 第一组\nexport default function crc32() &#123; // 输出\n  // ...\n&#125;\n\nimport crc32 from &#39;crc32&#39;; // 输入\n\n// 第二组\nexport function crc32() &#123; // 输出\n  // ...\n&#125;;\n\nimport &#123;crc32&#125; from &#39;crc32&#39;; // 输入\n</code></pre>\n<p>上面代码的两组写法，第一组是使用<code>export default</code>时，对应的<code>import</code>语句不需要使用大括号；<strong>第二组是不使用<code>export default</code>时，对应的<code>import</code>语句需要使用大括号。</strong></p>\n<p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令。</p>\n<p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>\n<pre><code class=\"javascript\">// modules.js\nfunction add(x, y) &#123;\n  return x * y;\n&#125;\nexport &#123;add as default&#125;;\n// 等同于\n// export default add;\n\n// app.js\nimport &#123; default as foo &#125; from &#39;modules&#39;;\n// 等同于\n// import foo from &#39;modules&#39;;\n</code></pre>\n<p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p>\n<pre><code class=\"javascript\">// 正确\nexport var a = 1;\n\n// 正确\nvar a = 1;\nexport default a;\n\n// 错误\nexport default var a = 1;\n</code></pre>\n<p>上面代码中，<code>export default a</code>的含义是将变量<code>a</code>的值赋给变量<code>default</code>。所以，最后一种写法会报错。</p>\n<p>同样地，因为<code>export default</code>命令的本质是将后面的值，赋给<code>default</code>变量，所以可以直接将一个值写在<code>export default</code>之后。</p>\n<pre><code class=\"javascript\">// 正确\nexport default 42;\n\n// 报错\nexport 42;\n</code></pre>\n<p><strong>上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为<code>default</code>。</strong></p>\n<p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入 lodash 模块为例。</p>\n<pre><code class=\"javascript\">import _ from &#39;lodash&#39;;\n</code></pre>\n<p><strong>如果想在一条<code>import</code>语句中，同时输入默认方法和其他接口，可以写成下面这样。</strong></p>\n<pre><code class=\"javascript\">import _, &#123; each, forEach &#125; from &#39;lodash&#39;;\n</code></pre>\n<p>对应上面代码的<code>export</code>语句如下。</p>\n<pre><code class=\"javascript\">export default function (obj) &#123;\n  // ···\n&#125;\n\nexport function each(obj, iterator, context) &#123;\n  // ···\n&#125;\n\nexport &#123; each as forEach &#125;;\n</code></pre>\n<p>上面代码的最后一行的意思是，暴露出<code>forEach</code>接口，默认指向<code>each</code>接口，即<code>forEach</code>和<code>each</code>指向同一个方法。</p>\n<p><code>export default</code>也可以用来输出类。</p>\n<pre><code class=\"javascript\">// MyClass.js\nexport default class &#123; ... &#125;\n\n// main.js\nimport MyClass from &#39;MyClass&#39;;\nlet o = new MyClass();\n</code></pre>\n<hr>\n<h4 id=\"7-export-与-import-的复合写法\"><a href=\"#7-export-与-import-的复合写法\" class=\"headerlink\" title=\"7. export 与 import 的复合写法\"></a>7. export 与 import 的复合写法</h4><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起。</p>\n<pre><code class=\"javascript\">export &#123; foo, bar &#125; from &#39;my_module&#39;;\n\n// 可以简单理解为\nimport &#123; foo, bar &#125; from &#39;my_module&#39;;\nexport &#123; foo, bar &#125;;\n</code></pre>\n<p>上面代码中，<code>export</code>和<code>import</code>语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，<code>foo</code>和<code>bar</code>实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用<code>foo</code>和<code>bar</code>。</p>\n<p>模块的接口改名和整体输出，也可以采用这种写法。</p>\n<pre><code class=\"javascript\">// 接口改名\nexport &#123; foo as myFoo &#125; from &#39;my_module&#39;;\n\n// 整体输出\nexport * from &#39;my_module&#39;;\n</code></pre>\n<p>默认接口的写法如下。</p>\n<pre><code class=\"javascript\">export &#123; default &#125; from &#39;foo&#39;;\n</code></pre>\n<p>具名接口改为默认接口的写法如下。</p>\n<pre><code class=\"javascript\">export &#123; es6 as default &#125; from &#39;./someModule&#39;;\n\n// 等同于\nimport &#123; es6 &#125; from &#39;./someModule&#39;;\nexport default es6;\n</code></pre>\n<p>同样地，默认接口也可以改名为具名接口。</p>\n<pre><code class=\"javascript\">export &#123; default as es6 &#125; from &#39;./someModule&#39;;\n</code></pre>\n<p>ES2020 之前，有一种<code>import</code>语句，没有对应的复合写法。</p>\n<pre><code class=\"javascript\">import * as someIdentifier from &quot;someModule&quot;;\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZXhwb3J0LW5zLWZyb20=\">ES2020</span>补上了这个写法。</p>\n<pre><code class=\"javascript\">export * as ns from &quot;mod&quot;;\n\n// 等同于\nimport * as ns from &quot;mod&quot;;\nexport &#123;ns&#125;;\n</code></pre>\n<hr>\n<h4 id=\"8-模块的继承\"><a href=\"#8-模块的继承\" class=\"headerlink\" title=\"8. 模块的继承\"></a>8. 模块的继承</h4><p>模块之间也可以继承。</p>\n<p>假设有一个<code>circleplus</code>模块，继承了<code>circle</code>模块。</p>\n<pre><code class=\"javascript\">// circleplus.js\n\nexport * from &#39;circle&#39;;\nexport var e = 2.71828182846;\nexport default function(x) &#123;\n  return Math.exp(x);\n&#125;\n</code></pre>\n<p>上面代码中的<code>export *</code>，表示再输出<code>circle</code>模块的所有属性和方法。注意，<code>export *</code>命令会忽略<code>circle</code>模块的<code>default</code>方法。然后，上面代码又输出了自定义的<code>e</code>变量和默认方法。</p>\n<p>这时，也可以将<code>circle</code>的属性或方法，改名后再输出。</p>\n<pre><code class=\"javascript\">// circleplus.js\n\nexport &#123; area as circleArea &#125; from &#39;circle&#39;;\n</code></pre>\n<p>上面代码表示，只输出<code>circle</code>模块的<code>area</code>方法，且将其改名为<code>circleArea</code>。</p>\n<p>加载上面模块的写法如下。</p>\n<pre><code class=\"javascript\">// main.js\n\nimport * as math from &#39;circleplus&#39;;\nimport exp from &#39;circleplus&#39;;\nconsole.log(exp(math.e));\n</code></pre>\n<p>上面代码中的<code>import exp</code>表示，将<code>circleplus</code>模块的默认方法加载为<code>exp</code>方法。</p>\n<hr>\n<h4 id=\"9-跨模块常量\"><a href=\"#9-跨模块常量\" class=\"headerlink\" title=\"9. 跨模块常量\"></a>9. 跨模块常量</h4><p>本书介绍<code>const</code>命令的时候说过，<code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p>\n<pre><code class=\"javascript\">// constants.js 模块\nexport const A = 1;\nexport const B = 3;\nexport const C = 4;\n\n// test1.js 模块\nimport * as constants from &#39;./constants&#39;;\nconsole.log(constants.A); // 1\nconsole.log(constants.B); // 3\n\n// test2.js 模块\nimport &#123;A, B&#125; from &#39;./constants&#39;;\nconsole.log(A); // 1\nconsole.log(B); // 3\n</code></pre>\n<p>如果要使用的常量非常多，可以建一个专门的<code>constants</code>目录，将各种常量写在不同的文件里面，保存在该目录下。</p>\n<pre><code class=\"javascript\">// constants/db.js\nexport const db = &#123;\n  url: &#39;http://my.couchdbserver.local:5984&#39;,\n  admin_username: &#39;admin&#39;,\n  admin_password: &#39;admin password&#39;\n&#125;;\n\n// constants/user.js\nexport const users = [&#39;root&#39;, &#39;admin&#39;, &#39;staff&#39;, &#39;ceo&#39;, &#39;chief&#39;, &#39;moderator&#39;];\n</code></pre>\n<p>然后，将这些文件输出的常量，合并在<code>index.js</code>里面。</p>\n<pre><code class=\"javascript\">// constants/index.js\nexport &#123;db&#125; from &#39;./db&#39;;\nexport &#123;users&#125; from &#39;./users&#39;;\n</code></pre>\n<p>使用的时候，直接加载<code>index.js</code>就可以了。</p>\n<pre><code class=\"javascript\">// script.js\nimport &#123;db, users&#125; from &#39;./constants/index&#39;;\n</code></pre>\n<hr>\n<h4 id=\"10-import\"><a href=\"#10-import\" class=\"headerlink\" title=\"10. import()\"></a>10. import()</h4><p><strong>简介</strong></p>\n<p>前面介绍过，<code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（<code>import</code>命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。</p>\n<pre><code class=\"javascript\">// 报错\nif (x === 2) &#123;\n  import MyModual from &#39;./myModual&#39;;\n&#125;\n</code></pre>\n<p>上面代码中，<strong>引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报句法错误</strong>，而不是执行时错误。也就是说，<code>import</code>和<code>export</code>命令只能在模块的顶层，不能在代码块之中（比如，在<code>if</code>代码块之中，或在函数之中）。</p>\n<p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果<code>import</code>命令要取代 Node 的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p>\n<pre><code class=\"javascript\">const path = &#39;./&#39; + fileName;\nconst myModual = require(path);\n</code></pre>\n<p>上面的语句就是动态加载，<code>require</code>到底加载哪一个模块，只有运行时才知道。<code>import</code>命令做不到这一点。</p>\n<p><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZHluYW1pYy1pbXBvcnQ=\">ES2020提案</span> 引入<code>import()</code>函数，支持动态加载模块。</strong></p>\n<pre><code class=\"javascript\">import(specifier)\n</code></pre>\n<p>上面代码中，**<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。**</p>\n<p><code>import()</code>返回一个 Promise 对象。下面是一个例子。</p>\n<pre><code class=\"javascript\">const main = document.querySelector(&#39;main&#39;);\n\nimport(`./section-modules/$&#123;someVariable&#125;.js`)\n  .then(module =&gt; &#123;\n    module.loadPageInto(main);\n  &#125;)\n  .catch(err =&gt; &#123;\n    main.textContent = err.message;\n  &#125;);\n</code></pre>\n<p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。**<code>import()</code>类似于 Node 的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。**</p>\n<p><strong>适用场合</strong></p>\n<p>下面是<code>import()</code>的一些适用场合。</p>\n<p><strong>（1）按需加载。</strong></p>\n<p><code>import()</code>可以在需要的时候，再加载某个模块。</p>\n<pre><code class=\"javascript\">button.addEventListener(&#39;click&#39;, event =&gt; &#123;\n  import(&#39;./dialogBox.js&#39;)\n  .then(dialogBox =&gt; &#123;\n    dialogBox.open();\n  &#125;)\n  .catch(error =&gt; &#123;\n    /* Error handling */\n  &#125;)\n&#125;);\n</code></pre>\n<p>上面代码中，<code>import()</code>方法放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p>\n<p><strong>（2）条件加载</strong></p>\n<p><code>import()</code>可以放在<code>if</code>代码块，根据不同的情况，加载不同的模块。</p>\n<pre><code class=\"javascript\">if (condition) &#123;\n  import(&#39;moduleA&#39;).then(...);\n&#125; else &#123;\n  import(&#39;moduleB&#39;).then(...);\n&#125;\n</code></pre>\n<p>上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。</p>\n<p><strong>（3）动态的模块路径</strong></p>\n<p><code>import()</code>允许模块路径动态生成。</p>\n<pre><code class=\"javascript\">import(f())\n.then(...);\n</code></pre>\n<p>上面代码中，根据函数<code>f</code>的返回结果，加载不同的模块。</p>\n<p><strong>注意点</strong></p>\n<p><strong><code>import()</code>加载模块成功以后，这个模块会作为一个对象，当作<code>then</code>方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。</strong></p>\n<pre><code class=\"javascript\">import(&#39;./myModule.js&#39;)\n.then((&#123;export1, export2&#125;) =&gt; &#123;\n  // ...·\n&#125;);\n</code></pre>\n<p>上面代码中，<code>export1</code>和<code>export2</code>都是<code>myModule.js</code>的输出接口，可以解构获得。</p>\n<p>如果模块有<code>default</code>输出接口，可以用参数直接获得。</p>\n<pre><code class=\"javascript\">import(&#39;./myModule.js&#39;)\n.then(myModule =&gt; &#123;\n  console.log(myModule.default);\n&#125;);\n</code></pre>\n<p>上面的代码也可以使用具名输入的形式。</p>\n<pre><code class=\"javascript\">import(&#39;./myModule.js&#39;)\n.then((&#123;default: theDefault&#125;) =&gt; &#123;\n  console.log(theDefault);\n&#125;);\n</code></pre>\n<p>如果想同时加载多个模块，可以采用下面的写法。</p>\n<pre><code class=\"javascript\">Promise.all([\n  import(&#39;./module1.js&#39;),\n  import(&#39;./module2.js&#39;),\n  import(&#39;./module3.js&#39;),\n])\n.then(([module1, module2, module3]) =&gt; &#123;\n   ···\n&#125;);\n</code></pre>\n<p><code>import()</code>也可以用在 async 函数之中。</p>\n<pre><code class=\"javascript\">async function main() &#123;\n  const myModule = await import(&#39;./myModule.js&#39;);\n  const &#123;export1, export2&#125; = await import(&#39;./myModule.js&#39;);\n  const [module1, module2, module3] =\n    await Promise.all([\n      import(&#39;./module1.js&#39;),\n      import(&#39;./module2.js&#39;),\n      import(&#39;./module3.js&#39;),\n    ]);\n&#125;\nmain();\n</code></pre>\n<h3 id=\"24、-Module-的加载实现\"><a href=\"#24、-Module-的加载实现\" class=\"headerlink\" title=\"24、 Module 的加载实现\"></a>24、 Module 的加载实现</h3><hr>\n<h4 id=\"1-浏览器加载\"><a href=\"#1-浏览器加载\" class=\"headerlink\" title=\"1. 浏览器加载\"></a>1. 浏览器加载</h4><p><strong>传统方法</strong></p>\n<p>HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。</p>\n<pre><code class=\"html\">&lt;!-- 页面内嵌的脚本 --&gt;\n&lt;script type=&quot;application/javascript&quot;&gt;\n  // module code\n&lt;/script&gt;\n\n&lt;!-- 外部脚本 --&gt;\n&lt;script type=&quot;application/javascript&quot; src=&quot;path/to/myModule.js&quot;&gt;\n&lt;/script&gt;\n</code></pre>\n<p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略。</p>\n<p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p>\n<p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以<strong>浏览器允许脚本异步加载，下面就是两种异步加载的语法。</strong></p>\n<pre><code class=\"html\">&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;\n&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;\n</code></pre>\n<p>上面代码中，**<code>&lt;script&gt;</code>标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。**</p>\n<p><strong><code>defer</code>与<code>async</code>的区别是：<code>defer</code>要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；<code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染</strong>。一句话，**<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”<strong>。另外，</strong>如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。**</p>\n<hr>\n<p><strong>加载规则</strong></p>\n<p><strong>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=&quot;module&quot;</code>属性。</strong></p>\n<pre><code class=\"html\">&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt;\n</code></pre>\n<p>上面代码在网页中插入一个模块<code>foo.js</code>，由于<code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个 ES6 模块。</p>\n<p><strong>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</strong></p>\n<pre><code class=\"html\">&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt;\n&lt;!-- 等同于 --&gt;\n&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; defer&gt;&lt;/script&gt;\n</code></pre>\n<p>如果网页有多个<code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面出现的顺序依次执行。</p>\n<p><strong>script 标签的async属性可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</strong></p>\n<pre><code class=\"html\">&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; async&gt;&lt;/script&gt;\n</code></pre>\n<p>一旦使用了<code>async</code>属性，<code>&lt;script type=&quot;module&quot;&gt;</code>就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</p>\n<p><strong>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</strong></p>\n<pre><code class=\"html\">&lt;script type=&quot;module&quot;&gt;\n  import utils from &quot;./utils.js&quot;;\n\n  // other code\n&lt;/script&gt;\n</code></pre>\n<p>举例来说，jQuery 就支持模块加载。</p>\n<pre><code class=\"html\">&lt;script type=&quot;module&quot;&gt;\n  import $ from &quot;./jquery/src/jquery.js&quot;;\n  $(&#39;#message&#39;).text(&#39;Hi from jQuery!&#39;);\n&lt;/script&gt;\n</code></pre>\n<p>对于外部的模块脚本（上例是<code>foo.js</code>），有几点需要注意。</p>\n<ul>\n<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>\n<li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li>\n<li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li>\n<li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li>\n<li>同一个模块如果加载多次，将只执行一次。</li>\n</ul>\n<p>下面是一个示例模块。</p>\n<pre><code class=\"javascript\">import utils from &#39;https://example.com/js/utils.js&#39;;\n\nconst x = 1;\n\nconsole.log(x === window.x); //false\nconsole.log(this === undefined); // true\n</code></pre>\n<p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p>\n<pre><code class=\"javascript\">const isNotModuleScript = this !== undefined;\n</code></pre>\n<hr>\n<h4 id=\"2-ES6-模块与-CommonJS-模块的差异\"><a href=\"#2-ES6-模块与-CommonJS-模块的差异\" class=\"headerlink\" title=\"2. ES6 模块与 CommonJS 模块的差异\"></a>2. ES6 模块与 CommonJS 模块的差异</h4><p>讨论 Node.js 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。</p>\n<p>它们有三个重大差异。</p>\n<ul>\n<li><strong>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</strong></li>\n<li><strong>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</strong></li>\n<li><strong>CommonJS 模块的<code>require()</code>是同步加载模块，ES6 模块的<code>import</code>命令是异步加载，有一个独立的模块依赖的解析阶段。</strong></li>\n</ul>\n<p><strong>第二个差异是因为 CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</strong></p>\n<p>下面重点解释第一个差异。</p>\n<p><strong>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</strong>请看下面这个模块文件<code>lib.js</code>的例子。</p>\n<pre><code class=\"javascript\">// lib.js\nvar counter = 3;\nfunction incCounter() &#123;\n  counter++;\n&#125;\nmodule.exports = &#123;\n  counter: counter,\n  incCounter: incCounter,\n&#125;;\n</code></pre>\n<p>上面代码输出内部变量<code>counter</code>和改写这个变量的内部方法<code>incCounter</code>。然后，在<code>main.js</code>里面加载这个模块。</p>\n<pre><code class=\"javascript\">// main.js\nvar mod = require(&#39;./lib&#39;);\n\nconsole.log(mod.counter);  // 3\nmod.incCounter();\nconsole.log(mod.counter); // 3\n</code></pre>\n<p>上面代码说明，<code>lib.js</code>模块加载以后，它的内部变化就影响不到输出的<code>mod.counter</code>了。这是因为<code>mod.counter</code>是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p>\n<pre><code class=\"javascript\">// lib.js\nvar counter = 3;\nfunction incCounter() &#123;\n  counter++;\n&#125;\nmodule.exports = &#123;\n  get counter() &#123;\n    return counter\n  &#125;,\n  incCounter: incCounter,\n&#125;;\n</code></pre>\n<p>上面代码中，输出的<code>counter</code>属性实际上是一个取值器函数。现在再执行<code>main.js</code>，就可以正确读取内部变量<code>counter</code>的变动了。</p>\n<pre><code class=\"bash\">$ node main.js\n3\n4\n</code></pre>\n<p>ES6 模块的运行机制与 CommonJS 不一样。<strong>JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</strong>换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>\n<p>还是举上面的例子。</p>\n<pre><code class=\"javascript\">// lib.js\nexport let counter = 3;\nexport function incCounter() &#123;\n  counter++;\n&#125;\n\n// main.js\nimport &#123; counter, incCounter &#125; from &#39;./lib&#39;;\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 4\n</code></pre>\n<p>上面代码说明，ES6 模块输入的变量<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p>\n<p>再举一个出现在<code>export</code>一节中的例子。</p>\n<pre><code class=\"javascript\">// m1.js\nexport var foo = &#39;bar&#39;;\nsetTimeout(() =&gt; foo = &#39;baz&#39;, 500);\n\n// m2.js\nimport &#123;foo&#125; from &#39;./m1.js&#39;;\nconsole.log(foo);\nsetTimeout(() =&gt; console.log(foo), 500);\n</code></pre>\n<p>上面代码中，<code>m1.js</code>的变量<code>foo</code>，在刚加载时等于<code>bar</code>，过了 500 毫秒，又变为等于<code>baz</code>。</p>\n<p>让我们看看，<code>m2.js</code>能否正确读取这个变化。</p>\n<pre><code class=\"bash\">$ babel-node m2.js\n\nbar\nbaz\n</code></pre>\n<p>上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</p>\n<p><strong>由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</strong></p>\n<pre><code class=\"javascript\">// lib.js\nexport let obj = &#123;&#125;;\n\n// main.js\nimport &#123; obj &#125; from &#39;./lib&#39;;\n\nobj.prop = 123; // OK\nobj = &#123;&#125;; // TypeError\n</code></pre>\n<p>上面代码中，<code>main.js</code>从<code>lib.js</code>输入变量<code>obj</code>，可以对<code>obj</code>添加属性，但是重新赋值就会报错。因为变量<code>obj</code>指向的地址是只读的，不能重新赋值，这就好比<code>main.js</code>创造了一个名为<code>obj</code>的<code>const</code>变量。</p>\n<p>最后，<code>export</code>通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</p>\n<pre><code class=\"javascript\">// mod.js\nfunction C() &#123;\n  this.sum = 0;\n  this.add = function () &#123;\n    this.sum += 1;\n  &#125;;\n  this.show = function () &#123;\n    console.log(this.sum);\n  &#125;;\n&#125;\n\nexport let c = new C();\n</code></pre>\n<p>上面的脚本<code>mod.js</code>，输出的是一个<code>C</code>的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p>\n<pre><code class=\"javascript\">// x.js\nimport &#123;c&#125; from &#39;./mod&#39;;\nc.add();\n\n// y.js\nimport &#123;c&#125; from &#39;./mod&#39;;\nc.show();\n\n// main.js\nimport &#39;./x&#39;;\nimport &#39;./y&#39;;\n</code></pre>\n<p>现在执行<code>main.js</code>，输出的是<code>1</code>。</p>\n<pre><code class=\"bash\">$ babel-node main.js\n1\n</code></pre>\n<p>这就证明了<code>x.js</code>和<code>y.js</code>加载的都是<code>C</code>的同一个实例。</p>\n<hr>\n<h4 id=\"3-Node-js-的模块加载方法\"><a href=\"#3-Node-js-的模块加载方法\" class=\"headerlink\" title=\"3. Node.js 的模块加载方法\"></a>3. Node.js 的模块加载方法</h4><p><strong>概述</strong></p>\n<p>JavaScript 现在有两种模块。一种是 ES6 模块，简称 ESM；另一种是 CommonJS 模块，简称 CJS。</p>\n<p>CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用<code>require()</code>和<code>module.exports</code>，ES6 模块使用<code>import</code>和<code>export</code>。</p>\n<p>它们采用不同的加载方案。从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。</p>\n<p>Node.js 要求 ES6 模块采用<code>.mjs</code>后缀文件名。也就是说，只要脚本文件里面使用<code>import</code>或者<code>export</code>命令，<strong>那么就必须采用<code>.mjs</code>后缀名</strong>。Node.js 遇到<code>.mjs</code>文件，就认为它是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定<code>&quot;use strict&quot;</code>。</p>\n<p><strong>如果不希望将后缀名改成<code>.mjs</code>，可以在项目的<code>package.json</code>文件中，指定<code>type</code>字段为<code>module</code>。</strong></p>\n<pre><code class=\"javascript\">&#123;\n   &quot;type&quot;: &quot;module&quot;\n&#125;\n</code></pre>\n<p>一旦设置了以后，该项目的 JS 脚本，就被解释成 ES6 模块。</p>\n<pre><code class=\"bash\"># 解释成 ES6 模块\n$ node my-app.js\n</code></pre>\n<p><strong>如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成<code>.cjs</code>。如果没有<code>type</code>字段，或者<code>type</code>字段为<code>commonjs</code>，则<code>.js</code>脚本会被解释成 CommonJS 模块。</strong></p>\n<p>总结为一句话：**<code>.mjs</code>文件总是以 ES6 模块加载，<code>.cjs</code>文件总是以 CommonJS 模块加载，<code>.js</code>文件的加载取决于<code>package.json</code>里面<code>type</code>字段的设置。**</p>\n<p>注意，ES6 模块与 CommonJS 模块尽量不要混用。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错，只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code>。</p>\n<hr>\n<p><strong>package.json 的 main 字段</strong></p>\n<p><code>package.json</code>文件有两个字段可以指定模块的入口文件：<code>main</code>和<code>exports</code>。比较简单的模块，<strong>可以只使用<code>main</code>字段，指定模块加载的入口文件。</strong></p>\n<pre><code class=\"javascript\">// ./node_modules/es-module-package/package.json\n&#123;\n  &quot;type&quot;: &quot;module&quot;,\n  &quot;main&quot;: &quot;./src/index.js&quot;\n&#125;\n</code></pre>\n<p>上面代码指定项目的入口脚本为<code>./src/index.js</code>，它的格式为 ES6 模块。如果没有<code>type</code>字段，<code>index.js</code>就会被解释为 CommonJS 模块。</p>\n<p>然后，<code>import</code>命令就可以加载这个模块。</p>\n<pre><code class=\"javascript\">// ./my-app.mjs\n\nimport &#123; something &#125; from &#39;es-module-package&#39;;\n// 实际加载的是 ./node_modules/es-module-package/src/index.js\n</code></pre>\n<p>上面代码中，运行该脚本以后，Node.js 就会到<code>./node_modules</code>目录下面，寻找<code>es-module-package</code>模块，然后根据该模块<code>package.json</code>的<code>main</code>字段去执行入口文件。</p>\n<p>这时，如果用 CommonJS 模块的<code>require()</code>命令去加载<code>es-module-package</code>模块会报错，因为 CommonJS 模块不能处理<code>export</code>命令。</p>\n<hr>\n<p><strong>package.json 的 exports 字段</strong></p>\n<p><strong><code>exports</code>字段的优先级高于<code>main</code>字段。它有多种用法。</strong></p>\n<p><strong>（1）子目录别名</strong></p>\n<p><strong><code>package.json</code>文件的<code>exports</code>字段可以指定脚本或子目录的别名。</strong></p>\n<pre><code class=\"javascript\">// ./node_modules/es-module-package/package.json\n&#123;\n  &quot;exports&quot;: &#123;\n    &quot;./submodule&quot;: &quot;./src/submodule.js&quot;\n  &#125;\n&#125;\n</code></pre>\n<p>上面的代码指定<code>src/submodule.js</code>别名为<code>submodule</code>，然后就可以从别名加载这个文件。</p>\n<pre><code class=\"javascript\">import submodule from &#39;es-module-package/submodule&#39;;\n// 加载 ./node_modules/es-module-package/src/submodule.js\n</code></pre>\n<p>下面是子目录别名的例子。</p>\n<pre><code class=\"javascript\">// ./node_modules/es-module-package/package.json\n&#123;\n  &quot;exports&quot;: &#123;\n    &quot;./features/&quot;: &quot;./src/features/&quot;\n  &#125;\n&#125;\n\nimport feature from &#39;es-module-package/features/x.js&#39;;\n// 加载 ./node_modules/es-module-package/src/features/x.js\n</code></pre>\n<p>如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。</p>\n<pre><code class=\"javascript\">// 报错\nimport submodule from &#39;es-module-package/private-module.js&#39;;\n\n// 不报错\nimport submodule from &#39;./node_modules/es-module-package/private-module.js&#39;;\n</code></pre>\n<p><strong>（2）main 的别名</strong></p>\n<p><strong><code>exports</code>字段的别名如果是<code>.</code>，就代表模块的主入口，优先级高于<code>main</code>字段，并且可以直接简写成<code>exports</code>字段的值。</strong></p>\n<pre><code class=\"javascript\">&#123;\n  &quot;exports&quot;: &#123;\n    &quot;.&quot;: &quot;./main.js&quot;\n  &#125;\n&#125;\n\n// 等同于\n&#123;\n  &quot;exports&quot;: &quot;./main.js&quot;\n&#125;\n</code></pre>\n<p>由于<code>exports</code>字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。</p>\n<pre><code class=\"javascript\">&#123;\n  &quot;main&quot;: &quot;./main-legacy.cjs&quot;,\n  &quot;exports&quot;: &#123;\n    &quot;.&quot;: &quot;./main-modern.cjs&quot;\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是<code>main-legacy.cjs</code>，新版本的 Node.js 的入口文件是<code>main-modern.cjs</code>。</p>\n<p><strong>（3）条件加载</strong></p>\n<p>利用<code>.</code>这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 Node.js 运行的时候，打开<code>--experimental-conditional-exports</code>标志。</p>\n<pre><code class=\"javascript\">&#123;\n  &quot;type&quot;: &quot;module&quot;,\n  &quot;exports&quot;: &#123;\n    &quot;.&quot;: &#123;\n      &quot;require&quot;: &quot;./main.cjs&quot;,\n      &quot;default&quot;: &quot;./main.js&quot;\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，别名<code>.</code>的<code>require</code>条件指定<code>require()</code>命令的入口文件（即 CommonJS 的入口），<code>default</code>条件指定其他情况的入口（即 ES6 的入口）。</p>\n<p>上面的写法可以简写如下。</p>\n<pre><code class=\"javascript\">&#123;\n  &quot;exports&quot;: &#123;\n    &quot;require&quot;: &quot;./main.cjs&quot;,\n    &quot;default&quot;: &quot;./main.js&quot;\n  &#125;\n&#125;\n</code></pre>\n<p>注意，如果同时还有其他别名，就不能采用简写，否则会报错。</p>\n<pre><code class=\"javascript\">&#123;\n  // 报错\n  &quot;exports&quot;: &#123;\n    &quot;./feature&quot;: &quot;./lib/feature.js&quot;,\n    &quot;require&quot;: &quot;./main.cjs&quot;,\n    &quot;default&quot;: &quot;./main.js&quot;\n  &#125;\n&#125;\n</code></pre>\n<hr>\n<p><strong>CommonJS 模块加载 ES6 模块</strong></p>\n<p><strong>CommonJS 的<code>require()</code>命令不能加载 ES6 模块，会报错，只能使用<code>import()</code>这个方法加载。</strong></p>\n<pre><code class=\"javascript\">(async () =&gt; &#123;\n  await import(&#39;./my-app.mjs&#39;);\n&#125;)();\n</code></pre>\n<p>上面代码可以在 CommonJS 模块中运行。</p>\n<p><code>require()</code>不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层<code>await</code>命令，导致无法被同步加载。</p>\n<hr>\n<p><strong>ES6 模块加载 CommonJS 模块</strong></p>\n<p><strong>ES6 模块的<code>import</code>命令可以加载 CommonJS 模块，但是只能整体加载，不能只加载单一的输出项。</strong></p>\n<pre><code class=\"javascript\">// 正确\nimport packageMain from &#39;commonjs-package&#39;;\n\n// 报错\nimport &#123; method &#125; from &#39;commonjs-package&#39;;\n</code></pre>\n<p>这是因为 ES6 模块需要支持静态代码分析，而 CommonJS 模块的输出接口是<code>module.exports</code>，是一个对象，无法被静态分析，所以只能整体加载。</p>\n<p><strong>加载单一的输出项，可以写成下面这样。</strong></p>\n<pre><code class=\"javascript\">import packageMain from &#39;commonjs-package&#39;;\nconst &#123; method &#125; = packageMain;\n</code></pre>\n<p>还有一种变通的加载方法，就是使用 Node.js 内置的<code>module.createRequire()</code>方法。</p>\n<pre><code class=\"javascript\">// cjs.cjs\nmodule.exports = &#39;cjs&#39;;\n\n// esm.mjs\nimport &#123; createRequire &#125; from &#39;module&#39;;\n\nconst require = createRequire(import.meta.url);\n\nconst cjs = require(&#39;./cjs.cjs&#39;);\ncjs === &#39;cjs&#39;; // true\n</code></pre>\n<p>上面代码中，ES6 模块通过<code>module.createRequire()</code>方法可以加载 CommonJS 模块。但是，这种写法等于将 ES6 和 CommonJS 混在一起了，所以不建议使用。</p>\n<hr>\n<p><strong>同时支持两种格式的模块</strong></p>\n<p>一个模块同时要支持 CommonJS 和 ES6 两种格式，也很容易。</p>\n<p>如果原始模块是 ES6 格式，那么需要给出一个整体输出接口，比如<code>export default obj</code>，使得 CommonJS 可以用<code>import()</code>进行加载。</p>\n<p>如果原始模块是 CommonJS 格式，那么可以加一个包装层。</p>\n<pre><code class=\"javascript\">import cjsModule from &#39;../index.js&#39;;\nexport const foo = cjsModule.foo;\n</code></pre>\n<p>上面代码先整体输入 CommonJS 模块，然后再根据需要输出具名接口。</p>\n<p>你可以把这个文件的后缀名改为<code>.mjs</code>，或者将它放在一个子目录，再在这个子目录里面放一个单独的<code>package.json</code>文件，指明<code>&#123; type: &quot;module&quot; &#125;</code>。</p>\n<p>另一种做法是在<code>package.json</code>文件的<code>exports</code>字段，指明两种格式模块各自的加载入口。</p>\n<pre><code class=\"javascript\">&quot;exports&quot;：&#123;\n  &quot;require&quot;: &quot;./index.js&quot;，\n  &quot;import&quot;: &quot;./esm/wrapper.js&quot;\n&#125;\n</code></pre>\n<p>上面代码指定<code>require()</code>和<code>import</code>，加载该模块会自动切换到不一样的入口文件。</p>\n<hr>\n<p><strong>Node.js 的内置模块</strong></p>\n<p>Node.js 的内置模块可以整体加载，也可以加载指定的输出项。</p>\n<pre><code class=\"javascript\">// 整体加载\nimport EventEmitter from &#39;events&#39;;\nconst e = new EventEmitter();\n\n// 加载指定的输出项\nimport &#123; readFile &#125; from &#39;fs&#39;;\nreadFile(&#39;./foo.txt&#39;, (err, source) =&gt; &#123;\n  if (err) &#123;\n    console.error(err);\n  &#125; else &#123;\n    console.log(source);\n  &#125;\n&#125;);\n</code></pre>\n<hr>\n<p><strong>加载路径</strong></p>\n<p>ES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。<code>import</code>命令和<code>package.json</code>文件的<code>main</code>字段如果省略脚本的后缀名，会报错。</p>\n<pre><code class=\"javascript\">// ES6 模块中将报错\nimport &#123; something &#125; from &#39;./index&#39;;\n</code></pre>\n<p>为了与浏览器的<code>import</code>加载规则相同，Node.js 的<code>.mjs</code>文件支持 URL 路径。</p>\n<pre><code class=\"javascript\">import &#39;./foo.mjs?query=1&#39;; // 加载 ./foo 传入参数 ?query=1\n</code></pre>\n<p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有<code>:</code>、<code>%</code>、<code>#</code>、<code>?</code>等特殊字符，最好对这些字符进行转义。</p>\n<p>目前，Node.js 的<code>import</code>命令只支持加载本地模块（<code>file:</code>协议）和<code>data:</code>协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以<code>/</code>或<code>//</code>开头的路径）。</p>\n<hr>\n<p><strong>内部变量</strong></p>\n<p>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node.js 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。</p>\n<p><strong>首先，就是<code>this</code>关键字。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS 模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。</strong></p>\n<p>其次，以下这些顶层变量在 ES6 模块之中都是不存在的。</p>\n<ul>\n<li><code>arguments</code></li>\n<li><code>require</code></li>\n<li><code>module</code></li>\n<li><code>exports</code></li>\n<li><code>__filename</code></li>\n<li><code>__dirname</code></li>\n</ul>\n<hr>\n<h4 id=\"4-循环加载\"><a href=\"#4-循环加载\" class=\"headerlink\" title=\"4. 循环加载\"></a>4. 循环加载</h4><p><strong>“循环加载”（circular dependency）指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本。</strong></p>\n<pre><code class=\"javascript\">// a.js\nvar b = require(&#39;b&#39;);\n\n// b.js\nvar a = require(&#39;a&#39;);\n</code></pre>\n<p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</p>\n<p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，<strong>很容易出现<code>a</code>依赖<code>b</code>，<code>b</code>依赖<code>c</code>，<code>c</code>又依赖<code>a</code>这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</strong></p>\n<p><strong>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</strong></p>\n<hr>\n<p><strong>CommonJS 模块的加载原理</strong></p>\n<p>介绍 ES6 如何处理“循环加载”之前，先介绍目前最流行的 CommonJS 模块格式的加载原理。</p>\n<p><strong>CommonJS 的一个模块，就是一个脚本文件。<code>require</code>命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</strong></p>\n<pre><code class=\"javascript\">&#123;\n  id: &#39;...&#39;,\n  exports: &#123; ... &#125;,\n  loaded: true,\n  ...\n&#125;\n</code></pre>\n<p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的<code>id</code>属性是模块名，<code>exports</code>属性是模块输出的各个接口，<code>loaded</code>属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。</p>\n<p><strong>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。即使再次执行<code>require</code>命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</strong></p>\n<hr>\n<p><strong>CommonJS 模块的循环加载</strong></p>\n<p><strong>CommonJS 模块的重要特性是加载时执行，即脚本代码在<code>require</code>的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</strong></p>\n<p>让我们来看，Node <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2FwaS9tb2R1bGVzLmh0bWwjbW9kdWxlc19jeWNsZXM=\">官方文档</span>里面的例子。脚本文件<code>a.js</code>代码如下。</p>\n<pre><code class=\"javascript\">exports.done = false;\nvar b = require(&#39;./b.js&#39;);\nconsole.log(&#39;在 a.js 之中，b.done = %j&#39;, b.done);\nexports.done = true;\nconsole.log(&#39;a.js 执行完毕&#39;);\n</code></pre>\n<p>上面代码之中，<code>a.js</code>脚本先输出一个<code>done</code>变量，然后加载另一个脚本文件<code>b.js</code>。注意，此时<code>a.js</code>代码就停在这里，等待<code>b.js</code>执行完毕，再往下执行。</p>\n<p>再看<code>b.js</code>的代码。</p>\n<pre><code class=\"javascript\">exports.done = false;\nvar a = require(&#39;./a.js&#39;);\nconsole.log(&#39;在 b.js 之中，a.done = %j&#39;, a.done);\nexports.done = true;\nconsole.log(&#39;b.js 执行完毕&#39;);\n</code></pre>\n<p>上面代码之中，<code>b.js</code>执行到第二行，就会去加载<code>a.js</code>，这时，就发生了“循环加载”。系统会去<code>a.js</code>模块对应对象的<code>exports</code>属性取值，可是因为<code>a.js</code>还没有执行完，从<code>exports</code>属性只能取回已经执行的部分，而不是最后的值。</p>\n<p><code>a.js</code>已经执行的部分，只有一行。</p>\n<pre><code class=\"javascript\">exports.done = false;\n</code></pre>\n<p>因此，对于<code>b.js</code>来说，它从<code>a.js</code>只输入一个变量<code>done</code>，值为<code>false</code>。</p>\n<p>然后，<code>b.js</code>接着往下执行，等到全部执行完毕，再把执行权交还给<code>a.js</code>。于是，<code>a.js</code>接着往下执行，直到执行完毕。我们写一个脚本<code>main.js</code>，验证这个过程。</p>\n<pre><code class=\"javascript\">var a = require(&#39;./a.js&#39;);\nvar b = require(&#39;./b.js&#39;);\nconsole.log(&#39;在 main.js 之中, a.done=%j, b.done=%j&#39;, a.done, b.done);\n</code></pre>\n<p>执行<code>main.js</code>，运行结果如下。</p>\n<pre><code class=\"bash\">$ node main.js\n\n在 b.js 之中，a.done = false\nb.js 执行完毕\n在 a.js 之中，b.done = true\na.js 执行完毕\n在 main.js 之中, a.done=true, b.done=true\n</code></pre>\n<p>上面的代码证明了两件事。一是，在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。二是，<code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，而是输出缓存的<code>b.js</code>的执行结果，即它的第四行。</p>\n<pre><code class=\"javascript\">exports.done = true;\n</code></pre>\n<p><strong>总之，CommonJS 输入的是被输出值的拷贝，不是引用。</strong></p>\n<p><strong>另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值</strong>，两者可能会有差异。所以，输入变量的时候，必须非常小心。</p>\n<pre><code class=\"javascript\">var a = require(&#39;a&#39;); // 安全的写法\nvar foo = require(&#39;a&#39;).foo; // 危险的写法\n\nexports.good = function (arg) &#123;\n  return a.foo(&#39;good&#39;, arg); // 使用的是 a.foo 的最新值\n&#125;;\n\nexports.bad = function (arg) &#123;\n  return foo(&#39;bad&#39;, arg); // 使用的是一个部分加载时的值\n&#125;;\n</code></pre>\n<p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code>的值很可能后面会被改写，改用<code>require(&#39;a&#39;)</code>会更保险一点。</p>\n<hr>\n<p><strong>ES6 模块的循环加载</strong></p>\n<p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，<strong>如果使用<code>import</code>从一个模块加载变量（即<code>import foo from &#39;foo&#39;</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</strong></p>\n<p>请看下面这个例子。</p>\n<pre><code class=\"javascript\">// a.mjs\nimport &#123;bar&#125; from &#39;./b&#39;;\nconsole.log(&#39;a.mjs&#39;);\nconsole.log(bar);\nexport let foo = &#39;foo&#39;;\n\n// b.mjs\nimport &#123;foo&#125; from &#39;./a&#39;;\nconsole.log(&#39;b.mjs&#39;);\nconsole.log(foo);\nexport let bar = &#39;bar&#39;;\n</code></pre>\n<p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p>\n<pre><code class=\"bash\">$ node --experimental-modules a.mjs\nb.mjs\nReferenceError: foo is not defined\n</code></pre>\n<p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？</p>\n<p>让我们一行行来看，ES6 循环加载是怎么处理的。<strong>首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。</strong></p>\n<p><strong>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，<code>foo</code>已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</strong></p>\n<pre><code class=\"javascript\">// a.mjs\nimport &#123;bar&#125; from &#39;./b&#39;;\nconsole.log(&#39;a.mjs&#39;);\nconsole.log(bar());\nfunction foo() &#123; return &#39;foo&#39; &#125;\nexport &#123;foo&#125;;\n\n// b.mjs\nimport &#123;foo&#125; from &#39;./a&#39;;\nconsole.log(&#39;b.mjs&#39;);\nconsole.log(foo());\nfunction bar() &#123; return &#39;bar&#39; &#125;\nexport &#123;bar&#125;;\n</code></pre>\n<p>这时再执行<code>a.mjs</code>就可以得到预期结果。</p>\n<pre><code class=\"bash\">$ node --experimental-modules a.mjs\nb.mjs\nfoo\na.mjs\nbar\n</code></pre>\n<p><strong>这是因为函数具有提升作用，在执行<code>import &#123;bar&#125; from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。这也意味着，如果把函数<code>foo</code>改写成函数表达式，也会报错。</strong></p>\n<pre><code class=\"javascript\">// a.mjs\nimport &#123;bar&#125; from &#39;./b&#39;;\nconsole.log(&#39;a.mjs&#39;);\nconsole.log(bar());\nconst foo = () =&gt; &#39;foo&#39;;\nexport &#123;foo&#125;;\n</code></pre>\n<p>上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。</p>\n<p>我们再来看 ES6 模块加载器<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL01vZHVsZUxvYWRlci9lczYtbW9kdWxlLWxvYWRlci9ibG9iL21hc3Rlci9kb2NzL2NpcmN1bGFyLXJlZmVyZW5jZXMtYmluZGluZ3MubWQ=\">SystemJS</span>给出的一个例子。</p>\n<pre><code class=\"javascript\">// even.js\nimport &#123; odd &#125; from &#39;./odd&#39;\nexport var counter = 0;\nexport function even(n) &#123;\n  counter++;\n  return n === 0 || odd(n - 1);\n&#125;\n\n// odd.js\nimport &#123; even &#125; from &#39;./even&#39;;\nexport function odd(n) &#123;\n  return n !== 0 &amp;&amp; even(n - 1);\n&#125;\n</code></pre>\n<p>上面代码中，<code>even.js</code>里面的函数<code>even</code>有一个参数<code>n</code>，只要不等于 0，就会减去 1，传入加载的<code>odd()</code>。<code>odd.js</code>也会做类似操作。</p>\n<p>运行上面这段代码，结果如下。</p>\n<pre><code class=\"javascript\">$ babel-node\n&gt; import * as m from &#39;./even.js&#39;;\n&gt; m.even(10);\ntrue\n&gt; m.counter\n6\n&gt; m.even(20)\ntrue\n&gt; m.counter\n17\n</code></pre>\n<p>上面代码中，参数<code>n</code>从 10 变为 0 的过程中，<code>even()</code>一共会执行 6 次，所以变量<code>counter</code>等于 6。第二次调用<code>even()</code>时，参数<code>n</code>从 20 变为 0，<code>even()</code>一共会执行 11 次，加上前面的 6 次，所以变量<code>counter</code>等于 17。</p>\n<p>这个例子要是改写成 CommonJS，就根本无法执行，会报错。</p>\n<pre><code class=\"javascript\">// even.js\nvar odd = require(&#39;./odd&#39;);\nvar counter = 0;\nexports.counter = counter;\nexports.even = function (n) &#123;\n  counter++;\n  return n == 0 || odd(n - 1);\n&#125;\n\n// odd.js\nvar even = require(&#39;./even&#39;).even;\nmodule.exports = function (n) &#123;\n  return n != 0 &amp;&amp; even(n - 1);\n&#125;\n</code></pre>\n<p>上面代码中，<code>even.js</code>加载<code>odd.js</code>，而<code>odd.js</code>又去加载<code>even.js</code>，形成“循环加载”。这时，执行引擎就会输出<code>even.js</code>已经执行的部分（不存在任何结果），所以在<code>odd.js</code>之中，变量<code>even</code>等于<code>undefined</code>，等到后面调用<code>even(n - 1)</code>就会报错。</p>\n<pre><code class=\"bash\">$ node\n&gt; var m = require(&#39;./even&#39;);\n&gt; m.even(10)\nTypeError: even is not a function\n</code></pre>\n<h3 id=\"25、-编程风格\"><a href=\"#25、-编程风格\" class=\"headerlink\" title=\"25、 编程风格\"></a>25、 编程风格</h3><hr>\n<h4 id=\"1-块级作用域\"><a href=\"#1-块级作用域\" class=\"headerlink\" title=\"1. 块级作用域\"></a>1. 块级作用域</h4><p><strong>（1）let 取代 var</strong></p>\n<p>ES6 提出了两个新的声明变量的命令：<code>let</code>和<code>const</code>。其中，**<code>let</code>完全可以取代<code>var</code>，因为两者语义相同，而且<code>let</code>没有副作用。**</p>\n<pre><code class=\"javascript\">&#39;use strict&#39;;\n\nif (true) &#123;\n  let x = &#39;hello&#39;;\n&#125;\n\nfor (let i = 0; i &lt; 10; i++) &#123;\n  console.log(i);\n&#125;\n</code></pre>\n<p>上面代码如果用<code>var</code>替代<code>let</code>，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，<code>var</code>命令做不到这一点。</p>\n<p><code>var</code>命令存在变量提升效用，<code>let</code>命令没有这个问题。</p>\n<pre><code class=\"javascript\">&#39;use strict&#39;;\n\nif (true) &#123;\n  console.log(x); // ReferenceError\n  let x = &#39;hello&#39;;\n&#125;\n</code></pre>\n<p>上面代码如果使用<code>var</code>替代<code>let</code>，<code>console.log</code>那一行就不会报错，而是会输出<code>undefined</code>，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。</p>\n<p>所以，建议不再使用<code>var</code>命令，而是使用<code>let</code>命令取代。</p>\n<p><strong>（2）全局常量和线程安全</strong></p>\n<p><strong>在<code>let</code>和<code>const</code>之间，建议优先使用<code>const</code>，尤其是在全局环境，不应该设置变量，只应设置常量。</strong></p>\n<p><code>const</code>优于<code>let</code>有几个原因。一个是<code>const</code>可以提醒阅读程序的人，这个变量不应该改变；另一个是<code>const</code>比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；<strong>最后一个原因是 JavaScript 编译器会对<code>const</code>进行优化，所以多使用<code>const</code>，有利于提高程序的运行效率，也就是说<code>let</code>和<code>const</code>的本质区别，其实是编译器内部的处理不同。</strong></p>\n<pre><code class=\"javascript\">// bad\nvar a = 1, b = 2, c = 3;\n\n// good\nconst a = 1;\nconst b = 2;\nconst c = 3;\n\n// best\nconst [a, b, c] = [1, 2, 3];\n</code></pre>\n<p><strong><code>const</code>声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。</strong></p>\n<p><strong>所有的函数都应该设置为常量。</strong></p>\n<p>长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时<code>let</code>表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。</p>\n<hr>\n<h4 id=\"2-字符串\"><a href=\"#2-字符串\" class=\"headerlink\" title=\"2. 字符串\"></a>2. 字符串</h4><p><strong>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</strong></p>\n<pre><code class=\"javascript\">// bad\nconst a = &quot;foobar&quot;;\nconst b = &#39;foo&#39; + a + &#39;bar&#39;;\n\n// acceptable\nconst c = `foobar`;\n\n// good\nconst a = &#39;foobar&#39;;\nconst b = `foo$&#123;a&#125;bar`;\n</code></pre>\n<hr>\n<h4 id=\"3-解构赋值\"><a href=\"#3-解构赋值\" class=\"headerlink\" title=\"3. 解构赋值\"></a>3. 解构赋值</h4><p><strong>使用数组成员对变量赋值时，优先使用解构赋值。</strong></p>\n<pre><code class=\"javascript\">const arr = [1, 2, 3, 4];\n\n// bad\nconst first = arr[0];\nconst second = arr[1];\n\n// good\nconst [first, second] = arr;\n</code></pre>\n<p><strong>函数的参数如果是对象的成员，优先使用解构赋值。</strong></p>\n<pre><code class=\"javascript\">// bad\nfunction getFullName(user) &#123;\n  const firstName = user.firstName;\n  const lastName = user.lastName;\n&#125;\n\n// good\nfunction getFullName(obj) &#123;\n  const &#123; firstName, lastName &#125; = obj;\n&#125;\n\n// best\nfunction getFullName(&#123; firstName, lastName &#125;) &#123;\n&#125;\n</code></pre>\n<p><strong>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</strong>因为解构赋值时数组按顺序，对象不用</p>\n<pre><code class=\"javascript\">// bad\nfunction processInput(input) &#123;\n  return [left, right, top, bottom];\n&#125;\n\n// good\nfunction processInput(input) &#123;\n  return &#123; left, right, top, bottom &#125;;\n&#125;\n\nconst &#123; left, right &#125; = processInput(input);\n</code></pre>\n<hr>\n<h4 id=\"4-对象\"><a href=\"#4-对象\" class=\"headerlink\" title=\"4. 对象\"></a>4. 对象</h4><p><strong>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</strong></p>\n<pre><code class=\"javascript\">// bad\nconst a = &#123; k1: v1, k2: v2, &#125;;\nconst b = &#123;\n  k1: v1,\n  k2: v2\n&#125;;\n\n// good\nconst a = &#123; k1: v1, k2: v2 &#125;;\nconst b = &#123;\n  k1: v1,\n  k2: v2,\n&#125;;\n</code></pre>\n<p><strong>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign</code>方法。</strong></p>\n<pre><code class=\"javascript\">// bad\nconst a = &#123;&#125;;\na.x = 3;\n\n// if reshape unavoidable\nconst a = &#123;&#125;;\nObject.assign(a, &#123; x: 3 &#125;);\n\n// good\nconst a = &#123; x: null &#125;;\na.x = 3;\n</code></pre>\n<p><strong>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。</strong></p>\n<pre><code class=\"javascript\">// bad\nconst obj = &#123;\n  id: 5,\n  name: &#39;San Francisco&#39;,\n&#125;;\nobj[getKey(&#39;enabled&#39;)] = true;\n\n// good\nconst obj = &#123;\n  id: 5,\n  name: &#39;San Francisco&#39;,\n  [getKey(&#39;enabled&#39;)]: true,\n&#125;;\n</code></pre>\n<p>上面代码中，对象<code>obj</code>的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建<code>obj</code>的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。</p>\n<p><strong>另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。</strong></p>\n<pre><code class=\"javascript\">var ref = &#39;some value&#39;;\n\n// bad\nconst atom = &#123;\n  ref: ref,\n\n  value: 1,\n\n  addValue: function (value) &#123;\n    return atom.value + value;\n  &#125;,\n&#125;;\n\n// good\nconst atom = &#123;\n  ref,\n\n  value: 1,\n\n  addValue(value) &#123;\n    return atom.value + value;\n  &#125;,\n&#125;;\n</code></pre>\n<hr>\n<h4 id=\"5-数组\"><a href=\"#5-数组\" class=\"headerlink\" title=\"5. 数组\"></a>5. 数组</h4><p><strong>使用扩展运算符（…）拷贝数组。</strong></p>\n<pre><code class=\"javascript\">// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i &lt; len; i++) &#123;\n  itemsCopy[i] = items[i];\n&#125;\n\n// good\nconst itemsCopy = [...items];\n</code></pre>\n<p><strong>使用 Array.from 方法，将类似数组的对象转为数组。</strong></p>\n<pre><code class=\"javascript\">const foo = document.querySelectorAll(&#39;.foo&#39;);\nconst nodes = Array.from(foo);\n</code></pre>\n<hr>\n<h4 id=\"6-函数\"><a href=\"#6-函数\" class=\"headerlink\" title=\"6. 函数\"></a>6. 函数</h4><p>立即执行函数可以<strong>写成</strong>箭头函数的形式。</p>\n<pre><code class=\"javascript\">(() =&gt; &#123;\n  console.log(&#39;Welcome to the Internet.&#39;);\n&#125;)();\n</code></pre>\n<p><strong>那些使用匿名函数当作参数的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。</strong></p>\n<pre><code class=\"javascript\">// bad\n[1, 2, 3].map(function (x) &#123;\n  return x * x;\n&#125;);\n\n// good\n[1, 2, 3].map((x) =&gt; &#123;\n  return x * x;\n&#125;);\n\n// best\n[1, 2, 3].map(x =&gt; x * x);\n</code></pre>\n<p><strong>箭头函数取代<code>Function.prototype.bind</code>，不应再用 self/_this/that 绑定 this。</strong></p>\n<pre><code class=\"javascript\">// bad\nconst self = this;\nconst boundMethod = function(...params) &#123;\n  return method.apply(self, params);\n&#125;\n\n// acceptable\nconst boundMethod = method.bind(this);\n\n// best\nconst boundMethod = (...params) =&gt; method.apply(this, params);\n</code></pre>\n<p><strong>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。</strong></p>\n<p><strong>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。</strong></p>\n<pre><code class=\"javascript\">// bad\nfunction divide(a, b, option = false ) &#123;\n&#125;\n\n// good\nfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;\n&#125;\n</code></pre>\n<p><strong>不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。</strong></p>\n<pre><code class=\"javascript\">// bad\nfunction concatenateAll() &#123;\n  const args = Array.prototype.slice.call(arguments);\n  return args.join(&#39;&#39;);\n&#125;\n\n// good\nfunction concatenateAll(...args) &#123;\n  return args.join(&#39;&#39;);\n&#125;\n</code></pre>\n<p><strong>使用默认值语法设置函数参数的默认值。</strong></p>\n<pre><code class=\"javascript\">// bad\nfunction handleThings(opts) &#123;\n  opts = opts || &#123;&#125;;\n&#125;\n\n// good\nfunction handleThings(opts = &#123;&#125;) &#123;\n  // ...\n&#125;\n</code></pre>\n<hr>\n<h4 id=\"7-Map-结构\"><a href=\"#7-Map-结构\" class=\"headerlink\" title=\"7. Map 结构\"></a>7. Map 结构</h4><p><strong>注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要<code>key: value</code>的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制</strong>。需要for of循环就用Map。</p>\n<pre><code class=\"javascript\">let map = new Map(arr);\n\nfor (let key of map.keys()) &#123;\n  console.log(key);\n&#125;\n\nfor (let value of map.values()) &#123;\n  console.log(value);\n&#125;\n\nfor (let item of map.entries()) &#123;\n  console.log(item[0], item[1]);\n&#125;\n</code></pre>\n<hr>\n<h4 id=\"8-Class\"><a href=\"#8-Class\" class=\"headerlink\" title=\"8. Class\"></a>8. Class</h4><p><strong>总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。</strong></p>\n<pre><code class=\"javascript\">// bad\nfunction Queue(contents = []) &#123;\n  this._queue = [...contents];\n&#125;\nQueue.prototype.pop = function() &#123;\n  const value = this._queue[0];\n  this._queue.splice(0, 1);\n  return value;\n&#125;\n\n// good\nclass Queue &#123;\n  constructor(contents = []) &#123;\n    this._queue = [...contents];\n  &#125;\n  pop() &#123;\n    const value = this._queue[0];\n    this._queue.splice(0, 1);\n    return value;\n  &#125;\n&#125;\n</code></pre>\n<p><strong>使用<code>extends</code>实现继承，因为这样更简单，不会有破坏<code>instanceof</code>运算的危险。</strong></p>\n<pre><code class=\"javascript\">// bad\nconst inherits = require(&#39;inherits&#39;);\nfunction PeekableQueue(contents) &#123;\n  Queue.apply(this, contents);\n&#125;\ninherits(PeekableQueue, Queue);\nPeekableQueue.prototype.peek = function() &#123;\n  return this._queue[0];\n&#125;\n\n// good\nclass PeekableQueue extends Queue &#123;\n  peek() &#123;\n    return this._queue[0];\n  &#125;\n&#125;\n</code></pre>\n<hr>\n<h4 id=\"9-模块\"><a href=\"#9-模块\" class=\"headerlink\" title=\"9. 模块\"></a>9. 模块</h4><p>ES6 模块语法是 JavaScript 模块的标准写法，坚持使用这种写法，取代 Node.js 的 CommonJS 语法。</p>\n<p><strong>首先，使用<code>import</code>取代<code>require()</code>。</strong></p>\n<pre><code class=\"javascript\">// CommonJS 的写法\nconst moduleA = require(&#39;moduleA&#39;);\nconst func1 = moduleA.func1;\nconst func2 = moduleA.func2;\n\n// ES6 的写法\nimport &#123; func1, func2 &#125; from &#39;moduleA&#39;;\n</code></pre>\n<p><strong>其次，使用<code>export</code>取代<code>module.exports</code>。</strong></p>\n<pre><code class=\"javascript\">// commonJS 的写法\nvar React = require(&#39;react&#39;);\n\nvar Breadcrumbs = React.createClass(&#123;\n  render() &#123;\n    return &lt;nav /&gt;;\n  &#125;\n&#125;);\n\nmodule.exports = Breadcrumbs;\n\n// ES6 的写法\nimport React from &#39;react&#39;;\n\nclass Breadcrumbs extends React.Component &#123;\n  render() &#123;\n    return &lt;nav /&gt;;\n  &#125;\n&#125;;\n\nexport default Breadcrumbs;\n</code></pre>\n<p><strong>如果模块只有一个输出值，就使用<code>export default</code>，如果模块有多个输出值，除非其中某个输出值特别重要，否则建议不要使用<code>export default</code>，即多个输出值如果是平等关系，<code>export default</code>与普通的<code>export</code>就不要同时使用。</strong></p>\n<p><strong>如果模块默认输出一个函数，函数名的首字母应该小写，表示这是一个工具方法。</strong></p>\n<pre><code class=\"javascript\">function makeStyleGuide() &#123;\n&#125;\n\nexport default makeStyleGuide;\n</code></pre>\n<p><strong>如果模块默认输出一个对象，对象名的首字母应该大写，表示这是一个配置值对象。</strong></p>\n<pre><code class=\"javascript\">const StyleGuide = &#123;\n  es6: &#123;\n  &#125;\n&#125;;\n\nexport default StyleGuide;\n</code></pre>\n<hr>\n<h4 id=\"10-ESLint-的使用\"><a href=\"#10-ESLint-的使用\" class=\"headerlink\" title=\"10. ESLint 的使用\"></a>10. ESLint 的使用</h4><p>ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。</p>\n<p>首先，在项目的根目录安装 ESLint。</p>\n<pre><code class=\"bash\">$ npm install --save-dev eslint\n</code></pre>\n<p>然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。</p>\n<pre><code class=\"bash\">$ npm install --save-dev eslint-config-airbnb\n$ npm install --save-dev eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react\n</code></pre>\n<p>最后，在项目的根目录下新建一个<code>.eslintrc</code>文件，配置 ESLint。</p>\n<pre><code class=\"javascript\">&#123;\n  &quot;extends&quot;: &quot;eslint-config-airbnb&quot;\n&#125;\n</code></pre>\n<p>现在就可以检查，当前项目的代码是否符合预设的规则。</p>\n<p><code>index.js</code>文件的代码如下。</p>\n<pre><code class=\"javascript\">var unused = &#39;I have no purpose!&#39;;\n\nfunction greet() &#123;\n    var message = &#39;Hello, World!&#39;;\n    console.log(message);\n&#125;\n\ngreet();\n</code></pre>\n<p>使用 ESLint 检查这个文件，就会报出错误。</p>\n<pre><code class=\"bash\">$ npx eslint index.js\nindex.js\n  1:1  error  Unexpected var, use let or const instead          no-var\n  1:5  error  unused is defined but never used                 no-unused-vars\n  4:5  error  Expected indentation of 2 characters but found 4  indent\n  4:5  error  Unexpected var, use let or const instead          no-var\n  5:5  error  Expected indentation of 2 characters but found 4  indent\n\n✖ 5 problems (5 errors, 0 warnings)\n</code></pre>\n<p>上面代码说明，原文件有五个错误，其中两个是不应该使用<code>var</code>命令，而要使用<code>let</code>或<code>const</code>；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。</p>\n<h3 id=\"26、-异步遍历器\"><a href=\"#26、-异步遍历器\" class=\"headerlink\" title=\"26、 异步遍历器\"></a>26、 异步遍历器</h3><hr>\n<h4 id=\"1-同步遍历器的问题\"><a href=\"#1-同步遍历器的问题\" class=\"headerlink\" title=\"1. 同步遍历器的问题\"></a>1. 同步遍历器的问题</h4><p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>&#123;value, done&#125;</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p>\n<pre><code class=\"javascript\">function idMaker() &#123;\n  let index = 0;\n\n  return &#123;\n    next: function() &#123;\n      return &#123; value: index++, done: false &#125;;\n    &#125;\n  &#125;;\n&#125;\n\nconst it = idMaker();\n\nit.next().value // 0\nit.next().value // 1\nit.next().value // 2\n// ...\n</code></pre>\n<p>上面代码中，变量<code>it</code>是一个遍历器（iterator）。每次调用<code>it.next()</code>方法，就返回一个对象，表示当前遍历位置的信息。</p>\n<p>这里隐含着一个规定，<code>it.next()</code>方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行<code>it.next()</code>方法，就必须同步地得到<code>value</code>和<code>done</code>这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。</p>\n<pre><code class=\"javascript\">function idMaker() &#123;\n  let index = 0;\n\n  return &#123;\n    next: function() &#123;\n      return new Promise(function (resolve, reject) &#123;\n        setTimeout(() =&gt; &#123;\n          resolve(&#123; value: index++, done: false &#125;);\n        &#125;, 1000);\n      &#125;);\n    &#125;\n  &#125;;\n&#125;\n</code></pre>\n<p>上面代码中，<code>next()</code>方法返回的是一个 Promise 对象，这样就不行，不符合 Iterator 协议，只要代码里面包含异步操作都不行。也就是说，Iterator 协议里面<code>next()</code>方法只能包含同步操作。</p>\n<p>目前的解决方法是，将异步操作包装成 Thunk 函数或者 Promise 对象，即<code>next()</code>方法返回值的<code>value</code>属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而<code>done</code>属性则还是同步产生的。</p>\n<pre><code class=\"javascript\">function idMaker() &#123;\n  let index = 0;\n\n  return &#123;\n    next: function() &#123;\n      return &#123;\n        value: new Promise(resolve =&gt; setTimeout(() =&gt; resolve(index++), 1000)),\n        done: false\n      &#125;;\n    &#125;\n  &#125;;\n&#125;\n\nconst it = idMaker();\n\nit.next().value.then(o =&gt; console.log(o)) // 0\nit.next().value.then(o =&gt; console.log(o)) // 1\nit.next().value.then(o =&gt; console.log(o)) // 2\n// ...\n</code></pre>\n<p>上面代码中，<code>value</code>属性的返回值是一个 Promise 对象，用来放置异步操作。但是这样写很麻烦，不太符合直觉，语义也比较绕。</p>\n<p><strong>ES2018 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXN5bmMtaXRlcmF0aW9u\">引入</span>了“异步遍历器”（Async Iterator），为异步操作提供原生的遍历器接口，即<code>value</code>和<code>done</code>这两个属性都是异步产生。</strong></p>\n<hr>\n<h4 id=\"2-异步遍历的接口\"><a href=\"#2-异步遍历的接口\" class=\"headerlink\" title=\"2. 异步遍历的接口\"></a>2. 异步遍历的接口</h4><p><strong>异步遍历器的最大的语法特点，就是调用遍历器的<code>next</code>方法，返回的是一个 Promise 对象。</strong></p>\n<pre><code class=\"javascript\">asyncIterator\n  .next()\n  .then(\n    (&#123; value, done &#125;) =&gt; /* ... */\n  );\n</code></pre>\n<p>上面代码中，<code>asyncIterator</code>是一个异步遍历器，调用<code>next</code>方法以后，返回一个 Promise 对象。因此，可以使用<code>then</code>方法指定，这个 Promise 对象的状态变为<code>resolve</code>以后的回调函数。回调函数的参数，则是一个具有<code>value</code>和<code>done</code>两个属性的对象，这个跟同步遍历器是一样的。</p>\n<p>我们知道，一个对象的同步遍历器的接口，部署在<code>Symbol.iterator</code>属性上面。同样地，对象的异步遍历器接口，部署在<code>Symbol.asyncIterator</code>属性上面。不管是什么样的对象，只要它的<code>Symbol.asyncIterator</code>属性有值，就表示应该对它进行异步遍历。</p>\n<p>下面是一个异步遍历器的例子。</p>\n<pre><code class=\"javascript\">const asyncIterable = createAsyncIterable([&#39;a&#39;, &#39;b&#39;]);\nconst asyncIterator = asyncIterable[Symbol.asyncIterator]();\n\nasyncIterator\n.next()\n.then(iterResult1 =&gt; &#123;\n  console.log(iterResult1); // &#123; value: &#39;a&#39;, done: false &#125;\n  return asyncIterator.next();\n&#125;)\n.then(iterResult2 =&gt; &#123;\n  console.log(iterResult2); // &#123; value: &#39;b&#39;, done: false &#125;\n  return asyncIterator.next();\n&#125;)\n.then(iterResult3 =&gt; &#123;\n  console.log(iterResult3); // &#123; value: undefined, done: true &#125;\n&#125;);\n</code></pre>\n<p>上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个 Promise 对象；等到 Promise 对象<code>resolve</code>了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回 Promise 对象，作为中介。</p>\n<p>由于异步遍历器的<code>next</code>方法，返回的是一个 Promise 对象。因此，可以把它放在<code>await</code>命令后面。</p>\n<pre><code class=\"javascript\">async function f() &#123;\n  const asyncIterable = createAsyncIterable([&#39;a&#39;, &#39;b&#39;]);\n  const asyncIterator = asyncIterable[Symbol.asyncIterator]();\n  console.log(await asyncIterator.next());\n  // &#123; value: &#39;a&#39;, done: false &#125;\n  console.log(await asyncIterator.next());\n  // &#123; value: &#39;b&#39;, done: false &#125;\n  console.log(await asyncIterator.next());\n  // &#123; value: undefined, done: true &#125;\n&#125;\n</code></pre>\n<p>上面代码中，**<code>next</code>方法用<code>await</code>处理以后，就不必使用<code>then</code>方法了。整个流程已经很接近同步处理了。**</p>\n<p>注意，异步遍历器的<code>next</code>方法是可以连续调用的，不必等到上一步产生的 Promise 对象<code>resolve</code>以后再调用。这种情况下，<code>next</code>方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，<strong>把所有的<code>next</code>方法放在<code>Promise.all</code>方法里面。</strong></p>\n<pre><code class=\"javascript\">const asyncIterable = createAsyncIterable([&#39;a&#39;, &#39;b&#39;]);\nconst asyncIterator = asyncIterable[Symbol.asyncIterator]();\nconst [&#123;value: v1&#125;, &#123;value: v2&#125;] = await Promise.all([\n  asyncIterator.next(), asyncIterator.next()\n]);\n\nconsole.log(v1, v2); // a b\n</code></pre>\n<p><strong>另一种用法是一次性调用所有的<code>next</code>方法，然后<code>await</code>最后一步操作。</strong></p>\n<pre><code class=\"javascript\">async function runner() &#123;\n  const writer = openFile(&#39;someFile.txt&#39;);\n  writer.next(&#39;hello&#39;);\n  writer.next(&#39;world&#39;);\n  await writer.return();\n&#125;\n\nrunner();\n</code></pre>\n<hr>\n<h4 id=\"3-for-await…of\"><a href=\"#3-for-await…of\" class=\"headerlink\" title=\"3. for await…of\"></a>3. for await…of</h4><p>前面介绍过，**<code>for...of</code>循环用于遍历同步的 Iterator 接口。新引入的<code>for await...of</code>循环，则是用于遍历异步的 Iterator 接口。**</p>\n<pre><code class=\"javascript\">async function f() &#123;\n  for await (const x of createAsyncIterable([&#39;a&#39;, &#39;b&#39;])) &#123;\n    console.log(x);\n  &#125;\n&#125;\n// a\n// b\n</code></pre>\n<p>上面代码中，<code>createAsyncIterable()</code>返回一个拥有异步遍历器接口的对象，<code>for...of</code>循环自动调用这个对象的异步遍历器的<code>next</code>方法，会得到一个 Promise 对象。<code>await</code>用来处理这个 Promise 对象，一旦<code>resolve</code>，就把得到的值（<code>x</code>）传入<code>for...of</code>的循环体。</p>\n<p><code>for await...of</code>循环的一个用途，是部署了 asyncIterable 操作的异步接口，可以直接放入这个循环。</p>\n<pre><code class=\"javascript\">let body = &#39;&#39;;\n\nasync function f() &#123;\n  for await(const data of req) body += data;\n  const parsed = JSON.parse(body);\n  console.log(&#39;got&#39;, parsed);\n&#125;\n</code></pre>\n<p>上面代码中，<code>req</code>是一个 asyncIterable 对象，用来异步读取数据。可以看到，使用<code>for await...of</code>循环以后，代码会非常简洁。</p>\n<p><strong>如果<code>next</code>方法返回的 Promise 对象被<code>reject</code>，<code>for await...of</code>就会报错，要用<code>try...catch</code>捕捉。</strong></p>\n<pre><code class=\"javascript\">async function () &#123;\n  try &#123;\n    for await (const x of createRejectingIterable()) &#123;\n      console.log(x);\n    &#125;\n  &#125; catch (e) &#123;\n    console.error(e);\n  &#125;\n&#125;\n</code></pre>\n<p><strong>注意，<code>for await...of</code>循环也可以用于同步遍历器。</strong></p>\n<pre><code class=\"javascript\">(async function () &#123;\n  for await (const x of [&#39;a&#39;, &#39;b&#39;]) &#123;\n    console.log(x);\n  &#125;\n&#125;)();\n// a\n// b\n</code></pre>\n<p>Node v10 支持异步遍历器，Stream 就部署了这个接口。下面是读取文件的传统写法与异步遍历器写法的差异。</p>\n<pre><code class=\"javascript\">// 传统写法\nfunction main(inputFilePath) &#123;\n  const readStream = fs.createReadStream(\n    inputFilePath,\n    &#123; encoding: &#39;utf8&#39;, highWaterMark: 1024 &#125;\n  );\n  readStream.on(&#39;data&#39;, (chunk) =&gt; &#123;\n    console.log(&#39;&gt;&gt;&gt; &#39;+chunk);\n  &#125;);\n  readStream.on(&#39;end&#39;, () =&gt; &#123;\n    console.log(&#39;### DONE ###&#39;);\n  &#125;);\n&#125;\n\n// 异步遍历器写法\nasync function main(inputFilePath) &#123;\n  const readStream = fs.createReadStream(\n    inputFilePath,\n    &#123; encoding: &#39;utf8&#39;, highWaterMark: 1024 &#125;\n  );\n\n  for await (const chunk of readStream) &#123;\n    console.log(&#39;&gt;&gt;&gt; &#39;+chunk);\n  &#125;\n  console.log(&#39;### DONE ###&#39;);\n&#125;\n</code></pre>\n<hr>\n<h4 id=\"4-异步-Generator-函数\"><a href=\"#4-异步-Generator-函数\" class=\"headerlink\" title=\"4. 异步 Generator 函数\"></a>4. 异步 Generator 函数</h4><p>就像 Generator 函数返回一个同步遍历器对象一样，<strong>异步 Generator 函数的作用，是返回一个异步遍历器对象。</strong></p>\n<p><strong>在语法上，异步 Generator 函数就是<code>async</code>函数与 Generator 函数的结合。</strong></p>\n<pre><code class=\"javascript\">async function* gen() &#123;\n  yield &#39;hello&#39;;\n&#125;\nconst genObj = gen();\ngenObj.next().then(x =&gt; console.log(x));\n// &#123; value: &#39;hello&#39;, done: false &#125;\n</code></pre>\n<p>上面代码中，<code>gen</code>是一个异步 Generator 函数，执行后返回一个异步 Iterator 对象。对该对象调用<code>next</code>方法，返回一个 Promise 对象。</p>\n<p><strong>异步遍历器的设计目的之一，就是 Generator 函数处理同步操作和异步操作时，能够使用同一套接口。</strong></p>\n<pre><code class=\"javascript\">// 同步 Generator 函数\nfunction* map(iterable, func) &#123;\n  const iter = iterable[Symbol.iterator]();\n  while (true) &#123;\n    const &#123;value, done&#125; = iter.next();\n    if (done) break;\n    yield func(value);\n  &#125;\n&#125;\n\n// 异步 Generator 函数\nasync function* map(iterable, func) &#123;\n  const iter = iterable[Symbol.asyncIterator]();\n  while (true) &#123;\n    const &#123;value, done&#125; = await iter.next();\n    if (done) break;\n    yield func(value);\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，<code>map</code>是一个 Generator 函数，第一个参数是可遍历对象<code>iterable</code>，第二个参数是一个回调函数<code>func</code>。<code>map</code>的作用是将<code>iterable</code>每一步返回的值，使用<code>func</code>进行处理。上面有两个版本的<code>map</code>，前一个处理同步遍历器，后一个处理异步遍历器，可以看到两个版本的写法基本上是一致的。</p>\n<p>下面是另一个异步 Generator 函数的例子。</p>\n<pre><code class=\"javascript\">async function* readLines(path) &#123;\n  let file = await fileOpen(path);\n\n  try &#123;\n    while (!file.EOF) &#123;\n      yield await file.readLine();\n    &#125;\n  &#125; finally &#123;\n    await file.close();\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，异步操作前面使用<code>await</code>关键字标明，即<code>await</code>后面的操作，应该返回 Promise 对象。凡是使用<code>yield</code>关键字的地方，就是<code>next</code>方法停下来的地方，它后面的表达式的值（即<code>await file.readLine()</code>的值），会作为<code>next()</code>返回对象的<code>value</code>属性，这一点是与同步 Generator 函数一致的。</p>\n<p><strong>异步 Generator 函数内部，能够同时使用<code>await</code>和<code>yield</code>命令。可以这样理解，<code>await</code>命令用于将外部操作产生的值输入函数内部，<code>yield</code>命令用于将函数内部的值输出。</strong></p>\n<p>上面代码定义的异步 Generator 函数的用法如下。</p>\n<pre><code class=\"javascript\">(async function () &#123;\n  for await (const line of readLines(filePath)) &#123;\n    console.log(line);\n  &#125;\n&#125;)()\n</code></pre>\n<p>异步 Generator 函数可以与<code>for await...of</code>循环结合起来使用。</p>\n<pre><code class=\"javascript\">async function* prefixLines(asyncIterable) &#123;\n  for await (const line of asyncIterable) &#123;\n    yield &#39;&gt; &#39; + line;\n  &#125;\n&#125;\n</code></pre>\n<p>异步 Generator 函数的返回值是一个异步 Iterator，即每次调用它的<code>next</code>方法，会返回一个 Promise 对象，也就是说，跟在<code>yield</code>命令后面的，应该是一个 Promise 对象。如果像上面那个例子那样，<code>yield</code>命令后面是一个字符串，会被自动包装成一个 Promise 对象。</p>\n<pre><code class=\"javascript\">function fetchRandom() &#123;\n  const url = &#39;https://www.random.org/decimal-fractions/&#39;\n    + &#39;?num=1&amp;dec=10&amp;col=1&amp;format=plain&amp;rnd=new&#39;;\n  return fetch(url);\n&#125;\n\nasync function* asyncGenerator() &#123;\n  console.log(&#39;Start&#39;);\n  const result = await fetchRandom(); // (A)\n  yield &#39;Result: &#39; + await result.text(); // (B)\n  console.log(&#39;Done&#39;);\n&#125;\n\nconst ag = asyncGenerator();\nag.next().then((&#123;value, done&#125;) =&gt; &#123;\n  console.log(value);\n&#125;)\n</code></pre>\n<p>上面代码中，<code>ag</code>是<code>asyncGenerator</code>函数返回的异步遍历器对象。调用<code>ag.next()</code>以后，上面代码的执行顺序如下。</p>\n<ol>\n<li><code>ag.next()</code>立刻返回一个 Promise 对象。</li>\n<li><code>asyncGenerator</code>函数开始执行，打印出<code>Start</code>。</li>\n<li><code>await</code>命令返回一个 Promise 对象，<code>asyncGenerator</code>函数停在这里。</li>\n<li>A 处变成 fulfilled 状态，产生的值放入<code>result</code>变量，<code>asyncGenerator</code>函数继续往下执行。</li>\n<li>函数在 B 处的<code>yield</code>暂停执行，一旦<code>yield</code>命令取到值，<code>ag.next()</code>返回的那个 Promise 对象变成 fulfilled 状态。</li>\n<li><code>ag.next()</code>后面的<code>then</code>方法指定的回调函数开始执行。该回调函数的参数是一个对象<code>&#123;value, done&#125;</code>，其中<code>value</code>的值是<code>yield</code>命令后面的那个表达式的值，<code>done</code>的值是<code>false</code>。</li>\n</ol>\n<p>A 和 B 两行的作用类似于下面的代码。</p>\n<pre><code class=\"javascript\">return new Promise((resolve, reject) =&gt; &#123;\n  fetchRandom()\n  .then(result =&gt; result.text())\n  .then(result =&gt; &#123;\n     resolve(&#123;\n       value: &#39;Result: &#39; + result,\n       done: false,\n     &#125;);\n  &#125;);\n&#125;);\n</code></pre>\n<p><strong>如果异步 Generator 函数抛出错误，会导致 Promise 对象的状态变为<code>reject</code>，然后抛出的错误被<code>catch</code>方法捕获。</strong></p>\n<pre><code class=\"javascript\">async function* asyncGenerator() &#123;\n  throw new Error(&#39;Problem!&#39;);\n&#125;\n\nasyncGenerator()\n.next()\n.catch(err =&gt; console.log(err)); // Error: Problem!\n</code></pre>\n<p>注意，<strong>普通的 async 函数返回的是一个 Promise 对象，而异步 Generator 函数返回的是一个异步 Iterator 对象</strong>。可以这样理解，<strong>async 函数和异步 Generator 函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过<code>for await...of</code>执行，或者自己编写执行器。下面就是一个异步 Generator 函数的执行器。</strong></p>\n<pre><code class=\"javascript\">async function takeAsync(asyncIterable, count = Infinity) &#123;\n  const result = [];\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  while (result.length &lt; count) &#123;\n    const &#123;value, done&#125; = await iterator.next();\n    if (done) break;\n    result.push(value);\n  &#125;\n  return result;\n&#125;\n</code></pre>\n<p>上面代码中，异步 Generator 函数产生的异步遍历器，会通过<code>while</code>循环自动执行，每当<code>await iterator.next()</code>完成，就会进入下一轮循环。一旦<code>done</code>属性变为<code>true</code>，就会跳出循环，异步遍历器执行结束。</p>\n<p>下面是这个自动执行器的一个使用实例。</p>\n<pre><code class=\"javascript\">async function f() &#123;\n  async function* gen() &#123;\n    yield &#39;a&#39;;\n    yield &#39;b&#39;;\n    yield &#39;c&#39;;\n  &#125;\n\n  return await takeAsync(gen());\n&#125;\n\nf().then(function (result) &#123;\n  console.log(result); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n&#125;)\n</code></pre>\n<p>异步 Generator 函数出现以后，<strong>JavaScript 就有了四种函数形式：普通函数、async 函数、Generator 函数和异步 Generator 函数。</strong>请注意区分每种函数的不同之处。基本上，<strong>如果是一系列按照顺序执行的异步操作（比如读取文件，然后写入新内容，再存入硬盘），可以使用 async 函数；如果是一系列产生相同数据结构的异步操作（比如一行一行读取文件），可以使用异步 Generator 函数。</strong></p>\n<p><strong>异步 Generator 函数也可以通过<code>next</code>方法的参数，接收外部传入的数据。</strong></p>\n<pre><code class=\"javascript\">const writer = openFile(&#39;someFile.txt&#39;);\nwriter.next(&#39;hello&#39;); // 立即执行\nwriter.next(&#39;world&#39;); // 立即执行\nawait writer.return(); // 等待写入结束\n</code></pre>\n<p>上面代码中，<code>openFile</code>是一个异步 Generator 函数。<code>next</code>方法的参数，向该函数内部的操作传入数据。每次<code>next</code>方法都是同步执行的，最后的<code>await</code>命令用于等待整个写入操作结束。</p>\n<p>最后，同步的数据结构，也可以使用异步 Generator 函数。</p>\n<pre><code class=\"javascript\">async function* createAsyncIterable(syncIterable) &#123;\n  for (const elem of syncIterable) &#123;\n    yield elem;\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，由于没有异步操作，所以也就没有使用<code>await</code>关键字。</p>\n<hr>\n<h4 id=\"5-yield-语句\"><a href=\"#5-yield-语句\" class=\"headerlink\" title=\"5. yield* 语句\"></a>5. yield* 语句</h4><p><code>yield*</code>语句也可以跟一个异步遍历器。</p>\n<pre><code class=\"javascript\">async function* gen1() &#123;\n  yield &#39;a&#39;;\n  yield &#39;b&#39;;\n  return 2;\n&#125;\n\nasync function* gen2() &#123;\n  // result 最终会等于 2\n  const result = yield* gen1();\n&#125;\n</code></pre>\n<p>上面代码中，<code>gen2</code>函数里面的<code>result</code>变量，最后的值是<code>2</code>。</p>\n<p>与同步 Generator 函数一样，<code>for await...of</code>循环会展开<code>yield*</code>。</p>\n<pre><code class=\"javascript\">(async function () &#123;\n  for await (const x of gen2()) &#123;\n    console.log(x);\n  &#125;\n&#125;)();\n// a\n// b\n</code></pre>\n",
            "tags": [
                "前端",
                "ES6",
                "前端"
            ]
        },
        {
            "id": "https://1234cas.github.io/1234cas.github.io/qianduan/ES6/ES6%E4%B8%8A/",
            "url": "https://1234cas.github.io/1234cas.github.io/qianduan/ES6/ES6%E4%B8%8A/",
            "title": "ES6上",
            "date_published": "2022-03-27T08:52:26.088Z",
            "content_html": "<h3 id=\"1、let-和-const-命令\"><a href=\"#1、let-和-const-命令\" class=\"headerlink\" title=\"1、let 和 const 命令\"></a>1、let 和 const 命令</h3><hr>\n<h4 id=\"1-let-命令\"><a href=\"#1-let-命令\" class=\"headerlink\" title=\"1. let 命令\"></a>1. let 命令</h4><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>。</p>\n<blockquote>\n<pre><code class=\"javascript\">var a = [];\nfor (let i = 0; i &lt; 10; i++) &#123;\n  a[i] = function () &#123;\n    console.log(i);\n  &#125;;\n&#125;\na[6](); // 6\n</code></pre>\n<p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是<code>6</code>。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算。</p>\n<p><code>for</code>循环中设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域</p>\n<pre><code class=\"javascript\">for (let i = 0; i &lt; 3; i++) &#123;\n  let i = &#39;abc&#39;;\n  console.log(i);\n&#125;\n// abc\n// abc\n// abc\n</code></pre>\n<p>这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 <code>let</code> 重复声明同一个变量）。</p>\n</blockquote>\n<p><code>let</code>具有以下特点：</p>\n<ol>\n<li><p><strong>不存在变量提升</strong>。 在声明它之前，变量<code>bar</code>是不存在的，使用会报错ReferenceError。</p>\n</li>\n<li><p><strong>暂时性死区</strong>。在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。</p>\n</li>\n</ol>\n<pre><code class=\"javascript\">if (true) &#123;\n  // TDZ开始\n  tmp = &#39;abc&#39;; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n  let tmp; // TDZ结束\n  console.log(tmp); // undefined\n\n  tmp = 123;\n  console.log(tmp); // 123\n&#125;\n</code></pre>\n<pre><code class=\"javascript\">function bar(x = y, y = 2) &#123;\n  return [x, y];\n&#125;\n\nbar(); // 报错\n</code></pre>\n<pre><code class=\"javascript\">// 不报错\nvar x = x;\n\n// 报错\nlet x = x;\n// ReferenceError: x is not defined\n</code></pre>\n<p>使用<code>let</code>声明变量时，只要变量在还没有声明完成前使用，就会报错。</p>\n<ol start=\"3\">\n<li><strong>不允许重复声明</strong>。</li>\n</ol>\n<hr>\n<h4 id=\"2-块级作用域\"><a href=\"#2-块级作用域\" class=\"headerlink\" title=\"2. 块级作用域\"></a>2. 块级作用域</h4><p><code>let</code>实际上为 JavaScript 新增了块级作用域。</p>\n<p>块级作用域的出现使得获得广泛应用的立即执行函数不再必要了。</p>\n<p>应该避免在块级作用域内声明函数，如需要，优先使用函数表达式，不建议使用函数声明语句</p>\n<hr>\n<h4 id=\"3-const-命令\"><a href=\"#3-const-命令\" class=\"headerlink\" title=\"3. const 命令\"></a>3. const 命令</h4><p><strong>基本</strong></p>\n<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变，否则报错。</p>\n<p><code>const</code>一旦声明变量，就必须立即初始化，不能只声明不赋值，否则报错。</p>\n<p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。存在暂时性死区。不可重复声明。</p>\n<p><strong>本质</strong></p>\n<p><code>const</code>实际上保证的，并不是变量的值不变，而是变量指向的内存地址不变。</p>\n<p>对于简单数据类型的数据(Number、String、Boolean)，值就保存在变量所指向的内存地址，因此相当于常量。</p>\n<p>对于复杂类型(Object、Array)，变量指向的内存地址只是实际内存地址的一个引用，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），但是可以修改其中的数据。</p>\n<pre><code class=\"javascript\">const foo = &#123;&#125;;\n\n// 为 foo 添加一个属性，可以成功\nfoo.prop = 123;\nfoo.prop // 123\n\n// 将 foo 指向另一个对象，就会报错\nfoo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only\n</code></pre>\n<p>常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>\n<blockquote>\n<p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p>\n<pre><code class=\"javascript\">const foo = Object.freeze(&#123;&#125;);\n\n// 常规模式时，下面一行不起作用；\n// 严格模式时，该行会报错\nfoo.prop = 123;\n</code></pre>\n<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>\n<pre><code class=\"javascript\">var constantize = (obj) =&gt; &#123;\n  Object.freeze(obj);\n  Object.keys(obj).forEach( (key, i) =&gt; &#123;\n    if ( typeof obj[key] === &#39;object&#39; ) &#123;\n      constantize( obj[key] );\n    &#125;\n  &#125;);\n&#125;;\n</code></pre>\n</blockquote>\n<hr>\n<h4 id=\"4-顶层对象的属性\"><a href=\"#4-顶层对象的属性\" class=\"headerlink\" title=\"4. 顶层对象的属性\"></a>4. 顶层对象的属性</h4><p><strong>顶层对象</strong>，在浏览器环境指的是<code>window</code>对象，在 Node 指的是<code>global</code>对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p>\n<p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>\n<p>ES6 为了改变这一点，，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>\n<pre><code class=\"javascript\">var a = 1;\n// 如果在 Node 的 REPL 环境，可以写成 global.a\n// 或者采用通用方法，写成 this.a\nwindow.a // 1\n\nlet b = 1;\nwindow.b // undefined\n</code></pre>\n<p>全局变量<code>a</code>由<code>var</code>命令声明，所以它是顶层对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是顶层对象的属性，返回<code>undefined</code>。</p>\n<h3 id=\"2、变量的解构赋值\"><a href=\"#2、变量的解构赋值\" class=\"headerlink\" title=\"2、变量的解构赋值\"></a>2、变量的解构赋值</h3><hr>\n<h4 id=\"1-数组的解构赋值\"><a href=\"#1-数组的解构赋值\" class=\"headerlink\" title=\"1. 数组的解构赋值\"></a>1. 数组的解构赋值</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>\n<p>按照对应位置，对变量赋值。本质上，这种写法属于“<strong>模式匹配</strong>”，只要等号两边的<strong>模式</strong>相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子：</p>\n<pre><code class=\"javascript\">let [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];\nthird // &quot;baz&quot;\n\nlet [x, , y] = [1, 2, 3];\nx // 1\ny // 3\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [x, y, ...z] = [&#39;a&#39;];\nx // &quot;a&quot;\ny // undefined\nz // []\n</code></pre>\n<p>如果<strong>解构不成功</strong>，变量的值就等于<code>undefined</code>。</p>\n<pre><code class=\"javascript\">let [foo] = [];\nlet [bar, foo] = [1];\n</code></pre>\n<p>以上两种情况都属于解构不成功，<code>foo</code>的值都会等于<code>undefined</code>。</p>\n<p>另一种情况是<strong>不完全解构</strong>，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>\n<pre><code class=\"javascript\">let [x, y] = [1, 2, 3];\nx // 1\ny // 2\n\nlet [a, [b], d] = [1, [2, 3], 4];\na // 1\nb // 2\nd // 4\n</code></pre>\n<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p>\n<pre><code class=\"javascript\">// 报错\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = &#123;&#125;;\n</code></pre>\n<p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</p>\n<p>对于 Set 结构，也可以使用数组的解构赋值。</p>\n<pre><code class=\"javascript\">let [x, y, z] = new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);\nx // &quot;a&quot;\n</code></pre>\n<p>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p>\n<pre><code class=\"javascript\">function* fibs() &#123;\n  let a = 0;\n  let b = 1;\n  while (true) &#123;\n    yield a;\n    [a, b] = [b, a + b];\n  &#125;\n&#125;\n\nlet [first, second, third, fourth, fifth, sixth] = fibs();\nsixth // 5\n</code></pre>\n<p>上面代码中，<code>fibs</code>是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p>\n<hr>\n<h4 id=\"2-对象的解构赋值\"><a href=\"#2-对象的解构赋值\" class=\"headerlink\" title=\"2. 对象的解构赋值\"></a>2. 对象的解构赋值</h4><p>解构不仅可以用于数组，还可以用于对象。</p>\n<pre><code class=\"javascript\">let &#123; foo, bar &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;\nfoo // &quot;aaa&quot;\nbar // &quot;bbb&quot;\n</code></pre>\n<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>\n<pre><code class=\"javascript\">let &#123; bar, foo &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;\nfoo // &quot;aaa&quot;\nbar // &quot;bbb&quot;\n\nlet &#123; baz &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;\nbaz // undefined\n</code></pre>\n<p>如果解构失败，变量的值等于<code>undefined</code>。</p>\n<pre><code class=\"javascript\">let &#123;foo&#125; = &#123;bar: &#39;baz&#39;&#125;;\nfoo // undefined\n</code></pre>\n<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>\n<pre><code class=\"javascript\">// 例一\nlet &#123; log, sin, cos &#125; = Math;\n\n// 例二\nconst &#123; log &#125; = console;\nlog(&#39;hello&#39;) // hello\n</code></pre>\n<p>上面代码的例一将<code>Math</code>对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将<code>console.log</code>赋值到<code>log</code>变量。</p>\n<p>如果变量名与属性名不一致，必须写成下面这样。</p>\n<pre><code class=\"javascript\">let &#123; foo: baz &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;\nbaz // &quot;aaa&quot;\n\nlet obj = &#123; first: &#39;hello&#39;, last: &#39;world&#39; &#125;;\nlet &#123; first: f, last: l &#125; = obj;\nf // &#39;hello&#39;\nl // &#39;world&#39;\n</code></pre>\n<p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p>\n<pre><code class=\"javascript\">let &#123; foo: foo, bar: bar &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;\n</code></pre>\n<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>\n<pre><code class=\"javascript\">let &#123; foo: baz &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;\nbaz // &quot;aaa&quot;\nfoo // error: foo is not defined\n</code></pre>\n<p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p>\n<p>与数组一样，解构也可以用于嵌套结构的对象。</p>\n<pre><code class=\"javascript\">let obj = &#123;\n  p: [\n    &#39;Hello&#39;,\n    &#123; y: &#39;World&#39; &#125;\n  ]\n&#125;;\n\nlet &#123; p: [x, &#123; y &#125;] &#125; = obj;\nx // &quot;Hello&quot;\ny // &quot;World&quot;\n</code></pre>\n<p>注意，这时<code>p</code>是<strong>模式</strong>，不是变量，因此不会被赋值。如果<code>p</code>也要作为变量赋值，可以写成下面这样。</p>\n<pre><code class=\"javascript\">let obj = &#123;\n  p: [\n    &#39;Hello&#39;,\n    &#123; y: &#39;World&#39; &#125;\n  ]\n&#125;;\n\nlet &#123; p, p: [x, &#123; y &#125;] &#125; = obj;\nx // &quot;Hello&quot;\ny // &quot;World&quot;\np // [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]\n</code></pre>\n<p>下面是嵌套赋值的例子。</p>\n<pre><code class=\"javascript\">let obj = &#123;&#125;;\nlet arr = [];\n\n(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);\n\nobj // &#123;prop:123&#125;\narr // [true]\n</code></pre>\n<p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p>\n<pre><code class=\"javascript\">// 报错\nlet &#123;foo: &#123;bar&#125;&#125; = &#123;baz: &#39;baz&#39;&#125;;\n</code></pre>\n<p>上面代码中，等号左边对象的<code>foo</code>属性，对应一个子对象。该子对象的<code>bar</code>属性，解构时会报错。原因很简单，因为<code>foo</code>这时等于<code>undefined</code>，再取子属性就会报错。</p>\n<p><strong>默认值</strong></p>\n<p>对象的解构也可以指定默认值。</p>\n<pre><code class=\"javascript\">var &#123;x = 3&#125; = &#123;&#125;;\nx // 3\n\nvar &#123;x, y = 5&#125; = &#123;x: 1&#125;;\nx // 1\ny // 5\n\nvar &#123;x: y = 3&#125; = &#123;&#125;;\ny // 3\n\nvar &#123;x: y = 3&#125; = &#123;x: 5&#125;;\ny // 5\n\nvar &#123; message: msg = &#39;Something went wrong&#39; &#125; = &#123;&#125;;\nmsg // &quot;Something went wrong&quot;\n</code></pre>\n<p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p>\n<pre><code class=\"javascript\">var &#123;x = 3&#125; = &#123;x: undefined&#125;;\nx // 3\n\nvar &#123;x = 3&#125; = &#123;x: null&#125;;\nx // null\n</code></pre>\n<p>上面代码中，属性<code>x</code>等于<code>null</code>，因为<code>null</code>与<code>undefined</code>不严格相等，所以是个有效的赋值，导致默认值<code>3</code>不会生效。</p>\n<hr>\n<h4 id=\"3-函数参数的解构赋值\"><a href=\"#3-函数参数的解构赋值\" class=\"headerlink\" title=\"3. 函数参数的解构赋值\"></a>3. 函数参数的解构赋值</h4><p>函数的参数也可以使用解构赋值。</p>\n<pre><code class=\"javascript\">function add([x, y])&#123;\n  return x + y;\n&#125;\n\nadd([1, 2]); // 3\n</code></pre>\n<p>上面代码中，函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。</p>\n<p>下面是另一个例子。</p>\n<pre><code class=\"javascript\">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);\n// [ 3, 7 ]\n</code></pre>\n<p>函数参数的解构也可以使用默认值。</p>\n<pre><code class=\"javascript\">function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;\n  return [x, y];\n&#125;\n\nmove(&#123;x: 3, y: 8&#125;); // [3, 8]\nmove(&#123;x: 3&#125;); // [3, 0]\nmove(&#123;&#125;); // [0, 0]\nmove(); // [0, 0]\n</code></pre>\n<p>上面代码中，函数<code>move</code>的参数是一个对象，通过对这个对象进行解构，得到变量<code>x</code>和<code>y</code>的值。如果解构失败，<code>x</code>和<code>y</code>等于默认值。</p>\n<p>注意，下面的写法会得到不一样的结果。</p>\n<pre><code class=\"javascript\">function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;\n  return [x, y];\n&#125;\n\nmove(&#123;x: 3, y: 8&#125;); // [3, 8]\nmove(&#123;x: 3&#125;); // [3, undefined]\nmove(&#123;&#125;); // [undefined, undefined]\nmove(); // [0, 0]\n</code></pre>\n<p>上面代码是为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值，所以会得到与前一种写法不同的结果。</p>\n<p><code>undefined</code>就会触发函数参数的默认值。</p>\n<pre><code class=\"javascript\">[1, undefined, 3].map((x = &#39;yes&#39;) =&gt; x);\n// [ 1, &#39;yes&#39;, 3 ]\n</code></pre>\n<hr>\n<h4 id=\"4-用途\"><a href=\"#4-用途\" class=\"headerlink\" title=\"4. 用途\"></a>4. 用途</h4><p>变量的解构赋值用途很多。</p>\n<p><strong>（1）交换变量的值</strong></p>\n<pre><code class=\"javascript\">let x = 1;\nlet y = 2;\n\n[x, y] = [y, x];\n</code></pre>\n<p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>\n<p><strong>（2）从函数返回多个值</strong></p>\n<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>\n<pre><code class=\"javascript\">// 返回一个数组\n\nfunction example() &#123;\n  return [1, 2, 3];\n&#125;\nlet [a, b, c] = example();\n\n// 返回一个对象\n\nfunction example() &#123;\n  return &#123;\n    foo: 1,\n    bar: 2\n  &#125;;\n&#125;\nlet &#123; foo, bar &#125; = example();\n</code></pre>\n<p><strong>（3）函数参数的定义</strong></p>\n<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>\n<pre><code class=\"javascript\">// 参数是一组有次序的值\nfunction f([x, y, z]) &#123; ... &#125;\nf([1, 2, 3]);\n\n// 参数是一组无次序的值\nfunction f(&#123;x, y, z&#125;) &#123; ... &#125;\nf(&#123;z: 3, y: 2, x: 1&#125;);\n</code></pre>\n<p><strong>（4）提取 JSON 数据</strong></p>\n<p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p>\n<pre><code class=\"javascript\">let jsonData = &#123;\n  id: 42,\n  status: &quot;OK&quot;,\n  data: [867, 5309]\n&#125;;\n\nlet &#123; id, status, data: number &#125; = jsonData;\n\nconsole.log(id, status, number);\n// 42, &quot;OK&quot;, [867, 5309]\n</code></pre>\n<p>上面代码可以快速提取 JSON 数据的值。</p>\n<p><strong>（5）函数参数的默认值</strong></p>\n<pre><code class=\"javascript\">jQuery.ajax = function (url, &#123;\n  async = true,\n  beforeSend = function () &#123;&#125;,\n  cache = true,\n  complete = function () &#123;&#125;,\n  crossDomain = false,\n  global = true,\n  // ... more config\n&#125; = &#123;&#125;) &#123;\n  // ... do stuff\n&#125;;\n</code></pre>\n<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>\n<p><strong>（6）遍历 Map 结构</strong></p>\n<p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>\n<pre><code class=\"javascript\">const map = new Map();\nmap.set(&#39;first&#39;, &#39;hello&#39;);\nmap.set(&#39;second&#39;, &#39;world&#39;);\n\nfor (let [key, value] of map) &#123;\n  console.log(key + &quot; is &quot; + value);\n&#125;\n// first is hello\n// second is world\n</code></pre>\n<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>\n<pre><code class=\"javascript\">// 获取键名\nfor (let [key] of map) &#123;\n  // ...\n&#125;\n\n// 获取键值\nfor (let [,value] of map) &#123;\n  // ...\n&#125;\n</code></pre>\n<p><strong>（7）输入模块的指定方法</strong></p>\n<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>\n<pre><code class=\"javascript\">const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);\n</code></pre>\n<h3 id=\"3、字符串的扩展\"><a href=\"#3、字符串的扩展\" class=\"headerlink\" title=\"3、字符串的扩展\"></a>3、字符串的扩展</h3><hr>\n<h4 id=\"1-字符的-Unicode-表示法\"><a href=\"#1-字符的-Unicode-表示法\" class=\"headerlink\" title=\"1. 字符的 Unicode 表示法\"></a>1. 字符的 Unicode 表示法</h4><p>ES6 加强了对 Unicode 的支持，允许采用<code>\\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p>\n<pre><code class=\"javascript\">&quot;\\u0061&quot;\n// &quot;a&quot;\n</code></pre>\n<p>但是，这种表示法只限于码点在<code>\\u0000</code>~`\\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p>\n<pre><code class=\"javascript\">&quot;\\uD842\\uDFB7&quot;\n// &quot;𠮷&quot;\n\n&quot;\\u20BB7&quot;\n// &quot; 7&quot;\n</code></pre>\n<p>上面代码表示，如果直接在<code>\\u</code>后面跟上超过<code>0xFFFF</code>的数值（比如<code>\\u20BB7</code>），JavaScript 会理解成<code>\\u20BB+7</code>。由于<code>\\u20BB</code>是一个不可打印字符，所以只会显示一个空格，后面跟着一个<code>7</code>。</p>\n<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>\n<pre><code class=\"javascript\">&quot;\\u&#123;20BB7&#125;&quot;\n// &quot;𠮷&quot;\n\n&quot;\\u&#123;41&#125;\\u&#123;42&#125;\\u&#123;43&#125;&quot;\n// &quot;ABC&quot;\n\nlet hello = 123;\nhell\\u&#123;6F&#125; // 123\n\n&#39;\\u&#123;1F680&#125;&#39; === &#39;\\uD83D\\uDE80&#39;\n// true\n</code></pre>\n<p>上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p>\n<p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。</p>\n<pre><code class=\"javascript\">&#39;\\z&#39; === &#39;z&#39;  // true\n&#39;\\172&#39; === &#39;z&#39; // true\n&#39;\\x7A&#39; === &#39;z&#39; // true\n&#39;\\u007A&#39; === &#39;z&#39; // true\n&#39;\\u&#123;7A&#125;&#39; === &#39;z&#39; // true\n</code></pre>\n<hr>\n<h4 id=\"2-字符串的遍历器接口\"><a href=\"#2-字符串的遍历器接口\" class=\"headerlink\" title=\"2. 字符串的遍历器接口\"></a>2. 字符串的遍历器接口</h4><p>ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被<code>for...of</code>循环遍历。</p>\n<pre><code class=\"javascript\">for (let codePoint of &#39;foo&#39;) &#123;\n  console.log(codePoint)\n&#125;\n// &quot;f&quot;\n// &quot;o&quot;\n// &quot;o&quot;\n</code></pre>\n<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于<code>0xFFFF</code>的码点，传统的<code>for</code>循环无法识别这样的码点。</p>\n<pre><code class=\"javascript\">let text = String.fromCodePoint(0x20BB7);\n\nfor (let i = 0; i &lt; text.length; i++) &#123;\n  console.log(text[i]);\n&#125;\n// &quot; &quot;\n// &quot; &quot;\n\nfor (let i of text) &#123;\n  console.log(i);\n&#125;\n// &quot;𠮷&quot;\n</code></pre>\n<p>上面代码中，字符串<code>text</code>只有一个字符，但是<code>for</code>循环会认为它包含两个字符（都不可打印），而<code>for...of</code>循环会正确识别出这一个字符。</p>\n<hr>\n<h4 id=\"3-模板字符串\"><a href=\"#3-模板字符串\" class=\"headerlink\" title=\"3. 模板字符串\"></a>3. 模板字符串</h4><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>\n<pre><code class=\"javascript\">// 普通字符串\n`In JavaScript &#39;\\n&#39; is a line-feed.`\n\n// 多行字符串\n`In JavaScript this is\n not legal.`\n\nconsole.log(`string text line 1\nstring text line 2`);\n\n// 字符串中嵌入变量\nlet name = &quot;Bob&quot;, time = &quot;today&quot;;\n`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`\n</code></pre>\n<p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>\n<pre><code class=\"javascript\">let greeting = `\\`Yo\\` World!`;\n</code></pre>\n<p>所有模板字符串的空格和换行，都是被保留的，比如<code>&lt;ul&gt;</code>标签前面会有一个换行。如果你不想要这个换行，可以使用<code>trim</code>方法消除它。</p>\n<pre><code class=\"javascript\">$(&#39;#list&#39;).html(`\n&lt;ul&gt;\n  &lt;li&gt;first&lt;/li&gt;\n  &lt;li&gt;second&lt;/li&gt;\n&lt;/ul&gt;\n`.trim());\n</code></pre>\n<p><strong>模板字符串中嵌入变量，需要将变量名写在<code>$&#123;&#125;</code>之中。</strong></p>\n<pre><code class=\"javascript\">function authorize(user, action) &#123;\n  if (!user.hasPrivilege(action)) &#123;\n    throw new Error(\n      // 传统写法为\n      // &#39;User &#39;\n      // + user.name\n      // + &#39; is not authorized to do &#39;\n      // + action\n      // + &#39;.&#39;\n      `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`);\n  &#125;\n&#125;\n</code></pre>\n<p><strong>大括号内部可以放入任意的 JavaScript 表达式</strong>，可以进行运算，以及引用对象属性。</p>\n<pre><code class=\"javascript\">let x = 1;\nlet y = 2;\n\n`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`\n// &quot;1 + 2 = 3&quot;\n\n`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`\n// &quot;1 + 4 = 5&quot;\n\nlet obj = &#123;x: 1, y: 2&#125;;\n`$&#123;obj.x + obj.y&#125;`\n// &quot;3&quot;\n</code></pre>\n<p><strong>模板字符串之中还能调用函数</strong>。</p>\n<pre><code class=\"javascript\">function fn() &#123;\n  return &quot;Hello World&quot;;\n&#125;\n\n`foo $&#123;fn()&#125; bar`\n// foo Hello World bar\n</code></pre>\n<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法。</p>\n<p>如果模板字符串中的变量没有声明，将报错。</p>\n<pre><code class=\"javascript\">// 变量place没有声明\nlet msg = `Hello, $&#123;place&#125;`;\n// 报错\n</code></pre>\n<p>由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。</p>\n<pre><code class=\"javascript\">`Hello $&#123;&#39;World&#39;&#125;`\n// &quot;Hello World&quot;\n</code></pre>\n<p>模板字符串甚至还能嵌套。</p>\n<pre><code class=\"javascript\">const tmpl = addrs =&gt; `\n  &lt;table&gt;\n  $&#123;addrs.map(addr =&gt; `\n    &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt;\n    &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt;\n  `).join(&#39;&#39;)&#125;\n  &lt;/table&gt;\n`;\n</code></pre>\n<p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。</p>\n<pre><code class=\"javascript\">const data = [\n    &#123; first: &#39;&lt;Jane&gt;&#39;, last: &#39;Bond&#39; &#125;,\n    &#123; first: &#39;Lars&#39;, last: &#39;&lt;Croft&gt;&#39; &#125;,\n];\n\nconsole.log(tmpl(data));\n// &lt;table&gt;\n//\n//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;\n//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;\n//\n//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;\n//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;\n//\n// &lt;/table&gt;\n</code></pre>\n<p>如果需要引用模板字符串本身，在需要时执行，可以写成函数。</p>\n<pre><code class=\"javascript\">let func = (name) =&gt; `Hello $&#123;name&#125;!`;\nfunc(&#39;Jack&#39;) // &quot;Hello Jack!&quot;\n</code></pre>\n<p>上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。</p>\n<hr>\n<h4 id=\"4-实例：模板编译\"><a href=\"#4-实例：模板编译\" class=\"headerlink\" title=\"4. 实例：模板编译\"></a>4. 实例：模板编译</h4><p>下面，我们来看一个通过模板字符串，生成正式模板的实例。</p>\n<pre><code class=\"javascript\">let template = `\n&lt;ul&gt;\n  &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt;\n    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;\n  &lt;% &#125; %&gt;\n&lt;/ul&gt;\n`;\n</code></pre>\n<p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用<code>&lt;%...%&gt;</code>放置 JavaScript 代码，使用<code>&lt;%= ... %&gt;</code>输出 JavaScript 表达式。</p>\n<p>怎么编译这个模板字符串呢？</p>\n<p>一种思路是将其转换为 JavaScript 表达式字符串。</p>\n<pre><code class=\"javascript\">echo(&#39;&lt;ul&gt;&#39;);\nfor(let i=0; i &lt; data.supplies.length; i++) &#123;\n  echo(&#39;&lt;li&gt;&#39;);\n  echo(data.supplies[i]);\n  echo(&#39;&lt;/li&gt;&#39;);\n&#125;;\necho(&#39;&lt;/ul&gt;&#39;);\n</code></pre>\n<p>这个转换使用正则表达式就行了。</p>\n<pre><code class=\"javascript\">let evalExpr = /&lt;%=(.+?)%&gt;/g;\nlet expr = /&lt;%([\\s\\S]+?)%&gt;/g;\n\ntemplate = template\n  .replace(evalExpr, &#39;`); \\n  echo( $1 ); \\n  echo(`&#39;)\n  .replace(expr, &#39;`); \\n $1 \\n  echo(`&#39;);\n\ntemplate = &#39;echo(`&#39; + template + &#39;`);&#39;;\n</code></pre>\n<p>然后，将<code>template</code>封装在一个函数里面返回，就可以了。</p>\n<pre><code class=\"javascript\">let script =\n`(function parse(data)&#123;\n  let output = &quot;&quot;;\n\n  function echo(html)&#123;\n    output += html;\n  &#125;\n\n  $&#123; template &#125;\n\n  return output;\n&#125;)`;\n\nreturn script;\n</code></pre>\n<p>将上面的内容拼装成一个模板编译函数<code>compile</code>。</p>\n<pre><code class=\"javascript\">function compile(template)&#123;\n  const evalExpr = /&lt;%=(.+?)%&gt;/g;\n  const expr = /&lt;%([\\s\\S]+?)%&gt;/g;\n\n  template = template\n    .replace(evalExpr, &#39;`); \\n  echo( $1 ); \\n  echo(`&#39;)\n    .replace(expr, &#39;`); \\n $1 \\n  echo(`&#39;);\n\n  template = &#39;echo(`&#39; + template + &#39;`);&#39;;\n\n  let script =\n  `(function parse(data)&#123;\n    let output = &quot;&quot;;\n\n    function echo(html)&#123;\n      output += html;\n    &#125;\n\n    $&#123; template &#125;\n\n    return output;\n  &#125;)`;\n\n  return script;\n&#125;\n</code></pre>\n<p><code>compile</code>函数的用法如下。</p>\n<pre><code class=\"javascript\">let parse = eval(compile(template));\ndiv.innerHTML = parse(&#123; supplies: [ &quot;broom&quot;, &quot;mop&quot;, &quot;cleaner&quot; ] &#125;);\n//   &lt;ul&gt;\n//     &lt;li&gt;broom&lt;/li&gt;\n//     &lt;li&gt;mop&lt;/li&gt;\n//     &lt;li&gt;cleaner&lt;/li&gt;\n//   &lt;/ul&gt;\n</code></pre>\n<hr>\n<h4 id=\"5-标签模板\"><a href=\"#5-标签模板\" class=\"headerlink\" title=\"5. 标签模板\"></a>5. 标签模板</h4><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p>\n<pre><code class=\"javascript\">alert`hello`\n// 等同于\nalert([&#39;hello&#39;])\n</code></pre>\n<p>标签模板其实不是模板，<strong>而是函数调用的一种特殊形式</strong>。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>\n<p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p>\n<pre><code class=\"javascript\">let a = 5;\nlet b = 10;\n\ntag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;\n// 等同于\ntag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 15, 50);\n</code></pre>\n<p>上面代码中，模板字符串前面有一个标识名<code>tag</code>，它是一个函数。整个表达式的返回值，就是<code>tag</code>函数处理模板字符串后的返回值。</p>\n<p>函数<code>tag</code>依次会接收到多个参数。</p>\n<pre><code class=\"javascript\">function tag(stringArr, value1, value2)&#123;\n  // ...\n&#125;\n\n// 等同于\n\nfunction tag(stringArr, ...values)&#123;\n  // ...\n&#125;\n</code></pre>\n<p><code>tag</code>函数的第一个参数是一个数组，<strong>该数组的成员是模板字符串中那些没有变量替换的部分</strong>，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>\n<p><code>tag</code>函数的其他参数，都是<strong>模板字符串各个变量被替换后的值</strong>。由于本例中，模板字符串含有两个变量，因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数。</p>\n<p><code>tag</code>函数所有参数的实际值如下。</p>\n<ul>\n<li>第一个参数：<code>[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;]</code></li>\n<li>第二个参数: 15</li>\n<li>第三个参数：50</li>\n</ul>\n<p>我们可以按照需要编写<code>tag</code>函数的代码。下面是<code>tag</code>函数的一种写法，以及运行结果。</p>\n<pre><code class=\"javascript\">let a = 5;\nlet b = 10;\n\nfunction tag(s, v1, v2) &#123;\n  console.log(s[0]);\n  console.log(s[1]);\n  console.log(s[2]);\n  console.log(v1);\n  console.log(v2);\n\n  return &quot;OK&quot;;\n&#125;\n\ntag`Hello $&#123; a + b &#125; world $&#123; a * b&#125;`;\n// &quot;Hello &quot;\n// &quot; world &quot;\n// &quot;&quot;\n// 15\n// 50\n// &quot;OK&quot;\n</code></pre>\n<p>下面是一个更复杂的例子。</p>\n<pre><code class=\"javascript\">let total = 30;\nlet msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;\n\nfunction passthru(literals) &#123;\n  let result = &#39;&#39;;\n  let i = 0;\n//literals是形参 要求传入 arguments是实参 实际传入\n  while (i &lt; literals.length) &#123;\n    result += literals[i++];\n    if (i &lt; arguments.length) &#123;\n      result += arguments[i];\n    &#125;\n  &#125;\n\n  return result;\n&#125;\n\nmsg // &quot;The total is 30 (31.5 with tax)&quot;\n</code></pre>\n<p>上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。</p>\n<p><code>passthru</code>函数采用 rest 参数的写法如下。</p>\n<pre><code class=\"javascript\">function passthru(literals, ...values) &#123;\n  let output = &quot;&quot;;\n  let index;\n  for (index = 0; index &lt; values.length; index++) &#123;\n    output += literals[index] + values[index];\n  &#125;\n\n  output += literals[index]\n  return output;\n&#125;\n</code></pre>\n<p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p>\n<pre><code class=\"javascript\">let message =\n  SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;\n\nfunction SaferHTML(templateData) &#123;\n  let s = templateData[0];\n  for (let i = 1; i &lt; arguments.length; i++) &#123;\n    let arg = String(arguments[i]);\n\n    // Escape special characters in the substitution.\n    s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;)\n            .replace(/&lt;/g, &quot;&amp;lt;&quot;)\n            .replace(/&gt;/g, &quot;&amp;gt;&quot;);\n\n    // Don&#39;t escape special characters in the template.\n    s += templateData[i];\n  &#125;\n  return s;\n&#125;\n</code></pre>\n<p>上面代码中，<code>sender</code>变量往往是用户提供的，经过<code>SaferHTML</code>函数处理，里面的特殊字符都会被转义。</p>\n<pre><code class=\"javascript\">let sender = &#39;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#39;; // 恶意代码\nlet message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;\n\nmessage\n// &lt;p&gt;&amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;\n</code></pre>\n<p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p>\n<pre><code class=\"javascript\">i18n`Welcome to $&#123;siteName&#125;, you are visitor number $&#123;visitorNumber&#125;!`\n// &quot;欢迎访问xxx，您是第xxxx位访问者！&quot;\n</code></pre>\n<p>模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。</p>\n<pre><code class=\"javascript\">// 下面的hashTemplate函数\n// 是一个自定义的模板处理函数\nlet libraryHtml = hashTemplate`\n  &lt;ul&gt;\n    #for book in $&#123;myBooks&#125;\n      &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;\n    #end\n  &lt;/ul&gt;\n`;\n</code></pre>\n<p>模板处理函数的第一个参数（模板字符串数组），还有一个<code>raw</code>属性。</p>\n<pre><code class=\"javascript\">console.log`123`\n// [&quot;123&quot;, raw: Array[1]]\n</code></pre>\n<p>上面代码中，<code>console.log</code>接受的参数，实际上是一个数组。该数组有一个<code>raw</code>属性，保存的是转义后的原字符串。</p>\n<p>请看下面的例子。</p>\n<pre><code class=\"javascript\">tag`First line\\nSecond line`\n\nfunction tag(strings) &#123;\n  console.log(strings.raw[0]);\n  // strings.raw[0] 为 &quot;First line\\\\nSecond line&quot;\n  // 打印输出 &quot;First line\\nSecond line&quot;\n&#125;\n</code></pre>\n<h3 id=\"4、字符串的新增方法\"><a href=\"#4、字符串的新增方法\" class=\"headerlink\" title=\"4、字符串的新增方法\"></a>4、字符串的新增方法</h3><hr>\n<h4 id=\"1-String-fromCodePoint\"><a href=\"#1-String-fromCodePoint\" class=\"headerlink\" title=\"1. String.fromCodePoint()\"></a>1. String.fromCodePoint()</h4><p>ES5 提供<code>String.fromCharCode()</code>方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符。</p>\n<pre><code class=\"javascript\">String.fromCharCode(0x20BB7)\n// &quot;ஷ&quot;\n</code></pre>\n<p>上面代码中，<code>String.fromCharCode()</code>不能识别大于<code>0xFFFF</code>的码点，所以<code>0x20BB7</code>就发生了溢出，最高位<code>2</code>被舍弃了，最后返回码点<code>U+0BB7</code>对应的字符，而不是码点<code>U+20BB7</code>对应的字符。</p>\n<p><strong>ES6 提供了<code>String.fromCodePoint()</code>方法，可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode()</code>方法的不足。在作用上，正好与下面的<code>codePointAt()</code>方法相反。</strong></p>\n<pre><code class=\"javascript\">String.fromCodePoint(0x20BB7)\n// &quot;𠮷&quot;\nString.fromCodePoint(0x78, 0x1f680, 0x79) === &#39;x\\uD83D\\uDE80y&#39;\n// true\n</code></pre>\n<p>上面代码中，如果<code>String.fromCodePoint</code>方法有多个参数，则它们会被合并成一个字符串返回。</p>\n<p>注意，<code>fromCodePoint</code>方法定义在<code>String</code>对象上，而<code>codePointAt</code>方法定义在字符串的实例对象上。</p>\n<hr>\n<h4 id=\"2-String-raw\"><a href=\"#2-String-raw\" class=\"headerlink\" title=\"2. String.raw()\"></a>2. String.raw()</h4><p>ES6 还为原生的 String 对象，<strong>提供了一个<code>raw()</code>方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</strong></p>\n<pre><code class=\"javascript\">String.raw`Hi\\n$&#123;2+3&#125;!`\n// 实际返回 &quot;Hi\\\\n5!&quot;，显示的是转义后的结果 &quot;Hi\\n5!&quot;\n\nString.raw`Hi\\u000A!`;\n// 实际返回 &quot;Hi\\\\u000A!&quot;，显示的是转义后的结果 &quot;Hi\\u000A!&quot;\n</code></pre>\n<p>如果原字符串的斜杠已经转义，那么<code>String.raw()</code>会进行再次转义。</p>\n<pre><code class=\"javascript\">String.raw`Hi\\\\n`\n// 返回 &quot;Hi\\\\\\\\n&quot;\n\nString.raw`Hi\\\\n` === &quot;Hi\\\\\\\\n&quot; // true\n</code></pre>\n<p><code>String.raw()</code>方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p>\n<p><code>String.raw()</code>本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组，对应模板字符串解析后的值。</p>\n<pre><code class=\"javascript\">// `foo$&#123;1 + 2&#125;bar`\n// 等同于\nString.raw(&#123; raw: [&#39;foo&#39;, &#39;bar&#39;] &#125;, 1 + 2) // &quot;foo3bar&quot;\n</code></pre>\n<p>上面代码中，<code>String.raw()</code>方法的第一个参数是一个对象，它的<code>raw</code>属性等同于原始的模板字符串解析后得到的数组。</p>\n<p>作为函数，<code>String.raw()</code>的代码实现基本如下。</p>\n<pre><code class=\"javascript\">String.raw = function (strings, ...values) &#123;\n  let output = &#39;&#39;;\n  let index;\n  for (index = 0; index &lt; values.length; index++) &#123;\n    output += strings.raw[index] + values[index];\n  &#125;\n\n  output += strings.raw[index]\n  return output;\n&#125;\n</code></pre>\n<hr>\n<h4 id=\"3-实例方法：codePointAt\"><a href=\"#3-实例方法：codePointAt\" class=\"headerlink\" title=\"3. 实例方法：codePointAt()\"></a>3. 实例方法：codePointAt()</h4><p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为<code>2</code>个字节。对于那些需要<code>4</code>个字节储存的字符（Unicode 码点大于<code>0xFFFF</code>的字符），JavaScript 会认为它们是两个字符。</p>\n<pre><code class=\"javascript\">var s = &quot;𠮷&quot;;\n\ns.length // 2\ns.charAt(0) // &#39;&#39;\ns.charAt(1) // &#39;&#39;\ns.charCodeAt(0) // 55362\ns.charCodeAt(1) // 57271\n</code></pre>\n<p>上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是<code>0x20BB7</code>，UTF-16 编码为<code>0xD842 0xDFB7</code>（十进制为<code>55362 57271</code>），<strong>需要<code>4</code>个字节储存</strong>。对于这种<code>4</code>个字节的字符，JavaScript 不能正确处理，字符串长度会误判为<code>2</code>，而且<code>charAt()</code>方法无法读取整个字符，<code>charCodeAt()</code>方法只能分别返回前两个字节和后两个字节的值。</p>\n<p><strong>ES6 提供了<code>codePointAt()</code>方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</strong></p>\n<pre><code class=\"javascript\">let s = &#39;𠮷a&#39;;\n\ns.codePointAt(0) // 134071\ns.codePointAt(1) // 57271\n\ns.codePointAt(2) // 97\n</code></pre>\n<p><code>codePointAt()</code>方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的<code>20BB7</code>）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，<code>codePointAt()</code>方法的结果与<code>charCodeAt()</code>方法相同。</p>\n<p>总之，<code>codePointAt()</code>方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与<code>charCodeAt()</code>方法相同。</p>\n<p><code>codePointAt()</code>方法返回的是码点的十进制值，如果想要十六进制的值，可以使用<code>toString()</code>方法转换一下。</p>\n<pre><code class=\"javascript\">let s = &#39;𠮷a&#39;;\n\ns.codePointAt(0).toString(16) // &quot;20bb7&quot;\ns.codePointAt(2).toString(16) // &quot;61&quot;\n</code></pre>\n<p>你可能注意到了，<code>codePointAt()</code>方法的参数，仍然是不正确的。比如，上面代码中，字符<code>a</code>在字符串<code>s</code>的正确位置序号应该是 1，但是必须向<code>codePointAt()</code>方法传入 2。解决这个问题的一个办法是使用<code>for...of</code>循环，因为它会正确识别 32 位的 UTF-16 字符。</p>\n<pre><code class=\"javascript\">let s = &#39;𠮷a&#39;;\nfor (let ch of s) &#123;\n  console.log(ch.codePointAt(0).toString(16));\n&#125;\n// 20bb7\n// 61\n</code></pre>\n<p>另一种方法也可以，使用扩展运算符（<code>...</code>）进行展开运算。</p>\n<pre><code class=\"javascript\">let arr = [...&#39;𠮷a&#39;]; // arr.length === 2\narr.forEach(\n  ch =&gt; console.log(ch.codePointAt(0).toString(16))\n);\n// 20bb7\n// 61\n</code></pre>\n<p><code>codePointAt()</code>方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p>\n<pre><code class=\"javascript\">function is32Bit(c) &#123;\n  return c.codePointAt(0) &gt; 0xFFFF;\n&#125;\n\nis32Bit(&quot;𠮷&quot;) // true\nis32Bit(&quot;a&quot;) // false\n</code></pre>\n<h4 id=\"4-实例方法：normalize\"><a href=\"#4-实例方法：normalize\" class=\"headerlink\" title=\"4. 实例方法：normalize()\"></a>4. 实例方法：normalize()</h4><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如<code>Ǒ</code>（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如<code>O</code>（\\u004F）和<code>ˇ</code>（\\u030C）合成<code>Ǒ</code>（\\u004F\\u030C）。</p>\n<p>这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。</p>\n<pre><code class=\"javascript\">&#39;\\u01D1&#39;===&#39;\\u004F\\u030C&#39; //false\n\n&#39;\\u01D1&#39;.length // 1\n&#39;\\u004F\\u030C&#39;.length // 2\n</code></pre>\n<p>上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。</p>\n<p><strong>ES6 提供字符串实例的<code>normalize()</code>方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</strong></p>\n<pre><code class=\"javascript\">&#39;\\u01D1&#39;.normalize() === &#39;\\u004F\\u030C&#39;.normalize()\n// true\n</code></pre>\n<p><code>normalize</code>方法可以接受一个参数来指定<code>normalize</code>的方式，参数的四个可选值如下。</p>\n<ul>\n<li><code>NFC</code>，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</li>\n<li><code>NFD</code>，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</li>\n<li><code>NFKC</code>，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，<code>normalize</code>方法不能识别中文。）</li>\n<li><code>NFKD</code>，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</li>\n</ul>\n<pre><code class=\"javascript\">&#39;\\u004F\\u030C&#39;.normalize(&#39;NFC&#39;).length // 1\n&#39;\\u004F\\u030C&#39;.normalize(&#39;NFD&#39;).length // 2\n</code></pre>\n<p>上面代码表示，<code>NFC</code>参数返回字符的合成形式，<code>NFD</code>参数返回字符的分解形式。</p>\n<p>不过，<code>normalize</code>方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断</p>\n<hr>\n<h4 id=\"5-实例方法：includes-startsWith-endsWith\"><a href=\"#5-实例方法：includes-startsWith-endsWith\" class=\"headerlink\" title=\"5. 实例方法：includes(), startsWith(), endsWith()\"></a>5. 实例方法：includes(), startsWith(), endsWith()</h4><p><strong>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</strong></p>\n<ul>\n<li>**includes()**：返回布尔值，表示是否找到了参数字符串。</li>\n<li>**startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。</li>\n<li>**endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>\n</ul>\n<pre><code class=\"javascript\">let s = &#39;Hello world!&#39;;\n\ns.startsWith(&#39;Hello&#39;) // true\ns.endsWith(&#39;!&#39;) // true\ns.includes(&#39;o&#39;) // true\n</code></pre>\n<p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>\n<pre><code class=\"javascript\">let s = &#39;Hello world!&#39;;\n\ns.startsWith(&#39;world&#39;, 6) // true\ns.endsWith(&#39;Hello&#39;, 5) // true\ns.includes(&#39;Hello&#39;, 6) // false\n</code></pre>\n<p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p>\n<hr>\n<h4 id=\"6-实例方法：repeat\"><a href=\"#6-实例方法：repeat\" class=\"headerlink\" title=\"6. 实例方法：repeat()\"></a>6. 实例方法：repeat()</h4><p><strong><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</strong></p>\n<pre><code class=\"javascript\">&#39;x&#39;.repeat(3) // &quot;xxx&quot;\n&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;\n&#39;na&#39;.repeat(0) // &quot;&quot;\n</code></pre>\n<p>参数如果是小数，会被取整。</p>\n<pre><code class=\"javascript\">&#39;na&#39;.repeat(2.9) // &quot;nana&quot;\n</code></pre>\n<p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。</p>\n<pre><code class=\"javascript\">&#39;na&#39;.repeat(Infinity)\n// RangeError\n&#39;na&#39;.repeat(-1)\n// RangeError\n</code></pre>\n<p>但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为 0。</p>\n<pre><code class=\"javascript\">&#39;na&#39;.repeat(-0.9) // &quot;&quot;\n</code></pre>\n<p>参数<code>NaN</code>等同于 0。</p>\n<pre><code class=\"javascript\">&#39;na&#39;.repeat(NaN) // &quot;&quot;\n</code></pre>\n<p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。</p>\n<pre><code class=\"javascript\">&#39;na&#39;.repeat(&#39;na&#39;) // &quot;&quot;\n&#39;na&#39;.repeat(&#39;3&#39;) // &quot;nanana&quot;\n</code></pre>\n<hr>\n<h4 id=\"7-实例方法：padStart-，padEnd\"><a href=\"#7-实例方法：padStart-，padEnd\" class=\"headerlink\" title=\"7. 实例方法：padStart()，padEnd()\"></a>7. 实例方法：padStart()，padEnd()</h4><p><strong>ES2017 引入了字符串补全长度的功能</strong>。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p>\n<pre><code class=\"javascript\">&#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39;\n&#39;x&#39;.padStart(4, &#39;ab&#39;) // &#39;abax&#39;\n\n&#39;x&#39;.padEnd(5, &#39;ab&#39;) // &#39;xabab&#39;\n&#39;x&#39;.padEnd(4, &#39;ab&#39;) // &#39;xaba&#39;\n</code></pre>\n<p>上面代码中，<code>padStart()</code>和<code>padEnd()</code>一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。</p>\n<p>如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。</p>\n<pre><code class=\"javascript\">&#39;xxx&#39;.padStart(2, &#39;ab&#39;) // &#39;xxx&#39;\n&#39;xxx&#39;.padEnd(2, &#39;ab&#39;) // &#39;xxx&#39;\n</code></pre>\n<p>如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。</p>\n<pre><code class=\"javascript\">&#39;abc&#39;.padStart(10, &#39;0123456789&#39;)\n// &#39;0123456abc&#39;\n</code></pre>\n<p>如果省略第二个参数，默认使用空格补全长度。</p>\n<pre><code class=\"javascript\">&#39;x&#39;.padStart(4) // &#39;   x&#39;\n&#39;x&#39;.padEnd(4) // &#39;x   &#39;\n</code></pre>\n<p><code>padStart()</code>的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</p>\n<pre><code class=\"javascript\">&#39;1&#39;.padStart(10, &#39;0&#39;) // &quot;0000000001&quot;\n&#39;12&#39;.padStart(10, &#39;0&#39;) // &quot;0000000012&quot;\n&#39;123456&#39;.padStart(10, &#39;0&#39;) // &quot;0000123456&quot;\n</code></pre>\n<p>另一个用途是提示字符串格式。</p>\n<pre><code class=\"javascript\">&#39;12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-MM-12&quot;\n&#39;09-12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-09-12&quot;\n</code></pre>\n<hr>\n<h4 id=\"8-实例方法：trimStart-，trimEnd\"><a href=\"#8-实例方法：trimStart-，trimEnd\" class=\"headerlink\" title=\"8. 实例方法：trimStart()，trimEnd()\"></a>8. 实例方法：trimStart()，trimEnd()</h4><p><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbQ==\">ES2019</span> 对字符串实例新增了<code>trimStart()</code>和<code>trimEnd()</code>这两个方法。</strong>它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</p>\n<pre><code class=\"javascript\">const s = &#39;  abc  &#39;;\n\ns.trim() // &quot;abc&quot;\ns.trimStart() // &quot;abc  &quot;\ns.trimEnd() // &quot;  abc&quot;\n</code></pre>\n<p>上面代码中，<code>trimStart()</code>只消除头部的空格，保留尾部的空格。<code>trimEnd()</code>也是类似行为。</p>\n<p>除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。</p>\n<p>浏览器还部署了额外的两个方法，<code>trimLeft()</code>是<code>trimStart()</code>的别名，<code>trimRight()</code>是<code>trimEnd()</code>的别名。</p>\n<hr>\n<h4 id=\"9-实例方法：matchAll\"><a href=\"#9-实例方法：matchAll\" class=\"headerlink\" title=\"9. 实例方法：matchAll()\"></a>9. 实例方法：matchAll()</h4><p><code>matchAll()</code>方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。</p>\n<hr>\n<h4 id=\"10-实例方法：replaceAll\"><a href=\"#10-实例方法：replaceAll\" class=\"headerlink\" title=\"10. 实例方法：replaceAll()\"></a>10. 实例方法：replaceAll()</h4><p>之前，字符串的实例方法<code>replace()</code>只能替换第一个匹配。</p>\n<pre><code class=\"javascript\">&#39;aabbcc&#39;.replace(&#39;b&#39;, &#39;_&#39;)\n// &#39;aa_bcc&#39;\n</code></pre>\n<p>上面例子中，<code>replace()</code>只将第一个<code>b</code>替换成了下划线。</p>\n<p>如果要替换所有的匹配，不得不使用正则表达式的<code>g</code>修饰符。</p>\n<pre><code class=\"javascript\">&#39;aabbcc&#39;.replace(/b/g, &#39;_&#39;)\n// &#39;aa__cc&#39;\n</code></pre>\n<p>正则表达式毕竟不是那么方便和直观，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXJlcGxhY2VhbGw=\">ES2021</span> 引入了<code>replaceAll()</code>方法，可以一次性替换所有匹配。</p>\n<pre><code class=\"javascript\">&#39;aabbcc&#39;.replaceAll(&#39;b&#39;, &#39;_&#39;)\n// &#39;aa__cc&#39;\n</code></pre>\n<p>它的用法与<code>replace()</code>相同，返回一个新字符串，不会改变原字符串。</p>\n<pre><code class=\"javascript\">String.prototype.replaceAll(searchValue, replacement)\n</code></pre>\n<p>上面代码中，<code>searchValue</code>是搜索模式，可以是一个字符串，也可以是一个全局的正则表达式（带有<code>g</code>修饰符）。</p>\n<p>如果<code>searchValue</code>是一个不带有<code>g</code>修饰符的正则表达式，<code>replaceAll()</code>会报错。这一点跟<code>replace()</code>不同。</p>\n<pre><code class=\"javascript\">// 不报错\n&#39;aabbcc&#39;.replace(/b/, &#39;_&#39;)\n\n// 报错\n&#39;aabbcc&#39;.replaceAll(/b/, &#39;_&#39;)\n</code></pre>\n<p>上面例子中，<code>/b/</code>不带有<code>g</code>修饰符，会导致<code>replaceAll()</code>报错。</p>\n<p><code>replaceAll()</code>的第二个参数<code>replacement</code>是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。</p>\n<ul>\n<li><code>$&amp;</code>：匹配的字符串。</li>\n<li><code>$</code> `：匹配结果前面的文本。</li>\n<li><code>$&#39;</code>：匹配结果后面的文本。</li>\n<li><code>$n</code>：匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式。</li>\n<li><code>$$</code>：指代美元符号<code>$</code>。</li>\n</ul>\n<p>下面是一些例子。</p>\n<pre><code class=\"javascript\">// $&amp; 表示匹配的字符串，即`b`本身\n// 所以返回结果与原字符串一致\n&#39;abbc&#39;.replaceAll(&#39;b&#39;, &#39;$&amp;&#39;)\n// &#39;abbc&#39;\n\n// $` 表示匹配结果之前的字符串\n// 对于第一个`b`，$` 指代`a`\n// 对于第二个`b`，$` 指代`ab`\n&#39;abbc&#39;.replaceAll(&#39;b&#39;, &#39;$`&#39;)\n// &#39;aaabc&#39;\n\n// $&#39; 表示匹配结果之后的字符串\n// 对于第一个`b`，$&#39; 指代`bc`\n// 对于第二个`b`，$&#39; 指代`c`\n&#39;abbc&#39;.replaceAll(&#39;b&#39;, `$&#39;`)\n// &#39;abccc&#39;\n\n// $1 表示正则表达式的第一个组匹配，指代`ab`\n// $2 表示正则表达式的第二个组匹配，指代`bc`\n&#39;abbc&#39;.replaceAll(/(ab)(bc)/g, &#39;$2$1&#39;)\n// &#39;bcab&#39;\n\n// $$ 指代 $\n&#39;abc&#39;.replaceAll(&#39;b&#39;, &#39;$$&#39;)\n// &#39;a$c&#39;\n</code></pre>\n<p><code>replaceAll()</code>的第二个参数<code>replacement</code>除了为字符串，也可以是一个函数，该函数的返回值将替换掉第一个参数<code>searchValue</code>匹配的文本。</p>\n<pre><code class=\"javascript\">&#39;aabbcc&#39;.replaceAll(&#39;b&#39;, () =&gt; &#39;_&#39;)\n// &#39;aa__cc&#39;\n</code></pre>\n<p>上面例子中，<code>replaceAll()</code>的第二个参数是一个函数，该函数的返回值会替换掉所有<code>b</code>的匹配。</p>\n<p>这个替换函数可以接受多个参数。第一个参数是捕捉到的匹配内容，第二个参数捕捉到是组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。</p>\n<pre><code class=\"javascript\">const str = &#39;123abc456&#39;;\nconst regex = /(\\d+)([a-z]+)(\\d+)/g;\n\nfunction replacer(match, p1, p2, p3, offset, string) &#123;\n  return [p1, p2, p3].join(&#39; - &#39;);\n&#125;\n\nstr.replaceAll(regex, replacer)\n// 123 - abc - 456\n</code></pre>\n<p>上面例子中，正则表达式有三个组匹配，所以<code>replacer()</code>函数的第一个参数<code>match</code>是捕捉到的匹配内容（即字符串<code>123abc456</code>），后面三个参数<code>p1</code>、<code>p2</code>、<code>p3</code>则依次为三个组匹配。</p>\n<h3 id=\"5、正则的扩展\"><a href=\"#5、正则的扩展\" class=\"headerlink\" title=\"5、正则的扩展\"></a>5、正则的扩展</h3><hr>\n<h4 id=\"1-RegExp-构造函数\"><a href=\"#1-RegExp-构造函数\" class=\"headerlink\" title=\"1. RegExp 构造函数\"></a>1. RegExp 构造函数</h4><p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况。</p>\n<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>\n<pre><code class=\"javascript\">var regex = new RegExp(&#39;xyz&#39;, &#39;i&#39;);\n// 等价于\nvar regex = /xyz/i;\n</code></pre>\n<p>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</p>\n<pre><code class=\"javascript\">var regex = new RegExp(/xyz/i);\n// 等价于\nvar regex = /xyz/i;\n</code></pre>\n<p>但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。</p>\n<pre><code class=\"javascript\">var regex = new RegExp(/xyz/, &#39;i&#39;);\n// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another\n</code></pre>\n<p>ES6 改变了这种行为。如果<code>RegExp</code>构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>\n<pre><code class=\"javascript\">new RegExp(/abc/ig, &#39;i&#39;).flags\n// &quot;i&quot;\n</code></pre>\n<p>上面代码中，原有正则对象的修饰符是<code>ig</code>，它会被第二个参数<code>i</code>覆盖</p>\n<hr>\n<h4 id=\"2-字符串的正则方法\"><a href=\"#2-字符串的正则方法\" class=\"headerlink\" title=\"2. 字符串的正则方法\"></a>2. 字符串的正则方法</h4><p>ES6 出现之前，字符串对象共有 4 个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p>\n<p>ES6 将这 4 个方法，在语言内部全部调用<code>RegExp</code>的实例方法，从而做到所有与正则相关的方法，全都定义在<code>RegExp</code>对象上。</p>\n<ul>\n<li><code>String.prototype.match</code> 调用 <code>RegExp.prototype[Symbol.match]</code></li>\n<li><code>String.prototype.replace</code> 调用 <code>RegExp.prototype[Symbol.replace]</code></li>\n<li><code>String.prototype.search</code> 调用 <code>RegExp.prototype[Symbol.search]</code></li>\n<li><code>String.prototype.split</code> 调用 <code>RegExp.prototype[Symbol.split]</code></li>\n</ul>\n<hr>\n<h4 id=\"3-u修饰符\"><a href=\"#3-u修饰符\" class=\"headerlink\" title=\"3. u修饰符\"></a>3. u修饰符</h4><p>ES6 对正则表达式添加了<code>u</code>修饰符，含义为“Unicode 模式”，用来正确处理大于<code>\\uFFFF</code>的 Unicode 字符。也就是说，<strong>会正确处理四个字节的 UTF-16 编码。</strong></p>\n<pre><code class=\"javascript\">/^\\uD83D/u.test(&#39;\\uD83D\\uDC2A&#39;) // false\n/^\\uD83D/.test(&#39;\\uD83D\\uDC2A&#39;) // true\n</code></pre>\n<p>上面代码中，<code>\\uD83D\\uDC2A</code>是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为<code>true</code>。加了<code>u</code>修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为<code>false</code>。</p>\n<p>一旦加上<code>u</code>修饰符号，就会修改下面这些正则表达式的行为。</p>\n<p><strong>（1）点字符</strong></p>\n<p>点（<code>.</code>）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于<code>0xFFFF</code>的 Unicode 字符，点字符不能识别，<strong>必须加上<code>u</code>修饰符。</strong></p>\n<pre><code class=\"javascript\">var s = &#39;𠮷&#39;;\n\n/^.$/.test(s) // false\n/^.$/u.test(s) // true\n</code></pre>\n<p>上面代码表示，如果不添加<code>u</code>修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</p>\n<p><strong>（2）Unicode 字符表示法</strong></p>\n<p>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上<code>u</code>修饰符，才能识别当中的大括号，否则会被解读为量词。</p>\n<pre><code class=\"javascript\">/\\u&#123;61&#125;/.test(&#39;a&#39;) // false\n/\\u&#123;61&#125;/u.test(&#39;a&#39;) // true\n/\\u&#123;20BB7&#125;/u.test(&#39;𠮷&#39;) // true\n</code></pre>\n<p>上面代码表示，如果不加<code>u</code>修饰符，正则表达式无法识别<code>\\u&#123;61&#125;</code>这种表示法，只会认为这匹配 61 个连续的<code>u</code>。</p>\n<p><strong>（3）量词</strong></p>\n<p>使用<code>u</code>修饰符后，所有量词都会正确识别码点大于<code>0xFFFF</code>的 Unicode 字符。</p>\n<pre><code class=\"javascript\">/a&#123;2&#125;/.test(&#39;aa&#39;) // true\n/a&#123;2&#125;/u.test(&#39;aa&#39;) // true\n/𠮷&#123;2&#125;/.test(&#39;𠮷𠮷&#39;) // false\n/𠮷&#123;2&#125;/u.test(&#39;𠮷𠮷&#39;) // true\n</code></pre>\n<p><strong>（4）预定义模式</strong></p>\n<p><code>u</code>修饰符也影响到预定义模式，能否正确识别码点大于<code>0xFFFF</code>的 Unicode 字符。</p>\n<pre><code class=\"javascript\">/^\\S$/.test(&#39;𠮷&#39;) // false\n/^\\S$/u.test(&#39;𠮷&#39;) // true\n</code></pre>\n<p>上面代码的<code>\\S</code>是预定义模式，匹配所有非空白字符。只有加了<code>u</code>修饰符，它才能正确匹配码点大于<code>0xFFFF</code>的 Unicode 字符。</p>\n<p>利用这一点，可以写出一个正确返回字符串长度的函数。</p>\n<pre><code class=\"javascript\">function codePointLength(text) &#123;\n  var result = text.match(/[\\s\\S]/gu);\n  return result ? result.length : 0;\n&#125;\n\nvar s = &#39;𠮷𠮷&#39;;\n\ns.length // 4\ncodePointLength(s) // 2\n</code></pre>\n<p><strong>（5）i 修饰符</strong></p>\n<p>有些 Unicode 字符的编码不同，但是字型很相近，比如，<code>\\u004B</code>与<code>\\u212A</code>都是大写的<code>K</code>。</p>\n<pre><code class=\"javascript\">/[a-z]/i.test(&#39;\\u212A&#39;) // false\n/[a-z]/iu.test(&#39;\\u212A&#39;) // true\n</code></pre>\n<p>上面代码中，不加<code>u</code>修饰符，就无法识别非规范的<code>K</code>字符。</p>\n<p><strong>（6）转义</strong></p>\n<p>没有<code>u</code>修饰符的情况下，正则中没有定义的转义（如逗号的转义<code>\\,</code>）无效，而在<code>u</code>模式会报错。</p>\n<pre><code class=\"javascript\">/\\,/ // /\\,/\n/\\,/u // 报错\n</code></pre>\n<p>上面代码中，没有<code>u</code>修饰符时，逗号前面的反斜杠是无效的，加了<code>u</code>修饰符就报错。</p>\n<hr>\n<h4 id=\"4-RegExp-prototype-unicode-属性\"><a href=\"#4-RegExp-prototype-unicode-属性\" class=\"headerlink\" title=\"4. RegExp.prototype.unicode 属性\"></a>4. RegExp.prototype.unicode 属性</h4><p>正则实例对象新增<code>unicode</code>属性，表示是否设置了<code>u</code>修饰符。</p>\n<pre><code class=\"javascript\">const r1 = /hello/;\nconst r2 = /hello/u;\n\nr1.unicode // false\nr2.unicode // true\n</code></pre>\n<p>上面代码中，正则表达式是否设置了<code>u</code>修饰符，可以从<code>unicode</code>属性看出来</p>\n<hr>\n<h4 id=\"5-y-修饰符\"><a href=\"#5-y-修饰符\" class=\"headerlink\" title=\"5. y 修饰符\"></a>5. y 修饰符</h4><p>除了<code>u</code>修饰符，ES6 还为正则表达式添加了<code>y</code>修饰符，叫做“粘连”（sticky）修饰符。</p>\n<p><code>y</code>修饰符的作用与<code>g</code>修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，**<code>g</code>修饰符只要剩余位置中存在匹配就可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始**，这也就是“粘连”的涵义。</p>\n<pre><code class=\"javascript\">var s = &#39;aaa_aa_a&#39;;\nvar r1 = /a+/g;\nvar r2 = /a+/y;\n\nr1.exec(s) // [&quot;aaa&quot;]\nr2.exec(s) // [&quot;aaa&quot;]\n\nr1.exec(s) // [&quot;aa&quot;]\nr2.exec(s) // null\n</code></pre>\n<p>上面代码有两个正则表达式，一个使用<code>g</code>修饰符，另一个使用<code>y</code>修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是<code>_aa_a</code>。由于<code>g</code>修饰没有位置要求，所以第二次执行会返回结果，而<code>y</code>修饰符要求匹配必须从头部开始，所以返回<code>null</code>。</p>\n<p>如果改一下正则表达式，保证每次都能头部匹配，<code>y</code>修饰符就会返回结果了。</p>\n<pre><code class=\"javascript\">var s = &#39;aaa_aa_a&#39;;\nvar r = /a+_/y;\n\nr.exec(s) // [&quot;aaa_&quot;]\nr.exec(s) // [&quot;aa_&quot;]\n</code></pre>\n<p>上面代码每次匹配，都是从剩余字符串的头部开始。</p>\n<p><strong>实际上，<code>y</code>修饰符号隐含了头部匹配的标志<code>^</code>。</strong></p>\n<pre><code class=\"javascript\">/b/y.exec(&#39;aba&#39;)\n// null\n</code></pre>\n<p>上面代码由于不能保证头部匹配，所以返回<code>null</code>。<code>y</code>修饰符的设计本意，就是让头部匹配的标志<code>^</code>在全局匹配中都有效。</p>\n<p>单单一个<code>y</code>修饰符对<code>match</code>方法，只能返回第一个匹配，必须与<code>g</code>修饰符联用，才能返回所有匹配。</p>\n<pre><code class=\"javascript\">&#39;a1a2a3&#39;.match(/a\\d/y) // [&quot;a1&quot;]\n&#39;a1a2a3&#39;.match(/a\\d/gy) // [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;]\n</code></pre>\n<p><code>y</code>修饰符的一个应用，是从字符串提取 token（词元），<code>y</code>修饰符确保了匹配之间不会有漏掉的字符。</p>\n<pre><code class=\"javascript\">const TOKEN_Y = /\\s*(\\+|[0-9]+)\\s*/y;\nconst TOKEN_G  = /\\s*(\\+|[0-9]+)\\s*/g;\n\ntokenize(TOKEN_Y, &#39;3 + 4&#39;)\n// [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ]\ntokenize(TOKEN_G, &#39;3 + 4&#39;)\n// [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ]\n\nfunction tokenize(TOKEN_REGEX, str) &#123;\n  let result = [];\n  let match;\n  while (match = TOKEN_REGEX.exec(str)) &#123;\n    result.push(match[1]);\n  &#125;\n  return result;\n&#125;\n</code></pre>\n<p>上面代码中，如果字符串里面没有非法字符，<code>y</code>修饰符与<code>g</code>修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。</p>\n<pre><code class=\"javascript\">tokenize(TOKEN_Y, &#39;3x + 4&#39;)\n// [ &#39;3&#39; ]\ntokenize(TOKEN_G, &#39;3x + 4&#39;)\n// [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ]\n</code></pre>\n<p>上面代码中，<code>g</code>修饰符会忽略非法字符，而<code>y</code>修饰符不会，这样就很容易发现错误。</p>\n<hr>\n<h4 id=\"6-RegExp-prototype-sticky-属性\"><a href=\"#6-RegExp-prototype-sticky-属性\" class=\"headerlink\" title=\"6. RegExp.prototype.sticky 属性\"></a>6. RegExp.prototype.sticky 属性</h4><p>与<code>y</code>修饰符相匹配，ES6 的正则实例对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p>\n<pre><code class=\"javascript\">var r = /hello\\d/y;\nr.sticky // true\n</code></pre>\n<hr>\n<h4 id=\"7-RegExp-prototype-flags-属性\"><a href=\"#7-RegExp-prototype-flags-属性\" class=\"headerlink\" title=\"7. RegExp.prototype.flags 属性\"></a>7. RegExp.prototype.flags 属性</h4><p>ES6 为正则表达式新增了<code>flags</code>属性，会返回正则表达式的修饰符。</p>\n<pre><code class=\"javascript\">// ES5 的 source 属性\n// 返回正则表达式的正文\n/abc/ig.source\n// &quot;abc&quot;\n\n// ES6 的 flags 属性\n// 返回正则表达式的修饰符\n/abc/ig.flags\n// &#39;gi&#39;\n</code></pre>\n<hr>\n<h4 id=\"8-s-修饰符：dotAll-模式\"><a href=\"#8-s-修饰符：dotAll-模式\" class=\"headerlink\" title=\"8. s 修饰符：dotAll 模式\"></a>8. s 修饰符：dotAll 模式</h4><p><strong>正则表达式中，点（<code>.</code>）是一个特殊字符，代表任意的单个字符，但是有两个例外</strong>。一个是四个字节的 UTF-16 字符，这个可以用<code>u</code>修饰符解决；另一个是行终止符（line terminator character）。</p>\n<p>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。</p>\n<ul>\n<li>U+000A 换行符（<code>\\n</code>）</li>\n<li>U+000D 回车符（<code>\\r</code>）</li>\n<li>U+2028 行分隔符（line separator）</li>\n<li>U+2029 段分隔符（paragraph separator）</li>\n</ul>\n<pre><code class=\"javascript\">/foo.bar/.test(&#39;foo\\nbar&#39;)\n// false\n</code></pre>\n<p>上面代码中，因为<code>.</code>不匹配<code>\\n</code>，所以正则表达式返回<code>false</code>。</p>\n<p>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。</p>\n<pre><code class=\"javascript\">/foo[^]bar/.test(&#39;foo\\nbar&#39;)\n// true\n</code></pre>\n<p>这种解决方案毕竟不太符合直觉，ES2018 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcmVnZXhwLWRvdGFsbC1mbGFn\">引入</span><code>s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p>\n<pre><code class=\"javascript\">/foo.bar/s.test(&#39;foo\\nbar&#39;) // true\n</code></pre>\n<p><strong>这被称为<code>dotAll</code>模式，即点（dot）代表一切字符</strong>。所以，正则表达式还引入了一个<code>dotAll</code>属性，返回一个布尔值，表示该正则表达式是否处在<code>dotAll</code>模式。</p>\n<pre><code class=\"javascript\">const re = /foo.bar/s;\n// 另一种写法\n// const re = new RegExp(&#39;foo.bar&#39;, &#39;s&#39;);\n\nre.test(&#39;foo\\nbar&#39;) // true\nre.dotAll // true\nre.flags // &#39;s&#39;\n</code></pre>\n<p><code>/s</code>修饰符和多行修饰符<code>/m</code>不冲突，两者一起使用的情况下，<code>.</code>匹配所有字符，而<code>^</code>和<code>$</code>匹配每一行的行首和行尾。</p>\n<hr>\n<h4 id=\"9-后行断言\"><a href=\"#9-后行断言\" class=\"headerlink\" title=\"9. 后行断言\"></a>9. 后行断言</h4><blockquote>\n<p>JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcmVnZXhwLWxvb2tiZWhpbmQ=\">后行断言</span>，V8 引擎 4.9 版（Chrome 62）已经支持。</p>\n</blockquote>\n<p>**“先行断言”指的是，<code>x</code>只有在<code>y</code>前面才匹配，必须写成<code>/x(?=y)/</code><strong>。比如，只匹配百分号之前的数字，要写成<code>/\\d+(?=%)/</code>。</strong>“先行否定断言”指的是，<code>x</code>只有不在<code>y</code>前面才匹配，必须写成<code>/x(?!y)/</code>**。比如，只匹配不在百分号之前的数字，要写成<code>/\\d+(?!%)/</code>。</p>\n<pre><code class=\"javascript\">/\\d+(?=%)/.exec(&#39;100% of US presidents have been male&#39;)  // [&quot;100&quot;]\n/\\d+(?!%)/.exec(&#39;that’s all 44 of them&#39;)                 // [&quot;44&quot;]\n</code></pre>\n<p>上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（<code>(?=%)</code>），是不计入返回结果的。</p>\n<p><strong>“后行断言”正好与“先行断言”相反，<code>x</code>只有在<code>y</code>后面才匹配，必须写成<code>/(?&lt;=y)x/</code><strong>。比如，只匹配美元符号之后的数字，要写成<code>/(?&lt;=\\$)\\d+/</code>。</strong>“后行否定断言”则与“先行否定断言”相反，<code>x</code>只有不在<code>y</code>后面才匹配，必须写成<code>/(?&lt;!y)x/</code>。</strong>比如，只匹配不在美元符号后面的数字，要写成<code>/(?&lt;!\\$)\\d+/</code>。</p>\n<pre><code class=\"javascript\">/(?&lt;=\\$)\\d+/.exec(&#39;Benjamin Franklin is on the $100 bill&#39;)  // [&quot;100&quot;]\n/(?&lt;!\\$)\\d+/.exec(&#39;it’s is worth about €90&#39;)                // [&quot;90&quot;]\n</code></pre>\n<p>上面的例子中，“后行断言”的括号之中的部分（<code>(?&lt;=\\$)</code>），也是不计入返回结果。</p>\n<p>下面的例子是使用后行断言进行字符串替换。</p>\n<pre><code class=\"javascript\">const RE_DOLLAR_PREFIX = /(?&lt;=\\$)foo/g;\n&#39;$foo %foo foo&#39;.replace(RE_DOLLAR_PREFIX, &#39;bar&#39;);\n// &#39;$bar %foo foo&#39;\n</code></pre>\n<p>上面代码中，只有在美元符号后面的<code>foo</code>才会被替换。</p>\n<p><strong>“后行断言”的实现，需要先匹配<code>/(?&lt;=y)x/</code>的<code>x</code>，然后再回到左边，匹配<code>y</code>的部分</strong>。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。</p>\n<p><strong>首先，后行断言的组匹配，与正常情况下结果是不一样的。</strong></p>\n<pre><code class=\"javascript\">/(?&lt;=(\\d+)(\\d+))$/.exec(&#39;1053&#39;) // [&quot;&quot;, &quot;1&quot;, &quot;053&quot;]\n/^(\\d+)(\\d+)$/.exec(&#39;1053&#39;) // [&quot;1053&quot;, &quot;105&quot;, &quot;3&quot;]\n</code></pre>\n<p>上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是<code>105</code>和<code>3</code>。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是<code>1</code>和<code>053</code>。</p>\n<p>其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。</p>\n<pre><code class=\"javascript\">/(?&lt;=(o)d\\1)r/.exec(&#39;hodor&#39;)  // null\n/(?&lt;=\\1d(o))r/.exec(&#39;hodor&#39;)  // [&quot;r&quot;, &quot;o&quot;]\n</code></pre>\n<p>上面代码中，如果后行断言的反斜杠引用（<code>\\1</code>）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。</p>\n<hr>\n<h4 id=\"10-Unicode-属性类\"><a href=\"#10-Unicode-属性类\" class=\"headerlink\" title=\"10. Unicode 属性类\"></a>10. Unicode 属性类</h4><p><strong>ES2018 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcmVnZXhwLXVuaWNvZGUtcHJvcGVydHktZXNjYXBlcw==\">引入</span>了一种新的类的写法<code>\\p&#123;...&#125;</code>和<code>\\P&#123;...&#125;</code>，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</strong></p>\n<pre><code class=\"javascript\">const regexGreekSymbol = /\\p&#123;Script=Greek&#125;/u;\nregexGreekSymbol.test(&#39;π&#39;) // true\n</code></pre>\n<p>上面代码中，<code>\\p&#123;Script=Greek&#125;</code>指定匹配一个希腊文字母，所以匹配<code>π</code>成功。</p>\n<p>Unicode 属性类要指定属性名和属性值。</p>\n<pre><code class=\"javascript\">\\p&#123;UnicodePropertyName=UnicodePropertyValue&#125;\n</code></pre>\n<p>对于某些属性，可以只写属性名，或者只写属性值。</p>\n<pre><code class=\"javascript\">\\p&#123;UnicodePropertyName&#125;\n\\p&#123;UnicodePropertyValue&#125;\n</code></pre>\n<p><code>\\P&#123;…&#125;</code>是<code>\\p&#123;…&#125;</code>的反向匹配，即匹配不满足条件的字符。</p>\n<p>注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上<code>u</code>修饰符。如果不加<code>u</code>修饰符，正则表达式使用<code>\\p</code>和<code>\\P</code>会报错，ECMAScript 预留了这两个类。</p>\n<p>由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。</p>\n<pre><code class=\"javascript\">const regex = /^\\p&#123;Decimal_Number&#125;+$/u;\nregex.test(&#39;𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼&#39;) // true\n</code></pre>\n<p>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。</p>\n<p><code>\\p&#123;Number&#125;</code>甚至能匹配罗马数字。</p>\n<pre><code class=\"javascript\">// 匹配所有数字\nconst regex = /^\\p&#123;Number&#125;+$/u;\nregex.test(&#39;²³¹¼½¾&#39;) // true\nregex.test(&#39;㉛㉜㉝&#39;) // true\nregex.test(&#39;ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ&#39;) // true\n</code></pre>\n<p>下面是其他一些例子。</p>\n<pre><code class=\"javascript\">// 匹配所有空格\n\\p&#123;White_Space&#125;\n\n// 匹配各种文字的所有字母，等同于 Unicode 版的 \\w\n[\\p&#123;Alphabetic&#125;\\p&#123;Mark&#125;\\p&#123;Decimal_Number&#125;\\p&#123;Connector_Punctuation&#125;\\p&#123;Join_Control&#125;]\n\n// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W\n[^\\p&#123;Alphabetic&#125;\\p&#123;Mark&#125;\\p&#123;Decimal_Number&#125;\\p&#123;Connector_Punctuation&#125;\\p&#123;Join_Control&#125;]\n\n// 匹配 Emoji\n/\\p&#123;Emoji_Modifier_Base&#125;\\p&#123;Emoji_Modifier&#125;?|\\p&#123;Emoji_Presentation&#125;|\\p&#123;Emoji&#125;\\uFE0F/gu\n\n// 匹配所有的箭头字符\nconst regexArrows = /^\\p&#123;Block=Arrows&#125;+$/u;\nregexArrows.test(&#39;←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩&#39;) // true\n</code></pre>\n<hr>\n<h4 id=\"11-具名组匹配\"><a href=\"#11-具名组匹配\" class=\"headerlink\" title=\"11. 具名组匹配\"></a>11. 具名组匹配</h4><p><strong>简介</strong></p>\n<p>正则表达式使用圆括号进行组匹配。</p>\n<pre><code class=\"javascript\">const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;\n</code></pre>\n<p>上面代码中，正则表达式里面有三组圆括号。使用<code>exec</code>方法，就可以将这三组匹配结果提取出来。</p>\n<pre><code class=\"javascript\">const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;\n\nconst matchObj = RE_DATE.exec(&#39;1999-12-31&#39;);\nconst year = matchObj[1]; // 1999\nconst month = matchObj[2]; // 12\nconst day = matchObj[3]; // 31\n</code></pre>\n<p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如<code>matchObj[1]</code>）引用，要是组的顺序变了，引用的时候就必须修改序号。</p>\n<p>ES2018 引入了<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcmVnZXhwLW5hbWVkLWdyb3Vwcw==\">具名组匹配</span>（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p>\n<pre><code class=\"javascript\">const RE_DATE = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/;\n\nconst matchObj = RE_DATE.exec(&#39;1999-12-31&#39;);\nconst year = matchObj.groups.year; // &quot;1999&quot;\nconst month = matchObj.groups.month; // &quot;12&quot;\nconst day = matchObj.groups.day; // &quot;31&quot;\n</code></pre>\n<p>上面代码中，<strong>“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（<code>?&lt;year&gt;</code>）</strong>，然后就可以在<code>exec</code>方法返回结果的<code>groups</code>属性上引用该组名。同时，数字序号（<code>matchObj[1]</code>）依然有效。</p>\n<p>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。</p>\n<p>如果具名组没有匹配，那么对应的<code>groups</code>对象属性会是<code>undefined</code>。</p>\n<pre><code class=\"javascript\">const RE_OPT_A = /^(?&lt;as&gt;a+)?$/;\nconst matchObj = RE_OPT_A.exec(&#39;&#39;);\n\nmatchObj.groups.as // undefined\n&#39;as&#39; in matchObj.groups // true\n</code></pre>\n<p>上面代码中，具名组<code>as</code>没有找到匹配，那么<code>matchObj.groups.as</code>属性值就是<code>undefined</code>，并且<code>as</code>这个键名在<code>groups</code>是始终存在的。</p>\n<p><strong>解构赋值和替换</strong></p>\n<p>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。</p>\n<pre><code class=\"javascript\">let &#123;groups: &#123;one, two&#125;&#125; = /^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u.exec(&#39;foo:bar&#39;);\none  // foo\ntwo  // bar\n</code></pre>\n<p><strong>字符串替换时，使用<code>$&lt;组名&gt;</code>引用具名组。</strong></p>\n<pre><code class=\"javascript\">let re = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u;\n\n&#39;2015-01-02&#39;.replace(re, &#39;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#39;)\n// &#39;02/01/2015&#39;\n</code></pre>\n<p>上面代码中，<code>replace</code>方法的第二个参数是一个字符串，而不是正则表达式。</p>\n<p><code>replace</code>方法的第二个参数也可以是函数，该函数的参数序列如下。</p>\n<pre><code class=\"javascript\">&#39;2015-01-02&#39;.replace(re, (\n   matched, // 整个匹配结果 2015-01-02\n   capture1, // 第一个组匹配 2015\n   capture2, // 第二个组匹配 01\n   capture3, // 第三个组匹配 02\n   position, // 匹配开始的位置 0\n   S, // 原字符串 2015-01-02\n   groups // 具名组构成的一个对象 &#123;year, month, day&#125;\n ) =&gt; &#123;\n let &#123;day, month, year&#125; = groups;\n return `$&#123;day&#125;/$&#123;month&#125;/$&#123;year&#125;`;\n&#125;);\n</code></pre>\n<p>具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。</p>\n<p><strong>引用</strong></p>\n<p><strong>如果要在正则表达式内部引用某个“具名组匹配”，可以使用<code>\\k&lt;组名&gt;</code>的写法。</strong></p>\n<pre><code class=\"javascript\">const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\\k&lt;word&gt;$/;\nRE_TWICE.test(&#39;abc!abc&#39;) // true\nRE_TWICE.test(&#39;abc!ab&#39;) // false\n</code></pre>\n<p>数字引用（<code>\\1</code>）依然有效。</p>\n<pre><code class=\"javascript\">const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\\1$/;\nRE_TWICE.test(&#39;abc!abc&#39;) // true\nRE_TWICE.test(&#39;abc!ab&#39;) // false\n</code></pre>\n<p>这两种引用语法还可以同时使用。</p>\n<pre><code class=\"javascript\">const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\\k&lt;word&gt;!\\1$/;\nRE_TWICE.test(&#39;abc!abc!abc&#39;) // true\nRE_TWICE.test(&#39;abc!abc!ab&#39;) // false\n</code></pre>\n<h4 id=\"12-正则匹配索引\"><a href=\"#12-正则匹配索引\" class=\"headerlink\" title=\"12. 正则匹配索引\"></a>12. 正则匹配索引</h4><p>正则匹配结果的开始位置和结束位置，目前获取并不是很方便。正则实例的<code>exec()</code>方法，返回结果有一个<code>index</code>属性，可以获取整个匹配结果的开始位置，但是如果包含组匹配，每个组匹配的开始位置，很难拿到。</p>\n<p>现在有一个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcmVnZXhwLW1hdGNoLUluZGljZXM=\">第三阶段提案</span>，为<code>exec()</code>方法的返回结果加上<code>indices</code>属性，在这个属性上面可以拿到匹配的开始位置和结束位置。</p>\n<pre><code class=\"javascript\">const text = &#39;zabbcdef&#39;;\nconst re = /ab/;\nconst result = re.exec(text);\n\nresult.index // 1\nresult.indices // [ [1, 3] ]\n</code></pre>\n<p>上面例子中，<code>exec()</code>方法的返回结果<code>result</code>，它的<code>index</code>属性是整个匹配结果（<code>ab</code>）的开始位置，而它的<code>indices</code>属性是一个数组，成员是每个匹配的开始位置和结束位置的数组。由于该例子的正则表达式没有组匹配，所以<code>indices</code>数组只有一个成员，表示整个匹配的开始位置是<code>1</code>，结束位置是<code>3</code>。</p>\n<p>注意，开始位置包含在匹配结果之中，但是结束位置不包含在匹配结果之中。比如，匹配结果为<code>ab</code>，分别是原始字符串的第1位和第2位，那么结束位置就是第3位。</p>\n<p>如果正则表达式包含组匹配，那么<code>indices</code>属性对应的数组就会包含多个成员，提供每个组匹配的开始位置和结束位置。</p>\n<pre><code class=\"javascript\">const text = &#39;zabbcdef&#39;;\nconst re = /ab+(cd)/;\nconst result = re.exec(text);\n\nresult.indices // [ [ 1, 6 ], [ 4, 6 ] ]\n</code></pre>\n<p>上面例子中，正则表达式包含一个组匹配，那么<code>indices</code>属性数组就有两个成员，第一个成员是整个匹配结果（<code>abbcd</code>）的开始位置和结束位置，第二个成员是组匹配（<code>cd</code>）的开始位置和结束位置。</p>\n<p>下面是多个组匹配的例子。</p>\n<pre><code class=\"javascript\">const text = &#39;zabbcdef&#39;;\nconst re = /ab+(cd(ef))/;\nconst result = re.exec(text);\n\nresult.indices // [ [1, 8], [4, 8], [6, 8] ]\n</code></pre>\n<p>上面例子中，正则表达式包含两个组匹配，所以<code>indices</code>属性数组就有三个成员。</p>\n<p>如果正则表达式包含具名组匹配，<code>indices</code>属性数组还会有一个<code>groups</code>属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置。</p>\n<pre><code class=\"javascript\">const text = &#39;zabbcdef&#39;;\nconst re = /ab+(?&lt;Z&gt;cd)/;\nconst result = re.exec(text);\n\nresult.indices.groups // &#123; Z: [ 4, 6 ] &#125;\n</code></pre>\n<p>上面例子中，<code>exec()</code>方法返回结果的<code>indices.groups</code>属性是一个对象，提供具名组匹配<code>Z</code>的开始位置和结束位置。</p>\n<p>如果获取组匹配不成功，<code>indices</code>属性数组的对应成员则为<code>undefined</code>，<code>indices.groups</code>属性对象的对应成员也是<code>undefined</code>。</p>\n<pre><code class=\"javascript\">const text = &#39;zabbcdef&#39;;\nconst re = /ab+(?&lt;Z&gt;ce)?/;\nconst result = re.exec(text);\n\nresult.indices[1] // undefined\nresult.indices.groups[&#39;Z&#39;] // undefined\n</code></pre>\n<p>上面例子中，由于组匹配不成功，所以<code>indices</code>属性数组和<code>indices.groups</code>属性对象对应的组匹配成员都是<code>undefined</code>。</p>\n<h4 id=\"13-String-prototype-matchAll\"><a href=\"#13-String-prototype-matchAll\" class=\"headerlink\" title=\"13. String.prototype.matchAll()\"></a>13. String.prototype.matchAll()</h4><p>如果一个正则表达式在字符串里面有多个匹配，现在一般使用<code>g</code>修饰符或<code>y</code>修饰符，在循环里面逐一取出。</p>\n<pre><code class=\"javascript\">var regex = /t(e)(st(\\d?))/g;\nvar string = &#39;test1test2test3&#39;;\n\nvar matches = [];\nvar match;\nwhile (match = regex.exec(string)) &#123;\n  matches.push(match);\n&#125;\n\nmatches\n// [\n//   [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;],\n//   [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;],\n//   [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]\n// ]\n</code></pre>\n<p>上面代码中，<code>while</code>循环取出每一轮的正则匹配，一共三轮。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLW1hdGNoYWxs\">ES2020</span> 增加了<code>String.prototype.matchAll()</code>方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。</p>\n<pre><code class=\"javascript\">const string = &#39;test1test2test3&#39;;\nconst regex = /t(e)(st(\\d?))/g;\n\nfor (const match of string.matchAll(regex)) &#123;\n  console.log(match);\n&#125;\n// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]\n// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]\n// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]\n</code></pre>\n<p>上面代码中，由于<code>string.matchAll(regex)</code>返回的是遍历器，所以可以用<code>for...of</code>循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。</p>\n<p>遍历器转为数组是非常简单的，使用<code>...</code>运算符和<code>Array.from()</code>方法就可以了。</p>\n<pre><code class=\"javascript\">// 转为数组的方法一\n[...string.matchAll(regex)]\n\n// 转为数组的方法二\nArray.from(string.matchAll(regex))\n</code></pre>\n<h3 id=\"6、数值的扩展\"><a href=\"#6、数值的扩展\" class=\"headerlink\" title=\"6、数值的扩展\"></a>6、数值的扩展</h3><hr>\n<h4 id=\"1-二进制和八进制表示法\"><a href=\"#1-二进制和八进制表示法\" class=\"headerlink\" title=\"1. 二进制和八进制表示法\"></a>1. 二进制和八进制表示法</h4><p>ES6 提供了二进制和八进制数值的新的写法，<strong>分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）</strong>表示。</p>\n<pre><code class=\"javascript\">0b111110111 === 503 // true\n0o767 === 503 // true\n</code></pre>\n<p>从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀<code>0</code>表示，ES6 进一步明确，要使用前缀<code>0o</code>表示。</p>\n<pre><code class=\"javascript\">// 非严格模式\n(function()&#123;\n  console.log(0o11 === 011);\n&#125;)() // true\n\n// 严格模式\n(function()&#123;\n  &#39;use strict&#39;;\n  console.log(0o11 === 011);\n&#125;)() // Uncaught SyntaxError: Octal literals are not allowed in strict mode.\n</code></pre>\n<p><strong>如果要将<code>0b</code>和<code>0o</code>前缀的字符串数值转为十进制，要使用<code>Number</code>方法。</strong></p>\n<pre><code class=\"javascript\">Number(&#39;0b111&#39;)  // 7\nNumber(&#39;0o10&#39;)  // 8\n</code></pre>\n<hr>\n<h4 id=\"2-数值分隔符\"><a href=\"#2-数值分隔符\" class=\"headerlink\" title=\"2. 数值分隔符\"></a>2. 数值分隔符</h4><p>欧美语言中，较长的数值允许每三位添加一个分隔符（通常是一个逗号），增加数值的可读性。比如，<code>1000</code>可以写作<code>1,000</code>。</p>\n<p><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtbnVtZXJpYy1zZXBhcmF0b3I=\">ES2021</span>，允许 JavaScript 的数值使用下划线（<code>_</code>）作为分隔符。</strong></p>\n<pre><code class=\"javascript\">let budget = 1_000_000_000_000;\nbudget === 10 ** 12 // true\n</code></pre>\n<p>这个数值分隔符没有指定间隔的位数，也就是说，可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个。</p>\n<pre><code class=\"javascript\">123_00 === 12_300 // true\n\n12345_00 === 123_4500 // true\n12345_00 === 1_234_500 // true\n</code></pre>\n<p>小数和科学计数法也可以使用数值分隔符。</p>\n<pre><code class=\"javascript\">// 小数\n0.000_001\n\n// 科学计数法\n1e10_000\n</code></pre>\n<p>数值分隔符有几个使用注意点。</p>\n<ul>\n<li>不能放在数值的最前面（leading）或最后面（trailing）。</li>\n<li>不能两个或两个以上的分隔符连在一起。</li>\n<li>小数点的前后不能有分隔符。</li>\n<li>科学计数法里面，表示指数的<code>e</code>或<code>E</code>前后不能有分隔符。</li>\n</ul>\n<p>下面的写法都会报错。</p>\n<pre><code class=\"javascript\">// 全部报错\n3_.141\n3._141\n1_e12\n1e_12\n123__456\n_1464301\n1464301_\n</code></pre>\n<p>除了十进制，其他进制的数值也可以使用分隔符。</p>\n<pre><code class=\"javascript\">// 二进制\n0b1010_0001_1000_0101\n// 十六进制\n0xA0_B0_C0\n</code></pre>\n<p>注意，分隔符不能紧跟着进制的前缀<code>0b</code>、<code>0B</code>、<code>0o</code>、<code>0O</code>、<code>0x</code>、<code>0X</code>。</p>\n<pre><code class=\"javascript\">// 报错\n0_b111111000\n0b_111111000\n</code></pre>\n<p>数值分隔符只是一种书写便利，对于 JavaScript 内部数值的存储和输出，并没有影响。</p>\n<pre><code class=\"javascript\">let num = 12_345;\n\nnum // 12345\nnum.toString() // 12345\n</code></pre>\n<p>上面示例中，变量<code>num</code>的值为<code>12_345</code>，但是内部存储和输出的时候，都不会有数值分隔符。</p>\n<p>下面三个将字符串转成数值的函数，不支持数值分隔符。主要原因是语言的设计者认为，数值分隔符主要是为了编码时书写数值的方便，而不是为了处理外部输入的数据。</p>\n<ul>\n<li>Number()</li>\n<li>parseInt()</li>\n<li>parseFloat()</li>\n</ul>\n<pre><code class=\"javascript\">Number(&#39;123_456&#39;) // NaN\nparseInt(&#39;123_456&#39;) // 123\n</code></pre>\n<hr>\n<h4 id=\"3-Number-isFinite-Number-isNaN\"><a href=\"#3-Number-isFinite-Number-isNaN\" class=\"headerlink\" title=\"3. Number.isFinite(), Number.isNaN()\"></a>3. Number.isFinite(), Number.isNaN()</h4><p>ES6 在<code>Number</code>对象上，新提供了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。</p>\n<p><strong><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite），即不是<code>Infinity</code>。</strong></p>\n<pre><code class=\"javascript\">Number.isFinite(15); // true\nNumber.isFinite(0.8); // true\nNumber.isFinite(NaN); // false\nNumber.isFinite(Infinity); // false\nNumber.isFinite(-Infinity); // false\nNumber.isFinite(&#39;foo&#39;); // false\nNumber.isFinite(&#39;15&#39;); // false\nNumber.isFinite(true); // false\n</code></pre>\n<p>注意，如果参数类型不是数值，<code>Number.isFinite</code>一律返回<code>false</code>。</p>\n<p><strong><code>Number.isNaN()</code>用来检查一个值是否为<code>NaN</code>。</strong></p>\n<pre><code class=\"javascript\">Number.isNaN(NaN) // true\nNumber.isNaN(15) // false\nNumber.isNaN(&#39;15&#39;) // false\nNumber.isNaN(true) // false\nNumber.isNaN(9/NaN) // true\nNumber.isNaN(&#39;true&#39; / 0) // true\nNumber.isNaN(&#39;true&#39; / &#39;true&#39;) // true\n</code></pre>\n<p>如果参数类型不是<code>NaN</code>，<code>Number.isNaN</code>一律返回<code>false</code>。</p>\n<p><strong>它们与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，</strong><code>Number.isFinite()</code>对于非数值一律返回<code>false</code>, <code>Number.isNaN()</code>只有对于<code>NaN</code>才返回<code>true</code>，非<code>NaN</code>一律返回<code>false</code>。</p>\n<pre><code class=\"javascript\">isFinite(25) // true\nisFinite(&quot;25&quot;) // true\nNumber.isFinite(25) // true\nNumber.isFinite(&quot;25&quot;) // false\n\nisNaN(NaN) // true\nisNaN(&quot;NaN&quot;) // true\nNumber.isNaN(NaN) // true\nNumber.isNaN(&quot;NaN&quot;) // false\nNumber.isNaN(1) // false\n</code></pre>\n<hr>\n<h4 id=\"4-Number-parseInt-Number-parseFloat\"><a href=\"#4-Number-parseInt-Number-parseFloat\" class=\"headerlink\" title=\"4. Number.parseInt(), Number.parseFloat()\"></a>4. Number.parseInt(), Number.parseFloat()</h4><p>ES6 将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到<code>Number</code>对象上面，行为完全保持不变。</p>\n<pre><code class=\"javascript\">// ES5的写法\nparseInt(&#39;12.34&#39;) // 12\nparseFloat(&#39;123.45#&#39;) // 123.45\n\n// ES6的写法\nNumber.parseInt(&#39;12.34&#39;) // 12\nNumber.parseFloat(&#39;123.45#&#39;) // 123.45\n</code></pre>\n<p>这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</p>\n<pre><code class=\"javascript\">Number.parseInt === parseInt // true\nNumber.parseFloat === parseFloat // true\n</code></pre>\n<hr>\n<h4 id=\"5-Number-isInteger\"><a href=\"#5-Number-isInteger\" class=\"headerlink\" title=\"5.Number.isInteger()\"></a>5.Number.isInteger()</h4><p><code>Number.isInteger()</code>用来判断一个数值是否为整数。</p>\n<pre><code class=\"javascript\">Number.isInteger(25) // true\nNumber.isInteger(25.1) // false\n</code></pre>\n<p>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。</p>\n<pre><code class=\"javascript\">Number.isInteger(25) // true\nNumber.isInteger(25.0) // true\n</code></pre>\n<p>如果参数不是数值，<code>Number.isInteger</code>返回<code>false</code>。</p>\n<pre><code class=\"javascript\">Number.isInteger() // false\nNumber.isInteger(null) // false\nNumber.isInteger(&#39;15&#39;) // false\nNumber.isInteger(true) // false\n</code></pre>\n<p>注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，<code>Number.isInteger</code>可能会误判。</p>\n<pre><code class=\"javascript\">Number.isInteger(3.0000000000000002) // true\n</code></pre>\n<p>上面代码中，<code>Number.isInteger</code>的参数明明不是整数，但是会返回<code>true</code>。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个<code>2</code>被丢弃了。</p>\n<p>类似的情况还有，如果一个数值的绝对值小于<code>Number.MIN_VALUE</code>（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，<code>Number.isInteger</code>也会误判。</p>\n<pre><code class=\"javascript\">Number.isInteger(5E-324) // false\nNumber.isInteger(5E-325) // true\n</code></pre>\n<p>上面代码中，<code>5E-325</code>由于值太小，会被自动转为0，因此返回<code>true</code>。</p>\n<p><strong>总之，如果对数据精度的要求较高，不建议使用<code>Number.isInteger()</code>判断一个数值是否为整数。</strong></p>\n<hr>\n<h4 id=\"6-Number-EPSILON\"><a href=\"#6-Number-EPSILON\" class=\"headerlink\" title=\"6. Number.EPSILON\"></a>6. Number.EPSILON</h4><p><strong>ES6 在<code>Number</code>对象上面，新增一个极小的常量<code>Number.EPSILON</code>。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</strong></p>\n<p>对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的<code>1.00..001</code>，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。</p>\n<pre><code class=\"javascript\">Number.EPSILON === Math.pow(2, -52)\n// true\nNumber.EPSILON\n// 2.220446049250313e-16\nNumber.EPSILON.toFixed(20)\n// &quot;0.00000000000000022204&quot;\n</code></pre>\n<p><strong><code>Number.EPSILON</code>实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</strong></p>\n<p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</p>\n<pre><code class=\"javascript\">0.1 + 0.2\n// 0.30000000000000004\n\n0.1 + 0.2 - 0.3\n// 5.551115123125783e-17\n\n5.551115123125783e-17.toFixed(20)\n// &#39;0.00000000000000005551&#39;\n</code></pre>\n<p>上面代码解释了，为什么比较<code>0.1 + 0.2</code>与<code>0.3</code>得到的结果是<code>false</code>。</p>\n<pre><code class=\"javascript\">0.1 + 0.2 === 0.3 // false\n</code></pre>\n<p><code>Number.EPSILON</code>可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即<code>Number.EPSILON * Math.pow(2, 2)</code>），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。</p>\n<pre><code class=\"javascript\">5.551115123125783e-17 &lt; Number.EPSILON * Math.pow(2, 2)\n// true\n</code></pre>\n<p>因此，<code>Number.EPSILON</code>的实质是一个可以接受的最小误差范围。</p>\n<pre><code class=\"javascript\">function withinErrorMargin (left, right) &#123;\n  return Math.abs(left - right) &lt; Number.EPSILON * Math.pow(2, 2);\n&#125;\n\n0.1 + 0.2 === 0.3 // false\nwithinErrorMargin(0.1 + 0.2, 0.3) // true\n\n1.1 + 1.3 === 2.4 // false\nwithinErrorMargin(1.1 + 1.3, 2.4) // true\n</code></pre>\n<p>上面的代码为浮点数运算，部署了一个误差检查函数。</p>\n<hr>\n<h4 id=\"7-安全整数和-Number-isSafeInteger\"><a href=\"#7-安全整数和-Number-isSafeInteger\" class=\"headerlink\" title=\"7. 安全整数和 Number.isSafeInteger()\"></a>7. 安全整数和 Number.isSafeInteger()</h4><p>JavaScript 能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>\n<pre><code class=\"javascript\">Math.pow(2, 53) // 9007199254740992\n\n9007199254740992  // 9007199254740992\n9007199254740993  // 9007199254740992\n\nMath.pow(2, 53) === Math.pow(2, 53) + 1\n// true\n</code></pre>\n<p>上面代码中，超出 2 的 53 次方之后，一个数就不精确了。</p>\n<p><strong>ES6 引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。</strong></p>\n<pre><code class=\"javascript\">Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1\n// true\nNumber.MAX_SAFE_INTEGER === 9007199254740991\n// true\n\nNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER\n// true\nNumber.MIN_SAFE_INTEGER === -9007199254740991\n// true\n</code></pre>\n<p>上面代码中，可以看到 JavaScript 能够精确表示的极限。</p>\n<p><code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>\n<pre><code class=\"javascript\">Number.isSafeInteger(&#39;a&#39;) // false\nNumber.isSafeInteger(null) // false\nNumber.isSafeInteger(NaN) // false\nNumber.isSafeInteger(Infinity) // false\nNumber.isSafeInteger(-Infinity) // false\n\nNumber.isSafeInteger(3) // true\nNumber.isSafeInteger(1.2) // false\nNumber.isSafeInteger(9007199254740990) // true\nNumber.isSafeInteger(9007199254740992) // false\n\nNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false\nNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // true\nNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // true\nNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false\n</code></pre>\n<p>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。</p>\n<pre><code class=\"javascript\">Number.isSafeInteger = function (n) &#123;\n  return (typeof n === &#39;number&#39; &amp;&amp;\n    Math.round(n) === n &amp;&amp;\n    Number.MIN_SAFE_INTEGER &lt;= n &amp;&amp;\n    n &lt;= Number.MAX_SAFE_INTEGER);\n&#125;\n</code></pre>\n<p><strong>实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。</strong></p>\n<pre><code class=\"javascript\">Number.isSafeInteger(9007199254740993)\n// false\nNumber.isSafeInteger(990)\n// true\nNumber.isSafeInteger(9007199254740993 - 990)\n// true\n9007199254740993 - 990\n// 返回结果 9007199254740002\n// 正确答案应该是 9007199254740003\n</code></pre>\n<p>上面代码中，<code>9007199254740993</code>不是一个安全整数，但是<code>Number.isSafeInteger</code>会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以<code>9007199254740992</code>的形式储存。</p>\n<pre><code class=\"javascript\">9007199254740993 === 9007199254740992\n// true\n</code></pre>\n<p>所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。</p>\n<pre><code class=\"javascript\">function trusty (left, right, result) &#123;\n  if (\n    Number.isSafeInteger(left) &amp;&amp;\n    Number.isSafeInteger(right) &amp;&amp;\n    Number.isSafeInteger(result)\n  ) &#123;\n    return result;\n  &#125;\n  throw new RangeError(&#39;Operation cannot be trusted!&#39;);\n&#125;\n\ntrusty(9007199254740993, 990, 9007199254740993 - 990)\n// RangeError: Operation cannot be trusted!\n\ntrusty(1, 2, 3)\n// 3\n</code></pre>\n<hr>\n<h4 id=\"8-Math-对象的扩展\"><a href=\"#8-Math-对象的扩展\" class=\"headerlink\" title=\"8. Math 对象的扩展\"></a>8. Math 对象的扩展</h4><p>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p>\n<p><strong>Math.trunc()</strong></p>\n<p><strong><code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分。</strong></p>\n<pre><code class=\"javascript\">Math.trunc(4.1) // 4\nMath.trunc(4.9) // 4\nMath.trunc(-4.1) // -4\nMath.trunc(-4.9) // -4\nMath.trunc(-0.1234) // -0\n</code></pre>\n<p>对于非数值，<code>Math.trunc</code>内部使用<code>Number</code>方法将其先转为数值。</p>\n<pre><code class=\"javascript\">Math.trunc(&#39;123.456&#39;) // 123\nMath.trunc(true) //1\nMath.trunc(false) // 0\nMath.trunc(null) // 0\n</code></pre>\n<p>对于空值和无法截取整数的值，返回<code>NaN</code>。</p>\n<pre><code class=\"javascript\">Math.trunc(NaN);      // NaN\nMath.trunc(&#39;foo&#39;);    // NaN\nMath.trunc();         // NaN\nMath.trunc(undefined) // NaN\n</code></pre>\n<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>\n<pre><code class=\"javascript\">Math.trunc = Math.trunc || function(x) &#123;\n  return x &lt; 0 ? Math.ceil(x) : Math.floor(x);\n&#125;;\n</code></pre>\n<hr>\n<p><strong>Math.sign()</strong></p>\n<p><strong><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</strong></p>\n<p>它会返回五种值。</p>\n<ul>\n<li>参数为正数，返回<code>+1</code>；</li>\n<li>参数为负数，返回<code>-1</code>；</li>\n<li>参数为 0，返回<code>0</code>；</li>\n<li>参数为-0，返回<code>-0</code>;</li>\n<li>其他值，返回<code>NaN</code>。</li>\n</ul>\n<pre><code class=\"javascript\">Math.sign(-5) // -1\nMath.sign(5) // +1\nMath.sign(0) // +0\nMath.sign(-0) // -0\nMath.sign(NaN) // NaN\n</code></pre>\n<p>如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回<code>NaN</code>。</p>\n<pre><code class=\"javascript\">Math.sign(&#39;&#39;)  // 0\nMath.sign(true)  // +1\nMath.sign(false)  // 0\nMath.sign(null)  // 0\nMath.sign(&#39;9&#39;)  // +1\nMath.sign(&#39;foo&#39;)  // NaN\nMath.sign()  // NaN\nMath.sign(undefined)  // NaN\n</code></pre>\n<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>\n<pre><code class=\"javascript\">Math.sign = Math.sign || function(x) &#123;\n  x = +x; // convert to a number\n  if (x === 0 || isNaN(x)) &#123;\n    return x;\n  &#125;\n  return x &gt; 0 ? 1 : -1;\n&#125;;\n</code></pre>\n<hr>\n<p><strong>Math.cbrt()</strong></p>\n<p><strong><code>Math.cbrt()</code>方法用于计算一个数的立方根。</strong></p>\n<pre><code class=\"javascript\">Math.cbrt(-1) // -1\nMath.cbrt(0)  // 0\nMath.cbrt(1)  // 1\nMath.cbrt(2)  // 1.2599210498948732\n</code></pre>\n<p>对于非数值，<code>Math.cbrt()</code>方法内部也是先使用<code>Number()</code>方法将其转为数值。</p>\n<pre><code class=\"javascript\">Math.cbrt(&#39;8&#39;) // 2\nMath.cbrt(&#39;hello&#39;) // NaN\n</code></pre>\n<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>\n<pre><code class=\"javascript\">Math.cbrt = Math.cbrt || function(x) &#123;\n  var y = Math.pow(Math.abs(x), 1/3);\n  return x &lt; 0 ? -y : y;\n&#125;;\n</code></pre>\n<hr>\n<p><strong>Math.clz32()</strong></p>\n<p><strong><code>Math.clz32()</code>方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。</strong></p>\n<pre><code class=\"javascript\">Math.clz32(0) // 32\nMath.clz32(1) // 31\nMath.clz32(1000) // 22\nMath.clz32(0b01000000000000000000000000000000) // 1\nMath.clz32(0b00100000000000000000000000000000) // 2\n</code></pre>\n<p>上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是<code>0b1</code>，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是<code>0b1111101000</code>，一共有 10 位，所以 32 位之中有 22 个前导 0。</p>\n<p><code>clz32</code>这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。</p>\n<p>左移运算符（<code>&lt;&lt;</code>）与<code>Math.clz32</code>方法直接相关。</p>\n<pre><code class=\"javascript\">Math.clz32(0) // 32\nMath.clz32(1) // 31\nMath.clz32(1 &lt;&lt; 1) // 30\nMath.clz32(1 &lt;&lt; 2) // 29\nMath.clz32(1 &lt;&lt; 29) // 2\n</code></pre>\n<p>对于小数，<code>Math.clz32</code>方法只考虑整数部分。</p>\n<pre><code class=\"javascript\">Math.clz32(3.2) // 30\nMath.clz32(3.9) // 30\n</code></pre>\n<p>对于空值或其他类型的值，<code>Math.clz32</code>方法会将它们先转为数值，然后再计算。</p>\n<pre><code class=\"javascript\">Math.clz32() // 32\nMath.clz32(NaN) // 32\nMath.clz32(Infinity) // 32\nMath.clz32(null) // 32\nMath.clz32(&#39;foo&#39;) // 32\nMath.clz32([]) // 32\nMath.clz32(&#123;&#125;) // 32\nMath.clz32(true) // 31\n</code></pre>\n<hr>\n<p><strong>Math.imul()</strong></p>\n<p><strong><code>Math.imul</code>方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</strong></p>\n<pre><code class=\"javascript\">Math.imul(2, 4)   // 8\nMath.imul(-1, 8)  // -8\nMath.imul(-2, -2) // 4\n</code></pre>\n<p>如果只考虑最后 32 位，大多数情况下，<code>Math.imul(a, b)</code>与<code>a * b</code>的结果是相同的，即该方法等同于<code>(a * b)|0</code>的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，<code>Math.imul</code>方法可以返回正确的低位数值。</p>\n<pre><code class=\"javascript\">(0x7fffffff * 0x7fffffff)|0 // 0\n</code></pre>\n<p>上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。<code>Math.imul</code>方法可以返回正确的值 1。</p>\n<pre><code class=\"javascript\">Math.imul(0x7fffffff, 0x7fffffff) // 1\n</code></pre>\n<hr>\n<p><strong>Math.fround()</strong></p>\n<p><strong><code>Math.fround</code>方法返回一个数的32位单精度浮点数形式。</strong></p>\n<p>对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。</p>\n<pre><code class=\"javascript\">Math.fround(0)   // 0\nMath.fround(1)   // 1\nMath.fround(2 ** 24 - 1)   // 16777215\n</code></pre>\n<p>如果参数的绝对值大于 224，返回的结果便开始丢失精度。</p>\n<pre><code class=\"javascript\">Math.fround(2 ** 24)       // 16777216\nMath.fround(2 ** 24 + 1)   // 16777216\n</code></pre>\n<p><code>Math.fround</code>方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。</p>\n<pre><code class=\"javascript\">// 未丢失有效精度\nMath.fround(1.125) // 1.125\nMath.fround(7.25)  // 7.25\n\n// 丢失精度\nMath.fround(0.3)   // 0.30000001192092896\nMath.fround(0.7)   // 0.699999988079071\nMath.fround(1.0000000123) // 1\n</code></pre>\n<p>对于 <code>NaN</code> 和 <code>Infinity</code>，此方法返回原值。对于其它类型的非数值，<code>Math.fround</code> 方法会先将其转为数值，再返回单精度浮点数。</p>\n<pre><code class=\"javascript\">Math.fround(NaN)      // NaN\nMath.fround(Infinity) // Infinity\n\nMath.fround(&#39;5&#39;)      // 5\nMath.fround(true)     // 1\nMath.fround(null)     // 0\nMath.fround([])       // 0\nMath.fround(&#123;&#125;)       // NaN\n</code></pre>\n<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>\n<pre><code class=\"javascript\">Math.fround = Math.fround || function (x) &#123;\n  return new Float32Array([x])[0];\n&#125;;\n</code></pre>\n<hr>\n<p><strong>Math.hypot()</strong></p>\n<p><strong><code>Math.hypot</code>方法返回所有参数的平方和的平方根。</strong></p>\n<pre><code class=\"javascript\">Math.hypot(3, 4);        // 5\nMath.hypot(3, 4, 5);     // 7.0710678118654755\nMath.hypot();            // 0\nMath.hypot(NaN);         // NaN\nMath.hypot(3, 4, &#39;foo&#39;); // NaN\nMath.hypot(3, 4, &#39;5&#39;);   // 7.0710678118654755\nMath.hypot(-3);          // 3\n</code></pre>\n<p>上面代码中，3 的平方加上 4 的平方，等于 5 的平方。</p>\n<p>如果参数不是数值，<code>Math.hypot</code>方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。</p>\n<hr>\n<p><strong>对数方法</strong></p>\n<p>ES6 新增了 4 个对数相关方法。</p>\n<p><strong>（1） Math.expm1()</strong></p>\n<p><code>Math.expm1(x)</code>返回 ex - 1，即<code>Math.exp(x) - 1</code>。</p>\n<pre><code class=\"javascript\">Math.expm1(-1) // -0.6321205588285577\nMath.expm1(0)  // 0\nMath.expm1(1)  // 1.718281828459045\n</code></pre>\n<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>\n<pre><code class=\"javascript\">Math.expm1 = Math.expm1 || function(x) &#123;\n  return Math.exp(x) - 1;\n&#125;;\n</code></pre>\n<p><strong>（2）Math.log1p()</strong></p>\n<p><code>Math.log1p(x)</code>方法返回<code>1 + x</code>的自然对数，即<code>Math.log(1 + x)</code>。如果<code>x</code>小于-1，返回<code>NaN</code>。</p>\n<pre><code class=\"javascript\">Math.log1p(1)  // 0.6931471805599453\nMath.log1p(0)  // 0\nMath.log1p(-1) // -Infinity\nMath.log1p(-2) // NaN\n</code></pre>\n<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>\n<pre><code class=\"javascript\">Math.log1p = Math.log1p || function(x) &#123;\n  return Math.log(1 + x);\n&#125;;\n</code></pre>\n<p><strong>（3）Math.log10()</strong></p>\n<p><code>Math.log10(x)</code>返回以 10 为底的<code>x</code>的对数。如果<code>x</code>小于 0，则返回 NaN。</p>\n<pre><code class=\"javascript\">Math.log10(2)      // 0.3010299956639812\nMath.log10(1)      // 0\nMath.log10(0)      // -Infinity\nMath.log10(-2)     // NaN\nMath.log10(100000) // 5\n</code></pre>\n<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>\n<pre><code class=\"javascript\">Math.log10 = Math.log10 || function(x) &#123;\n  return Math.log(x) / Math.LN10;\n&#125;;\n</code></pre>\n<p><strong>（4）Math.log2()</strong></p>\n<p><code>Math.log2(x)</code>返回以 2 为底的<code>x</code>的对数。如果<code>x</code>小于 0，则返回 NaN。</p>\n<pre><code class=\"javascript\">Math.log2(3)       // 1.584962500721156\nMath.log2(2)       // 1\nMath.log2(1)       // 0\nMath.log2(0)       // -Infinity\nMath.log2(-2)      // NaN\nMath.log2(1024)    // 10\nMath.log2(1 &lt;&lt; 29) // 29\n</code></pre>\n<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>\n<pre><code class=\"javascript\">Math.log2 = Math.log2 || function(x) &#123;\n  return Math.log(x) / Math.LN2;\n&#125;;\n</code></pre>\n<p><strong>双曲函数方法</strong></p>\n<p>ES6 新增了 6 个双曲函数方法。</p>\n<ul>\n<li><code>Math.sinh(x)</code> 返回<code>x</code>的双曲正弦（hyperbolic sine）</li>\n<li><code>Math.cosh(x)</code> 返回<code>x</code>的双曲余弦（hyperbolic cosine）</li>\n<li><code>Math.tanh(x)</code> 返回<code>x</code>的双曲正切（hyperbolic tangent）</li>\n<li><code>Math.asinh(x)</code> 返回<code>x</code>的反双曲正弦（inverse hyperbolic sine）</li>\n<li><code>Math.acosh(x)</code> 返回<code>x</code>的反双曲余弦（inverse hyperbolic cosine）</li>\n<li><code>Math.atanh(x)</code> 返回<code>x</code>的反双曲正切（inverse hyperbolic tangent）</li>\n</ul>\n<hr>\n<h4 id=\"9-BigInt-数据类型\"><a href=\"#9-BigInt-数据类型\" class=\"headerlink\" title=\"9. BigInt 数据类型\"></a>9. BigInt 数据类型</h4><p>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回<code>Infinity</code>。</p>\n<pre><code class=\"javascript\">// 超过 53 个二进制位的数值，无法保持精度\nMath.pow(2, 53) === Math.pow(2, 53) + 1 // true\n\n// 超过 2 的 1024 次方的数值，无法表示\nMath.pow(2, 1024) // Infinity\n</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYmlnaW50\">ES2020</span> 引入了一种新的数据类型 BigInt（大整数），来解决这个问题，这是 ECMAScript 的第八种数据类型。<strong>BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</strong></p>\n<pre><code class=\"javascript\">const a = 2172141653n;\nconst b = 15346349309n;\n\n// BigInt 可以保持精度\na * b // 33334444555566667777n\n\n// 普通整数无法保持精度\nNumber(a) * Number(b) // 33334444555566670000\n</code></pre>\n<p><strong>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀<code>n</code>。</strong></p>\n<pre><code class=\"javascript\">1234 // 普通整数\n1234n // BigInt\n\n// BigInt 的运算\n1n + 2n // 3n\n</code></pre>\n<p>BigInt 同样可以使用各种进制表示，都要加上后缀<code>n</code>。</p>\n<pre><code class=\"javascript\">0b1101n // 二进制\n0o777n // 八进制\n0xFFn // 十六进制\n</code></pre>\n<p>BigInt 与普通整数是两种值，它们之间并不相等。</p>\n<pre><code class=\"javascript\">42n === 42 // false\n</code></pre>\n<p><code>typeof</code>运算符对于 BigInt 类型的数据返回<code>bigint</code>。</p>\n<pre><code class=\"javascript\">typeof 123n // &#39;bigint&#39;\n</code></pre>\n<p>BigInt 可以使用负号（<code>-</code>），但是不能使用正号（<code>+</code>），因为会与 asm.js 冲突。</p>\n<pre><code class=\"javascript\">-42n // 正确\n+42n // 报错\n</code></pre>\n<p>JavaScript 以前不能计算70的阶乘（即<code>70!</code>），因为超出了可以表示的精度。</p>\n<pre><code class=\"javascript\">let p = 1;\nfor (let i = 1; i &lt;= 70; i++) &#123;\n  p *= i;\n&#125;\nconsole.log(p); // 1.197857166996989e+100\n</code></pre>\n<p>现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就OK。</p>\n<pre><code class=\"javascript\">let p = 1n;\nfor (let i = 1n; i &lt;= 70n; i++) &#123;\n  p *= i;\n&#125;\nconsole.log(p); // 11978571...00000000n\n</code></pre>\n<hr>\n<p><strong>BigInt 函数</strong></p>\n<p>JavaScript 原生提供<code>BigInt</code>函数，可以用它生成 BigInt 类型的数值。转换规则基本与<code>Number()</code>一致，将其他类型的值转为 BigInt。</p>\n<pre><code class=\"javascript\">BigInt(123) // 123n\nBigInt(&#39;123&#39;) // 123n\nBigInt(false) // 0n\nBigInt(true) // 1n\n</code></pre>\n<p><code>BigInt()</code>函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。</p>\n<pre><code class=\"javascript\">new BigInt() // TypeError\nBigInt(undefined) //TypeError\nBigInt(null) // TypeError\nBigInt(&#39;123n&#39;) // SyntaxError\nBigInt(&#39;abc&#39;) // SyntaxError\n</code></pre>\n<p>上面代码中，尤其值得注意字符串<code>123n</code>无法解析成 Number 类型，所以会报错。</p>\n<p>参数如果是小数，也会报错。</p>\n<pre><code class=\"javascript\">BigInt(1.5) // RangeError\nBigInt(&#39;1.5&#39;) // SyntaxError\n</code></pre>\n<p>BigInt 继承了 Object 对象的两个实例方法。</p>\n<ul>\n<li><code>BigInt.prototype.toString()</code></li>\n<li><code>BigInt.prototype.valueOf()</code></li>\n</ul>\n<p>它还继承了 Number 对象的一个实例方法。</p>\n<ul>\n<li><code>BigInt.prototype.toLocaleString()</code></li>\n</ul>\n<p>此外，还提供了三个静态方法。</p>\n<ul>\n<li><code>BigInt.asUintN(width, BigInt)</code>： 给定的 BigInt 转为 0 到 2width - 1 之间对应的值。</li>\n<li><code>BigInt.asIntN(width, BigInt)</code>：给定的 BigInt 转为 -2width - 1 到 2width - 1 - 1 之间对应的值。</li>\n<li><code>BigInt.parseInt(string[, radix])</code>：近似于<code>Number.parseInt()</code>，将一个字符串转换成指定进制的 BigInt。</li>\n</ul>\n<pre><code class=\"javascript\">const max = 2n ** (64n - 1n) - 1n;\n\nBigInt.asIntN(64, max)\n// 9223372036854775807n\nBigInt.asIntN(64, max + 1n)\n// -9223372036854775808n\nBigInt.asUintN(64, max + 1n)\n// 9223372036854775808n\n</code></pre>\n<p>上面代码中，<code>max</code>是64位带符号的 BigInt 所能表示的最大值。如果对这个值加<code>1n</code>，<code>BigInt.asIntN()</code>将会返回一个负值，因为这时新增的一位将被解释为符号位。而<code>BigInt.asUintN()</code>方法由于不存在符号位，所以可以正确返回结果。</p>\n<p>如果<code>BigInt.asIntN()</code>和<code>BigInt.asUintN()</code>指定的位数，小于数值本身的位数，那么头部的位将被舍弃。</p>\n<pre><code class=\"javascript\">const max = 2n ** (64n - 1n) - 1n;\n\nBigInt.asIntN(32, max) // -1n\nBigInt.asUintN(32, max) // 4294967295n\n</code></pre>\n<p>上面代码中，<code>max</code>是一个64位的 BigInt，如果转为32位，前面的32位都会被舍弃。</p>\n<p>下面是<code>BigInt.parseInt()</code>的例子。</p>\n<pre><code class=\"javascript\">// Number.parseInt() 与 BigInt.parseInt() 的对比\nNumber.parseInt(&#39;9007199254740993&#39;, 10)\n// 9007199254740992\nBigInt.parseInt(&#39;9007199254740993&#39;, 10)\n// 9007199254740993n\n</code></pre>\n<p>上面代码中，由于有效数字超出了最大限度，<code>Number.parseInt</code>方法返回的结果是不精确的，而<code>BigInt.parseInt</code>方法正确返回了对应的 BigInt。</p>\n<p>对于二进制数组，BigInt 新增了两个类型<code>BigUint64Array</code>和<code>BigInt64Array</code>，这两种数据类型返回的都是64位 BigInt。<code>DataView</code>对象的实例方法<code>DataView.prototype.getBigInt64()</code>和<code>DataView.prototype.getBigUint64()</code>，返回的也是 BigInt。</p>\n<hr>\n<p><strong>转换规则</strong></p>\n<p>可以使用<code>Boolean()</code>、<code>Number()</code>和<code>String()</code>这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。</p>\n<pre><code class=\"javascript\">Boolean(0n) // false\nBoolean(1n) // true\nNumber(1n)  // 1\nString(1n)  // &quot;1&quot;\n</code></pre>\n<p>上面代码中，注意最后一个例子，转为字符串时后缀<code>n</code>会消失。</p>\n<p>另外，取反运算符（<code>!</code>）也可以将 BigInt 转为布尔值。</p>\n<pre><code class=\"javascript\">!0n // true\n!1n // false\n</code></pre>\n<hr>\n<p><strong>数学运算</strong></p>\n<p>数学运算方面，BigInt 类型的<code>+</code>、<code>-</code>、<code>*</code>和<code>**</code>这四个二元运算符，与 Number 类型的行为一致。除法运算<code>/</code>会舍去小数部分，返回一个整数。</p>\n<pre><code class=\"javascript\">9n / 5n\n// 1n\n</code></pre>\n<p>几乎所有的数值运算符都可以用在 BigInt，但是有两个例外。</p>\n<ul>\n<li>不带符号的右移位运算符<code>&gt;&gt;&gt;</code></li>\n<li>一元的求正运算符<code>+</code></li>\n</ul>\n<p>上面两个运算符用在 BigInt 会报错。前者是因为<code>&gt;&gt;&gt;</code>运算符是不带符号的，但是 BigInt 总是带有符号的，导致该运算无意义，完全等同于右移运算符<code>&gt;&gt;</code>。后者是因为一元运算符<code>+</code>在 asm.js 里面总是返回 Number 类型，为了不破坏 asm.js 就规定<code>+1n</code>会报错。</p>\n<p>BigInt 不能与普通数值进行混合运算。</p>\n<pre><code class=\"javascript\">1n + 1.3 // 报错\n</code></pre>\n<p>上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失精度信息。比如<code>(2n**53n + 1n) + 0.5</code>这个表达式，如果返回 BigInt 类型，<code>0.5</code>这个小数部分会丢失；如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。</p>\n<p>同样的原因，如果一个标准库函数的参数预期是 Number 类型，但是得到的是一个 BigInt，就会报错。</p>\n<pre><code class=\"javascript\">// 错误的写法\nMath.sqrt(4n) // 报错\n\n// 正确的写法\nMath.sqrt(Number(4n)) // 2\n</code></pre>\n<p>上面代码中，<code>Math.sqrt</code>的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用<code>Number</code>方法转一下类型，才能进行计算。</p>\n<p>asm.js 里面，<code>|0</code>跟在一个数值的后面会返回一个32位整数。根据不能与 Number 类型混合运算的规则，BigInt 如果与<code>|0</code>进行运算会报错。</p>\n<pre><code class=\"javascript\">1n | 0 // 报错\n</code></pre>\n<hr>\n<p><strong>其他运算</strong></p>\n<p>BigInt 对应的布尔值，与 Number 类型一致，即<code>0n</code>会转为<code>false</code>，其他值转为<code>true</code>。</p>\n<pre><code class=\"javascript\">if (0n) &#123;\n  console.log(&#39;if&#39;);\n&#125; else &#123;\n  console.log(&#39;else&#39;);\n&#125;\n// else\n</code></pre>\n<p>上面代码中，<code>0n</code>对应<code>false</code>，所以会进入<code>else</code>子句。</p>\n<p>比较运算符（比如<code>&gt;</code>）和相等运算符（<code>==</code>）允许 BigInt 与其他类型的值混合计算，因为这样做不会损失精度。</p>\n<pre><code class=\"javascript\">0n &lt; 1 // true\n0n &lt; true // true\n0n == 0 // true\n0n == false // true\n0n === 0 // false\n</code></pre>\n<p>BigInt 与字符串混合运算时，会先转为字符串，再进行运算。</p>\n<pre><code class=\"javascript\">&#39;&#39; + 123n // &quot;123&quot;\n</code></pre>\n<h3 id=\"7、函数的扩展\"><a href=\"#7、函数的扩展\" class=\"headerlink\" title=\"7、函数的扩展\"></a>7、函数的扩展</h3><hr>\n<h4 id=\"1-函数参数的默认值\"><a href=\"#1-函数参数的默认值\" class=\"headerlink\" title=\"1. 函数参数的默认值\"></a>1. 函数参数的默认值</h4><p><strong>基本用法</strong></p>\n<p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>\n<pre><code class=\"javascript\">function log(x, y) &#123;\n  y = y || &#39;World&#39;;\n  console.log(x, y);\n&#125;\n\nlog(&#39;Hello&#39;) // Hello World\nlog(&#39;Hello&#39;, &#39;China&#39;) // Hello China\nlog(&#39;Hello&#39;, &#39;&#39;) // Hello World\n</code></pre>\n<p>上面代码检查函数<code>log</code>的参数<code>y</code>有没有赋值，如果没有，则指定默认值为<code>World</code>。这种写法的缺点在于，如果参数<code>y</code>赋值了，但是对应的布尔值为<code>false</code>，则该赋值不起作用。就像上面代码的最后一行，参数<code>y</code>等于空字符，结果被改为默认值。</p>\n<p>为了避免这个问题，通常需要先判断一下参数<code>y</code>是否被赋值，如果没有，再等于默认值。</p>\n<pre><code class=\"javascript\">if (typeof y === &#39;undefined&#39;) &#123;\n  y = &#39;World&#39;;\n&#125;\n</code></pre>\n<p><strong>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</strong></p>\n<pre><code class=\"javascript\">function log(x, y = &#39;World&#39;) &#123;  \n    console.log(x, y);\n&#125;\n\nlog(&#39;Hello&#39;) // Hello World\nlog(&#39;Hello&#39;, &#39;China&#39;) // Hello China\nlog(&#39;Hello&#39;, &#39;&#39;) // Hello\n</code></pre>\n<p>以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。</p>\n<pre><code class=\"javascript\">function Point(x = 0, y = 0) &#123;\n  this.x = x;\n  this.y = y;\n&#125;\n\nconst p = new Point();\np // &#123; x: 0, y: 0 &#125;\n</code></pre>\n<p><strong>除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</strong></p>\n<p><strong>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</strong></p>\n<pre><code class=\"javascript\">function foo(x = 5) &#123;\n  let x = 1; // error\n  const x = 2; // error\n&#125;\n</code></pre>\n<p>上面代码中，参数变量<code>x</code>是默认声明的，在函数体中，不能用<code>let</code>或<code>const</code>再次声明，否则会报错。</p>\n<p><strong>使用参数默认值时，函数不能有同名参数。</strong></p>\n<pre><code class=\"javascript\">// 不报错\nfunction foo(x, x, y) &#123;\n  // ...\n&#125;\n\n// 报错\nfunction foo(x, x, y = 1) &#123;\n  // ...\n&#125;\n// SyntaxError: Duplicate parameter name not allowed in this context\n</code></pre>\n<p>另外，一个容易忽略的地方是，<strong>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</strong></p>\n<pre><code class=\"javascript\">let x = 99;\nfunction foo(p = x + 1) &#123;\n  console.log(p);\n&#125;\n\nfoo() // 100\n\nx = 100;\nfoo() // 101\n</code></pre>\n<p>上面代码中，参数<code>p</code>的默认值是<code>x + 1</code>。这时，每次调用函数<code>foo</code>，都会重新计算<code>x + 1</code>，而不是默认<code>p</code>等于 100。</p>\n<hr>\n<p><strong>与解构赋值默认值结合使用</strong></p>\n<p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>\n<pre><code class=\"javascript\">function foo(&#123;x, y = 5&#125;) &#123;\n  console.log(x, y);\n&#125;\n\nfoo(&#123;&#125;) // undefined 5\nfoo(&#123;x: 1&#125;) // 1 5\nfoo(&#123;x: 1, y: 2&#125;) // 1 2\nfoo() // TypeError: Cannot read property &#39;x&#39; of undefined\n</code></pre>\n<p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数<code>foo</code>的参数是一个对象时，变量<code>x</code>和<code>y</code>才会通过解构赋值生成。如果函数<code>foo</code>调用时没提供参数，变量<code>x</code>和<code>y</code>就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p>\n<pre><code class=\"javascript\">function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123;\n  console.log(x, y);\n&#125;\n\nfoo() // undefined 5\n</code></pre>\n<p>上面代码指定，如果没有提供参数，函数<code>foo</code>的参数默认为一个空对象。</p>\n<p>下面是另一个解构赋值默认值的例子。</p>\n<pre><code class=\"javascript\">function fetch(url, &#123; body = &#39;&#39;, method = &#39;GET&#39;, headers = &#123;&#125; &#125;) &#123;\n  console.log(method);\n&#125;\n\nfetch(&#39;http://example.com&#39;, &#123;&#125;)\n// &quot;GET&quot;\n\nfetch(&#39;http://example.com&#39;)\n// 报错\n</code></pre>\n<p>上面代码中，如果函数<code>fetch</code>的第二个参数是一个对象，<strong>就可以为它的三个属性设置默认值</strong>。这种写法不能省略第二个参数，如果<strong>结合函数参数的默认值</strong>，就可以省略第二个参数。这时，<strong>就出现了双重默认值</strong>。</p>\n<pre><code class=\"javascript\">function fetch(url, &#123; body = &#39;&#39;, method = &#39;GET&#39;, headers = &#123;&#125; &#125; = &#123;&#125;) &#123;\n  console.log(method);\n&#125;\n\nfetch(&#39;http://example.com&#39;)\n// &quot;GET&quot;\n</code></pre>\n<p><strong>function fetch(url, { body = ‘’, method = ‘GET’, headers = {} } = {})</strong></p>\n<p>上面代码中，<strong>函数<code>fetch</code>没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效</strong>，变量<code>method</code>才会取到默认值<code>GET</code>。</p>\n<p>作为练习，请问下面两种写法有什么差别？</p>\n<pre><code class=\"javascript\">// 写法一\nfunction m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;\n  return [x, y];\n&#125;\n\n// 写法二\nfunction m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;\n  return [x, y];\n&#125;\n</code></pre>\n<p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>\n<pre><code class=\"javascript\">// 函数没有参数的情况\nm1() // [0, 0]\nm2() // [0, 0]\n\n// x 和 y 都有值的情况\nm1(&#123;x: 3, y: 8&#125;) // [3, 8]\nm2(&#123;x: 3, y: 8&#125;) // [3, 8]\n\n// x 有值，y 无值的情况\nm1(&#123;x: 3&#125;) // [3, 0]\nm2(&#123;x: 3&#125;) // [3, undefined]\n\n// x 和 y 都无值的情况\nm1(&#123;&#125;) // [0, 0];\nm2(&#123;&#125;) // [undefined, undefined]\n\nm1(&#123;z: 3&#125;) // [0, 0]\nm2(&#123;z: 3&#125;) // [undefined, undefined]\n</code></pre>\n<hr>\n<p><strong>参数默认值的位置</strong></p>\n<p>通常情况下，定义了默认值的参数，<strong>应该是函数的尾参数</strong>。因为这样比较容易看出来，到底省略了哪些参数。<strong>如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</strong></p>\n<pre><code class=\"javascript\">// 例一\nfunction f(x = 1, y) &#123;\n  return [x, y];\n&#125;\n\nf() // [1, undefined]\nf(2) // [2, undefined]\nf(, 1) // 报错\nf(undefined, 1) // [1, 1]\n\n// 例二\nfunction f(x, y = 5, z) &#123;\n  return [x, y, z];\n&#125;\n\nf() // [undefined, 5, undefined]\nf(1) // [1, 5, undefined]\nf(1, ,2) // 报错\nf(1, undefined, 2) // [1, 5, 2]\n</code></pre>\n<p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入<code>undefined</code>。</p>\n<p>如果传入<code>undefined</code>，将触发该参数等于默认值，<code>null</code>则没有这个效果。</p>\n<pre><code class=\"javascript\">function foo(x = 5, y = 6) &#123;\n  console.log(x, y);\n&#125;\n\nfoo(undefined, null)\n// 5 null\n</code></pre>\n<p>上面代码中，<code>x</code>参数对应<code>undefined</code>，结果触发了默认值，<code>y</code>参数等于<code>null</code>，就没有触发默认值。</p>\n<hr>\n<p><strong>函数的 length 属性</strong></p>\n<p>指定了默认值以后，函数的<code>length</code>属性，<strong>将返回没有指定默认值的参数个数</strong>。也就是说，指定了默认值后，**<code>length</code>属性将失真**。</p>\n<pre><code class=\"javascript\">(function (a) &#123;&#125;).length // 1\n(function (a = 5) &#123;&#125;).length // 0\n(function (a, b, c = 5) &#123;&#125;).length // 2\n</code></pre>\n<p>上面代码中，<code>length</code>属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数<code>c</code>指定了默认值，因此<code>length</code>属性等于<code>3</code>减去<code>1</code>，最后得到<code>2</code>。</p>\n<p>这是因为<code>length</code>属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 <strong>rest 参数也不会计入<code>length</code>属性。</strong></p>\n<pre><code class=\"javascript\">(function(...args) &#123;&#125;).length // 0\n</code></pre>\n<p><strong>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。</strong></p>\n<pre><code class=\"javascript\">(function (a = 0, b, c) &#123;&#125;).length // 0\n(function (a, b = 1, c) &#123;&#125;).length // 1\n</code></pre>\n<hr>\n<p><strong>作用域</strong></p>\n<p><strong>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域</strong>（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。<strong>独立于函数作用域和全局作用域</strong></p>\n<pre><code class=\"javascript\">var x = 1;\n\nfunction f(x, y = x) &#123;\n  console.log(y);\n&#125;\n\nf(2) // 2\n</code></pre>\n<p>上面代码中，参数<code>y</code>的默认值等于变量<code>x</code>。调用函数<code>f</code>时，参数形成一个单独的作用域。在这个作用域里面，默认值变量<code>x</code>指向第一个参数<code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code>。</p>\n<p>再看下面的例子。</p>\n<pre><code class=\"javascript\">let x = 1;\n\nfunction f(y = x) &#123;\n  let x = 2;\n  console.log(y);\n&#125;\n\nf() // 1\n</code></pre>\n<p>上面代码中，函数<code>f</code>调用时，参数<code>y = x</code>形成一个单独的作用域。<strong>这个作用域里面，变量<code>x</code>本身没有定义，所以指向外层的全局变量<code>x</code>。函数调用时，函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>。</strong></p>\n<p><strong>如果此时，全局变量<code>x</code>不存在，就会报错。</strong>内部定义的变量影响不到</p>\n<pre><code class=\"javascript\">function f(y = x) &#123;\n  let x = 2;\n  console.log(y);\n&#125;\n\nf() // ReferenceError: x is not defined\n</code></pre>\n<p>下面这样写，也会报错。</p>\n<pre><code class=\"javascript\">var x = 1;\n\nfunction foo(x = x) &#123;\n  // ...\n&#125;\n\nfoo() // ReferenceError: Cannot access &#39;x&#39; before initialization\n</code></pre>\n<p><strong>上面代码中，参数<code>x = x</code>形成一个单独作用域。实际执行的是<code>let x = x</code>，由于暂时性死区的原因，这行代码会报错。</strong></p>\n<p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。</p>\n<pre><code class=\"javascript\">let foo = &#39;outer&#39;;\n\nfunction bar(func = () =&gt; foo) &#123;\n  let foo = &#39;inner&#39;;\n  console.log(func());\n&#125;\n\nbar(); // outer\n</code></pre>\n<p>上面代码中，函数<code>bar</code>的参数<code>func</code>的默认值是一个匿名函数，返回值为变量<code>foo</code>。函数参数形成的单独作用域里面，并没有定义变量<code>foo</code>，所以<code>foo</code>指向外层的全局变量<code>foo</code>，因此输出<code>outer</code>。</p>\n<p>如果写成下面这样，就会报错。</p>\n<pre><code class=\"javascript\">function bar(func = () =&gt; foo) &#123;\n  let foo = &#39;inner&#39;;\n  console.log(func());\n&#125;\n\nbar() // ReferenceError: foo is not defined\n</code></pre>\n<p>上面代码中，匿名函数里面的<code>foo</code>指向函数外层，但是函数外层并没有声明变量<code>foo</code>，所以就报错了。</p>\n<p>下面是一个更复杂的例子。</p>\n<pre><code class=\"javascript\">var x = 1;\nfunction foo(x, y = function() &#123; x = 2; &#125;) &#123;\n  var x = 3;\n  y();\n  console.log(x);\n&#125;\n\nfoo() // 3\nx // 1\n</code></pre>\n<p>上面代码中，函数<code>foo</code>的参数形成一个单独作用域。这个作用域里面，首先声明了变量<code>x</code>，然后声明了变量<code>y</code>，<code>y</code>的默认值是一个匿名函数。这个匿名函数内部的变量<code>x</code>，指向同一个作用域的第一个参数<code>x</code>。函数<code>foo</code>内部又声明了一个内部变量<code>x</code>，<strong>该变量与第一个参数<code>x</code>由于不是同一个作用域</strong>，所以不是同一个变量，因此执行<code>y</code>后，内部变量<code>x</code>和外部全局变量<code>x</code>的值都没变。</p>\n<p><strong>如果将<code>var x = 3</code>的<code>var</code>去除，函数<code>foo</code>的内部变量<code>x</code>就指向第一个参数<code>x</code>，与匿名函数内部的<code>x</code>是一致的，所以最后输出的就是<code>2</code>，而外层的全局变量<code>x</code>依然不受影响。</strong></p>\n<pre><code class=\"javascript\">var x = 1;\nfunction foo(x, y = function() &#123; x = 2; &#125;) &#123;\n  x = 3;\n  y();\n  console.log(x);\n&#125;\n\nfoo() // 2\nx // 1\n</code></pre>\n<hr>\n<p><strong>应用</strong></p>\n<p><strong>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</strong></p>\n<pre><code class=\"javascript\">function throwIfMissing() &#123;\n  throw new Error(&#39;Missing parameter&#39;);\n&#125;\n\nfunction foo(mustBeProvided = throwIfMissing()) &#123;\n  return mustBeProvided;\n&#125;\n\nfoo()\n// Error: Missing parameter\n</code></pre>\n<p>上面代码的<code>foo</code>函数，如果调用的时候没有参数，就会调用默认值<code>throwIfMissing</code>函数，从而抛出一个错误。</p>\n<p>从上面代码还可以看到，参数<code>mustBeProvided</code>的默认值等于<code>throwIfMissing</code>函数的运行结果（注意函数名<code>throwIfMissing</code>之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。</p>\n<p><strong>另外，可以将参数默认值设为<code>undefined</code>，表明这个参数是可以省略的。</strong></p>\n<pre><code class=\"javascript\">function foo(optional = undefined) &#123; ··· &#125;\n</code></pre>\n<hr>\n<h4 id=\"2-rest-参数\"><a href=\"#2-rest-参数\" class=\"headerlink\" title=\"2. rest 参数\"></a>2. rest 参数</h4><p><strong>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</strong></p>\n<pre><code class=\"javascript\">function add(...values) &#123;\n  let sum = 0;\n\n  for (var val of values) &#123;\n    sum += val;\n  &#125;\n\n  return sum;\n&#125;\n\nadd(2, 5, 3) // 10\n</code></pre>\n<p>上面代码的<code>add</code>函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p>\n<p>下面是一个 rest 参数代替<code>arguments</code>变量的例子。</p>\n<pre><code class=\"javascript\">// arguments变量的写法\nfunction sortNumbers() &#123;\n  return Array.from(arguments).sort();\n&#125;\n\n// rest参数的写法\nconst sortNumbers = (...numbers) =&gt; numbers.sort();\n</code></pre>\n<p><code>arguments</code>对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用<code>Array.from</code>先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组<code>push</code>方法的例子。</p>\n<pre><code class=\"javascript\">function push(array, ...items) &#123;\n  items.forEach(function(item) &#123;\n    array.push(item);\n    console.log(item);\n  &#125;);\n&#125;\n\nvar a = [];\npush(a, 1, 2, 3)\n</code></pre>\n<p><strong>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</strong></p>\n<pre><code class=\"javascript\">// 报错\nfunction f(a, ...b, c) &#123;\n  // ...\n&#125;\n</code></pre>\n<p><strong>函数的<code>length</code>属性，不包括 rest 参数。</strong></p>\n<pre><code class=\"javascript\">(function(a) &#123;&#125;).length  // 1\n(function(...a) &#123;&#125;).length  // 0\n(function(a, ...b) &#123;&#125;).length  // 1\n</code></pre>\n<hr>\n<h4 id=\"3-严格模式\"><a href=\"#3-严格模式\" class=\"headerlink\" title=\"3.  严格模式\"></a>3.  严格模式</h4><p><strong>从 ES5 开始，函数内部可以设定为严格模式。</strong></p>\n<pre><code class=\"javascript\">function doSomething(a, b) &#123;\n  &#39;use strict&#39;;\n  // code\n&#125;\n</code></pre>\n<p>ES2016 做了一点修改，规定<strong>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式</strong>，否则会报错。</p>\n<pre><code class=\"javascript\">// 报错\nfunction doSomething(a, b = a) &#123;\n  &#39;use strict&#39;;\n  // code\n&#125;\n\n// 报错\nconst doSomething = function (&#123;a, b&#125;) &#123;\n  &#39;use strict&#39;;\n  // code\n&#125;;\n\n// 报错\nconst doSomething = (...a) =&gt; &#123;\n  &#39;use strict&#39;;\n  // code\n&#125;;\n\nconst obj = &#123;\n  // 报错\n  doSomething(&#123;a, b&#125;) &#123;\n    &#39;use strict&#39;;\n    // code\n  &#125;\n&#125;;\n</code></pre>\n<p>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。</p>\n<pre><code class=\"javascript\">// 报错\nfunction doSomething(value = 070) &#123;\n  &#39;use strict&#39;;\n  return value;\n&#125;\n</code></pre>\n<p>上面代码中，参数<code>value</code>的默认值是八进制数<code>070</code>，但是严格模式下不能用前缀<code>0</code>表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行<code>value = 070</code>，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。<strong>即参数没有被严格模式限制，进入函数体内报错</strong>。</p>\n<p>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，<strong>只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</strong></p>\n<p>两种方法可以规避这种限制。第一种是<strong>设定全局性的严格模式</strong>，这是合法的。</p>\n<pre><code class=\"javascript\">&#39;use strict&#39;;\n\nfunction doSomething(a, b = a) &#123;\n  // code\n&#125;\n</code></pre>\n<p>第二种是<strong>把函数包在一个无参数的立即执行函数</strong>里面。</p>\n<pre><code class=\"javascript\">const doSomething = (function () &#123;\n  &#39;use strict&#39;;\n  return function(value = 42) &#123;\n    return value;\n  &#125;;\n&#125;());\n</code></pre>\n<hr>\n<h4 id=\"4-name-属性\"><a href=\"#4-name-属性\" class=\"headerlink\" title=\"4. name 属性\"></a>4. name 属性</h4><p><strong>函数的<code>name</code>属性，返回该函数的函数名。</strong></p>\n<pre><code class=\"javascript\">function foo() &#123;&#125;\nfoo.name // &quot;foo&quot;\n</code></pre>\n<p>这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</p>\n<p>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的<code>name</code>属性，会返回空字符串，而 <strong>ES6 的<code>name</code>属性会返回实际的函数名。</strong></p>\n<pre><code class=\"javascript\">var f = function () &#123;&#125;;\n\n// ES5\nf.name // &quot;&quot;\n\n// ES6\nf.name // &quot;f&quot;\n</code></pre>\n<p>上面代码中，变量<code>f</code>等于一个匿名函数，ES5 和 ES6 的<code>name</code>属性返回的值不一样。</p>\n<p><strong>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的<code>name</code>属性都返回这个具名函数原本的名字。</strong></p>\n<pre><code class=\"javascript\">const bar = function baz() &#123;&#125;;\n\n// ES5\nbar.name // &quot;baz&quot;\n\n// ES6\nbar.name // &quot;baz&quot;\n</code></pre>\n<p><strong><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code>。</strong></p>\n<pre><code class=\"javascript\">(new Function).name // &quot;anonymous&quot;\n</code></pre>\n<p><strong><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀。</strong></p>\n<pre><code class=\"javascript\">function foo() &#123;&#125;;\nfoo.bind(&#123;&#125;).name // &quot;bound foo&quot;\n\n(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot;\n</code></pre>\n<hr>\n<h4 id=\"5-箭头函数\"><a href=\"#5-箭头函数\" class=\"headerlink\" title=\"5. 箭头函数\"></a>5. 箭头函数</h4><p><strong>基本用法</strong></p>\n<p><strong>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</strong></p>\n<pre><code class=\"javascript\">var f = v =&gt; v;\n\n// 等同于\nvar f = function (v) &#123;\n  return v;\n&#125;;\n</code></pre>\n<p><strong>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</strong></p>\n<pre><code class=\"javascript\">var f = () =&gt; 5;\n// 等同于\nvar f = function () &#123; return 5 &#125;;\n\nvar sum = (num1, num2) =&gt; num1 + num2;\n// 等同于\nvar sum = function(num1, num2) &#123;\n  return num1 + num2;\n&#125;;\n</code></pre>\n<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p>\n<pre><code class=\"javascript\">var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;\n</code></pre>\n<p><strong>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</strong></p>\n<pre><code class=\"javascript\">// 报错\nlet getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;\n\n// 不报错\nlet getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);\n</code></pre>\n<p>下面是一种特殊情况，虽然可以运行，但会得到错误的结果。</p>\n<pre><code class=\"javascript\">let foo = () =&gt; &#123; a: 1 &#125;;\nfoo() // undefined\n</code></pre>\n<p>上面代码中，原始意图是返回一个对象<code>&#123; a: 1 &#125;</code>，但是由于引擎认为大括号是代码块，所以执行了一行语句<code>a: 1</code>。这时，<code>a</code>可以被解释为语句的标签，因此实际执行的语句是<code>1;</code>，然后函数就结束了，没有返回值。</p>\n<p>如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。</p>\n<pre><code class=\"javascript\">let fn = () =&gt; void doesNotReturn();\n</code></pre>\n<p>箭头函数可以与变量解构结合使用。</p>\n<pre><code class=\"javascript\">const full = (&#123; first, last &#125;) =&gt; first + &#39; &#39; + last;\n\n// 等同于\nfunction full(person) &#123;\n  return person.first + &#39; &#39; + person.last;\n&#125;\n</code></pre>\n<p>箭头函数使得表达更加简洁。</p>\n<pre><code class=\"javascript\">const isEven = n =&gt; n % 2 === 0;\nconst square = n =&gt; n * n;\n</code></pre>\n<p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>\n<p>箭头函数的一个用处是简化回调函数。</p>\n<pre><code class=\"javascript\">// 普通函数写法\n[1,2,3].map(function (x) &#123;\n  return x * x;\n&#125;);\n\n// 箭头函数写法\n[1,2,3].map(x =&gt; x * x);\n</code></pre>\n<p>另一个例子是</p>\n<pre><code class=\"javascript\">// 普通函数写法\nvar result = values.sort(function (a, b) &#123;\n  return a - b;\n&#125;);\n\n// 箭头函数写法\nvar result = values.sort((a, b) =&gt; a - b);\n</code></pre>\n<p>下面是 rest 参数与箭头函数结合的例子。</p>\n<pre><code class=\"javascript\">const numbers = (...nums) =&gt; nums;\n\nnumbers(1, 2, 3, 4, 5)\n// [1,2,3,4,5]\n\nconst headAndTail = (head, ...tail) =&gt; [head, tail];\n\nheadAndTail(1, 2, 3, 4, 5)\n// [1,[2,3,4,5]]\n</code></pre>\n<hr>\n<p><strong>使用注意点</strong></p>\n<p>箭头函数有几个使用注意点。</p>\n<p>（1）<strong>箭头函数没有自己的<code>this</code>对象</strong>（详见下文）。</p>\n<p>（2）<strong>不可以当作构造函数</strong>，也就是说，<strong>不可以对箭头函数使用<code>new</code>命令</strong>，否则会抛出一个错误。</p>\n<p>（3）<strong>不可以使用<code>arguments</code>对象</strong>，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>\n<p>（4）<strong>不可以使用<code>yield</code>命令</strong>，因此箭头函数不能用作 Generator 函数。</p>\n<p>上面四点中，最重要的是第一点。对于普通函数来说，内部的<code>this</code>指向函数运行时所在的对象，但是这一点对箭头函数不成立。它没有自己的<code>this</code>对象，内部的<code>this</code>就是定义时上层作用域中的<code>this</code>。也就是说，箭头函数内部的<code>this</code>指向是固定的，相比之下，普通函数的<code>this</code>指向是可变的。</p>\n<pre><code class=\"javascript\">function foo() &#123;\n  setTimeout(() =&gt; &#123;\n    console.log(&#39;id:&#39;, this.id);\n  &#125;, 100);\n&#125;\n\nvar id = 21;\n\nfoo.call(&#123; id: 42 &#125;);\n// id: 42\n</code></pre>\n<p>上面代码中，<code>setTimeout()</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>&#123;id: 42&#125;</code>），所以打印出来的是<code>42</code>。</p>\n<p>下面例子是回调函数分别为箭头函数和普通函数，对比它们内部的<code>this</code>指向。</p>\n<pre><code class=\"javascript\">function Timer() &#123;\n  this.s1 = 0;\n  this.s2 = 0;\n  // 箭头函数\n  setInterval(() =&gt; this.s1++, 1000);\n  // 普通函数\n  setInterval(function () &#123;\n    this.s2++;\n  &#125;, 1000);\n&#125;\n\nvar timer = new Timer();\n\nsetTimeout(() =&gt; console.log(&#39;s1: &#39;, timer.s1), 3100);\nsetTimeout(() =&gt; console.log(&#39;s2: &#39;, timer.s2), 3100);\n// s1: 3\n// s2: 0\n</code></pre>\n<p>上面代码中，<code>Timer</code>函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的<code>this</code>绑定定义时所在的作用域（即<code>Timer</code>函数），后者的<code>this</code>指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，<code>timer.s1</code>被更新了 3 次，而<code>timer.s2</code>一次都没更新。</p>\n<p>箭头函数实际上可以让<code>this</code>指向固定化，绑定<code>this</code>使得它不再可变，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。</p>\n<pre><code class=\"javascript\">var handler = &#123;\n  id: &#39;123456&#39;,\n\n  init: function() &#123;\n    document.addEventListener(&#39;click&#39;,\n      event =&gt; this.doSomething(event.type), false);\n  &#125;,\n\n  doSomething: function(type) &#123;\n    console.log(&#39;Handling &#39; + type  + &#39; for &#39; + this.id);\n  &#125;\n&#125;;\n</code></pre>\n<p>上面代码的<code>init()</code>方法中，<strong>使用了箭头函数，这导致这个箭头函数里面的<code>this</code>，总是指向<code>handler</code>对象</strong>。如果回调函数是普通函数，那么运行<code>this.doSomething()</code>这一行会报错，因为此时<code>this</code>指向<code>document</code>对象。</p>\n<p>总之，箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数。</p>\n<p>下面是 Babel 转箭头函数产生的 ES5 代码，就能清楚地说明<code>this</code>的指向。</p>\n<pre><code class=\"javascript\">// ES6\nfunction foo() &#123;\n  setTimeout(() =&gt; &#123;\n    console.log(&#39;id:&#39;, this.id);\n  &#125;, 100);\n&#125;\n\n// ES5\nfunction foo() &#123;\n  var _this = this;\n\n  setTimeout(function () &#123;\n    console.log(&#39;id:&#39;, _this.id);\n  &#125;, 100);\n&#125;\n</code></pre>\n<p>上面代码中，转换后的 ES5 版本清楚地说明了，<strong>箭头函数里面根本没有自己的<code>this</code>，而是引用外层的<code>this</code>。</strong></p>\n<p>请问下面的代码之中，<code>this</code>的指向有几个？</p>\n<pre><code class=\"javascript\">function foo() &#123;\n  return () =&gt; &#123;\n    return () =&gt; &#123;\n      return () =&gt; &#123;\n        console.log(&#39;id:&#39;, this.id);\n      &#125;;\n    &#125;;\n  &#125;;\n&#125;\n\nvar f = foo.call(&#123;id: 1&#125;);\n\nvar t1 = f.call(&#123;id: 2&#125;)()(); // id: 1\nvar t2 = f().call(&#123;id: 3&#125;)(); // id: 1\nvar t3 = f()().call(&#123;id: 4&#125;); // id: 1\n</code></pre>\n<p>答案是<code>this</code>的指向只有一个，就是函数<code>foo</code>的<code>this</code>，这是因为所有的内层函数都是箭头函数，都没有自己的<code>this</code>，它们的<code>this</code>其实都是最外层<code>foo</code>函数的<code>this</code>。所以不管怎么嵌套，<code>t1</code>、<code>t2</code>、<code>t3</code>都输出同样的结果。如果这个例子的所有内层函数都写成普通函数，那么每个函数的<code>this</code>都指向运行时所在的不同对象。</p>\n<p><strong>除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code>。</strong></p>\n<pre><code class=\"javascript\">function foo() &#123;\n  setTimeout(() =&gt; &#123;\n    console.log(&#39;args:&#39;, arguments);\n  &#125;, 100);\n&#125;\n\nfoo(2, 4, 6, 8)\n// args: [2, 4, 6, 8]\n</code></pre>\n<p>上面代码中，箭头函数内部的变量<code>arguments</code>，其实是函数<code>foo</code>的<code>arguments</code>变量。</p>\n<p><strong>另外，由于箭头函数没有自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</strong></p>\n<pre><code class=\"javascript\">(function() &#123;\n  return [\n    (() =&gt; this.x).bind(&#123; x: &#39;inner&#39; &#125;)()\n  ];\n&#125;).call(&#123; x: &#39;outer&#39; &#125;);\n// [&#39;outer&#39;]\n</code></pre>\n<p>上面代码中，箭头函数没有自己的<code>this</code>，所以<code>bind</code>方法无效，内部的<code>this</code>指向外部的<code>this</code>。</p>\n<p>长期以来，JavaScript 语言的<code>this</code>对象一直是一个令人头痛的问题，在对象方法中使用<code>this</code>，必须非常小心。箭头函数”绑定”<code>this</code>，很大程度上解决了这个困扰。</p>\n<hr>\n<p><strong>不适用场合</strong></p>\n<p>由于箭头函数使得<code>this</code>从“动态”变成“静态”，下面两个场合不应该使用箭头函数。</p>\n<p><strong>第一个场合是定义对象的方法，且该方法内部包括<code>this</code>。</strong></p>\n<pre><code class=\"javascript\">const cat = &#123;\n  lives: 9,\n  jumps: () =&gt; &#123;\n    this.lives--;\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，<code>cat.jumps()</code>方法是一个箭头函数，这是错误的。调用<code>cat.jumps()</code>时，如果是普通函数，该方法内部的<code>this</code>指向<code>cat</code>；如果写成上面那样的箭头函数，使得<code>this</code>指向全局对象，因此不会得到预期结果。<strong>这是因为对象不构成单独的作用域，导致<code>jumps</code>箭头函数定义时的作用域就是全局作用域。</strong></p>\n<p>再看一个例子。</p>\n<pre><code class=\"javascript\">globalThis.s = 21;\n\nconst obj = &#123;\n  s: 42,\n  m: () =&gt; console.log(this.s)\n&#125;;\n\nobj.m() // 21\n</code></pre>\n<p>上面例子中，<code>obj.m()</code>使用箭头函数定义。JavaScript 引擎的处理方法是，先在全局空间生成这个箭头函数，然后赋值给<code>obj.m</code>，这导致箭头函数内部的<code>this</code>指向全局对象，所以<code>obj.m()</code>输出的是全局空间的<code>21</code>，而不是对象内部的<code>42</code>。上面的代码实际上等同于下面的代码。</p>\n<pre><code class=\"javascript\">globalThis.s = 21;\nglobalThis.m = () =&gt; console.log(this.s);\n\nconst obj = &#123;\n  s: 42,\n  m: globalThis.m\n&#125;;\n\nobj.m() // 21\n</code></pre>\n<p>由于上面这个原因，<strong>对象的属性建议使用传统的写法定义，不要用箭头函数定义。</strong></p>\n<p><strong>第二个场合是需要动态<code>this</code>的时候，也不应使用箭头函数。</strong></p>\n<pre><code class=\"javascript\">var button = document.getElementById(&#39;press&#39;);\nbutton.addEventListener(&#39;click&#39;, () =&gt; &#123;\n  this.classList.toggle(&#39;on&#39;);\n&#125;);\n</code></pre>\n<p>上面代码运行时，点击按钮会报错，因为<code>button</code>的监听函数是一个箭头函数，导致里面的<code>this</code>就是全局对象。如果改成普通函数，<code>this</code>就会动态指向被点击的按钮对象。</p>\n<p>另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。</p>\n<hr>\n<p><strong>嵌套的箭头函数</strong></p>\n<p>箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。</p>\n<pre><code class=\"javascript\">function insert(value) &#123;\n  return &#123;into: function (array) &#123;\n    return &#123;after: function (afterValue) &#123;\n      array.splice(array.indexOf(afterValue) + 1, 0, value);\n      return array;\n    &#125;&#125;;\n  &#125;&#125;;\n&#125;\n\ninsert(2).into([1, 3]).after(1); //[1, 2, 3]\n</code></pre>\n<p>上面这个函数，可以使用箭头函数改写。</p>\n<pre><code class=\"javascript\">let insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123;after: (afterValue) =&gt; &#123;\n  array.splice(array.indexOf(afterValue) + 1, 0, value);\n  return array;\n&#125;&#125;)&#125;);\n\ninsert(2).into([1, 3]).after(1); //[1, 2, 3]\n</code></pre>\n<p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p>\n<pre><code class=\"javascript\">const pipeline = (...funcs) =&gt;\n  val =&gt; funcs.reduce((a, b) =&gt; b(a), val);\n\nconst plus1 = a =&gt; a + 1;\nconst mult2 = a =&gt; a * 2;\nconst addThenMult = pipeline(plus1, mult2);\n\naddThenMult(5)\n// 12\n</code></pre>\n<p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p>\n<pre><code class=\"javascript\">const plus1 = a =&gt; a + 1;\nconst mult2 = a =&gt; a * 2;\n\nmult2(plus1(5))\n// 12\n</code></pre>\n<p>箭头函数还有一个功能，就是可以很方便地改写 λ 演算。</p>\n<pre><code class=\"javascript\">// λ演算的写法\nfix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))\n\n// ES6的写法\nvar fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v)))\n               (x =&gt; f(v =&gt; x(x)(v)));\n</code></pre>\n<p>上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。</p>\n<hr>\n<h4 id=\"6-尾调用优化\"><a href=\"#6-尾调用优化\" class=\"headerlink\" title=\"6. 尾调用优化\"></a>6. 尾调用优化</h4><p><strong>什么是尾调用？</strong></p>\n<p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，<strong>就是指某个函数的最后一步是调用另一个函数。</strong></p>\n<pre><code class=\"javascript\">function f(x)&#123;\n  return g(x);\n&#125;\n</code></pre>\n<p>上面代码中，函数<code>f</code>的最后一步是调用函数<code>g</code>，这就叫尾调用。</p>\n<p>以下三种情况，都不属于尾调用。</p>\n<pre><code class=\"javascript\">// 情况一\nfunction f(x)&#123;\n  let y = g(x);\n  return y;\n&#125;\n\n// 情况二\nfunction f(x)&#123;\n  return g(x) + 1;\n&#125;\n\n// 情况三\nfunction f(x)&#123;\n  g(x);\n&#125;\n</code></pre>\n<p>上面代码中，情况一是调用函数<code>g</code>之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。<strong>情况三等同于下面的代码</strong>。</p>\n<pre><code class=\"javascript\">function f(x)&#123;\n  g(x);\n  return undefined;\n&#125;\n</code></pre>\n<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>\n<pre><code class=\"javascript\">function f(x) &#123;\n  if (x &gt; 0) &#123;\n    return m(x)\n  &#125;\n  return n(x);\n&#125;\n</code></pre>\n<p>上面代码中，函数<code>m</code>和<code>n</code>都属于尾调用，因为它们都是函数<code>f</code>的最后一步操作。</p>\n<p><strong>尾调用优化</strong></p>\n<p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>\n<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数<code>A</code>的内部调用函数<code>B</code>，那么在<code>A</code>的调用帧上方，还会形成一个<code>B</code>的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>\n<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>\n<pre><code class=\"javascript\">function f() &#123;\n  let m = 1;\n  let n = 2;\n  return g(m + n);\n&#125;\nf();\n\n// 等同于\nfunction f() &#123;\n  return g(3);\n&#125;\nf();\n\n// 等同于\ng(3);\n</code></pre>\n<p>上面代码中，如果函数<code>g</code>不是尾调用，函数<code>f</code>就需要保存内部变量<code>m</code>和<code>n</code>的值、<code>g</code>的调用位置等信息。但由于调用<code>g</code>之后，函数<code>f</code>就结束了，所以执行到最后一步，完全可以删除<code>f(x)</code>的调用帧，只保留<code>g(3)</code>的调用帧。</p>\n<p><strong>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</strong></p>\n<p><strong>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</strong></p>\n<pre><code class=\"javascript\">function addOne(a)&#123;\n  var one = 1;\n  function inner(b)&#123;\n    return b + one;\n  &#125;\n  return inner(a);\n&#125;\n</code></pre>\n<p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p>\n<p>注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。</p>\n<hr>\n<p><strong>尾递归</strong></p>\n<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>\n<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>\n<pre><code class=\"javascript\">function factorial(n) &#123;\n  if (n === 1) return 1;\n  return n * factorial(n - 1);\n&#125;\n\nfactorial(5) // 120\n</code></pre>\n<p>上面代码是一个阶乘函数，计算<code>n</code>的阶乘，最多需要保存<code>n</code>个调用记录，复杂度 O(n) 。</p>\n<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>\n<pre><code class=\"javascript\">function factorial(n, total) &#123;\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n&#125;\n\nfactorial(5, 1) // 120\n</code></pre>\n<p>还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。</p>\n<p>非尾递归的 Fibonacci 数列实现如下。</p>\n<pre><code class=\"javascript\">function Fibonacci (n) &#123;\n  if ( n &lt;= 1 ) &#123;return 1&#125;;\n\n  return Fibonacci(n - 1) + Fibonacci(n - 2);\n&#125;\n\nFibonacci(10) // 89\nFibonacci(100) // 超时\nFibonacci(500) // 超时\n</code></pre>\n<p>尾递归优化过的 Fibonacci 数列实现如下。</p>\n<pre><code class=\"javascript\">function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123;\n  if( n &lt;= 1 ) &#123;return ac2&#125;;\n\n  return Fibonacci2 (n - 1, ac2, ac1 + ac2);\n&#125;\n\nFibonacci2(100) // 573147844013817200000\nFibonacci2(1000) // 7.0330367711422765e+208\nFibonacci2(10000) // Infinity\n</code></pre>\n<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。</p>\n<p><strong>递归函数的改写</strong></p>\n<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量<code>total</code>，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算<code>5</code>的阶乘，需要传入两个参数<code>5</code>和<code>1</code>？</p>\n<p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p>\n<pre><code class=\"javascript\">function tailFactorial(n, total) &#123;\n  if (n === 1) return total;\n  return tailFactorial(n - 1, n * total);\n&#125;\n\nfunction factorial(n) &#123;\n  return tailFactorial(n, 1);\n&#125;\n\nfactorial(5) // 120\n</code></pre>\n<p>上面代码通过一个正常形式的阶乘函数<code>factorial</code>，调用尾递归函数<code>tailFactorial</code>，看起来就正常多了。</p>\n<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>\n<pre><code class=\"javascript\">function currying(fn, n) &#123;\n  return function (m) &#123;\n    return fn.call(this, m, n);\n  &#125;;\n&#125;\n\nfunction tailFactorial(n, total) &#123;\n  if (n === 1) return total;\n  return tailFactorial(n - 1, n * total);\n&#125;\n\nconst factorial = currying(tailFactorial, 1);\n\nfactorial(5) // 120\n</code></pre>\n<p><strong>上面代码通过柯里化，将尾递归函数<code>tailFactorial</code>变为只接受一个参数的<code>factorial</code>。</strong></p>\n<p><strong>第二种方法就简单多了，就是采用 ES6 的函数默认值。</strong></p>\n<pre><code class=\"javascript\">function factorial(n, total = 1) &#123;\n  if (n === 1) return total;\n  return factorial(n - 1, n * total);\n&#125;\n\nfactorial(5) // 120\n</code></pre>\n<p>上面代码中，参数<code>total</code>有默认值<code>1</code>，所以调用时不用提供这个值。</p>\n<p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>\n<hr>\n<p><strong>严格模式</strong></p>\n<p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>\n<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>\n<ul>\n<li><code>func.arguments</code>：返回调用时函数的参数。</li>\n<li><code>func.caller</code>：返回调用当前函数的那个函数。</li>\n</ul>\n<p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>\n<pre><code class=\"javascript\">function restricted() &#123;\n  &#39;use strict&#39;;\n  restricted.caller;    // 报错\n  restricted.arguments; // 报错\n&#125;\nrestricted();\n</code></pre>\n<p><strong>尾递归优化的实现</strong></p>\n<p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>\n<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>\n<p>下面是一个正常的递归函数。</p>\n<pre><code class=\"javascript\">function sum(x, y) &#123;\n  if (y &gt; 0) &#123;\n    return sum(x + 1, y - 1);\n  &#125; else &#123;\n    return x;\n  &#125;\n&#125;\n\nsum(1, 100000)\n// Uncaught RangeError: Maximum call stack size exceeded(…)\n</code></pre>\n<p>上面代码中，<code>sum</code>是一个递归函数，参数<code>x</code>是需要累加的值，参数<code>y</code>控制递归次数。一旦指定<code>sum</code>递归 100000 次，就会报错，提示超出调用栈的最大次数。</p>\n<p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p>\n<pre><code class=\"javascript\">function trampoline(f) &#123;\n  while (f &amp;&amp; f instanceof Function) &#123;\n    f = f();\n  &#125;\n  return f;\n&#125;\n</code></pre>\n<p>上面就是蹦床函数的一个实现，它接受一个函数<code>f</code>作为参数。只要<code>f</code>执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>\n<p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p>\n<pre><code class=\"javascript\">function sum(x, y) &#123;\n  if (y &gt; 0) &#123;\n    return sum.bind(null, x + 1, y - 1);\n  &#125; else &#123;\n    return x;\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码中，<code>sum</code>函数的每次执行，都会返回自身的另一个版本。</p>\n<p>现在，使用蹦床函数执行<code>sum</code>，就不会发生调用栈溢出。</p>\n<pre><code class=\"javascript\">trampoline(sum(1, 100000))\n// 100001\n</code></pre>\n<p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p>\n<pre><code class=\"javascript\">function tco(f) &#123;\n  var value;\n  var active = false;\n  var accumulated = [];\n\n  return function accumulator() &#123;\n    accumulated.push(arguments);\n    if (!active) &#123;\n      active = true;\n      while (accumulated.length) &#123;\n        value = f.apply(this, accumulated.shift());\n      &#125;\n      active = false;\n      return value;\n    &#125;\n  &#125;;\n&#125;\n\nvar sum = tco(function(x, y) &#123;\n  if (y &gt; 0) &#123;\n    return sum(x + 1, y - 1)\n  &#125;\n  else &#123;\n    return x\n  &#125;\n&#125;);\n\nsum(1, 100000)\n// 100001\n</code></pre>\n<p>上面代码中，<code>tco</code>函数是尾递归优化的实现，它的奥妙就在于状态变量<code>active</code>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归<code>sum</code>返回的都是<code>undefined</code>，所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮<code>sum</code>执行的参数，总是有值的，这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>\n<hr>\n<h4 id=\"7-函数参数的尾逗号\"><a href=\"#7-函数参数的尾逗号\" class=\"headerlink\" title=\"7. 函数参数的尾逗号\"></a>7. 函数参数的尾逗号</h4><p>ES2017 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2plZmZtby9lcy10cmFpbGluZy1mdW5jdGlvbi1jb21tYXM=\">允许</span>函数的最后一个参数有尾逗号（trailing comma）。</p>\n<p>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</p>\n<pre><code class=\"javascript\">function clownsEverywhere(\n  param1,\n  param2\n) &#123; /* ... */ &#125;\n\nclownsEverywhere(\n  &#39;foo&#39;,\n  &#39;bar&#39;\n);\n</code></pre>\n<p>上面代码中，如果在<code>param2</code>或<code>bar</code>后面加一个逗号，就会报错。</p>\n<p>如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数<code>clownsEverywhere</code>添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。</p>\n<pre><code class=\"javascript\">function clownsEverywhere(\n  param1,\n  param2,\n) &#123; /* ... */ &#125;\n\nclownsEverywhere(\n  &#39;foo&#39;,\n  &#39;bar&#39;,\n);\n</code></pre>\n<p>这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。</p>\n<hr>\n<h4 id=\"8-Function-prototype-toString\"><a href=\"#8-Function-prototype-toString\" class=\"headerlink\" title=\"8. Function.prototype.toString()\"></a>8. Function.prototype.toString()</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvRnVuY3Rpb24tcHJvdG90eXBlLXRvU3RyaW5nLXJldmlzaW9u\">ES2019</span> 对函数实例的<code>toString()</code>方法做出了修改。</p>\n<p><code>toString()</code>方法返回函数代码本身，以前会省略注释和空格。</p>\n<pre><code class=\"javascript\">function /* foo comment */ foo () &#123;&#125;\n\nfoo.toString()\n// function foo() &#123;&#125;\n</code></pre>\n<p>上面代码中，函数<code>foo</code>的原始代码包含注释，函数名<code>foo</code>和圆括号之间有空格，但是<code>toString()</code>方法都把它们省略了。</p>\n<p>修改后的<code>toString()</code>方法，明确要求返回一模一样的原始代码。</p>\n<pre><code class=\"javascript\">function /* foo comment */ foo () &#123;&#125;\n\nfoo.toString()\n// &quot;function /* foo comment */ foo () &#123;&#125;&quot;\n</code></pre>\n<hr>\n<h4 id=\"9-catch-命令的参数省略\"><a href=\"#9-catch-命令的参数省略\" class=\"headerlink\" title=\"9. catch 命令的参数省略\"></a>9. catch 命令的参数省略</h4><p>JavaScript 语言的<code>try...catch</code>结构，以前明确要求<code>catch</code>命令后面必须跟参数，接受<code>try</code>代码块抛出的错误对象。</p>\n<pre><code class=\"javascript\">try &#123;\n  // ...\n&#125; catch (err) &#123;\n  // 处理错误\n&#125;\n</code></pre>\n<p>上面代码中，<code>catch</code>命令后面带有参数<code>err</code>。</p>\n<p>很多时候，<code>catch</code>代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb3B0aW9uYWwtY2F0Y2gtYmluZGluZw==\">ES2019</span> 做出了改变，允许<code>catch</code>语句省略参数。</p>\n<pre><code class=\"javascript\">try &#123;\n  // ...\n&#125; catch &#123;\n  // ...\n&#125;\n</code></pre>\n<h3 id=\"8、数组的扩展\"><a href=\"#8、数组的扩展\" class=\"headerlink\" title=\"8、数组的扩展\"></a>8、数组的扩展</h3><hr>\n<h4 id=\"1-扩展运算符\"><a href=\"#1-扩展运算符\" class=\"headerlink\" title=\"1. 扩展运算符\"></a>1. 扩展运算符</h4><p><strong>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</strong></p>\n<pre><code class=\"javascript\">console.log(...[1, 2, 3])\n// 1 2 3\n\nconsole.log(1, ...[2, 3, 4], 5)\n// 1 2 3 4 5\n\n[...document.querySelectorAll(&#39;div&#39;)]\n// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]\n</code></pre>\n<p><strong>该运算符主要用于函数调用。</strong></p>\n<pre><code class=\"javascript\">function push(array, ...items) &#123;\n  array.push(...items);\n&#125;\n\nfunction add(x, y) &#123;\n  return x + y;\n&#125;\n\nconst numbers = [4, 38];\nadd(...numbers) // 42\n</code></pre>\n<p>上面代码中，<code>array.push(...items)</code>和<code>add(...numbers)</code>这两行，都是函数的调用，它们都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>\n<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>\n<pre><code class=\"javascript\">function f(v, w, x, y, z) &#123; &#125;\nconst args = [0, 1];\nf(-1, ...args, 2, ...[3]);\n</code></pre>\n<p><strong>扩展运算符后面还可以放置表达式。</strong></p>\n<pre><code class=\"javascript\">const arr = [\n  ...(x &gt; 0 ? [&#39;a&#39;] : []),\n  &#39;b&#39;,\n];\n</code></pre>\n<p><strong>如果扩展运算符后面是一个空数组，则不产生任何效果。</strong></p>\n<pre><code class=\"javascript\">[...[], 1]\n// [1]\n</code></pre>\n<p><strong>注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。</strong></p>\n<pre><code class=\"javascript\">(...[1, 2])\n// Uncaught SyntaxError: Unexpected number\n\nconsole.log((...[1, 2]))\n// Uncaught SyntaxError: Unexpected number\n\nconsole.log(...[1, 2])\n// 1 2\n</code></pre>\n<p>上面三种情况，扩展运算符都放在圆括号里面，但是前两种情况会报错，因为扩展运算符所在的括号不是函数调用。</p>\n<hr>\n<p><strong>替代函数的 apply 方法</strong></p>\n<p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。</p>\n<pre><code class=\"javascript\">// ES5 的写法\nfunction f(x, y, z) &#123;\n  // ...\n&#125;\nvar args = [0, 1, 2];\nf.apply(null, args);\n\n// ES6的写法\nfunction f(x, y, z) &#123;\n  // ...\n&#125;\nlet args = [0, 1, 2];\nf(...args);\n</code></pre>\n<p>下面是扩展运算符取代<code>apply</code>方法的一个实际的例子，应用<code>Math.max</code>方法，简化求出一个数组最大元素的写法。</p>\n<pre><code class=\"javascript\">// ES5 的写法\nMath.max.apply(null, [14, 3, 77])\n\n// ES6 的写法\nMath.max(...[14, 3, 77])\n\n// 等同于\nMath.max(14, 3, 77);\n</code></pre>\n<p>上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用<code>Math.max</code>函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用<code>Math.max</code>了。</p>\n<p>另一个例子是通过<code>push</code>函数，将一个数组添加到另一个数组的尾部。</p>\n<pre><code class=\"javascript\">// ES5的 写法\nvar arr1 = [0, 1, 2];\nvar arr2 = [3, 4, 5];\nArray.prototype.push.apply(arr1, arr2);\n\n// ES6 的写法\nlet arr1 = [0, 1, 2];\nlet arr2 = [3, 4, 5];\narr1.push(...arr2);\n</code></pre>\n<p>上面代码的 ES5 写法中，<code>push</code>方法的参数不能是数组，所以只好通过<code>apply</code>方法变通使用<code>push</code>方法。有了扩展运算符，就可以直接将数组传入<code>push</code>方法。</p>\n<p>下面是另外一个例子。</p>\n<pre><code class=\"javascript\">// ES5\nnew (Date.bind.apply(Date, [null, 2015, 1, 1]))\n// ES6\nnew Date(...[2015, 1, 1]);\n</code></pre>\n<p><strong>扩展运算符的应用</strong></p>\n<p><strong>（1）复制数组</strong></p>\n<p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p>\n<pre><code class=\"javascript\">const a1 = [1, 2];\nconst a2 = a1;\n\na2[0] = 2;\na1 // [2, 2]\n</code></pre>\n<p>上面代码中，<code>a2</code>并不是<code>a1</code>的克隆，而是指向同一份数据的另一个指针。修改<code>a2</code>，会直接导致<code>a1</code>的变化。</p>\n<p><strong>ES5 只能用变通方法来复制数组。</strong></p>\n<pre><code class=\"javascript\">const a1 = [1, 2];\nconst a2 = a1.concat();\n\na2[0] = 2;\na1 // [1, 2]\n</code></pre>\n<p>上面代码中，<code>a1</code>会返回原数组的克隆，再修改<code>a2</code>就不会对<code>a1</code>产生影响。</p>\n<p><strong>扩展运算符提供了复制数组的简便写法。</strong></p>\n<pre><code class=\"javascript\">const a1 = [1, 2];\n// 写法一\nconst a2 = [...a1];\n// 写法二\nconst [...a2] = a1;\n</code></pre>\n<p>上面的两种写法，<code>a2</code>都是<code>a1</code>的克隆。</p>\n<p><strong>（2）合并数组</strong></p>\n<p>扩展运算符提供了数组合并的新写法。</p>\n<pre><code class=\"javascript\">const arr1 = [&#39;a&#39;, &#39;b&#39;];\nconst arr2 = [&#39;c&#39;];\nconst arr3 = [&#39;d&#39;, &#39;e&#39;];\n\n// ES5 的合并数组\narr1.concat(arr2, arr3);\n// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]\n\n// ES6 的合并数组\n[...arr1, ...arr2, ...arr3]\n// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]\n</code></pre>\n<p>不过，这两种方法都是浅拷贝，使用的时候需要注意。</p>\n<pre><code class=\"javascript\">const a1 = [&#123; foo: 1 &#125;];\nconst a2 = [&#123; bar: 2 &#125;];\n\nconst a3 = a1.concat(a2);\nconst a4 = [...a1, ...a2];\n\na3[0] === a1[0] // true\na4[0] === a1[0] // true\n</code></pre>\n<p>上面代码中，<code>a3</code>和<code>a4</code>是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。</p>\n<p><strong>（3）与解构赋值结合</strong></p>\n<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>\n<pre><code class=\"javascript\">// ES5\na = list[0], rest = list.slice(1)\n// ES6\n[a, ...rest] = list\n</code></pre>\n<p>下面是另外一些例子。</p>\n<pre><code class=\"javascript\">const [first, ...rest] = [1, 2, 3, 4, 5];\nfirst // 1\nrest  // [2, 3, 4, 5]\n\nconst [first, ...rest] = [];\nfirst // undefined\nrest  // []\n\nconst [first, ...rest] = [&quot;foo&quot;];\nfirst  // &quot;foo&quot;\nrest   // []\n</code></pre>\n<p><strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p>\n<pre><code class=\"javascript\">const [...butLast, last] = [1, 2, 3, 4, 5];\n// 报错\n\nconst [first, ...middle, last] = [1, 2, 3, 4, 5];\n// 报错\n</code></pre>\n<p><strong>（4）字符串</strong></p>\n<p><strong>扩展运算符还可以将字符串转为真正的数组。</strong></p>\n<pre><code class=\"javascript\">[...&#39;hello&#39;]\n// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]\n</code></pre>\n<p><strong>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。</strong></p>\n<pre><code class=\"javascript\">&#39;x\\uD83D\\uDE80y&#39;.length // 4\n[...&#39;x\\uD83D\\uDE80y&#39;].length // 3\n</code></pre>\n<p>上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p>\n<pre><code class=\"javascript\">function length(str) &#123;\n  return [...str].length;\n&#125;\n\nlength(&#39;x\\uD83D\\uDE80y&#39;) // 3\n</code></pre>\n<p>凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>\n<pre><code class=\"javascript\">let str = &#39;x\\uD83D\\uDE80y&#39;;\n\nstr.split(&#39;&#39;).reverse().join(&#39;&#39;)\n// &#39;y\\uDE80\\uD83Dx&#39;\n\n[...str].reverse().join(&#39;&#39;)\n// &#39;y\\uD83D\\uDE80x&#39;\n</code></pre>\n<p>上面代码中，如果不用扩展运算符，字符串的<code>reverse</code>操作就不正确。</p>\n<p><strong>（5）实现了 Iterator 接口的对象</strong></p>\n<p>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p>\n<pre><code class=\"javascript\">let nodeList = document.querySelectorAll(&#39;div&#39;);\nlet array = [...nodeList];\n</code></pre>\n<p>上面代码中，<code>querySelectorAll</code>方法返回的是一个<code>NodeList</code>对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于<code>NodeList</code>对象实现了 Iterator 。</p>\n<pre><code class=\"javascript\">Number.prototype[Symbol.iterator] = function*() &#123;\n  let i = 0;\n  let num = this.valueOf();\n  while (i &lt; num) &#123;\n    yield i++;\n  &#125;\n&#125;\n\nconsole.log([...5]) // [0, 1, 2, 3, 4]\n</code></pre>\n<p>上面代码中，先定义了<code>Number</code>对象的遍历器接口，扩展运算符将<code>5</code>自动转成<code>Number</code>实例以后，就会调用这个接口，就会返回自定义的结果。</p>\n<p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>\n<pre><code class=\"javascript\">let arrayLike = &#123;\n  &#39;0&#39;: &#39;a&#39;,\n  &#39;1&#39;: &#39;b&#39;,\n  &#39;2&#39;: &#39;c&#39;,\n  length: 3\n&#125;;\n\n// TypeError: Cannot spread non-iterable object.\nlet arr = [...arrayLike];\n</code></pre>\n<p>上面代码中，<code>arrayLike</code>是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，<strong>可以改为使用<code>Array.from</code>方法将<code>arrayLike</code>转为真正的数组。</strong></p>\n<p><strong>（6）Map 和 Set 结构，Generator 函数</strong></p>\n<p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p>\n<pre><code class=\"javascript\">let map = new Map([\n  [1, &#39;one&#39;],\n  [2, &#39;two&#39;],\n  [3, &#39;three&#39;],\n]);\n\nlet arr = [...map.keys()]; // [1, 2, 3]\n</code></pre>\n<p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>\n<pre><code class=\"javascript\">const go = function*()&#123;\n  yield 1;\n  yield 2;\n  yield 3;\n&#125;;\n\n[...go()] // [1, 2, 3]\n</code></pre>\n<p>上面代码中，变量<code>go</code>是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>\n<p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。</p>\n<pre><code class=\"javascript\">const obj = &#123;a: 1, b: 2&#125;;\nlet arr = [...obj]; // TypeError: Cannot spread non-iterable object\n</code></pre>\n<hr>\n<h4 id=\"2-Array-from\"><a href=\"#2-Array-from\" class=\"headerlink\" title=\"2. Array.from()\"></a>2. Array.from()</h4><p><strong><code>Array.from</code>方法用于将两类对象转为真正的数组：****类似数组的对象</strong>（array-like object）和<strong>可遍历（iterable）的对象</strong>（包括 ES6 新增的数据结构 Set 和 Map）。</p>\n<p>下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。</p>\n<pre><code class=\"javascript\">let arrayLike = &#123;\n    &#39;0&#39;: &#39;a&#39;,\n    &#39;1&#39;: &#39;b&#39;,\n    &#39;2&#39;: &#39;c&#39;,\n    length: 3\n&#125;;\n\n// ES5的写法\nvar arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n</code></pre>\n<p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的<code>arguments</code>对象。<code>Array.from</code>都可以将它们转为真正的数组。</p>\n<pre><code class=\"javascript\">// NodeList对象\nlet ps = document.querySelectorAll(&#39;p&#39;);\nArray.from(ps).filter(p =&gt; &#123;\n  return p.textContent.length &gt; 100;\n&#125;);\n\n// arguments对象\nfunction foo() &#123;\n  var args = Array.from(arguments);\n  // ...\n&#125;\n</code></pre>\n<p>上面代码中，<code>querySelectorAll</code>方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用<code>filter</code>方法。</p>\n<p>只要是部署了 Iterator 接口的数据结构，<code>Array.from</code>都能将其转为数组。</p>\n<pre><code class=\"javascript\">Array.from(&#39;hello&#39;)\n// [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]\n\nlet namesSet = new Set([&#39;a&#39;, &#39;b&#39;])\nArray.from(namesSet) // [&#39;a&#39;, &#39;b&#39;]\n</code></pre>\n<p>上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被<code>Array.from</code>转为真正的数组。</p>\n<p>如果参数是一个真正的数组，<code>Array.from</code>会返回一个一模一样的新数组。</p>\n<pre><code class=\"javascript\">Array.from([1, 2, 3])\n// [1, 2, 3]\n</code></pre>\n<p>值得提醒的是，扩展运算符（<code>...</code>）也可以将某些数据结构转为数组。</p>\n<pre><code class=\"javascript\">// arguments对象\nfunction foo() &#123;\n  const args = [...arguments];\n&#125;\n\n// NodeList对象\n[...document.querySelectorAll(&#39;div&#39;)]\n</code></pre>\n<p><strong>扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换</strong>。<code>Array.from</code>方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性。因此，<strong>任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组，而此时扩展运算符就无法转换。</strong></p>\n<pre><code class=\"javascript\">Array.from(&#123; length: 3 &#125;);\n// [ undefined, undefined, undefined ]\n</code></pre>\n<p>上面代码中，<code>Array.from</code>返回了一个具有三个成员的数组，每个位置的值都是<code>undefined</code>。扩展运算符转换不了这个对象。</p>\n<p>对于还没有部署该方法的浏览器，可以用<code>Array.prototype.slice</code>方法替代。</p>\n<pre><code class=\"javascript\">const toArray = (() =&gt;\n  Array.from ? Array.from : obj =&gt; [].slice.call(obj)\n)();\n</code></pre>\n<p><strong><code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</strong></p>\n<pre><code class=\"javascript\">Array.from(arrayLike, x =&gt; x * x);\n// 等同于\nArray.from(arrayLike).map(x =&gt; x * x);\n\nArray.from([1, 2, 3], (x) =&gt; x * x)\n// [1, 4, 9]\n</code></pre>\n<p>下面的例子是取出一组 DOM 节点的文本内容。</p>\n<pre><code class=\"javascript\">let spans = document.querySelectorAll(&#39;span.name&#39;);\n\n// map()\nlet names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);\n\n// Array.from()\nlet names2 = Array.from(spans, s =&gt; s.textContent)\n</code></pre>\n<p>下面的例子将数组中布尔值为<code>false</code>的成员转为<code>0</code>。</p>\n<pre><code class=\"javascript\">Array.from([1, , 2, , 3], (n) =&gt; n || 0)\n// [1, 0, 2, 0, 3]\n</code></pre>\n<p>另一个例子是返回各种数据的类型。</p>\n<pre><code class=\"javascript\">function typesOf () &#123;\n  return Array.from(arguments, value =&gt; typeof value)\n&#125;\ntypesOf(null, [], NaN)\n// [&#39;object&#39;, &#39;object&#39;, &#39;number&#39;]\n</code></pre>\n<p>如果<code>map</code>函数里面用到了<code>this</code>关键字，还可以传入<code>Array.from</code>的第三个参数，用来绑定<code>this</code>。</p>\n<p><code>Array.from()</code>可以将各种值转为真正的数组，并且还提供<code>map</code>功能。这实际上意味着，<strong>只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</strong></p>\n<pre><code class=\"javascript\">Array.from(&#123; length: 2 &#125;, () =&gt; &#39;jack&#39;)\n// [&#39;jack&#39;, &#39;jack&#39;]\n</code></pre>\n<p>上面代码中，<code>Array.from</code>的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。</p>\n<p><code>Array.from()</code>的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于<code>\\uFFFF</code>的 Unicode 字符，算作两个字符的 bug。</p>\n<pre><code class=\"javascript\">function countSymbols(string) &#123;\n  return Array.from(string).length;\n&#125;\n</code></pre>\n<hr>\n<h4 id=\"3-Array-of\"><a href=\"#3-Array-of\" class=\"headerlink\" title=\"3. Array.of()\"></a>3. Array.of()</h4><p><strong><code>Array.of()</code>方法用于将一组值，转换为数组。</strong></p>\n<pre><code class=\"javascript\">Array.of(3, 11, 8) // [3,11,8]\nArray.of(3) // [3]\nArray.of(3).length // 1\n</code></pre>\n<p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。<strong>因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</strong></p>\n<pre><code class=\"javascript\">Array() // []\nArray(3) // [, , ,]\nArray(3, 11, 8) // [3, 11, 8]\n</code></pre>\n<p>上面代码中，<code>Array()</code>方法没有参数、一个参数、三个参数时，返回的结果都不一样。只有当参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组。参数只有一个正整数时，实际上是指定数组的长度。</p>\n<p><code>Array.of()</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>\n<pre><code class=\"javascript\">Array.of() // []\nArray.of(undefined) // [undefined]\nArray.of(1) // [1]\nArray.of(1, 2) // [1, 2]\n</code></pre>\n<p><code>Array.of()</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>\n<p><code>Array.of()</code>方法可以用下面的代码模拟实现。</p>\n<pre><code class=\"javascript\">function ArrayOf()&#123;\n  return [].slice.call(arguments);\n&#125;\n</code></pre>\n<hr>\n<h4 id=\"4-数组实例的-copyWithin\"><a href=\"#4-数组实例的-copyWithin\" class=\"headerlink\" title=\"4. 数组实例的 copyWithin()\"></a>4. 数组实例的 copyWithin()</h4><p><strong>数组实例的<code>copyWithin()</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</strong>。也就是说，使用这个方法，<strong>会修改当前数组</strong>。</p>\n<pre><code class=\"javascript\">Array.prototype.copyWithin(target, start = 0, end = this.length)\n</code></pre>\n<p>它接受三个参数。</p>\n<ul>\n<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>\n<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>\n<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>\n</ul>\n<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>\n<pre><code class=\"javascript\">[1, 2, 3, 4, 5].copyWithin(0, 3)\n// [4, 5, 3, 4, 5]\n</code></pre>\n<p>上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。</p>\n<p>下面是更多例子。</p>\n<pre><code class=\"javascript\">// 将3号位复制到0号位\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4)\n// [4, 2, 3, 4, 5]\n\n// -2相当于3号位，-1相当于4号位\n[1, 2, 3, 4, 5].copyWithin(0, -2, -1)\n// [4, 2, 3, 4, 5]\n\n// 将3号位复制到0号位\n[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)\n// &#123;0: 1, 3: 1, length: 5&#125;\n\n// 将2号位到数组结束，复制到0号位\nlet i32a = new Int32Array([1, 2, 3, 4, 5]);\ni32a.copyWithin(0, 2);\n// Int32Array [3, 4, 5, 4, 5]\n\n// 对于没有部署 TypedArray 的 copyWithin 方法的平台\n// 需要采用下面的写法\n[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);\n// Int32Array [4, 2, 3, 4, 5]\n</code></pre>\n<hr>\n<h4 id=\"5-数组实例的-find-和-findIndex\"><a href=\"#5-数组实例的-find-和-findIndex\" class=\"headerlink\" title=\"5. 数组实例的 find() 和 findIndex()\"></a>5. 数组实例的 find() 和 findIndex()</h4><p><strong>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</strong></p>\n<pre><code class=\"javascript\">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)\n// -5\n</code></pre>\n<p>上面代码找出数组中第一个小于 0 的成员。</p>\n<pre><code class=\"javascript\">[1, 5, 10, 15].find(function(value, index, arr) &#123;\n  return value &gt; 9;\n&#125;) // 10\n</code></pre>\n<p>上面代码中，<code>find</code>方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>\n<p>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</p>\n<pre><code class=\"javascript\">[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;\n  return value &gt; 9;\n&#125;) // 2\n</code></pre>\n<p><strong>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</strong></p>\n<pre><code class=\"javascript\">function f(v)&#123;\n  return v &gt; this.age;\n&#125;\nlet person = &#123;name: &#39;John&#39;, age: 20&#125;;\n[10, 12, 26, 15].find(f, person);    // 26\n</code></pre>\n<p>上面的代码中，<code>find</code>函数接收了第二个参数<code>person</code>对象，回调函数中的<code>this</code>对象指向<code>person</code>对象。</p>\n<p>另外，这两个方法都可以发现<code>NaN</code>，弥补了数组的<code>indexOf</code>方法的不足。</p>\n<pre><code class=\"javascript\">[NaN].indexOf(NaN)\n// -1\n\n[NaN].findIndex(y =&gt; Object.is(NaN, y))\n// 0\n</code></pre>\n<p>上面代码中，<code>indexOf</code>方法无法识别数组的<code>NaN</code>成员，但是<code>findIndex</code>方法可以借助<code>Object.is</code>方法做到。</p>\n<hr>\n<h4 id=\"6-数组实例的-fill\"><a href=\"#6-数组实例的-fill\" class=\"headerlink\" title=\"6. 数组实例的 fill()\"></a>6. 数组实例的 fill()</h4><p><strong><code>fill</code>方法使用给定值，填充一个数组。</strong></p>\n<pre><code class=\"javascript\">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)\n// [7, 7, 7]\n\nnew Array(3).fill(7)\n// [7, 7, 7]\n</code></pre>\n<p>上面代码表明，**<code>fill</code>方法用于空数组的初始化非常方便**。数组中已有的元素，会被全部抹去。</p>\n<p><strong><code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</strong></p>\n<pre><code class=\"javascript\">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)\n// [&#39;a&#39;, 7, &#39;c&#39;]\n</code></pre>\n<p>上面代码表示，<code>fill</code>方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</p>\n<p><strong>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</strong></p>\n<pre><code class=\"javascript\">let arr = new Array(3).fill(&#123;name: &quot;Mike&quot;&#125;);\narr[0].name = &quot;Ben&quot;;\narr\n// [&#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;]\n\nlet arr = new Array(3).fill([]);\narr[0].push(5);\narr\n// [[5], [5], [5]]\n</code></pre>\n<hr>\n<h4 id=\"7-数组实例的-entries-，keys-和-values\"><a href=\"#7-数组实例的-entries-，keys-和-values\" class=\"headerlink\" title=\"7. 数组实例的 entries()，keys() 和 values()\"></a>7. 数组实例的 entries()，keys() 和 values()</h4><p>ES6 提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——<strong>用于遍历数组</strong>。它们都返回一个遍历器对象（详见《Iterator》一章），可以用<code>for...of</code>循环进行遍历，唯一的区别是**<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。**</p>\n<pre><code class=\"javascript\">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) &#123;\n  console.log(index);\n&#125;\n// 0\n// 1\n\nfor (let elem of [&#39;a&#39;, &#39;b&#39;].values()) &#123;\n  console.log(elem);\n&#125;\n// &#39;a&#39;\n// &#39;b&#39;\n\nfor (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) &#123;\n  console.log(index, elem);\n&#125;\n// 0 &quot;a&quot;\n// 1 &quot;b&quot;\n</code></pre>\n<p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>\n<pre><code class=\"javascript\">let letter = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];\nlet entries = letter.entries();\nconsole.log(entries.next().value); // [0, &#39;a&#39;]\nconsole.log(entries.next().value); // [1, &#39;b&#39;]\nconsole.log(entries.next().value); // [2, &#39;c&#39;]\n</code></pre>\n<hr>\n<h4 id=\"8-数组实例的-includes\"><a href=\"#8-数组实例的-includes\" class=\"headerlink\" title=\"8. 数组实例的 includes()\"></a>8. 数组实例的 includes()</h4><p><strong><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似</strong>。ES2016 引入了该方法。</p>\n<pre><code class=\"javascript\">[1, 2, 3].includes(2)     // true\n[1, 2, 3].includes(4)     // false\n[1, 2, NaN].includes(NaN) // true\n</code></pre>\n<p><strong>该方法的第二个参数表示搜索的起始位置，默认为<code>0</code>。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为<code>-4</code>，但数组长度为<code>3</code>），则会重置为从<code>0</code>开始。</strong></p>\n<pre><code class=\"javascript\">[1, 2, 3].includes(3, 3);  // false\n[1, 2, 3].includes(3, -1); // true\n</code></pre>\n<p>没有该方法之前，我们通常使用数组的<code>indexOf</code>方法，检查是否包含某个值。</p>\n<pre><code class=\"javascript\">if (arr.indexOf(el) !== -1) &#123;\n  // ...\n&#125;\n</code></pre>\n<p><code>indexOf</code>方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于<code>-1</code>，表达起来不够直观。二是，它内部使用严格相等运算符（<code>===</code>）进行判断，这会导致对<code>NaN</code>的误判。</p>\n<pre><code class=\"javascript\">[NaN].indexOf(NaN)\n// -1\n</code></pre>\n<p><code>includes</code>使用的是不一样的判断算法，就没有这个问题。</p>\n<pre><code class=\"javascript\">[NaN].includes(NaN)\n// true\n</code></pre>\n<p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p>\n<pre><code class=\"javascript\">const contains = (() =&gt;\n  Array.prototype.includes\n    ? (arr, value) =&gt; arr.includes(value)\n    : (arr, value) =&gt; arr.some(el =&gt; el === value)\n)();\ncontains([&#39;foo&#39;, &#39;bar&#39;], &#39;baz&#39;); // =&gt; false\n</code></pre>\n<p>另外，Map 和 Set 数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p>\n<ul>\n<li>Map 结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li>\n<li>Set 结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</li>\n</ul>\n<hr>\n<h4 id=\"9-数组实例的-flat-，flatMap\"><a href=\"#9-数组实例的-flat-，flatMap\" class=\"headerlink\" title=\"9. 数组实例的 flat()，flatMap()\"></a>9. 数组实例的 flat()，flatMap()</h4><p><strong>数组的成员有时还是数组，<code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</strong></p>\n<pre><code class=\"javascript\">[1, 2, [3, 4]].flat()\n// [1, 2, 3, 4]\n</code></pre>\n<p>上面代码中，原数组的成员里面有一个数组，<code>flat()</code>方法将子数组的成员取出来，添加在原来的位置。</p>\n<p><strong><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1。</strong></p>\n<pre><code class=\"javascript\">[1, 2, [3, [4, 5]]].flat()\n// [1, 2, 3, [4, 5]]\n\n[1, 2, [3, [4, 5]]].flat(2)\n// [1, 2, 3, 4, 5]\n</code></pre>\n<p>上面代码中，<code>flat()</code>的参数为2，表示要“拉平”两层的嵌套数组。</p>\n<p>如果不管有多少层嵌套，都要转成一维数组，可以用<code>Infinity</code>关键字作为参数。</p>\n<pre><code class=\"javascript\">[1, [2, [3]]].flat(Infinity)\n// [1, 2, 3]\n</code></pre>\n<p>如果原数组有空位，<code>flat()</code>方法会跳过空位。</p>\n<pre><code class=\"javascript\">[1, 2, , 4, 5].flat()\n// [1, 2, 4, 5]\n</code></pre>\n<p><code>flatMap()</code>方法对原数组的每个成员执行一个函数（相当于执行<code>Array.prototype.map()</code>），然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组。</p>\n<pre><code class=\"javascript\">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()\n[2, 3, 4].flatMap((x) =&gt; [x, x * 2])\n// [2, 4, 3, 6, 4, 8]\n</code></pre>\n<p><code>flatMap()</code>只能展开一层数组。</p>\n<pre><code class=\"javascript\">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()\n[1, 2, 3, 4].flatMap(x =&gt; [[x * 2]])\n// [[2], [4], [6], [8]]\n</code></pre>\n<p>上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此<code>flatMap()</code>返回的还是一个嵌套数组。</p>\n<p><code>flatMap()</code>方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。</p>\n<pre><code class=\"javascript\">arr.flatMap(function callback(currentValue[, index[, array]]) &#123;\n  // ...\n&#125;[, thisArg])\n</code></pre>\n<p><code>flatMap()</code>方法还可以有第二个参数，用来绑定遍历函数里面的<code>this</code>。</p>\n<hr>\n<h4 id=\"10-数组的空位\"><a href=\"#10-数组的空位\" class=\"headerlink\" title=\"10. 数组的空位\"></a>10. 数组的空位</h4><p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。</p>\n<pre><code class=\"javascript\">Array(3) // [, , ,]\n</code></pre>\n<p>上面代码中，<code>Array(3)</code>返回一个具有 3 个空位的数组。</p>\n<p>注意，空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>\n<pre><code class=\"javascript\">0 in [undefined, undefined, undefined] // true\n0 in [, , ,] // false\n</code></pre>\n<p>上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。</p>\n<p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>\n<ul>\n<li><code>forEach()</code>, <code>filter()</code>, <code>reduce()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。</li>\n<li><code>map()</code>会跳过空位，但会保留这个值</li>\n<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>\n</ul>\n<pre><code class=\"javascript\">// forEach方法\n[,&#39;a&#39;].forEach((x,i) =&gt; console.log(i)); // 1\n\n// filter方法\n[&#39;a&#39;,,&#39;b&#39;].filter(x =&gt; true) // [&#39;a&#39;,&#39;b&#39;]\n\n// every方法\n[,&#39;a&#39;].every(x =&gt; x===&#39;a&#39;) // true\n\n// reduce方法\n[1,,2].reduce((x,y) =&gt; x+y) // 3\n\n// some方法\n[,&#39;a&#39;].some(x =&gt; x !== &#39;a&#39;) // false\n\n// map方法\n[,&#39;a&#39;].map(x =&gt; 1) // [,1]\n\n// join方法\n[,&#39;a&#39;,undefined,null].join(&#39;#&#39;) // &quot;#a##&quot;\n\n// toString方法\n[,&#39;a&#39;,undefined,null].toString() // &quot;,a,,&quot;\n</code></pre>\n<p>ES6 则是明确将空位转为<code>undefined</code>。</p>\n<p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>\n<pre><code class=\"javascript\">Array.from([&#39;a&#39;,,&#39;b&#39;])\n// [ &quot;a&quot;, undefined, &quot;b&quot; ]\n</code></pre>\n<p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>\n<pre><code class=\"javascript\">[...[&#39;a&#39;,,&#39;b&#39;]]\n// [ &quot;a&quot;, undefined, &quot;b&quot; ]\n</code></pre>\n<p><code>copyWithin()</code>会连空位一起拷贝。</p>\n<pre><code class=\"javascript\">[,&#39;a&#39;,&#39;b&#39;,,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;]\n</code></pre>\n<p><code>fill()</code>会将空位视为正常的数组位置。</p>\n<pre><code class=\"javascript\">new Array(3).fill(&#39;a&#39;) // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]\n</code></pre>\n<p><code>for...of</code>循环也会遍历空位。</p>\n<pre><code class=\"javascript\">let arr = [, ,];\nfor (let i of arr) &#123;\n  console.log(1);\n&#125;\n// 1\n// 1\n</code></pre>\n<p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略它们。如果改成<code>map</code>方法遍历，空位是会跳过的。</p>\n<p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。</p>\n<pre><code class=\"javascript\">// entries()\n[...[,&#39;a&#39;].entries()] // [[0,undefined], [1,&quot;a&quot;]]\n\n// keys()\n[...[,&#39;a&#39;].keys()] // [0,1]\n\n// values()\n[...[,&#39;a&#39;].values()] // [undefined,&quot;a&quot;]\n\n// find()\n[,&#39;a&#39;].find(x =&gt; true) // undefined\n\n// findIndex()\n[,&#39;a&#39;].findIndex(x =&gt; true) // 0\n</code></pre>\n<p><strong>由于空位的处理规则非常不统一，所以建议避免出现空位。</strong></p>\n<hr>\n<h4 id=\"11-Array-prototype-sort-的排序稳定性\"><a href=\"#11-Array-prototype-sort-的排序稳定性\" class=\"headerlink\" title=\"11. Array.prototype.sort() 的排序稳定性\"></a>11. Array.prototype.sort() 的排序稳定性</h4><p>排序稳定性（stable sorting）是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变。</p>\n<pre><code class=\"javascript\">const arr = [\n  &#39;peach&#39;,\n  &#39;straw&#39;,\n  &#39;apple&#39;,\n  &#39;spork&#39;\n];\n\nconst stableSorting = (s1, s2) =&gt; &#123;\n  if (s1[0] &lt; s2[0]) return -1;\n  return 1;\n&#125;;\n\narr.sort(stableSorting)\n// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;]\n</code></pre>\n<p>上面代码对数组<code>arr</code>按照首字母进行排序。排序结果中，<code>straw</code>在<code>spork</code>的前面，跟原始顺序一致，所以排序算法<code>stableSorting</code>是稳定排序。</p>\n<pre><code class=\"javascript\">const unstableSorting = (s1, s2) =&gt; &#123;\n  if (s1[0] &lt;= s2[0]) return -1;\n  return 1;\n&#125;;\n\narr.sort(unstableSorting)\n// [&quot;apple&quot;, &quot;peach&quot;, &quot;spork&quot;, &quot;straw&quot;]\n</code></pre>\n<p>上面代码中，排序结果是<code>spork</code>在<code>straw</code>前面，跟原始顺序相反，所以排序算法<code>unstableSorting</code>是不稳定的。</p>\n<p>常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行。</p>\n<p>早先的 ECMAScript 没有规定，<code>Array.prototype.sort()</code>的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvZWNtYTI2Mi9wdWxsLzEzNDA=\">ES2019</span> 明确规定，<code>Array.prototype.sort()</code>的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。</p>\n<h3 id=\"9、对象的扩展\"><a href=\"#9、对象的扩展\" class=\"headerlink\" title=\"9、对象的扩展\"></a>9、对象的扩展</h3><hr>\n<h4 id=\"1-属性的简洁表达法\"><a href=\"#1-属性的简洁表达法\" class=\"headerlink\" title=\"1. 属性的简洁表达法\"></a>1. 属性的简洁表达法</h4><p><strong>ES6 允许在大括号里面，直接写入变量和函数</strong>，作为对象的属性和方法。这样的书写更加简洁。</p>\n<pre><code class=\"javascript\">const foo = &#39;bar&#39;;\nconst baz = &#123;foo&#125;;\nbaz // &#123;foo: &quot;bar&quot;&#125;\n\n// 等同于\nconst baz = &#123;foo: foo&#125;;\n</code></pre>\n<p>上面代码中，变量<code>foo</code>直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。</p>\n<pre><code class=\"javascript\">function f(x, y) &#123;\n  return &#123;x, y&#125;;\n&#125;\n\n// 等同于\n\nfunction f(x, y) &#123;\n  return &#123;x: x, y: y&#125;;\n&#125;\n\nf(1, 2) // Object &#123;x: 1, y: 2&#125;\n</code></pre>\n<p><strong>除了属性简写，方法也可以简写</strong>。</p>\n<pre><code class=\"javascript\">const o = &#123;\n  method() &#123;\n    return &quot;Hello!&quot;;\n  &#125;\n&#125;;\n\n// 等同于\n\nconst o = &#123;\n  method: function() &#123;\n    return &quot;Hello!&quot;;\n  &#125;\n&#125;;\n</code></pre>\n<p>下面是一个实际的例子。</p>\n<pre><code class=\"javascript\">let birth = &#39;2000/01/01&#39;;\n\nconst Person = &#123;\n\n  name: &#39;张三&#39;,\n\n  //等同于birth: birth\n  birth,\n\n  // 等同于hello: function ()...\n  hello() &#123; console.log(&#39;我的名字是&#39;, this.name); &#125;\n\n&#125;;\n</code></pre>\n<p>这种写法用于函数的返回值，将会非常方便。</p>\n<pre><code class=\"javascript\">function getPoint() &#123;\n  const x = 1;\n  const y = 10;\n  return &#123;x, y&#125;;\n&#125;\n\ngetPoint()\n// &#123;x:1, y:10&#125;\n</code></pre>\n<p>CommonJS 模块输出一组变量，就非常合适使用简洁写法。</p>\n<pre><code class=\"javascript\">let ms = &#123;&#125;;\n\nfunction getItem (key) &#123;\n  return key in ms ? ms[key] : null;\n&#125;\n\nfunction setItem (key, value) &#123;\n  ms[key] = value;\n&#125;\n\nfunction clear () &#123;\n  ms = &#123;&#125;;\n&#125;\n\nmodule.exports = &#123; getItem, setItem, clear &#125;;\n// 等同于\nmodule.exports = &#123;\n  getItem: getItem,\n  setItem: setItem,\n  clear: clear\n&#125;;\n</code></pre>\n<p>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。</p>\n<pre><code class=\"javascript\">const cart = &#123;\n  _wheels: 4,\n\n  get wheels () &#123;\n    return this._wheels;\n  &#125;,\n\n  set wheels (value) &#123;\n    if (value &lt; this._wheels) &#123;\n      throw new Error(&#39;数值太小了！&#39;);\n    &#125;\n    this._wheels = value;\n  &#125;\n&#125;\n</code></pre>\n<p>简洁写法在打印对象时也很有用。</p>\n<pre><code class=\"javascript\">let user = &#123;\n  name: &#39;test&#39;\n&#125;;\n\nlet foo = &#123;\n  bar: &#39;baz&#39;\n&#125;;\n\nconsole.log(user, foo)\n// &#123;name: &quot;test&quot;&#125; &#123;bar: &quot;baz&quot;&#125;\nconsole.log(&#123;user, foo&#125;)\n// &#123;user: &#123;name: &quot;test&quot;&#125;, foo: &#123;bar: &quot;baz&quot;&#125;&#125;\n</code></pre>\n<p>上面代码中，<code>console.log</code>直接输出<code>user</code>和<code>foo</code>两个对象时，就是两组键值对，可能会混淆。<strong>把它们放在大括号里面输出，就变成了对象的简洁表示法，</strong>每组键值对前面会打印对象名，这样就比较清晰了。</p>\n<p>注意，简写的对象方法不能用作构造函数，会报错。</p>\n<pre><code class=\"javascript\">const obj = &#123;\n  f() &#123;\n    this.foo = &#39;bar&#39;;\n  &#125;\n&#125;;\n\nnew obj.f() // 报错\n</code></pre>\n<p>上面代码中，<code>f</code>是一个简写的对象方法，所以<code>obj.f</code>不能当作构造函数使用。</p>\n<hr>\n<h4 id=\"2-属性名表达式\"><a href=\"#2-属性名表达式\" class=\"headerlink\" title=\"2. 属性名表达式\"></a>2. 属性名表达式</h4><p>JavaScript 定义对象的属性，有两种方法。</p>\n<pre><code class=\"javascript\">// 方法一\nobj.foo = true;\n\n// 方法二\nobj[&#39;a&#39; + &#39;bc&#39;] = 123;\n</code></pre>\n<p>上面代码的<strong>方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</strong></p>\n<p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p>\n<pre><code class=\"javascript\">var obj = &#123;\n  foo: true,\n  abc: 123\n&#125;;\n</code></pre>\n<p><strong>ES6 允许字面量定义对象</strong>时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>\n<pre><code class=\"javascript\">let propKey = &#39;foo&#39;;\n\nlet obj = &#123;\n  [propKey]: true,\n  [&#39;a&#39; + &#39;bc&#39;]: 123\n&#125;;\n</code></pre>\n<p>下面是另一个例子。</p>\n<pre><code class=\"javascript\">let lastWord = &#39;last word&#39;;\n\nconst a = &#123;\n  &#39;first word&#39;: &#39;hello&#39;,\n  [lastWord]: &#39;world&#39;\n&#125;;\n\na[&#39;first word&#39;] // &quot;hello&quot;\na[lastWord] // &quot;world&quot;\na[&#39;last word&#39;] // &quot;world&quot;\n</code></pre>\n<p>表达式还可以用于定义方法名。</p>\n<pre><code class=\"javascript\">let obj = &#123;\n  [&#39;h&#39; + &#39;ello&#39;]() &#123;\n    return &#39;hi&#39;;\n  &#125;\n&#125;;\n\nobj.hello() // hi\n</code></pre>\n<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p>\n<pre><code class=\"javascript\">// 报错\nconst foo = &#39;bar&#39;;\nconst bar = &#39;abc&#39;;\nconst baz = &#123; [foo] &#125;;\n\n// 正确\nconst foo = &#39;bar&#39;;\nconst baz = &#123; [foo]: &#39;abc&#39;&#125;;\n</code></pre>\n<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>，这一点要特别小心。</p>\n<pre><code class=\"javascript\">const keyA = &#123;a: 1&#125;;\nconst keyB = &#123;b: 2&#125;;\n\nconst myObject = &#123;\n  [keyA]: &#39;valueA&#39;,\n  [keyB]: &#39;valueB&#39;\n&#125;;\n\nmyObject // Object &#123;[object Object]: &quot;valueB&quot;&#125;\n</code></pre>\n<p>上面代码中，<code>[keyA]</code>和<code>[keyB]</code>得到的都是<code>[object Object]</code>，所以<code>[keyB]</code>会把<code>[keyA]</code>覆盖掉，而<code>myObject</code>最后只有一个<code>[object Object]</code>属性。</p>\n<hr>\n<h4 id=\"3-方法的-name-属性\"><a href=\"#3-方法的-name-属性\" class=\"headerlink\" title=\"3. 方法的 name 属性\"></a>3. 方法的 name 属性</h4><p>函数的<code>name</code>属性，返回函数名。对象方法也是函数，因此也有<code>name</code>属性。</p>\n<pre><code class=\"javascript\">const person = &#123;\n  sayName() &#123;\n    console.log(&#39;hello!&#39;);\n  &#125;,\n&#125;;\n\nperson.sayName.name   // &quot;sayName&quot;\n</code></pre>\n<p>上面代码中，方法的<code>name</code>属性返回函数名（即方法名）。</p>\n<p><strong>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code>。</strong></p>\n<pre><code class=\"javascript\">const obj = &#123;\n  get foo() &#123;&#125;,\n  set foo(x) &#123;&#125;\n&#125;;\n\nobj.foo.name\n// TypeError: Cannot read property &#39;name&#39; of undefined\n\nconst descriptor = Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;);\n\ndescriptor.get.name // &quot;get foo&quot;\ndescriptor.set.name // &quot;set foo&quot;\n</code></pre>\n<p>有两种特殊情况：**<code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字<strong>；</strong><code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code>。**</p>\n<pre><code class=\"javascript\">(new Function()).name // &quot;anonymous&quot;\n\nvar doSomething = function() &#123;\n  // ...\n&#125;;\ndoSomething.bind().name // &quot;bound doSomething&quot;\n</code></pre>\n<p><strong>如果对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述。</strong></p>\n<pre><code class=\"javascript\">const key1 = Symbol(&#39;description&#39;);\nconst key2 = Symbol();\nlet obj = &#123;\n  [key1]() &#123;&#125;,\n  [key2]() &#123;&#125;,\n&#125;;\nobj[key1].name // &quot;[description]&quot;\nobj[key2].name // &quot;&quot;\n</code></pre>\n<p>上面代码中，<code>key1</code>对应的 Symbol 值有描述，<code>key2</code>没有。</p>\n<hr>\n<h4 id=\"4-属性的可枚举性和遍历\"><a href=\"#4-属性的可枚举性和遍历\" class=\"headerlink\" title=\"4. 属性的可枚举性和遍历\"></a>4. 属性的可枚举性和遍历</h4><p><strong>可枚举性</strong></p>\n<p><strong>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</strong></p>\n<pre><code class=\"javascript\">let obj = &#123; foo: 123 &#125;;\nObject.getOwnPropertyDescriptor(obj, &#39;foo&#39;)\n//  &#123;\n//    value: 123,\n//    writable: true,\n//    enumerable: true,\n//    configurable: true\n//  &#125;\n</code></pre>\n<p>描述对象的<code>enumerable</code>属性，称为“可枚举性”，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p>\n<p>目前，<strong>有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</strong></p>\n<ul>\n<li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li>\n<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li>\n<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li>\n<li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li>\n</ul>\n<p>这四个操作之中，前三个是 ES5 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。其中，<strong>只有<code>for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性</strong>。实际上<strong>，引入“可枚举”（<code>enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作</strong>，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过“可枚举性”，从而避免被<code>for...in</code>遍历到。</p>\n<pre><code class=\"javascript\">Object.getOwnPropertyDescriptor(Object.prototype, &#39;toString&#39;).enumerable\n// false\n\nObject.getOwnPropertyDescriptor([], &#39;length&#39;).enumerable\n// false\n</code></pre>\n<p>上面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。</p>\n<p>另外，ES6 规定，<strong>所有 Class 的原型的方法都是不可枚举的。</strong></p>\n<pre><code class=\"javascript\">Object.getOwnPropertyDescriptor(class &#123;foo() &#123;&#125;&#125;.prototype, &#39;foo&#39;).enumerable\n// false\n</code></pre>\n<p>总的来说，<strong>操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</strong></p>\n<p><strong>属性的遍历</strong></p>\n<p>ES6 一共有 5 种方法可以遍历对象的属性。</p>\n<p><strong>（1）for…in</strong></p>\n<p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>\n<p><strong>（2）Object.keys(obj)</strong></p>\n<p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>\n<p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p>\n<p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>\n<p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p>\n<p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>\n<p><strong>（5）Reflect.ownKeys(obj)</strong></p>\n<p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>\n<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>\n<ul>\n<li>首先遍历所有数值键，按照数值升序排列。</li>\n<li>其次遍历所有字符串键，按照加入时间升序排列。</li>\n<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>\n</ul>\n<pre><code class=\"javascript\">Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)\n// [&#39;2&#39;, &#39;10&#39;, &#39;b&#39;, &#39;a&#39;, Symbol()]\n</code></pre>\n<p>上面代码中，<code>Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性<code>2</code>和<code>10</code>，其次是字符串属性<code>b</code>和<code>a</code>，最后是 Symbol 属性。</p>\n<hr>\n<h4 id=\"5-super-关键字\"><a href=\"#5-super-关键字\" class=\"headerlink\" title=\"5. super 关键字\"></a>5. super 关键字</h4><p>我们知道，**<code>this</code>关键字总是指向函数所在的当前对象<strong>，ES6 又新增了另一个类似的关键字</strong><code>super</code>，指向当前对象的原型对象**。</p>\n<pre><code class=\"javascript\">const proto = &#123;\n  foo: &#39;hello&#39;\n&#125;;\n\nconst obj = &#123;\n  foo: &#39;world&#39;,\n  find() &#123;\n    return super.foo;\n  &#125;\n&#125;;\n\nObject.setPrototypeOf(obj, proto);\nobj.find() // &quot;hello&quot;\n</code></pre>\n<p>上面代码中，对象<code>obj.find()</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性。</p>\n<p>注意，**<code>super</code>关键字表示原型对象时，只能用在对象的方法之中**，用在其他地方都会报错。</p>\n<pre><code class=\"javascript\">// 报错\nconst obj = &#123;\n  foo: super.foo\n&#125;\n\n// 报错\nconst obj = &#123;\n  foo: () =&gt; super.foo\n&#125;\n\n// 报错\nconst obj = &#123;\n  foo: function () &#123;\n    return super.foo\n  &#125;\n&#125;\n</code></pre>\n<p>上面三种<code>super</code>的用法都会报错，因为对于 JavaScript 引擎来说，这里的<code>super</code>都没有用在对象的方法之中。第一种写法是<code>super</code>用在属性里面，第二种和第三种写法是<code>super</code>用在一个函数里面，然后赋值给<code>foo</code>属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。</p>\n<p><strong>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。</strong></p>\n<pre><code class=\"javascript\">const proto = &#123;\n  x: &#39;hello&#39;,\n  foo() &#123;\n    console.log(this.x);\n  &#125;,\n&#125;;\n\nconst obj = &#123;\n  x: &#39;world&#39;,\n  foo() &#123;\n    super.foo();\n  &#125;\n&#125;\n\nObject.setPrototypeOf(obj, proto);\n\nobj.foo() // &quot;world&quot;\n</code></pre>\n<p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code>。</p>\n<hr>\n<h4 id=\"6-对象的扩展运算符\"><a href=\"#6-对象的扩展运算符\" class=\"headerlink\" title=\"6. 对象的扩展运算符\"></a>6. 对象的扩展运算符</h4><p>《数组的扩展》一章中，已经介绍过扩展运算符（<code>...</code>）。ES2018 将这个运算符<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtcmVzdC1zcHJlYWQ=\">引入</span>了对象。</p>\n<p><strong>解构赋值</strong></p>\n<p><strong>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。</strong>所有的键和它们的值，都会拷贝到新对象上面。</p>\n<pre><code class=\"javascript\">let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;\nx // 1\ny // 2\nz // &#123; a: 3, b: 4 &#125;\n</code></pre>\n<p>上面代码中，变量<code>z</code>是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（<code>a</code>和<code>b</code>），将它们连同值一起拷贝过来。</p>\n<p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是<code>undefined</code>或<code>null</code>，就会报错，因为它们无法转为对象。</p>\n<pre><code class=\"javascript\">let &#123; ...z &#125; = null; // 运行时错误\nlet &#123; ...z &#125; = undefined; // 运行时错误\n</code></pre>\n<p><strong>解构赋值必须是最后一个参数</strong>，否则会报错。</p>\n<pre><code class=\"javascript\">let &#123; ...x, y, z &#125; = someObject; // 句法错误\nlet &#123; x, ...y, ...z &#125; = someObject; // 句法错误\n</code></pre>\n<p>上面代码中，解构赋值不是最后一个参数，所以会报错。</p>\n<p>注意，<strong>解构赋值的拷贝是浅拷贝</strong>，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>\n<pre><code class=\"javascript\">let obj = &#123; a: &#123; b: 1 &#125; &#125;;\nlet &#123; ...x &#125; = obj;\nobj.a.b = 2;\nx.a.b // 2\n</code></pre>\n<p>上面代码中，<code>x</code>是解构赋值所在的对象，拷贝了对象<code>obj</code>的<code>a</code>属性。<code>a</code>属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p>\n<p>另外，扩展运算符的解构赋值，<strong>不能复制继承自原型对象的属性</strong>。</p>\n<pre><code class=\"javascript\">let o1 = &#123; a: 1 &#125;;\nlet o2 = &#123; b: 2 &#125;;\no2.__proto__ = o1;\nlet &#123; ...o3 &#125; = o2;\no3 // &#123; b: 2 &#125;\no3.a // undefined\n</code></pre>\n<p>上面代码中，对象<code>o3</code>复制了<code>o2</code>，但是只复制了<code>o2</code>自身的属性，没有复制它的原型对象<code>o1</code>的属性。</p>\n<p>下面是另一个例子。</p>\n<pre><code class=\"javascript\">const o = Object.create(&#123; x: 1, y: 2 &#125;);\no.z = 3;\n\nlet &#123; x, ...newObj &#125; = o;\nlet &#123; y, z &#125; = newObj;\nx // 1\ny // undefined\nz // 3\n</code></pre>\n<p>上面代码中，变量<code>x</code>是单纯的解构赋值，所以可以读取对象<code>o</code>继承的属性；变量<code>y</code>和<code>z</code>是扩展运算符的解构赋值，只能读取对象<code>o</code>自身的属性，所以变量<code>z</code>可以赋值成功，变量<code>y</code>取不到值。ES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量<code>newObj</code>，如果写成下面这样会报错。</p>\n<pre><code class=\"javascript\">let &#123; x, ...&#123; y, z &#125; &#125; = o;\n// SyntaxError: ... must be followed by an identifier in declaration contexts\n</code></pre>\n<p><strong>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</strong></p>\n<pre><code class=\"javascript\">function baseFunction(&#123; a, b &#125;) &#123;\n  // ...\n&#125;\nfunction wrapperFunction(&#123; x, y, ...restConfig &#125;) &#123;\n  // 使用 x 和 y 参数进行操作\n  // 其余参数传给原始函数\n  return baseFunction(restConfig);\n&#125;\n</code></pre>\n<p>上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p>\n<hr>\n<p><strong>扩展运算符</strong></p>\n<p><strong>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</strong></p>\n<pre><code class=\"javascript\">let z = &#123; a: 3, b: 4 &#125;;\nlet n = &#123; ...z &#125;;\nn // &#123; a: 3, b: 4 &#125;\n</code></pre>\n<p>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</p>\n<pre><code class=\"javascript\">let foo = &#123; ...[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &#125;;\nfoo\n// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;\n</code></pre>\n<p>如果扩展运算符后面是一个空对象，则没有任何效果。</p>\n<pre><code class=\"javascript\">&#123;...&#123;&#125;, a: 1&#125;\n// &#123; a: 1 &#125;\n</code></pre>\n<p>如果扩展运算符后面不是对象，则会自动将其转为对象。</p>\n<pre><code class=\"javascript\">// 等同于 &#123;...Object(1)&#125;\n&#123;...1&#125; // &#123;&#125;\n</code></pre>\n<p>上面代码中，扩展运算符后面是整数<code>1</code>，会自动转为数值的包装对象<code>Number&#123;1&#125;</code>。由于该对象没有自身属性，所以返回一个空对象。</p>\n<p>下面的例子都是类似的道理。</p>\n<pre><code class=\"javascript\">// 等同于 &#123;...Object(true)&#125;\n&#123;...true&#125; // &#123;&#125;\n\n// 等同于 &#123;...Object(undefined)&#125;\n&#123;...undefined&#125; // &#123;&#125;\n\n// 等同于 &#123;...Object(null)&#125;\n&#123;...null&#125; // &#123;&#125;\n</code></pre>\n<p>但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。</p>\n<pre><code class=\"javascript\">&#123;...&#39;hello&#39;&#125;\n// &#123;0: &quot;h&quot;, 1: &quot;e&quot;, 2: &quot;l&quot;, 3: &quot;l&quot;, 4: &quot;o&quot;&#125;\n</code></pre>\n<p><strong>对象的扩展运算符等同于使用<code>Object.assign()</code>方法。</strong></p>\n<pre><code class=\"javascript\">let aClone = &#123; ...a &#125;;\n// 等同于\nlet aClone = Object.assign(&#123;&#125;, a);\n</code></pre>\n<p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。</p>\n<pre><code class=\"javascript\">// 写法一\nconst clone1 = &#123;\n  __proto__: Object.getPrototypeOf(obj),\n  ...obj\n&#125;;\n\n// 写法二\nconst clone2 = Object.assign(\n  Object.create(Object.getPrototypeOf(obj)),\n  obj\n);\n\n// 写法三\nconst clone3 = Object.create(\n  Object.getPrototypeOf(obj),\n  Object.getOwnPropertyDescriptors(obj)\n)\n</code></pre>\n<p>上面代码中，写法一的<code>__proto__</code>属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。</p>\n<p><strong>扩展运算符可以用于合并两个对象。</strong></p>\n<pre><code class=\"javascript\">let ab = &#123; ...a, ...b &#125;;\n// 等同于\nlet ab = Object.assign(&#123;&#125;, a, b);\n</code></pre>\n<p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>\n<pre><code class=\"javascript\">let aWithOverrides = &#123; ...a, x: 1, y: 2 &#125;;\n// 等同于\nlet aWithOverrides = &#123; ...a, ...&#123; x: 1, y: 2 &#125; &#125;;\n// 等同于\nlet x = 1, y = 2, aWithOverrides = &#123; ...a, x, y &#125;;\n// 等同于\nlet aWithOverrides = Object.assign(&#123;&#125;, a, &#123; x: 1, y: 2 &#125;);\n</code></pre>\n<p>上面代码中，<code>a</code>对象的<code>x</code>属性和<code>y</code>属性，拷贝到新对象后会被覆盖掉。</p>\n<p><strong>这用来修改现有对象部分的属性就很方便了。</strong></p>\n<pre><code class=\"javascript\">let newVersion = &#123;\n  ...previousVersion,\n  name: &#39;New Name&#39; // Override the name property\n&#125;;\n</code></pre>\n<p>上面代码中，<code>newVersion</code>对象自定义了<code>name</code>属性，其他属性全部复制自<code>previousVersion</code>对象。</p>\n<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>\n<pre><code class=\"javascript\">let aWithDefaults = &#123; x: 1, y: 2, ...a &#125;;\n// 等同于\nlet aWithDefaults = Object.assign(&#123;&#125;, &#123; x: 1, y: 2 &#125;, a);\n// 等同于\nlet aWithDefaults = Object.assign(&#123; x: 1, y: 2 &#125;, a);\n</code></pre>\n<p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</p>\n<pre><code class=\"javascript\">const obj = &#123;\n  ...(x &gt; 1 ? &#123;a: 1&#125; : &#123;&#125;),\n  b: 2,\n&#125;;\n</code></pre>\n<p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p>\n<pre><code class=\"javascript\">let a = &#123;\n  get x() &#123;\n    throw new Error(&#39;not throw yet&#39;);\n  &#125;\n&#125;\n\nlet aWithXGetter = &#123; ...a &#125;; // 报错\n</code></pre>\n<p>上面例子中，取值函数<code>get</code>在扩展<code>a</code>对象时会自动执行，导致报错。</p>\n<hr>\n<h4 id=\"7-AggregateError-错误对象\"><a href=\"#7-AggregateError-错误对象\" class=\"headerlink\" title=\"7. AggregateError 错误对象\"></a>7. AggregateError 错误对象</h4><p>ES2021 标准之中，为了配合新增的<code>Promise.any()</code>方法（详见《Promise 对象》一章），还引入一个新的错误对象<code>AggregateError</code>，也放在这一章介绍。</p>\n<p>AggregateError 在一个错误对象里面，封装了多个错误。如果某个单一操作，同时引发了多个错误，，需要同时抛出这些错误，那么就可以抛出一个 AggregateError 错误对象，把各种错误都放在这个对象里面。</p>\n<p>AggregateError 本身是一个构造函数，用来生成 AggregateError 实例对象。</p>\n<pre><code class=\"javascript\">AggregateError(errors[, message])\n</code></pre>\n<p><code>AggregateError()</code>构造函数可以接受两个参数。</p>\n<ul>\n<li>errors：数组，它的每个成员都是一个错误对象。该参数是必须的。</li>\n<li>message：字符串，表示 AggregateError 抛出时的提示信息。该参数是可选的。</li>\n</ul>\n<pre><code class=\"javascript\">const error = new AggregateError([\n  new Error(&#39;ERROR_11112&#39;),\n  new TypeError(&#39;First name must be a string&#39;),\n  new RangeError(&#39;Transaction value must be at least 1&#39;),\n  new URIError(&#39;User profile link must be https&#39;),\n], &#39;Transaction cannot be processed&#39;)\n</code></pre>\n<p>上面示例中，<code>AggregateError()</code>的第一个参数数组里面，一共有四个错误实例。第二个参数字符串则是这四个错误的一个整体的提示。</p>\n<p><code>AggregateError</code>的实例对象有三个属性。</p>\n<ul>\n<li>name：错误名称，默认为“AggregateError”。</li>\n<li>message：错误的提示信息。</li>\n<li>errors：数组，每个成员都是一个错误对象。</li>\n</ul>\n<p>下面是一个示例。</p>\n<pre><code class=\"javascript\">try &#123;\n  throw new AggregateError([\n    new Error(&quot;some error&quot;),\n  ], &#39;Hello&#39;);\n&#125; catch (e) &#123;\n  console.log(e instanceof AggregateError); // true\n  console.log(e.message);                   // &quot;Hello&quot;\n  console.log(e.name);                      // &quot;AggregateError&quot;\n  console.log(e.errors);                    // [ Error: &quot;some error&quot; ]\n&#125;\n</code></pre>\n<h3 id=\"10、-对象的新增方法\"><a href=\"#10、-对象的新增方法\" class=\"headerlink\" title=\"10、 对象的新增方法\"></a>10、 对象的新增方法</h3><hr>\n<h4 id=\"1-Object-is\"><a href=\"#1-Object-is\" class=\"headerlink\" title=\"1. Object.is()\"></a>1. Object.is()</h4><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>\n<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。<strong>它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</strong></p>\n<pre><code class=\"javascript\">Object.is(&#39;foo&#39;, &#39;foo&#39;)\n// true\nObject.is(&#123;&#125;, &#123;&#125;)\n// false\n</code></pre>\n<p><strong>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</strong></p>\n<pre><code class=\"javascript\">+0 === -0 //true\nNaN === NaN // false\n\nObject.is(+0, -0) // false\nObject.is(NaN, NaN) // true\n</code></pre>\n<p>ES5 可以通过下面的代码，部署<code>Object.is</code>。</p>\n<pre><code class=\"javascript\">Object.defineProperty(Object, &#39;is&#39;, &#123;\n  value: function(x, y) &#123;\n    if (x === y) &#123;\n      // 针对+0 不等于 -0的情况\n      return x !== 0 || 1 / x === 1 / y;\n    &#125;\n    // 针对NaN的情况\n    return x !== x &amp;&amp; y !== y;\n  &#125;,\n  configurable: true,\n  enumerable: false,\n  writable: true\n&#125;);\n</code></pre>\n<hr>\n<h4 id=\"2-Object-assign\"><a href=\"#2-Object-assign\" class=\"headerlink\" title=\"2. Object.assign()\"></a>2. Object.assign()</h4><p><strong>基本用法</strong></p>\n<p><strong><code>Object.assign()</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</strong></p>\n<pre><code class=\"javascript\">const target = &#123; a: 1 &#125;;\n\nconst source1 = &#123; b: 2 &#125;;\nconst source2 = &#123; c: 3 &#125;;\n\nObject.assign(target, source1, source2);\ntarget // &#123;a:1, b:2, c:3&#125;\n</code></pre>\n<p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p>\n<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>\n<pre><code class=\"javascript\">const target = &#123; a: 1, b: 1 &#125;;\n\nconst source1 = &#123; b: 2, c: 2 &#125;;\nconst source2 = &#123; c: 3 &#125;;\n\nObject.assign(target, source1, source2);\ntarget // &#123;a:1, b:2, c:3&#125;\n</code></pre>\n<p>如果只有一个参数，<code>Object.assign()</code>会直接返回该参数。</p>\n<pre><code class=\"javascript\">const obj = &#123;a: 1&#125;;\nObject.assign(obj) === obj // true\n</code></pre>\n<p>如果该参数不是对象，则会先转成对象，然后返回。</p>\n<pre><code class=\"javascript\">typeof Object.assign(2) // &quot;object&quot;\n</code></pre>\n<p>由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。</p>\n<pre><code class=\"javascript\">Object.assign(undefined) // 报错\nObject.assign(null) // 报错\n</code></pre>\n<p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。</p>\n<pre><code class=\"javascript\">let obj = &#123;a: 1&#125;;\nObject.assign(obj, undefined) === obj // true\nObject.assign(obj, null) === obj // true\n</code></pre>\n<p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p>\n<pre><code class=\"javascript\">const v1 = &#39;abc&#39;;\nconst v2 = true;\nconst v3 = 10;\n\nconst obj = Object.assign(&#123;&#125;, v1, v2, v3);\nconsole.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;\n</code></pre>\n<p>上面代码中，<code>v1</code>、<code>v2</code>、<code>v3</code>分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p>\n<pre><code class=\"javascript\">Object(true) // &#123;[[PrimitiveValue]]: true&#125;\nObject(10)  //  &#123;[[PrimitiveValue]]: 10&#125;\nObject(&#39;abc&#39;) // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;&#125;\n</code></pre>\n<p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面，这个属性是不会被<code>Object.assign()</code>拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p>\n<p><strong><code>Object.assign()</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</strong></p>\n<pre><code class=\"javascript\">Object.assign(&#123;b: &#39;c&#39;&#125;,\n  Object.defineProperty(&#123;&#125;, &#39;invisible&#39;, &#123;\n    enumerable: false,\n    value: &#39;hello&#39;\n  &#125;)\n)\n// &#123; b: &#39;c&#39; &#125;\n</code></pre>\n<p>上面代码中，<code>Object.assign()</code>要拷贝的对象只有一个不可枚举属性<code>invisible</code>，这个属性并没有被拷贝进去。</p>\n<p>属性名为 Symbol 值的属性，也会被<code>Object.assign()</code>拷贝。</p>\n<pre><code class=\"javascript\">Object.assign(&#123; a: &#39;b&#39; &#125;, &#123; [Symbol(&#39;c&#39;)]: &#39;d&#39; &#125;)\n// &#123; a: &#39;b&#39;, Symbol(c): &#39;d&#39; &#125;\n</code></pre>\n<hr>\n<p><strong>注意点</strong></p>\n<p><strong>（1）浅拷贝</strong></p>\n<p><code>Object.assign()</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>\n<pre><code class=\"javascript\">const obj1 = &#123;a: &#123;b: 1&#125;&#125;;\nconst obj2 = Object.assign(&#123;&#125;, obj1);\n\nobj1.a.b = 2;\nobj2.a.b // 2\n</code></pre>\n<p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign()</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>\n<p><strong>（2）同名属性的替换</strong></p>\n<p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign()</code>的处理方法是替换，而不是添加。</p>\n<pre><code class=\"javascript\">const target = &#123; a: &#123; b: &#39;c&#39;, d: &#39;e&#39; &#125; &#125;\nconst source = &#123; a: &#123; b: &#39;hello&#39; &#125; &#125;\nObject.assign(target, source)\n// &#123; a: &#123; b: &#39;hello&#39; &#125; &#125;\n</code></pre>\n<p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到<code>&#123; a: &#123; b: &#39;hello&#39;, d: &#39;e&#39; &#125; &#125;</code>的结果。这通常不是开发者想要的，需要特别小心。</p>\n<p>一些函数库提供<code>Object.assign()</code>的定制版本（比如 Lodash 的<code>_.defaultsDeep()</code>方法），可以得到深拷贝的合并。</p>\n<p><strong>（3）数组的处理</strong></p>\n<p><code>Object.assign()</code>可以用来处理数组，但是会把数组视为对象。</p>\n<pre><code class=\"javascript\">Object.assign([1, 2, 3], [4, 5])\n// [4, 5, 3]\n</code></pre>\n<p>上面代码中，<code>Object.assign()</code>把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性<code>4</code>覆盖了目标数组的 0 号属性<code>1</code>。</p>\n<p><strong>（4）取值函数的处理</strong></p>\n<p><strong><code>Object.assign()</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</strong></p>\n<pre><code class=\"javascript\">const source = &#123;\n  get foo() &#123; return 1 &#125;\n&#125;;\nconst target = &#123;&#125;;\n\nObject.assign(target, source)\n// &#123; foo: 1 &#125;\n</code></pre>\n<p>上面代码中，<code>source</code>对象的<code>foo</code>属性是一个取值函数，<code>Object.assign()</code>不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p>\n<hr>\n<p><strong>常见用途</strong></p>\n<p><code>Object.assign()</code>方法有很多用处。</p>\n<p><strong>（1）为对象添加属性</strong></p>\n<pre><code class=\"javascript\">class Point &#123;\n  constructor(x, y) &#123;\n    Object.assign(this, &#123;x, y&#125;);\n  &#125;\n&#125;\n</code></pre>\n<p>上面方法通过<code>Object.assign()</code>方法，将<code>x</code>属性和<code>y</code>属性添加到<code>Point</code>类的对象实例。</p>\n<p><strong>（2）为对象添加方法</strong></p>\n<pre><code class=\"javascript\">Object.assign(SomeClass.prototype, &#123;\n  someMethod(arg1, arg2) &#123;\n    ···\n  &#125;,\n  anotherMethod() &#123;\n    ···\n  &#125;\n&#125;);\n\n// 等同于下面的写法\nSomeClass.prototype.someMethod = function (arg1, arg2) &#123;\n  ···\n&#125;;\nSomeClass.prototype.anotherMethod = function () &#123;\n  ···\n&#125;;\n</code></pre>\n<p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用<code>assign()</code>方法添加到<code>SomeClass.prototype</code>之中。</p>\n<p><strong>（3）克隆对象</strong></p>\n<pre><code class=\"javascript\">function clone(origin) &#123;\n  return Object.assign(&#123;&#125;, origin);\n&#125;\n</code></pre>\n<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p>\n<p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p>\n<pre><code class=\"javascript\">function clone(origin) &#123;\n  let originProto = Object.getPrototypeOf(origin);\n  return Object.assign(Object.create(originProto), origin);\n&#125;\n</code></pre>\n<p><strong>（4）合并多个对象</strong></p>\n<p>将多个对象合并到某个对象。</p>\n<pre><code class=\"javascript\">const merge =\n  (target, ...sources) =&gt; Object.assign(target, ...sources);\n</code></pre>\n<p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p>\n<pre><code class=\"javascript\">const merge =\n  (...sources) =&gt; Object.assign(&#123;&#125;, ...sources);\n</code></pre>\n<p><strong>（5）为属性指定默认值</strong></p>\n<pre><code class=\"javascript\">const DEFAULTS = &#123;\n  logLevel: 0,\n  outputFormat: &#39;html&#39;\n&#125;;\n\nfunction processContent(options) &#123;\n  options = Object.assign(&#123;&#125;, DEFAULTS, options);\n  console.log(options);\n  // ...\n&#125;\n</code></pre>\n<p>上面代码中，<code>DEFAULTS</code>对象是默认值，<code>options</code>对象是用户提供的参数。<code>Object.assign()</code>方法将<code>DEFAULTS</code>和<code>options</code>合并成一个新对象，如果两者有同名属性，则<code>options</code>的属性值会覆盖<code>DEFAULTS</code>的属性值。</p>\n<p>注意，由于存在浅拷贝的问题，<code>DEFAULTS</code>对象和<code>options</code>对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，<code>DEFAULTS</code>对象的该属性很可能不起作用。</p>\n<pre><code class=\"javascript\">const DEFAULTS = &#123;\n  url: &#123;\n    host: &#39;example.com&#39;,\n    port: 7070\n  &#125;,\n&#125;;\n\nprocessContent(&#123; url: &#123;port: 8000&#125; &#125;)\n// &#123;\n//   url: &#123;port: 8000&#125;\n// &#125;\n</code></pre>\n<p>上面代码的原意是将<code>url.port</code>改成 8000，<code>url.host</code>不变。实际结果却是<code>options.url</code>覆盖掉<code>DEFAULTS.url</code>，所以<code>url.host</code>就不存在了。</p>\n<hr>\n<h4 id=\"3-Object-getOwnPropertyDescriptors\"><a href=\"#3-Object-getOwnPropertyDescriptors\" class=\"headerlink\" title=\"3. Object.getOwnPropertyDescriptors()\"></a>3. Object.getOwnPropertyDescriptors()</h4><p>ES5 的<code>Object.getOwnPropertyDescriptor()</code>方法会返回某个对象属性的描述对象（descriptor）。<strong>ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</strong></p>\n<pre><code class=\"javascript\">const obj = &#123;\n  foo: 123,\n  get bar() &#123; return &#39;abc&#39; &#125;\n&#125;;\n\nObject.getOwnPropertyDescriptors(obj)\n// &#123; foo:\n//    &#123; value: 123,\n//      writable: true,\n//      enumerable: true,\n//      configurable: true &#125;,\n//   bar:\n//    &#123; get: [Function: get bar],\n//      set: undefined,\n//      enumerable: true,\n//      configurable: true &#125; &#125;\n</code></pre>\n<p>上面代码中，<code>Object.getOwnPropertyDescriptors()</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p>\n<p>该方法的实现非常容易。</p>\n<pre><code class=\"javascript\">function getOwnPropertyDescriptors(obj) &#123;\n  const result = &#123;&#125;;\n  for (let key of Reflect.ownKeys(obj)) &#123;\n    result[key] = Object.getOwnPropertyDescriptor(obj, key);\n  &#125;\n  return result;\n&#125;\n</code></pre>\n<p><strong>该方法的引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。</strong></p>\n<pre><code class=\"javascript\">const source = &#123;\n  set foo(value) &#123;\n    console.log(value);\n  &#125;\n&#125;;\n\nconst target1 = &#123;&#125;;\nObject.assign(target1, source);\n\nObject.getOwnPropertyDescriptor(target1, &#39;foo&#39;)\n// &#123; value: undefined,\n//   writable: true,\n//   enumerable: true,\n//   configurable: true &#125;\n</code></pre>\n<p>上面代码中，<code>source</code>对象的<code>foo</code>属性的值是一个赋值函数，<code>Object.assign</code>方法将这个属性拷贝给<code>target1</code>对象，结果该属性的值变成了<code>undefined</code>。这是因为<code>Object.assign</code>方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p>\n<p>这时，<code>Object.getOwnPropertyDescriptors()</code>方法配合<code>Object.defineProperties()</code>方法，就可以实现正确拷贝。</p>\n<pre><code class=\"javascript\">const source = &#123;\n  set foo(value) &#123;\n    console.log(value);\n  &#125;\n&#125;;\n\nconst target2 = &#123;&#125;;\nObject.defineProperties(target2, Object.getOwnPropertyDescriptors(source));\nObject.getOwnPropertyDescriptor(target2, &#39;foo&#39;)\n// &#123; get: undefined,\n//   set: [Function: set foo],\n//   enumerable: true,\n//   configurable: true &#125;\n</code></pre>\n<p>上面代码中，两个对象合并的逻辑可以写成一个函数。</p>\n<pre><code class=\"javascript\">const shallowMerge = (target, source) =&gt; Object.defineProperties(\n  target,\n  Object.getOwnPropertyDescriptors(source)\n);\n</code></pre>\n<p><strong><code>Object.getOwnPropertyDescriptors()</code>方法的另一个用处，是配合<code>Object.create()</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝。</strong></p>\n<pre><code class=\"javascript\">const clone = Object.create(Object.getPrototypeOf(obj),\n  Object.getOwnPropertyDescriptors(obj));\n\n// 或者\n\nconst shallowClone = (obj) =&gt; Object.create(\n  Object.getPrototypeOf(obj),\n  Object.getOwnPropertyDescriptors(obj)\n);\n</code></pre>\n<p>上面代码会克隆对象<code>obj</code>。</p>\n<p>另外，<code>Object.getOwnPropertyDescriptors()</code>方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p>\n<pre><code class=\"javascript\">const obj = &#123;\n  __proto__: prot,\n  foo: 123,\n&#125;;\n</code></pre>\n<p>ES6 规定<code>__proto__</code>只有浏览器要部署，其他环境不用部署。如果去除<code>__proto__</code>，上面代码就要改成下面这样。</p>\n<pre><code class=\"javascript\">const obj = Object.create(prot);\nobj.foo = 123;\n\n// 或者\n\nconst obj = Object.assign(\n  Object.create(prot),\n  &#123;\n    foo: 123,\n  &#125;\n);\n</code></pre>\n<p>有了<code>Object.getOwnPropertyDescriptors()</code>，我们就有了另一种写法。</p>\n<pre><code class=\"javascript\">const obj = Object.create(\n  prot,\n  Object.getOwnPropertyDescriptors(&#123;\n    foo: 123,\n  &#125;)\n);\n</code></pre>\n<p><code>Object.getOwnPropertyDescriptors()</code>也可以用来实现 Mixin（混入）模式。</p>\n<pre><code class=\"javascript\">let mix = (object) =&gt; (&#123;\n  with: (...mixins) =&gt; mixins.reduce(\n    (c, mixin) =&gt; Object.create(\n      c, Object.getOwnPropertyDescriptors(mixin)\n    ), object)\n&#125;);\n\n// multiple mixins example\nlet a = &#123;a: &#39;a&#39;&#125;;\nlet b = &#123;b: &#39;b&#39;&#125;;\nlet c = &#123;c: &#39;c&#39;&#125;;\nlet d = mix(c).with(a, b);\n\nd.c // &quot;c&quot;\nd.b // &quot;b&quot;\nd.a // &quot;a&quot;\n</code></pre>\n<p>上面代码返回一个新的对象<code>d</code>，代表了对象<code>a</code>和<code>b</code>被混入了对象<code>c</code>的操作。</p>\n<p>出于完整性的考虑，<code>Object.getOwnPropertyDescriptors()</code>进入标准以后，以后还会新增<code>Reflect.getOwnPropertyDescriptors()</code>方法。</p>\n<hr>\n<h4 id=\"4-proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf\"><a href=\"#4-proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf\" class=\"headerlink\" title=\"4. __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()\"></a>4. <code>__proto__属性</code>，Object.setPrototypeOf()，Object.getPrototypeOf()</h4><p>JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。</p>\n<p><strong><code>__proto__</code>属性</strong></p>\n<p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）。目前，所有浏览器（包括 IE11）都部署了这个属性。</p>\n<pre><code class=\"javascript\">// es5 的写法\nconst obj = &#123;\n  method: function() &#123; ... &#125;\n&#125;;\nobj.__proto__ = someOtherObj;\n\n// es6 的写法\nvar obj = Object.create(someOtherObj);\nobj.method = function() &#123; ... &#125;;\n</code></pre>\n<p>该属性没有写入 ES6 的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，<strong>而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</strong></p>\n<p>实现上，<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>，具体实现如下。</p>\n<pre><code class=\"javascript\">Object.defineProperty(Object.prototype, &#39;__proto__&#39;, &#123;\n  get() &#123;\n    let _thisObj = Object(this);\n    return Object.getPrototypeOf(_thisObj);\n  &#125;,\n  set(proto) &#123;\n    if (this === undefined || this === null) &#123;\n      throw new TypeError();\n    &#125;\n    if (!isObject(this)) &#123;\n      return undefined;\n    &#125;\n    if (!isObject(proto)) &#123;\n      return undefined;\n    &#125;\n    let status = Reflect.setPrototypeOf(this, proto);\n    if (!status) &#123;\n      throw new TypeError();\n    &#125;\n  &#125;,\n&#125;);\n\nfunction isObject(value) &#123;\n  return Object(value) === value;\n&#125;\n</code></pre>\n<p>如果一个对象本身部署了<code>__proto__</code>属性，该属性的值就是对象的原型。</p>\n<pre><code class=\"javascript\">Object.getPrototypeOf(&#123; __proto__: null &#125;)\n// null\n</code></pre>\n<p><strong>Object.setPrototypeOf</strong>()</p>\n<p><strong><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</strong></p>\n<pre><code class=\"javascript\">// 格式\nObject.setPrototypeOf(object, prototype)\n\n// 用法\nconst o = Object.setPrototypeOf(&#123;&#125;, null);\n</code></pre>\n<p>该方法等同于下面的函数。</p>\n<pre><code class=\"javascript\">function setPrototypeOf(obj, proto) &#123;\n  obj.__proto__ = proto;\n  return obj;\n&#125;\n</code></pre>\n<p>下面是一个例子。</p>\n<pre><code class=\"javascript\">let proto = &#123;&#125;;\nlet obj = &#123; x: 10 &#125;;\nObject.setPrototypeOf(obj, proto);\n\nproto.y = 20;\nproto.z = 40;\n\nobj.x // 10\nobj.y // 20\nobj.z // 40\n</code></pre>\n<p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性。</p>\n<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p>\n<pre><code class=\"javascript\">Object.setPrototypeOf(1, &#123;&#125;) === 1 // true\nObject.setPrototypeOf(&#39;foo&#39;, &#123;&#125;) === &#39;foo&#39; // true\nObject.setPrototypeOf(true, &#123;&#125;) === true // true\n</code></pre>\n<p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错。</p>\n<pre><code class=\"javascript\">Object.setPrototypeOf(undefined, &#123;&#125;)\n// TypeError: Object.setPrototypeOf called on null or undefined\n\nObject.setPrototypeOf(null, &#123;&#125;)\n// TypeError: Object.setPrototypeOf called on null or undefined\n</code></pre>\n<p><strong>Object.getPrototypeOf()</strong></p>\n<p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。</p>\n<pre><code class=\"javascript\">Object.getPrototypeOf(obj);\n</code></pre>\n<p>下面是一个例子。</p>\n<pre><code class=\"javascript\">function Rectangle() &#123;\n  // ...\n&#125;\n\nconst rec = new Rectangle();\n\nObject.getPrototypeOf(rec) === Rectangle.prototype\n// true\n\nObject.setPrototypeOf(rec, Object.prototype);\nObject.getPrototypeOf(rec) === Rectangle.prototype\n// false\n</code></pre>\n<p>如果参数不是对象，会被自动转为对象。</p>\n<pre><code class=\"javascript\">// 等同于 Object.getPrototypeOf(Number(1))\nObject.getPrototypeOf(1)\n// Number &#123;[[PrimitiveValue]]: 0&#125;\n\n// 等同于 Object.getPrototypeOf(String(&#39;foo&#39;))\nObject.getPrototypeOf(&#39;foo&#39;)\n// String &#123;length: 0, [[PrimitiveValue]]: &quot;&quot;&#125;\n\n// 等同于 Object.getPrototypeOf(Boolean(true))\nObject.getPrototypeOf(true)\n// Boolean &#123;[[PrimitiveValue]]: false&#125;\n\nObject.getPrototypeOf(1) === Number.prototype // true\nObject.getPrototypeOf(&#39;foo&#39;) === String.prototype // true\nObject.getPrototypeOf(true) === Boolean.prototype // true\n</code></pre>\n<p>如果参数是<code>undefined</code>或<code>null</code>，它们无法转为对象，所以会报错。</p>\n<pre><code class=\"javascript\">Object.getPrototypeOf(null)\n// TypeError: Cannot convert undefined or null to object\n\nObject.getPrototypeOf(undefined)\n// TypeError: Cannot convert undefined or null to object\n</code></pre>\n<hr>\n<h4 id=\"5-Object-keys-，Object-values-，Object-entries\"><a href=\"#5-Object-keys-，Object-values-，Object-entries\" class=\"headerlink\" title=\"5. Object.keys()，Object.values()，Object.entries()\"></a>5. Object.keys()，Object.values()，Object.entries()</h4><p><strong>Object.keys</strong>()</p>\n<p><strong>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</strong></p>\n<pre><code class=\"javascript\">var obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;\nObject.keys(obj)\n// [&quot;foo&quot;, &quot;baz&quot;]\n</code></pre>\n<p>ES2017 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVz\">引入</span>了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。</p>\n<pre><code class=\"javascript\">let &#123;keys, values, entries&#125; = Object;\nlet obj = &#123; a: 1, b: 2, c: 3 &#125;;\n\nfor (let key of keys(obj)) &#123;\n  console.log(key); // &#39;a&#39;, &#39;b&#39;, &#39;c&#39;\n&#125;\n\nfor (let value of values(obj)) &#123;\n  console.log(value); // 1, 2, 3\n&#125;\n\nfor (let [key, value] of entries(obj)) &#123;\n  console.log([key, value]); // [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]\n&#125;\n</code></pre>\n<p><strong>Object.values()</strong></p>\n<p><strong><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</strong></p>\n<pre><code class=\"javascript\">const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;\nObject.values(obj)\n// [&quot;bar&quot;, 42]\n</code></pre>\n<p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p>\n<pre><code class=\"javascript\">const obj = &#123; 100: &#39;a&#39;, 2: &#39;b&#39;, 7: &#39;c&#39; &#125;;\nObject.values(obj)\n// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]\n</code></pre>\n<p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code>b</code>、<code>c</code>、<code>a</code>。</p>\n<p><code>Object.values</code>只返回对象自身的可遍历属性。</p>\n<pre><code class=\"javascript\">const obj = Object.create(&#123;&#125;, &#123;p: &#123;value: 42&#125;&#125;);\nObject.values(obj) // []\n</code></pre>\n<p>上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性（属性<code>p</code>），如果不显式声明，默认是不可遍历的，因为<code>p</code>的属性描述对象的<code>enumerable</code>默认是<code>false</code>，<code>Object.values</code>不会返回这个属性。只要把<code>enumerable</code>改成<code>true</code>，<code>Object.values</code>就会返回属性<code>p</code>的值。</p>\n<pre><code class=\"javascript\">const obj = Object.create(&#123;&#125;, &#123;p:\n  &#123;\n    value: 42,\n    enumerable: true\n  &#125;\n&#125;);\nObject.values(obj) // [42]\n</code></pre>\n<p><code>Object.values</code>会过滤属性名为 Symbol 值的属性。</p>\n<pre><code class=\"javascript\">Object.values(&#123; [Symbol()]: 123, foo: &#39;abc&#39; &#125;);\n// [&#39;abc&#39;]\n</code></pre>\n<p>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。</p>\n<pre><code class=\"javascript\">Object.values(&#39;foo&#39;)\n// [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]\n</code></pre>\n<p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code>Object.values</code>返回每个属性的键值，就是各个字符组成的一个数组。</p>\n<p>如果参数不是对象，<code>Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code>会返回空数组。</p>\n<pre><code class=\"javascript\">Object.values(42) // []\nObject.values(true) // []\n</code></pre>\n<p><strong>Object.entries</strong>()</p>\n<p><strong><code>Object.entries()</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</strong></p>\n<pre><code class=\"javascript\">const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;\nObject.entries(obj)\n// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]\n</code></pre>\n<p>除了返回值不一样，该方法的行为与<code>Object.values</code>基本一致。</p>\n<p>如果原对象的属性名是一个 Symbol 值，该属性会被忽略。</p>\n<pre><code class=\"javascript\">Object.entries(&#123; [Symbol()]: 123, foo: &#39;abc&#39; &#125;);\n// [ [ &#39;foo&#39;, &#39;abc&#39; ] ]\n</code></pre>\n<p>上面代码中，原对象有两个属性，<code>Object.entries</code>只输出属性名非 Symbol 值的属性。将来可能会有<code>Reflect.ownEntries()</code>方法，返回对象自身的所有属性。</p>\n<p><code>Object.entries</code>的基本用途是遍历对象的属性。</p>\n<pre><code class=\"javascript\">let obj = &#123; one: 1, two: 2 &#125;;\nfor (let [k, v] of Object.entries(obj)) &#123;\n  console.log(\n    `$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;`\n  );\n&#125;\n// &quot;one&quot;: 1\n// &quot;two&quot;: 2\n</code></pre>\n<p><code>Object.entries</code>方法的另一个用处是，将对象转为真正的<code>Map</code>结构。</p>\n<pre><code class=\"javascript\">const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;\nconst map = new Map(Object.entries(obj));\nmap // Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;\n</code></pre>\n<p>自己实现<code>Object.entries</code>方法，非常简单。</p>\n<pre><code class=\"javascript\">// Generator函数的版本\nfunction* entries(obj) &#123;\n  for (let key of Object.keys(obj)) &#123;\n    yield [key, obj[key]];\n  &#125;\n&#125;\n\n// 非Generator函数的版本\nfunction entries(obj) &#123;\n  let arr = [];\n  for (let key of Object.keys(obj)) &#123;\n    arr.push([key, obj[key]]);\n  &#125;\n  return arr;\n&#125;\n</code></pre>\n<hr>\n<h4 id=\"6-Object-fromEntries\"><a href=\"#6-Object-fromEntries\" class=\"headerlink\" title=\"6. Object.fromEntries()\"></a>6. Object.fromEntries()</h4><p><strong><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。</strong></p>\n<pre><code class=\"javascript\">Object.fromEntries([\n  [&#39;foo&#39;, &#39;bar&#39;],\n  [&#39;baz&#39;, 42]\n])\n// &#123; foo: &quot;bar&quot;, baz: 42 &#125;\n</code></pre>\n<p><strong>该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。</strong></p>\n<pre><code class=\"javascript\">// 例一\nconst entries = new Map([\n  [&#39;foo&#39;, &#39;bar&#39;],\n  [&#39;baz&#39;, 42]\n]);\n\nObject.fromEntries(entries)\n// &#123; foo: &quot;bar&quot;, baz: 42 &#125;\n\n// 例二\nconst map = new Map().set(&#39;foo&#39;, true).set(&#39;bar&#39;, false);\nObject.fromEntries(map)\n// &#123; foo: true, bar: false &#125;\n</code></pre>\n<p><strong>该方法的一个用处是配合<code>URLSearchParams</code>对象，将查询字符串转为对象。</strong></p>\n<pre><code class=\"javascript\">Object.fromEntries(new URLSearchParams(&#39;foo=bar&amp;baz=qux&#39;))\n// &#123; foo: &quot;bar&quot;, baz: &quot;qux&quot; &#125;\n</code></pre>\n<h3 id=\"11、运算符的扩展\"><a href=\"#11、运算符的扩展\" class=\"headerlink\" title=\"11、运算符的扩展\"></a>11、运算符的扩展</h3><hr>\n<h4 id=\"1-指数运算符\"><a href=\"#1-指数运算符\" class=\"headerlink\" title=\"1. 指数运算符**\"></a>1. 指数运算符**</h4><p>ES2016 新增了一个指数运算符（<code>**</code>）。</p>\n<pre><code class=\"javascript\">2 ** 2 // 4\n2 ** 3 // 8\n</code></pre>\n<p>这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，<strong>是从最右边开始计算的。</strong></p>\n<pre><code class=\"javascript\">// 相当于 2 ** (3 ** 2)\n2 ** 3 ** 2\n// 512\n</code></pre>\n<p>上面代码中，首先计算的是第二个指数运算符，而不是第一个。</p>\n<p>指数运算符可以与等号结合，形成一个新的赋值运算符（<code>**=</code>）。</p>\n<pre><code class=\"javascript\">let a = 1.5;\na **= 2;\n// 等同于 a = a * a;\n\nlet b = 4;\nb **= 3;\n// 等同于 b = b * b * b;\n</code></pre>\n<hr>\n<h4 id=\"2-链判断运算符？\"><a href=\"#2-链判断运算符？\" class=\"headerlink\" title=\"2. 链判断运算符？.\"></a>2. 链判断运算符？.</h4><p><strong>编程实务中，如果读取对象内部的某个属性，往往需要判断一下，属性的上层对象是否存在</strong>。比如，读取<code>message.body.user.firstName</code>这个属性，安全的写法是写成下面这样。</p>\n<pre><code class=\"javascript\">// 错误的写法\nconst  firstName = message.body.user.firstName || &#39;default&#39;;\n\n// 正确的写法\nconst firstName = (message\n  &amp;&amp; message.body\n  &amp;&amp; message.body.user\n  &amp;&amp; message.body.user.firstName) || &#39;default&#39;;\n</code></pre>\n<p>上面例子中，<code>firstName</code>属性在对象的第四层，所以需要判断四次，每一层是否有值。</p>\n<p>三元运算符<code>?:</code>也常用于判断对象是否存在。</p>\n<pre><code class=\"javascript\">const fooInput = myForm.querySelector(&#39;input[name=foo]&#39;)\nconst fooValue = fooInput ? fooInput.value : undefined\n</code></pre>\n<p>上面例子中，必须先判断<code>fooInput</code>是否存在，才能读取<code>fooInput.value</code>。</p>\n<p><strong>这样的层层判断非常麻烦，因此 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb3B0aW9uYWwtY2hhaW5pbmc=\">ES2020</span> 引入了“链判断运算符”（optional chaining operator）<code>?.</code>，简化上面的写法。</strong></p>\n<pre><code class=\"javascript\">const firstName = message?.body?.user?.firstName || &#39;default&#39;;\nconst fooValue = myForm.querySelector(&#39;input[name=foo]&#39;)?.value\n</code></pre>\n<p>上面代码使用了<code>?.</code>运算符，直接在链式调用的时候判断，左侧的对象是否为<code>null</code>或<code>undefined</code>。如果是的，就不再往下运算，而是返回<code>undefined</code>。</p>\n<p>下面是判断对象方法是否存在，如果存在就立即执行的例子。</p>\n<pre><code class=\"javascript\">iterator.return?.()\n</code></pre>\n<p>上面代码中，<code>iterator.return</code>如果有定义，就会调用该方法，否则<code>iterator.return</code>直接返回<code>undefined</code>，不再执行<code>?.</code>后面的部分。</p>\n<p>对于那些可能没有实现的方法，这个运算符尤其有用。</p>\n<pre><code class=\"javascript\">if (myForm.checkValidity?.() === false) &#123;\n  // 表单校验失败\n  return;\n&#125;\n</code></pre>\n<p>上面代码中，老式浏览器的表单对象可能没有<code>checkValidity()</code>这个方法，这时<code>?.</code>运算符就会返回<code>undefined</code>，判断语句就变成了<code>undefined === false</code>，所以就会跳过下面的代码。</p>\n<p><strong>链判断运算符<code>?.</code>有三种写法。</strong></p>\n<ul>\n<li><strong><code>obj?.prop</code> // 对象属性是否存在</strong></li>\n<li><strong><code>obj?.[expr]</code> // 同上</strong></li>\n<li><strong><code>func?.(...args)</code> // 函数或对象方法是否存在</strong></li>\n</ul>\n<p>下面是<code>obj?.[expr]</code>用法的一个例子。</p>\n<pre><code class=\"bash\">let hex = &quot;#C0FFEE&quot;.match(/#([A-Z]+)/i)?.[1];\n</code></pre>\n<p>上面例子中，字符串的<code>match()</code>方法，如果没有发现匹配会返回<code>null</code>，如果发现匹配会返回一个数组，<code>?.</code>运算符起到了判断作用。</p>\n<p>下面是<code>?.</code>运算符常见形式，以及不使用该运算符时的等价形式。</p>\n<pre><code class=\"javascript\">a?.b\n// 等同于\na == null ? undefined : a.b\n\na?.[x]\n// 等同于\na == null ? undefined : a[x]\n\na?.b()\n// 等同于\na == null ? undefined : a.b()\n\na?.()\n// 等同于\na == null ? undefined : a()\n</code></pre>\n<p>上面代码中，特别注意后两种形式，如果<code>a?.b()</code>和<code>a?.()</code>。如果<code>a?.b()</code>里面的<code>a.b</code>有值，但不是函数，不可调用，那么<code>a?.b()</code>是会报错的。<code>a?.()</code>也是如此，<strong>如果<code>a</code>不是<code>null</code>或<code>undefined</code>，但也不是函数，那么<code>a?.()</code>会报错。</strong></p>\n<p>使用这个运算符，有几个注意点。</p>\n<p>（1）短路机制</p>\n<p><strong>本质上，<code>?.</code>运算符相当于一种短路机制，只要不满足条件，就不再往下执行。</strong></p>\n<pre><code class=\"javascript\">a?.[++x]\n// 等同于\na == null ? undefined : a[++x]\n</code></pre>\n<p>上面代码中，如果<code>a</code>是<code>undefined</code>或<code>null</code>，那么<code>x</code>不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。</p>\n<p>（2）括号的影响</p>\n<p>如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。</p>\n<pre><code class=\"javascript\">(a?.b).c\n// 等价于\n(a == null ? undefined : a.b).c\n</code></pre>\n<p>上面代码中，<code>?.</code>对圆括号外部没有影响，不管<code>a</code>对象是否存在，圆括号后面的<code>.c</code>总是会执行。</p>\n<p><strong>一般来说，使用<code>?.</code>运算符的场合，不应该使用圆括号。</strong></p>\n<p>（3）报错场合</p>\n<p>以下写法是禁止的，会报错。</p>\n<pre><code class=\"javascript\">// 构造函数\nnew a?.()\nnew a?.b()\n\n// 链判断运算符的右侧有模板字符串\na?.`&#123;b&#125;`\na?.b`&#123;c&#125;`\n\n// 链判断运算符的左侧是 super\nsuper?.()\nsuper?.foo\n\n// 链运算符用于赋值运算符左侧\na?.b = c\n</code></pre>\n<p>（4）右侧不得为十进制数值</p>\n<p>为了保证兼容以前的代码，允许<code>foo?.3:0</code>被解析成<code>foo ? .3 : 0</code>，因此规定如果<code>?.</code>后面紧跟一个十进制数字，<strong>那么<code>?.</code>不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。</strong></p>\n<hr>\n<h4 id=\"3-Null-判断运算符？？\"><a href=\"#3-Null-判断运算符？？\" class=\"headerlink\" title=\"3. Null 判断运算符？？\"></a>3. Null 判断运算符？？</h4><p>读取对象属性的时候，如果某个属性的值是<code>null</code>或<code>undefined</code>，有时候需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值。</p>\n<pre><code class=\"javascript\">const headerText = response.settings.headerText || &#39;Hello, world!&#39;;\nconst animationDuration = response.settings.animationDuration || 300;\nconst showSplashScreen = response.settings.showSplashScreen || true;\n</code></pre>\n<p><strong>上面的三行代码都通过<code>||</code>运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为<code>null</code>或<code>undefined</code>，默认值就会生效，但是属性的值如果为空字符串或<code>false</code>或<code>0</code>，默认值也会生效。</strong></p>\n<p><strong>为了避免这种情况，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtbnVsbGlzaC1jb2FsZXNjaW5n\">ES2020</span> 引入了一个新的 Null 判断运算符<code>??</code>。它的行为类似<code>||</code>，但是只有运算符左侧的值为<code>null</code>或<code>undefined</code>时，才会返回右侧的值。</strong></p>\n<pre><code class=\"javascript\">const headerText = response.settings.headerText ?? &#39;Hello, world!&#39;;\nconst animationDuration = response.settings.animationDuration ?? 300;\nconst showSplashScreen = response.settings.showSplashScreen ?? true;\n</code></pre>\n<p>上面代码中，默认值只有在左侧属性值为<code>null</code>或<code>undefined</code>时，才会生效。</p>\n<p><strong>这个运算符的一个目的，就是跟链判断运算符<code>?.</code>配合使用，为<code>null</code>或<code>undefined</code>的值设置默认值</strong>。</p>\n<pre><code class=\"javascript\">const animationDuration = response.settings?.animationDuration ?? 300;\n</code></pre>\n<p>上面代码中，如果<code>response.settings</code>是<code>null</code>或<code>undefined</code>，或者<code>response.settings.animationDuration</code>是<code>null</code>或<code>undefined</code>，就会返回默认值300。也就是说，这一行代码包括了两级属性的判断。</p>\n<p>这个运算符很适合判断函数参数是否赋值。</p>\n<pre><code class=\"javascript\">function Component(props) &#123;\n  const enable = props.enabled ?? true;\n  // …\n&#125;\n</code></pre>\n<p>上面代码判断<code>props</code>参数的<code>enabled</code>属性是否赋值，基本等同于下面的写法。</p>\n<pre><code class=\"javascript\">function Component(props) &#123;\n  const &#123;\n    enabled: enable = true,\n  &#125; = props;\n  // …\n&#125;\n</code></pre>\n<p><strong><code>??</code>本质上是逻辑运算，它与其他两个逻辑运算符<code>&amp;&amp;</code>和<code>||</code>有一个优先级问题</strong>，它们之间的优先级到底孰高孰低。优先级的不同，往往会导致逻辑运算的结果不同。</p>\n<p>现在的规则是，如果多个逻辑运算符一起使用，<strong>必须用括号表明优先级，否则会报错。</strong></p>\n<pre><code class=\"javascript\">// 报错\nlhs &amp;&amp; middle ?? rhs\nlhs ?? middle &amp;&amp; rhs\nlhs || middle ?? rhs\nlhs ?? middle || rhs\n</code></pre>\n<p>上面四个表达式都会报错，必须加入表明优先级的括号。</p>\n<pre><code class=\"javascript\">(lhs &amp;&amp; middle) ?? rhs;\nlhs &amp;&amp; (middle ?? rhs);\n\n(lhs ?? middle) &amp;&amp; rhs;\nlhs ?? (middle &amp;&amp; rhs);\n\n(lhs || middle) ?? rhs;\nlhs || (middle ?? rhs);\n\n(lhs ?? middle) || rhs;\nlhs ?? (middle || rhs);\n</code></pre>\n<hr>\n<h4 id=\"4-逻辑赋值运算符\"><a href=\"#4-逻辑赋值运算符\" class=\"headerlink\" title=\"4. 逻辑赋值运算符\"></a>4. 逻辑赋值运算符</h4><p>ES2021 引入了三个新的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtbG9naWNhbC1hc3NpZ25tZW50\">逻辑赋值运算符</span>（logical assignment operators），将逻辑运算符与赋值运算符进行结合。</p>\n<pre><code class=\"javascript\">// 或赋值运算符\nx ||= y\n// 等同于\nx || (x = y)\n\n// 与赋值运算符\nx &amp;&amp;= y\n// 等同于\nx &amp;&amp; (x = y)\n\n// Null 赋值运算符\nx ??= y\n// 等同于\nx ?? (x = y)\n</code></pre>\n<p><strong>这三个运算符<code>||=</code>、<code>&amp;&amp;=</code>、<code>??=</code>相当于先进行逻辑运算，然后根据运算结果，再视情况进行赋值运算。</strong></p>\n<p><strong>它们的一个用途是，为变量或属性设置默认值。</strong></p>\n<pre><code class=\"javascript\">// 老的写法\nuser.id = user.id || 1;\n\n// 新的写法\nuser.id ||= 1;\n</code></pre>\n<p>上面示例中，<code>user.id</code>属性如果不存在，则设为<code>1</code>，新的写法比老的写法更紧凑一些。</p>\n<p>下面是另一个例子。</p>\n<pre><code class=\"javascript\">function example(opts) &#123;\n  opts.foo = opts.foo ?? &#39;bar&#39;;\n  opts.baz ?? (opts.baz = &#39;qux&#39;);\n&#125;\n</code></pre>\n<p>上面示例中，参数对象<code>opts</code>如果不存在属性<code>foo</code>和属性<code>baz</code>，则为这两个属性设置默认值。有了“Null 赋值运算符”以后，就可以统一写成下面这样。</p>\n<pre><code class=\"javascript\">function example(opts) &#123;\n  opts.foo ??= &#39;bar&#39;;\n  opts.baz ??= &#39;qux&#39;;\n&#125;\n</code></pre>\n<h3 id=\"12、-Symbol\"><a href=\"#12、-Symbol\" class=\"headerlink\" title=\"12、 Symbol\"></a>12、 Symbol</h3><hr>\n<h4 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h4><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。<strong>如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</strong></p>\n<p><strong>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</strong></p>\n<p>Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>\n<pre><code class=\"javascript\">let s = Symbol();\n\ntypeof s\n// &quot;symbol&quot;\n</code></pre>\n<p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是 Symbol 数据类型，而不是字符串之类的其他类型。</p>\n<p>注意，**<code>Symbol</code>函数前不能使用<code>new</code>命令**，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>\n<p><strong><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述</strong>，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>\n<pre><code class=\"javascript\">let s1 = Symbol(&#39;foo&#39;);\nlet s2 = Symbol(&#39;bar&#39;);\n\ns1 // Symbol(foo)\ns2 // Symbol(bar)\n\ns1.toString() // &quot;Symbol(foo)&quot;\ns2.toString() // &quot;Symbol(bar)&quot;\n</code></pre>\n<p>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p>\n<p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。</p>\n<pre><code class=\"javascript\">const obj = &#123;\n  toString() &#123;\n    return &#39;abc&#39;;\n  &#125;\n&#125;;\nconst sym = Symbol(obj);\nsym // Symbol(abc)\n</code></pre>\n<p>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此<strong>相同参数的<code>Symbol</code>函数的返回值是不相等的。</strong></p>\n<pre><code class=\"javascript\">// 没有参数的情况\nlet s1 = Symbol();\nlet s2 = Symbol();\n\ns1 === s2 // false\n\n// 有参数的情况\nlet s1 = Symbol(&#39;foo&#39;);\nlet s2 = Symbol(&#39;foo&#39;);\n\ns1 === s2 // false\n</code></pre>\n<p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。</p>\n<p><strong>Symbol 值不能与其他类型的值进行运算，会报错。</strong></p>\n<pre><code class=\"javascript\">let sym = Symbol(&#39;My symbol&#39;);\n\n&quot;your symbol is &quot; + sym\n// TypeError: can&#39;t convert symbol to string\n`your symbol is $&#123;sym&#125;`\n// TypeError: can&#39;t convert symbol to string\n</code></pre>\n<p>但是，<strong>Symbol 值可以显式转为字符串。</strong></p>\n<pre><code class=\"javascript\">let sym = Symbol(&#39;My symbol&#39;);\n\nString(sym) // &#39;Symbol(My symbol)&#39;\nsym.toString() // &#39;Symbol(My symbol)&#39;\n</code></pre>\n<p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p>\n<pre><code class=\"javascript\">let sym = Symbol();\nBoolean(sym) // true\n!sym  // false\n\nif (sym) &#123;\n  // ...\n&#125;\n\nNumber(sym) // TypeError\nsym + 2 // TypeError\n</code></pre>\n<hr>\n<h4 id=\"2-Symbol-prototype-description\"><a href=\"#2-Symbol-prototype-description\" class=\"headerlink\" title=\"2. Symbol.prototype.description\"></a>2. Symbol.prototype.description</h4><p>创建 Symbol 的时候，可以添加一个描述。</p>\n<pre><code class=\"javascript\">const sym = Symbol(&#39;foo&#39;);\n</code></pre>\n<p>上面代码中，<code>sym</code>的描述就是字符串<code>foo</code>。</p>\n<p>但是，读取这个描述需要将 Symbol 显式转为字符串，即下面的写法。</p>\n<pre><code class=\"javascript\">const sym = Symbol(&#39;foo&#39;);\n\nString(sym) // &quot;Symbol(foo)&quot;\nsym.toString() // &quot;Symbol(foo)&quot;\n</code></pre>\n<p>上面的用法不是很方便。**<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtU3ltYm9sLWRlc2NyaXB0aW9u\">ES2019</span> 提供了一个实例属性<code>description</code>，直接返回 Symbol 的描述。**</p>\n<pre><code class=\"javascript\">const sym = Symbol(&#39;foo&#39;);\n\nsym.description // &quot;foo&quot;\n</code></pre>\n<hr>\n<h4 id=\"3-作为属性名的-Symbol\"><a href=\"#3-作为属性名的-Symbol\" class=\"headerlink\" title=\"3. 作为属性名的 Symbol\"></a>3. 作为属性名的 Symbol</h4><p>由于每一个 Symbol 值都是不相等的，<strong>这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性</strong>。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>\n<pre><code class=\"javascript\">let mySymbol = Symbol();\n\n// 第一种写法\nlet a = &#123;&#125;;\na[mySymbol] = &#39;Hello!&#39;;\n\n// 第二种写法\nlet a = &#123;\n  [mySymbol]: &#39;Hello!&#39;\n&#125;;\n\n// 第三种写法\nlet a = &#123;&#125;;\nObject.defineProperty(a, mySymbol, &#123; value: &#39;Hello!&#39; &#125;);\n\n// 以上写法都得到同样结果\na[mySymbol] // &quot;Hello!&quot;\n</code></pre>\n<p>上面代码通过方括号结构和<code>Object.defineProperty</code>，将对象的属性名指定为一个 Symbol 值。</p>\n<p><strong>注意，Symbol 值作为对象属性名时，不能用点运算符。</strong></p>\n<pre><code class=\"javascript\">const mySymbol = Symbol();\nconst a = &#123;&#125;;\n\na.mySymbol = &#39;Hello!&#39;;\na[mySymbol] // undefined\na[&#39;mySymbol&#39;] // &quot;Hello!&quot;\n</code></pre>\n<p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。</p>\n<p>同理，<strong>在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中</strong>。</p>\n<pre><code class=\"javascript\">let s = Symbol();\n\nlet obj = &#123;\n  [s]: function (arg) &#123; ... &#125;\n&#125;;\n\nobj[s](123);\n</code></pre>\n<p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个 Symbol 值。</p>\n<p>采用增强的对象写法，上面代码的<code>obj</code>对象可以写得更简洁一些。</p>\n<pre><code class=\"javascript\">let obj = &#123;\n  [s](arg) &#123; ... &#125;\n&#125;;\n</code></pre>\n<p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>\n<pre><code class=\"javascript\">const log = &#123;&#125;;\n\nlog.levels = &#123;\n  DEBUG: Symbol(&#39;debug&#39;),\n  INFO: Symbol(&#39;info&#39;),\n  WARN: Symbol(&#39;warn&#39;)\n&#125;;\nconsole.log(log.levels.DEBUG, &#39;debug message&#39;);\nconsole.log(log.levels.INFO, &#39;info message&#39;);\n</code></pre>\n<p>下面是另外一个例子。</p>\n<pre><code class=\"javascript\">const COLOR_RED    = Symbol();\nconst COLOR_GREEN  = Symbol();\n\nfunction getComplement(color) &#123;\n  switch (color) &#123;\n    case COLOR_RED:\n      return COLOR_GREEN;\n    case COLOR_GREEN:\n      return COLOR_RED;\n    default:\n      throw new Error(&#39;Undefined color&#39;);\n    &#125;\n&#125;\n</code></pre>\n<p>常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的<code>switch</code>语句会按设计的方式工作。</p>\n<p>还有一点需要注意，<strong>Symbol 值作为属性名时，该属性还是公开属性，不是私有属性</strong>。</p>\n<hr>\n<h4 id=\"4-实例：消除魔术字符串\"><a href=\"#4-实例：消除魔术字符串\" class=\"headerlink\" title=\"4. 实例：消除魔术字符串\"></a>4. 实例：消除魔术字符串</h4><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p>\n<pre><code class=\"javascript\">function getArea(shape, options) &#123;\n  let area = 0;\n\n  switch (shape) &#123;\n    case &#39;Triangle&#39;: // 魔术字符串\n      area = .5 * options.width * options.height;\n      break;\n    /* ... more code ... */\n  &#125;\n\n  return area;\n&#125;\n\ngetArea(&#39;Triangle&#39;, &#123; width: 100, height: 100 &#125;); // 魔术字符串\n</code></pre>\n<p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p>\n<p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p>\n<pre><code class=\"javascript\">const shapeType = &#123;\n  triangle: &#39;Triangle&#39;\n&#125;;\n\nfunction getArea(shape, options) &#123;\n  let area = 0;\n  switch (shape) &#123;\n    case shapeType.triangle:\n      area = .5 * options.width * options.height;\n      break;\n  &#125;\n  return area;\n&#125;\n\ngetArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;);\n</code></pre>\n<p>上面代码中，我们把<code>Triangle</code>写成<code>shapeType</code>对象的<code>triangle</code>属性，这样就消除了强耦合。</p>\n<p>如果仔细分析，可以发现<code>shapeType.triangle</code>等于哪个值并不重要，只要确保不会跟其他<code>shapeType</code>属性的值冲突即可。因此，这里就很适合改用 Symbol 值。</p>\n<pre><code class=\"javascript\">const shapeType = &#123;\n  triangle: Symbol()\n&#125;;\n</code></pre>\n<p>上面代码中，除了将<code>shapeType.triangle</code>的值设为一个 Symbol，其他地方都不用修改。</p>\n<hr>\n<h4 id=\"5-属性名的遍历\"><a href=\"#5-属性名的遍历\" class=\"headerlink\" title=\"5. 属性名的遍历\"></a>5. 属性名的遍历</h4><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p>\n<p>但是，<strong>它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。</strong>该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>\n<pre><code class=\"javascript\">const obj = &#123;&#125;;\nlet a = Symbol(&#39;a&#39;);\nlet b = Symbol(&#39;b&#39;);\n\nobj[a] = &#39;Hello&#39;;\nobj[b] = &#39;World&#39;;\n\nconst objectSymbols = Object.getOwnPropertySymbols(obj);\n\nobjectSymbols\n// [Symbol(a), Symbol(b)]\n</code></pre>\n<p>上面代码是<code>Object.getOwnPropertySymbols()</code>方法的示例，可以获取所有 Symbol 属性名。</p>\n<p>下面是另一个例子，<code>Object.getOwnPropertySymbols()</code>方法与<code>for...in</code>循环、<code>Object.getOwnPropertyNames</code>方法进行对比的例子。</p>\n<pre><code class=\"javascript\">const obj = &#123;&#125;;\nconst foo = Symbol(&#39;foo&#39;);\n\nobj[foo] = &#39;bar&#39;;\n\nfor (let i in obj) &#123;\n  console.log(i); // 无输出\n&#125;\n\nObject.getOwnPropertyNames(obj) // []\nObject.getOwnPropertySymbols(obj) // [Symbol(foo)]\n</code></pre>\n<p>上面代码中，使用<code>for...in</code>循环和<code>Object.getOwnPropertyNames()</code>方法都得不到 Symbol 键名，需要使用<code>Object.getOwnPropertySymbols()</code>方法。</p>\n<p>另一个新的 API，**<code>Reflect.ownKeys()</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。**</p>\n<pre><code class=\"javascript\">let obj = &#123;\n  [Symbol(&#39;my_key&#39;)]: 1,\n  enum: 2,\n  nonEnum: 3\n&#125;;\n\nReflect.ownKeys(obj)\n//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]\n</code></pre>\n<p>由于以 Symbol 值作为键名，不会被常规方法遍历得到。<strong>我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法</strong>。</p>\n<pre><code class=\"javascript\">let size = Symbol(&#39;size&#39;);\n\nclass Collection &#123;\n  constructor() &#123;\n    this[size] = 0;\n  &#125;\n\n  add(item) &#123;\n    this[this[size]] = item;\n    this[size]++;\n  &#125;\n\n  static sizeOf(instance) &#123;\n    return instance[size];\n  &#125;\n&#125;\n\nlet x = new Collection();\nCollection.sizeOf(x) // 0\n\nx.add(&#39;foo&#39;);\nCollection.sizeOf(x) // 1\n\nObject.keys(x) // [&#39;0&#39;]\nObject.getOwnPropertyNames(x) // [&#39;0&#39;]\nObject.getOwnPropertySymbols(x) // [Symbol(size)]\n</code></pre>\n<p>上面代码中，对象<code>x</code>的<code>size</code>属性是一个 Symbol 值，所以<code>Object.keys(x)</code>、<code>Object.getOwnPropertyNames(x)</code>都无法获取它。这就造成了一种非私有的内部方法的效果。</p>\n<hr>\n<h4 id=\"6-Symbol-for-，Symbol-keyFor\"><a href=\"#6-Symbol-for-，Symbol-keyFor\" class=\"headerlink\" title=\"6. Symbol.for()，Symbol.keyFor()\"></a>6. Symbol.for()，Symbol.keyFor()</h4><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p>\n<pre><code class=\"javascript\">let s1 = Symbol.for(&#39;foo&#39;);\nlet s2 = Symbol.for(&#39;foo&#39;);\n\ns1 === s2 // true\n</code></pre>\n<p>上面代码中，**<code>s1</code>和<code>s2</code>都是 Symbol 值，但是它们都是由同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。**</p>\n<p><strong><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会</strong>。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。</p>\n<pre><code class=\"javascript\">Symbol.for(&quot;bar&quot;) === Symbol.for(&quot;bar&quot;)\n// true\n\nSymbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;)\n// false\n</code></pre>\n<p>上面代码中，<strong>由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</strong></p>\n<p><strong><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</strong></p>\n<pre><code class=\"javascript\">let s1 = Symbol.for(&quot;foo&quot;);\nSymbol.keyFor(s1) // &quot;foo&quot;\n\nlet s2 = Symbol(&quot;foo&quot;);\nSymbol.keyFor(s2) // undefined\n</code></pre>\n<p>上面代码中，变量<code>s2</code>属于未登记的 Symbol 值，所以返回<code>undefined</code>。</p>\n<p>注意，**<code>Symbol.for()</code>为 Symbol 值登记的名字，是全局环境的**，不管有没有在全局环境运行。</p>\n<pre><code class=\"javascript\">function foo() &#123;\n  return Symbol.for(&#39;bar&#39;);\n&#125;\n\nconst x = foo();\nconst y = Symbol.for(&#39;bar&#39;);\nconsole.log(x === y); // true\n</code></pre>\n<p>上面代码中，<code>Symbol.for(&#39;bar&#39;)</code>是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的。所以，第二次运行<code>Symbol.for(&#39;bar&#39;)</code>可以取到这个 Symbol 值。</p>\n<p><code>Symbol.for()</code>的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。</p>\n<pre><code class=\"javascript\">iframe = document.createElement(&#39;iframe&#39;);\niframe.src = String(window.location);\ndocument.body.appendChild(iframe);\n\niframe.contentWindow.Symbol.for(&#39;foo&#39;) === Symbol.for(&#39;foo&#39;)\n// true\n</code></pre>\n<p>上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。</p>\n<hr>\n<h4 id=\"7-实例：模块的-Singleton-模式\"><a href=\"#7-实例：模块的-Singleton-模式\" class=\"headerlink\" title=\"7.实例：模块的 Singleton 模式\"></a>7.实例：模块的 Singleton 模式</h4><p>Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。</p>\n<p>对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p>\n<p>很容易想到，可以把实例放到顶层对象<code>global</code>。</p>\n<pre><code class=\"javascript\">// mod.js\nfunction A() &#123;\n  this.foo = &#39;hello&#39;;\n&#125;\n\nif (!global._foo) &#123;\n  global._foo = new A();\n&#125;\n\nmodule.exports = global._foo;\n</code></pre>\n<p>然后，加载上面的<code>mod.js</code>。</p>\n<pre><code class=\"javascript\">const a = require(&#39;./mod.js&#39;);\nconsole.log(a.foo);\n</code></pre>\n<p>上面代码中，变量<code>a</code>任何时候加载的都是<code>A</code>的同一个实例。</p>\n<p>但是，这里有一个问题，全局变量<code>global._foo</code>是可写的，任何文件都可以修改。</p>\n<pre><code class=\"javascript\">global._foo = &#123; foo: &#39;world&#39; &#125;;\n\nconst a = require(&#39;./mod.js&#39;);\nconsole.log(a.foo);\n</code></pre>\n<p>上面的代码，会使得加载<code>mod.js</code>的脚本都失真。</p>\n<p>为了防止这种情况出现，我们就可以使用 Symbol。</p>\n<pre><code class=\"javascript\">// mod.js\nconst FOO_KEY = Symbol.for(&#39;foo&#39;);\n\nfunction A() &#123;\n  this.foo = &#39;hello&#39;;\n&#125;\n\nif (!global[FOO_KEY]) &#123;\n  global[FOO_KEY] = new A();\n&#125;\n\nmodule.exports = global[FOO_KEY];\n</code></pre>\n<p>上面代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p>\n<pre><code class=\"javascript\">global[Symbol.for(&#39;foo&#39;)] = &#123; foo: &#39;world&#39; &#125;;\n\nconst a = require(&#39;./mod.js&#39;);\n</code></pre>\n<p>如果键名使用<code>Symbol</code>方法生成，那么外部将无法引用这个值，当然也就无法改写。</p>\n<pre><code class=\"javascript\">// mod.js\nconst FOO_KEY = Symbol(&#39;foo&#39;);\n\n// 后面代码相同 ……\n</code></pre>\n<p>上面代码将导致其他脚本都无法引用<code>FOO_KEY</code>。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的<code>FOO_KEY</code>都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。</p>\n<hr>\n<h4 id=\"8-内置的-Symbol-值\"><a href=\"#8-内置的-Symbol-值\" class=\"headerlink\" title=\"8. 内置的 Symbol 值\"></a>8. 内置的 Symbol 值</h4><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p>\n<p><strong>Symbol.hasInstance</strong></p>\n<p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。<strong>当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法</strong>。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p>\n<pre><code class=\"javascript\">class MyClass &#123;\n  [Symbol.hasInstance](foo) &#123;\n    return foo instanceof Array;\n  &#125;\n&#125;\n\n[1, 2, 3] instanceof new MyClass() // true\n</code></pre>\n<p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</p>\n<p>下面是另一个例子。</p>\n<pre><code class=\"javascript\">class Even &#123;\n  static [Symbol.hasInstance](obj) &#123;\n    return Number(obj) % 2 === 0;\n  &#125;\n&#125;\n\n// 等同于\nconst Even = &#123;\n  [Symbol.hasInstance](obj) &#123;\n    return Number(obj) % 2 === 0;\n  &#125;\n&#125;;\n\n1 instanceof Even // false\n2 instanceof Even // true\n12345 instanceof Even // false\n</code></pre>\n<hr>\n<p><strong>Symbol.isConcatSpreadable</strong></p>\n<p><strong>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。</strong></p>\n<pre><code class=\"javascript\">let arr1 = [&#39;c&#39;, &#39;d&#39;];\n[&#39;a&#39;, &#39;b&#39;].concat(arr1, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]\narr1[Symbol.isConcatSpreadable] // undefined\n\nlet arr2 = [&#39;c&#39;, &#39;d&#39;];\narr2[Symbol.isConcatSpreadable] = false;\n[&#39;a&#39;, &#39;b&#39;].concat(arr2, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, [&#39;c&#39;,&#39;d&#39;], &#39;e&#39;]\n</code></pre>\n<p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</p>\n<p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。</p>\n<pre><code class=\"javascript\">let obj = &#123;length: 2, 0: &#39;c&#39;, 1: &#39;d&#39;&#125;;\n[&#39;a&#39;, &#39;b&#39;].concat(obj, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, obj, &#39;e&#39;]\n\nobj[Symbol.isConcatSpreadable] = true;\n[&#39;a&#39;, &#39;b&#39;].concat(obj, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]\n</code></pre>\n<p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面。</p>\n<pre><code class=\"javascript\">class A1 extends Array &#123;\n  constructor(args) &#123;\n    super(args);\n    this[Symbol.isConcatSpreadable] = true;\n  &#125;\n&#125;\nclass A2 extends Array &#123;\n  constructor(args) &#123;\n    super(args);\n  &#125;\n  get [Symbol.isConcatSpreadable] () &#123;\n    return false;\n  &#125;\n&#125;\nlet a1 = new A1();\na1[0] = 3;\na1[1] = 4;\nlet a2 = new A2();\na2[0] = 5;\na2[1] = 6;\n[1, 2].concat(a1).concat(a2)\n// [1, 2, 3, 4, [5, 6]]\n</code></pre>\n<p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果。</p>\n<p>注意，<code>Symbol.isConcatSpreadable</code>的位置差异，<code>A1</code>是定义在实例上，<code>A2</code>是定义在类本身，效果相同。</p>\n<hr>\n<p><strong>Symbol.species</strong></p>\n<p><strong>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性。</strong></p>\n<pre><code class=\"javascript\">class MyArray extends Array &#123;\n&#125;\n\nconst a = new MyArray(1, 2, 3);\nconst b = a.map(x =&gt; x);\nconst c = a.filter(x =&gt; x &gt; 1);\n\nb instanceof MyArray // true\nc instanceof MyArray // true\n</code></pre>\n<p>上面代码中，子类<code>MyArray</code>继承了父类<code>Array</code>，<code>a</code>是<code>MyArray</code>的实例，<code>b</code>和<code>c</code>是<code>a</code>的衍生对象。你可能会认为，<code>b</code>和<code>c</code>都是调用数组方法生成的，所以应该是数组（<code>Array</code>的实例），但实际上它们也是<code>MyArray</code>的实例。</p>\n<p><code>Symbol.species</code>属性就是为了解决这个问题而提供的。现在，我们可以为<code>MyArray</code>设置<code>Symbol.species</code>属性。</p>\n<pre><code class=\"javascript\">class MyArray extends Array &#123;\n  static get [Symbol.species]() &#123; return Array; &#125;\n&#125;\n</code></pre>\n<p>上面代码中，由于定义了<code>Symbol.species</code>属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义<code>Symbol.species</code>属性要采用<code>get</code>取值器。默认的<code>Symbol.species</code>属性等同于下面的写法。</p>\n<pre><code class=\"javascript\">static get [Symbol.species]() &#123;\n  return this;\n&#125;\n</code></pre>\n<p>现在，再来看前面的例子。</p>\n<pre><code class=\"javascript\">class MyArray extends Array &#123;\n  static get [Symbol.species]() &#123; return Array; &#125;\n&#125;\n\nconst a = new MyArray();\nconst b = a.map(x =&gt; x);\n\nb instanceof MyArray // false\nb instanceof Array // true\n</code></pre>\n<p>上面代码中，<code>a.map(x =&gt; x)</code>生成的衍生对象，就不是<code>MyArray</code>的实例，而直接就是<code>Array</code>的实例。</p>\n<p>再看一个例子。</p>\n<pre><code class=\"javascript\">class T1 extends Promise &#123;\n&#125;\n\nclass T2 extends Promise &#123;\n  static get [Symbol.species]() &#123;\n    return Promise;\n  &#125;\n&#125;\n\nnew T1(r =&gt; r()).then(v =&gt; v) instanceof T1 // true\nnew T2(r =&gt; r()).then(v =&gt; v) instanceof T2 // false\n</code></pre>\n<p>上面代码中，<code>T2</code>定义了<code>Symbol.species</code>属性，<code>T1</code>没有。结果就导致了创建衍生对象时（<code>then</code>方法），<code>T1</code>调用的是自身的构造方法，而<code>T2</code>调用的是<code>Promise</code>的构造方法。</p>\n<p>总之，<code>Symbol.species</code>的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p>\n<hr>\n<p><strong>Symbol.match</strong></p>\n<p><strong>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</strong></p>\n<pre><code class=\"javascript\">String.prototype.match(regexp)\n// 等同于\nregexp[Symbol.match](this)\n\nclass MyMatcher &#123;\n  [Symbol.match](string) &#123;\n    return &#39;hello world&#39;.indexOf(string);\n  &#125;\n&#125;\n\n&#39;e&#39;.match(new MyMatcher()) // 1\n</code></pre>\n<p><strong>Symbol.replace</strong></p>\n<p><strong>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</strong></p>\n<pre><code class=\"javascript\">String.prototype.replace(searchValue, replaceValue)\n// 等同于\nsearchValue[Symbol.replace](this, replaceValue)\n</code></pre>\n<p>下面是一个例子。</p>\n<pre><code class=\"javascript\">const x = &#123;&#125;;\nx[Symbol.replace] = (...s) =&gt; console.log(s);\n\n&#39;Hello&#39;.replace(x, &#39;World&#39;) // [&quot;Hello&quot;, &quot;World&quot;]\n</code></pre>\n<p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code>。</p>\n<hr>\n<p><strong>Symbol.search</strong></p>\n<p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p>\n<pre><code class=\"javascript\">String.prototype.search(regexp)\n// 等同于\nregexp[Symbol.search](this)\n\nclass MySearch &#123;\n  constructor(value) &#123;\n    this.value = value;\n  &#125;\n  [Symbol.search](string) &#123;\n    return string.indexOf(this.value);\n  &#125;\n&#125;\n&#39;foobar&#39;.search(new MySearch(&#39;foo&#39;)) // 0\n</code></pre>\n<hr>\n<p><strong>Symbol.split</strong></p>\n<p><strong>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</strong></p>\n<pre><code class=\"javascript\">String.prototype.split(separator, limit)\n// 等同于\nseparator[Symbol.split](this, limit)\n</code></pre>\n<p>下面是一个例子。</p>\n<pre><code class=\"javascript\">class MySplitter &#123;\n  constructor(value) &#123;\n    this.value = value;\n  &#125;\n  [Symbol.split](string) &#123;\n    let index = string.indexOf(this.value);\n    if (index === -1) &#123;\n      return string;\n    &#125;\n    return [\n      string.substr(0, index),\n      string.substr(index + this.value.length)\n    ];\n  &#125;\n&#125;\n\n&#39;foobar&#39;.split(new MySplitter(&#39;foo&#39;))\n// [&#39;&#39;, &#39;bar&#39;]\n\n&#39;foobar&#39;.split(new MySplitter(&#39;bar&#39;))\n// [&#39;foo&#39;, &#39;&#39;]\n\n&#39;foobar&#39;.split(new MySplitter(&#39;baz&#39;))\n// &#39;foobar&#39;\n</code></pre>\n<p>上面方法使用<code>Symbol.split</code>方法，重新定义了字符串对象的<code>split</code>方法的行为，</p>\n<hr>\n<p><strong>Symbol.iterator</strong></p>\n<p><strong>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法。</strong></p>\n<pre><code class=\"javascript\">const myIterable = &#123;&#125;;\nmyIterable[Symbol.iterator] = function* () &#123;\n  yield 1;\n  yield 2;\n  yield 3;\n&#125;;\n\n[...myIterable] // [1, 2, 3]\n</code></pre>\n<p>对象进行<code>for...of</code>循环时，会调用<code>Symbol.iterator</code>方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for…of 循环》一章。</p>\n<pre><code class=\"javascript\">class Collection &#123;\n  *[Symbol.iterator]() &#123;\n    let i = 0;\n    while(this[i] !== undefined) &#123;\n      yield this[i];\n      ++i;\n    &#125;\n  &#125;\n&#125;\n\nlet myCollection = new Collection();\nmyCollection[0] = 1;\nmyCollection[1] = 2;\n\nfor(let value of myCollection) &#123;\n  console.log(value);\n&#125;\n// 1\n// 2\n</code></pre>\n<hr>\n<p><strong>Symbol.toPrimitive</strong></p>\n<p><strong>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</strong></p>\n<p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p>\n<ul>\n<li>Number：该场合需要转成数值</li>\n<li>String：该场合需要转成字符串</li>\n<li>Default：该场合可以转成数值，也可以转成字符串</li>\n</ul>\n<pre><code class=\"javascript\">let obj = &#123;\n  [Symbol.toPrimitive](hint) &#123;\n    switch (hint) &#123;\n      case &#39;number&#39;:\n        return 123;\n      case &#39;string&#39;:\n        return &#39;str&#39;;\n      case &#39;default&#39;:\n        return &#39;default&#39;;\n      default:\n        throw new Error();\n     &#125;\n   &#125;\n&#125;;\n\n2 * obj // 246\n3 + obj // &#39;3default&#39;\nobj == &#39;default&#39; // true\nString(obj) // &#39;str&#39;\n</code></pre>\n<hr>\n<p><strong>Symbol.toStringTag</strong></p>\n<p><strong>对象的<code>Symbol.toStringTag</code>属性，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串。</strong></p>\n<pre><code class=\"javascript\">// 例一\n(&#123;[Symbol.toStringTag]: &#39;Foo&#39;&#125;.toString())\n// &quot;[object Foo]&quot;\n\n// 例二\nclass Collection &#123;\n  get [Symbol.toStringTag]() &#123;\n    return &#39;xxx&#39;;\n  &#125;\n&#125;\nlet x = new Collection();\nObject.prototype.toString.call(x) // &quot;[object xxx]&quot;\n</code></pre>\n<p>ES6 新增内置对象的<code>Symbol.toStringTag</code>属性值如下。</p>\n<ul>\n<li><code>JSON[Symbol.toStringTag]</code>：’JSON’</li>\n<li><code>Math[Symbol.toStringTag]</code>：’Math’</li>\n<li>Module 对象<code>M[Symbol.toStringTag]</code>：’Module’</li>\n<li><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>：’ArrayBuffer’</li>\n<li><code>DataView.prototype[Symbol.toStringTag]</code>：’DataView’</li>\n<li><code>Map.prototype[Symbol.toStringTag]</code>：’Map’</li>\n<li><code>Promise.prototype[Symbol.toStringTag]</code>：’Promise’</li>\n<li><code>Set.prototype[Symbol.toStringTag]</code>：’Set’</li>\n<li><code>%TypedArray%.prototype[Symbol.toStringTag]</code>：’Uint8Array’等</li>\n<li><code>WeakMap.prototype[Symbol.toStringTag]</code>：’WeakMap’</li>\n<li><code>WeakSet.prototype[Symbol.toStringTag]</code>：’WeakSet’</li>\n<li><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>：’Map Iterator’</li>\n<li><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>：’Set Iterator’</li>\n<li><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>：’String Iterator’</li>\n<li><code>Symbol.prototype[Symbol.toStringTag]</code>：’Symbol’</li>\n<li><code>Generator.prototype[Symbol.toStringTag]</code>：’Generator’</li>\n<li><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>：’GeneratorFunction’</li>\n</ul>\n<hr>\n<p><strong>Symbol.unscopables</strong></p>\n<p><strong>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</strong></p>\n<pre><code class=\"javascript\">Array.prototype[Symbol.unscopables]\n// &#123;\n//   copyWithin: true,\n//   entries: true,\n//   fill: true,\n//   find: true,\n//   findIndex: true,\n//   includes: true,\n//   keys: true\n// &#125;\n\nObject.keys(Array.prototype[Symbol.unscopables])\n// [&#39;copyWithin&#39;, &#39;entries&#39;, &#39;fill&#39;, &#39;find&#39;, &#39;findIndex&#39;, &#39;includes&#39;, &#39;keys&#39;]\n</code></pre>\n<p>上面代码说明，数组有 7 个属性，会被<code>with</code>命令排除。</p>\n<pre><code class=\"javascript\">// 没有 unscopables 时\nclass MyClass &#123;\n  foo() &#123; return 1; &#125;\n&#125;\n\nvar foo = function () &#123; return 2; &#125;;\n\nwith (MyClass.prototype) &#123;\n  foo(); // 1\n&#125;\n\n// 有 unscopables 时\nclass MyClass &#123;\n  foo() &#123; return 1; &#125;\n  get [Symbol.unscopables]() &#123;\n    return &#123; foo: true &#125;;\n  &#125;\n&#125;\n\nvar foo = function () &#123; return 2; &#125;;\n\nwith (MyClass.prototype) &#123;\n  foo(); // 2\n&#125;\n</code></pre>\n<p>上面代码通过指定<code>Symbol.unscopables</code>属性，使得<code>with</code>语法块不会在当前作用域寻找<code>foo</code>属性，即<code>foo</code>将指向外层作用域的变量。</p>\n<h3 id=\"13、-Set-和-Map-数据结构\"><a href=\"#13、-Set-和-Map-数据结构\" class=\"headerlink\" title=\"13、 Set 和 Map 数据结构\"></a>13、 Set 和 Map 数据结构</h3><hr>\n<h4 id=\"1-Set\"><a href=\"#1-Set\" class=\"headerlink\" title=\"1. Set\"></a>1. Set</h4><p><strong>基本用法</strong></p>\n<p>ES6 提供了新的数据结构 Set。<strong>它类似于数组，但是成员的值都是唯一的，没有<code>重复</code>的值。</strong></p>\n<p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p>\n<pre><code class=\"javascript\">const s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));\n\nfor (let i of s) &#123;\n  console.log(i);\n&#125;\n// 2 3 5 4\n</code></pre>\n<p>上面代码通过<code>add()</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p>\n<p><strong><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</strong></p>\n<pre><code class=\"javascript\">// 例一\nconst set = new Set([1, 2, 3, 4, 4]);\n[...set]\n// [1, 2, 3, 4]\n\n// 例二\nconst items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);\nitems.size // 5\n\n// 例三\nconst set = new Set(document.querySelectorAll(&#39;div&#39;));\nset.size // 56\n\n// 类似于\nconst set = new Set();\ndocument\n .querySelectorAll(&#39;div&#39;)\n .forEach(div =&gt; set.add(div));\nset.size // 56\n</code></pre>\n<p>上面代码中，例一和例二都是<code>Set</code>函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p>\n<p>上面代码也展示了<strong>一种去除数组重复成员的方法。</strong></p>\n<pre><code class=\"javascript\">// 去除数组的重复成员\n[...new Set(array)]\n</code></pre>\n<p>上面的方法也可以用于，<strong>去除字符串里面的重复字符。</strong></p>\n<pre><code class=\"javascript\">[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)\n// &quot;abc&quot;\n</code></pre>\n<p><strong>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。</strong>Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），<strong>主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</strong></p>\n<pre><code class=\"javascript\">let set = new Set();\nlet a = NaN;\nlet b = NaN;\nset.add(a);\nset.add(b);\nset // Set &#123;NaN&#125;\n</code></pre>\n<p>上面代码向 Set 实例添加了两次<code>NaN</code>，但是只会加入一个。这表明，在 Set 内部，两个<code>NaN</code>是相等的。</p>\n<p>另外，<strong>两个对象总是不相等的。</strong></p>\n<pre><code class=\"javascript\">let set = new Set();\n\nset.add(&#123;&#125;);\nset.size // 1\n\nset.add(&#123;&#125;);\nset.size // 2\n</code></pre>\n<p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p>\n<hr>\n<p><strong>Set 实例的属性和方法</strong></p>\n<p>Set 结构的实例有以下属性。</p>\n<ul>\n<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>\n<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>\n</ul>\n<p>Set 实例的方法分为两大类：<strong>操作方法（用于操作数据）和遍历方法（用于遍历成员）</strong>。下面先介绍四个操作方法。</p>\n<ul>\n<li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li>\n<li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>\n<li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>\n<li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li>\n</ul>\n<p>上面这些属性和方法的实例如下。</p>\n<pre><code class=\"javascript\">s.add(1).add(2).add(2);\n// 注意2被加入了两次\n\ns.size // 2\n\ns.has(1) // true\ns.has(2) // true\ns.has(3) // false\n\ns.delete(2);\ns.has(2) // false\n</code></pre>\n<p>下面是一个对比，看看在判断是否包括一个键上面，<code>Object</code>结构和<code>Set</code>结构的写法不同。</p>\n<pre><code class=\"javascript\">// 对象的写法\nconst properties = &#123;\n  &#39;width&#39;: 1,\n  &#39;height&#39;: 1\n&#125;;\n\nif (properties[someName]) &#123;\n  // do something\n&#125;\n\n// Set的写法\nconst properties = new Set();\n\nproperties.add(&#39;width&#39;);\nproperties.add(&#39;height&#39;);\n\nif (properties.has(someName)) &#123;\n  // do something\n&#125;\n</code></pre>\n<p><strong><code>Array.from</code>方法可以将 Set 结构转为数组。</strong></p>\n<pre><code class=\"javascript\">const items = new Set([1, 2, 3, 4, 5]);\nconst array = Array.from(items);\n</code></pre>\n<p>这就提供了<strong>去除数组重复成员的另一种方法。</strong></p>\n<pre><code class=\"javascript\">function dedupe(array) &#123;\n  return Array.from(new Set(array));\n&#125;\n\ndedupe([1, 1, 2, 3]) // [1, 2, 3]\n</code></pre>\n<hr>\n<p><strong>遍历操作</strong></p>\n<p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p>\n<ul>\n<li><code>Set.prototype.keys()</code>：返回键名的遍历器</li>\n<li><code>Set.prototype.values()</code>：返回键值的遍历器</li>\n<li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li>\n<li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li>\n</ul>\n<p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>\n<p><strong>（1）<code>keys()</code>，<code>values()</code>，<code>entries()</code></strong></p>\n<p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），<strong>所以<code>keys</code>方法和<code>values</code>方法的行为完全一致</strong>。</p>\n<pre><code class=\"javascript\">let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);\n\nfor (let item of set.keys()) &#123;\n  console.log(item);\n&#125;\n// red\n// green\n// blue\n\nfor (let item of set.values()) &#123;\n  console.log(item);\n&#125;\n// red\n// green\n// blue\n\nfor (let item of set.entries()) &#123;\n  console.log(item);\n&#125;\n// [&quot;red&quot;, &quot;red&quot;]\n// [&quot;green&quot;, &quot;green&quot;]\n// [&quot;blue&quot;, &quot;blue&quot;]\n</code></pre>\n<p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>\n<p><strong>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</strong></p>\n<pre><code class=\"javascript\">Set.prototype[Symbol.iterator] === Set.prototype.values\n// true\n</code></pre>\n<p>这意味着，<strong>可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 Set。</strong></p>\n<pre><code class=\"javascript\">let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);\n\nfor (let x of set) &#123;\n  console.log(x);\n&#125;\n// red\n// green\n// blue\n</code></pre>\n<p><strong>（2）<code>forEach()</code></strong></p>\n<p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p>\n<pre><code class=\"javascript\">let set = new Set([1, 4, 9]);\nset.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))\n// 1 : 1\n// 4 : 4\n// 9 : 9\n</code></pre>\n<p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p>\n<p>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。</p>\n<p><strong>（3）遍历的应用</strong></p>\n<p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 Set 结构。</p>\n<pre><code class=\"javascript\">let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);\nlet arr = [...set];\n// [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]\n</code></pre>\n<p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p>\n<pre><code class=\"javascript\">let arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)];\n// [3, 5, 2]\n</code></pre>\n<p>而且，数组的<code>map</code>和<code>filter</code>方法也可以间接用于 Set 了。</p>\n<pre><code class=\"javascript\">let set = new Set([1, 2, 3]);\nset = new Set([...set].map(x =&gt; x * 2));\n// 返回Set结构：&#123;2, 4, 6&#125;\n\nlet set = new Set([1, 2, 3, 4, 5]);\nset = new Set([...set].filter(x =&gt; (x % 2) == 0));\n// 返回Set结构：&#123;2, 4&#125;\n</code></pre>\n<p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p>\n<pre><code class=\"javascript\">let a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet union = new Set([...a, ...b]);\n// Set &#123;1, 2, 3, 4&#125;\n\n// 交集\nlet intersect = new Set([...a].filter(x =&gt; b.has(x)));\n// set &#123;2, 3&#125;\n\n// （a 相对于 b 的）差集\nlet difference = new Set([...a].filter(x =&gt; !b.has(x)));\n// Set &#123;1&#125;\n</code></pre>\n<p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用<code>Array.from</code>方法。</p>\n<pre><code class=\"javascript\">// 方法一\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(val =&gt; val * 2));\n// set的值是2, 4, 6\n\n// 方法二\nlet set = new Set([1, 2, 3]);\nset = new Set(Array.from(set, val =&gt; val * 2));\n// set的值是2, 4, 6\n</code></pre>\n<p>上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。</p>\n<hr>\n<h4 id=\"2-WeakSet\"><a href=\"#2-WeakSet\" class=\"headerlink\" title=\"2. WeakSet\"></a>2. WeakSet</h4><p><strong>含义</strong></p>\n<p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>\n<p><strong>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</strong></p>\n<pre><code class=\"javascript\">const ws = new WeakSet();\nws.add(1)\n// TypeError: Invalid value used in weak set\nws.add(Symbol())\n// TypeError: invalid value used in weak set\n</code></pre>\n<p>上面代码试图向 WeakSet 添加一个数值和<code>Symbol</code>值，结果报错，因为 WeakSet 只能放置对象。</p>\n<p>其次，<strong>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用</strong>，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>\n<p>这是因为垃圾回收机制根据对象的可达性（reachability）来判断回收，如果对象还能被访问到，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。<strong>WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题</strong>。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p>\n<p>由于上面这个特点，<strong>WeakSet 的成员是不适合引用的</strong>，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 <strong>ES6 规定 WeakSet 不可遍历</strong>。</p>\n<p>这些特点同样适用于本章后面要介绍的 WeakMap 结构。</p>\n<p><strong>语法</strong></p>\n<p>WeakSet 是一个构造函数，可以使用<code>new</code>命令，创建 WeakSet 数据结构。</p>\n<pre><code class=\"javascript\">const ws = new WeakSet();\n</code></pre>\n<p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，<strong>任何具有 Iterable 接口的对象</strong>，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p>\n<pre><code class=\"javascript\">const a = [[1, 2], [3, 4]];\nconst ws = new WeakSet(a);\n// WeakSet &#123;[1, 2], [3, 4]&#125;\n</code></pre>\n<p>上面代码中，<code>a</code>是一个数组，它有两个成员，也都是数组。将<code>a</code>作为 WeakSet 构造函数的参数，<code>a</code>的成员会自动成为 WeakSet 的成员。</p>\n<p>注意，是<code>a</code>数组的成员成为 WeakSet 的成员，而不是<code>a</code>数组本身。这意味着，数组的成员只能是对象。</p>\n<pre><code class=\"javascript\">const b = [3, 4];\nconst ws = new WeakSet(b);\n// Uncaught TypeError: Invalid value used in weak set(…)\n</code></pre>\n<p>上面代码中，数组<code>b</code>的成员不是对象，加入 WeakSet 就会报错。</p>\n<p>WeakSet 结构有以下三个方法。</p>\n<ul>\n<li>**WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。</li>\n<li>**WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。</li>\n<li>**WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li>\n</ul>\n<p>下面是一个例子。</p>\n<pre><code class=\"javascript\">const ws = new WeakSet();\nconst obj = &#123;&#125;;\nconst foo = &#123;&#125;;\n\nws.add(window);\nws.add(obj);\n\nws.has(window); // true\nws.has(foo);    // false\n\nws.delete(window);\nws.has(window);    // false\n</code></pre>\n<p><strong>WeakSet 没有<code>size</code>属性，没有办法遍历它的成员。</strong></p>\n<pre><code class=\"javascript\">ws.size // undefined\nws.forEach // undefined\n\nws.forEach(function(item)&#123; console.log(&#39;WeakSet has &#39; + item)&#125;)\n// TypeError: undefined is not a function\n</code></pre>\n<p>上面代码试图获取<code>size</code>和<code>forEach</code>属性，结果都不能成功。</p>\n<p><strong>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失</strong>，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>\n<p>下面是 WeakSet 的另一个例子。</p>\n<pre><code class=\"javascript\">const foos = new WeakSet()\nclass Foo &#123;\n  constructor() &#123;\n    foos.add(this)\n  &#125;\n  method () &#123;\n    if (!foos.has(this)) &#123;\n      throw new TypeError(&#39;Foo.prototype.method 只能在Foo的实例上调用！&#39;);\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p>上面代码保证了<code>Foo</code>的实例方法，只能在<code>Foo</code>的实例上调用。这里使用 WeakSet 的好处是，<code>foos</code>对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑<code>foos</code>，也不会出现内存泄漏。</p>\n<hr>\n<h4 id=\"3-Map\"><a href=\"#3-Map\" class=\"headerlink\" title=\"3. Map\"></a>3. Map</h4><p><strong>含义和基本用法</strong></p>\n<p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>\n<pre><code class=\"javascript\">const data = &#123;&#125;;\nconst element = document.getElementById(&#39;myDiv&#39;);\n\ndata[element] = &#39;metadata&#39;;\ndata[&#39;[object HTMLDivElement]&#39;] // &quot;metadata&quot;\n</code></pre>\n<p>上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p>\n<p>为了解决这个问题，<strong>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键</strong>。也就是说，Object 结构提供了“字符串—值”的对应，<strong>Map 结构提供了“值—值”的对应</strong>，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>\n<pre><code class=\"javascript\">const m = new Map();\nconst o = &#123;p: &#39;Hello World&#39;&#125;;\n\nm.set(o, &#39;content&#39;)\nm.get(o) // &quot;content&quot;\n\nm.has(o) // true\nm.delete(o) // true\nm.has(o) // false\n</code></pre>\n<p>上面代码使用 Map 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p>\n<p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>\n<pre><code class=\"javascript\">const map = new Map([\n  [&#39;name&#39;, &#39;张三&#39;],\n  [&#39;title&#39;, &#39;Author&#39;]\n]);\n\nmap.size // 2\nmap.has(&#39;name&#39;) // true\nmap.get(&#39;name&#39;) // &quot;张三&quot;\nmap.has(&#39;title&#39;) // true\nmap.get(&#39;title&#39;) // &quot;Author&quot;\n</code></pre>\n<p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>title</code>。</p>\n<p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</p>\n<pre><code class=\"javascript\">const items = [\n  [&#39;name&#39;, &#39;张三&#39;],\n  [&#39;title&#39;, &#39;Author&#39;]\n];\n\nconst map = new Map();\n\nitems.forEach(\n  ([key, value]) =&gt; map.set(key, value)\n);\n</code></pre>\n<p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数。这就是说，**<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。**</p>\n<pre><code class=\"javascript\">const set = new Set([\n  [&#39;foo&#39;, 1],\n  [&#39;bar&#39;, 2]\n]);\nconst m1 = new Map(set);\nm1.get(&#39;foo&#39;) // 1\n\nconst m2 = new Map([[&#39;baz&#39;, 3]]);\nconst m3 = new Map(m2);\nm3.get(&#39;baz&#39;) // 3\n</code></pre>\n<p>上面代码中，我们分别使用 Set 对象和 Map 对象，当作<code>Map</code>构造函数的参数，结果都生成了新的 Map 对象。</p>\n<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>\n<pre><code class=\"javascript\">const map = new Map();\n\nmap\n.set(1, &#39;aaa&#39;)\n.set(1, &#39;bbb&#39;);\n\nmap.get(1) // &quot;bbb&quot;\n</code></pre>\n<p>上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值。</p>\n<p>如果读取一个未知的键，则返回<code>undefined</code>。</p>\n<pre><code class=\"javascript\">new Map().get(&#39;asfddfsasadf&#39;)\n// undefined\n</code></pre>\n<p>注意，<strong>只有对同一个对象的引用，Map 结构才将其视为同一个键</strong>。这一点要非常小心。</p>\n<pre><code class=\"javascript\">const map = new Map();\n\nmap.set([&#39;a&#39;], 555);\nmap.get([&#39;a&#39;]) // undefined\n</code></pre>\n<p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p>\n<p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p>\n<pre><code class=\"javascript\">const map = new Map();\n\nconst k1 = [&#39;a&#39;];\nconst k2 = [&#39;a&#39;];\n\nmap\n.set(k1, 111)\n.set(k2, 222);\n\nmap.get(k1) // 111\nmap.get(k2) // 222\n</code></pre>\n<p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在 Map 结构中被视为两个键。</p>\n<p>由上可知，<strong>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。</strong>这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p>\n<p><strong>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键</strong>，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。<strong>虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</strong></p>\n<pre><code class=\"javascript\">let map = new Map();\n\nmap.set(-0, 123);\nmap.get(+0) // 123\n\nmap.set(true, 1);\nmap.set(&#39;true&#39;, 2);\nmap.get(true) // 1\n\nmap.set(undefined, 3);\nmap.set(null, 4);\nmap.get(undefined) // 3\n\nmap.set(NaN, 123);\nmap.get(NaN) // 123\n</code></pre>\n<hr>\n<p><strong>实例的属性和操作方法</strong></p>\n<p>Map 结构的实例有以下属性和操作方法。</p>\n<p><strong>（1）size 属性</strong></p>\n<p><code>size</code>属性返回 Map 结构的成员总数。</p>\n<pre><code class=\"javascript\">const map = new Map();\nmap.set(&#39;foo&#39;, true);\nmap.set(&#39;bar&#39;, false);\n\nmap.size // 2\n</code></pre>\n<p><strong>（2）Map.prototype.set(key, value)</strong></p>\n<p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p>\n<pre><code class=\"javascript\">const m = new Map();\n\nm.set(&#39;edition&#39;, 6)        // 键是字符串\nm.set(262, &#39;standard&#39;)     // 键是数值\nm.set(undefined, &#39;nah&#39;)    // 键是 undefined\n</code></pre>\n<p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p>\n<pre><code class=\"javascript\">let map = new Map()\n  .set(1, &#39;a&#39;)\n  .set(2, &#39;b&#39;)\n  .set(3, &#39;c&#39;);\n</code></pre>\n<p><strong>（3）Map.prototype.get(key)</strong></p>\n<p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>\n<pre><code class=\"javascript\">const m = new Map();\n\nconst hello = function() &#123;console.log(&#39;hello&#39;);&#125;;\nm.set(hello, &#39;Hello ES6!&#39;) // 键是函数\n\nm.get(hello)  // Hello ES6!\n</code></pre>\n<p><strong>（4）Map.prototype.has(key)</strong></p>\n<p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>\n<pre><code class=\"javascript\">const m = new Map();\n\nm.set(&#39;edition&#39;, 6);\nm.set(262, &#39;standard&#39;);\nm.set(undefined, &#39;nah&#39;);\n\nm.has(&#39;edition&#39;)     // true\nm.has(&#39;years&#39;)       // false\nm.has(262)           // true\nm.has(undefined)     // true\n</code></pre>\n<p><strong>（5）Map.prototype.delete(key)</strong></p>\n<p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p>\n<pre><code class=\"javascript\">const m = new Map();\nm.set(undefined, &#39;nah&#39;);\nm.has(undefined)     // true\n\nm.delete(undefined)\nm.has(undefined)       // false\n</code></pre>\n<p><strong>（6）Map.prototype.clear()</strong></p>\n<p><code>clear</code>方法清除所有成员，没有返回值。</p>\n<pre><code class=\"javascript\">let map = new Map();\nmap.set(&#39;foo&#39;, true);\nmap.set(&#39;bar&#39;, false);\n\nmap.size // 2\nmap.clear()\nmap.size // 0\n</code></pre>\n<hr>\n<p><strong>遍历方法</strong></p>\n<p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p>\n<ul>\n<li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li>\n<li><code>Map.prototype.values()</code>：返回键值的遍历器。</li>\n<li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li>\n<li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li>\n</ul>\n<p><strong>需要特别注意的是，Map 的遍历顺序就是插入顺序。</strong></p>\n<pre><code class=\"javascript\">const map = new Map([\n  [&#39;F&#39;, &#39;no&#39;],\n  [&#39;T&#39;,  &#39;yes&#39;],\n]);\n\nfor (let key of map.keys()) &#123;\n  console.log(key);\n&#125;\n// &quot;F&quot;\n// &quot;T&quot;\n\nfor (let value of map.values()) &#123;\n  console.log(value);\n&#125;\n// &quot;no&quot;\n// &quot;yes&quot;\n\nfor (let item of map.entries()) &#123;\n  console.log(item[0], item[1]);\n&#125;\n// &quot;F&quot; &quot;no&quot;\n// &quot;T&quot; &quot;yes&quot;\n\n// 或者\nfor (let [key, value] of map.entries()) &#123;\n  console.log(key, value);\n&#125;\n// &quot;F&quot; &quot;no&quot;\n// &quot;T&quot; &quot;yes&quot;\n\n// 等同于使用map.entries()\nfor (let [key, value] of map) &#123;\n  console.log(key, value);\n&#125;\n// &quot;F&quot; &quot;no&quot;\n// &quot;T&quot; &quot;yes&quot;\n</code></pre>\n<p>上面代码最后的那个例子，<strong>表示 Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</strong></p>\n<pre><code class=\"javascript\">map[Symbol.iterator] === map.entries\n// true\n</code></pre>\n<p><strong>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</strong></p>\n<pre><code class=\"javascript\">const map = new Map([\n  [1, &#39;one&#39;],\n  [2, &#39;two&#39;],\n  [3, &#39;three&#39;],\n]);\n\n[...map.keys()]\n// [1, 2, 3]\n\n[...map.values()]\n// [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]\n\n[...map.entries()]\n// [[1,&#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;]]\n\n[...map]\n// [[1,&#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;]]\n</code></pre>\n<p><strong>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 Map 的遍历和过滤（Map 本身没有<code>map</code>和<code>filter</code>方法）。</strong></p>\n<pre><code class=\"javascript\">const map0 = new Map()\n  .set(1, &#39;a&#39;)\n  .set(2, &#39;b&#39;)\n  .set(3, &#39;c&#39;);\n\nconst map1 = new Map(\n  [...map0].filter(([k, v]) =&gt; k &lt; 3)\n);\n// 产生 Map 结构 &#123;1 =&gt; &#39;a&#39;, 2 =&gt; &#39;b&#39;&#125;\n\nconst map2 = new Map(\n  [...map0].map(([k, v]) =&gt; [k * 2, &#39;_&#39; + v])\n    );\n// 产生 Map 结构 &#123;2 =&gt; &#39;_a&#39;, 4 =&gt; &#39;_b&#39;, 6 =&gt; &#39;_c&#39;&#125;\n</code></pre>\n<p>此外，Map 还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p>\n<pre><code class=\"javascript\">map.forEach(function(value, key, map) &#123;\n  console.log(&quot;Key: %s, Value: %s&quot;, key, value);\n&#125;);\n</code></pre>\n<p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p>\n<pre><code class=\"javascript\">const reporter = &#123;\n  report: function(key, value) &#123;\n    console.log(&quot;Key: %s, Value: %s&quot;, key, value);\n  &#125;\n&#125;;\n\nmap.forEach(function(value, key, map) &#123;\n  this.report(key, value);\n&#125;, reporter);\n</code></pre>\n<p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p>\n<hr>\n<p><strong>与其他数据结构的互相转换</strong></p>\n<p><strong>（1）Map 转为数组</strong></p>\n<p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）。</p>\n<pre><code class=\"javascript\">const myMap = new Map()\n  .set(true, 7)\n  .set(&#123;foo: 3&#125;, [&#39;abc&#39;]);\n[...myMap]\n// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#39;abc&#39; ] ] ]\n</code></pre>\n<p><strong>（2）数组 转为 Map</strong></p>\n<p>将数组传入 Map 构造函数，就可以转为 Map。</p>\n<pre><code class=\"javascript\">new Map([\n  [true, 7],\n  [&#123;foo: 3&#125;, [&#39;abc&#39;]]\n])\n// Map &#123;\n//   true =&gt; 7,\n//   Object &#123;foo: 3&#125; =&gt; [&#39;abc&#39;]\n// &#125;\n</code></pre>\n<p><strong>（3）Map 转为对象</strong></p>\n<p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p>\n<pre><code class=\"javascript\">function strMapToObj(strMap) &#123;\n  let obj = Object.create(null);\n  for (let [k,v] of strMap) &#123;\n    obj[k] = v;\n  &#125;\n  return obj;\n&#125;\n\nconst myMap = new Map()\n  .set(&#39;yes&#39;, true)\n  .set(&#39;no&#39;, false);\nstrMapToObj(myMap)\n// &#123; yes: true, no: false &#125;\n</code></pre>\n<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>\n<p><strong>（4）对象转为 Map</strong></p>\n<p>对象转为 Map 可以通过<code>Object.entries()</code>。</p>\n<pre><code class=\"javascript\">let obj = &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;\nlet map = new Map(Object.entries(obj));\n</code></pre>\n<p>此外，也可以自己实现一个转换函数。</p>\n<pre><code class=\"javascript\">function objToStrMap(obj) &#123;\n  let strMap = new Map();\n  for (let k of Object.keys(obj)) &#123;\n    strMap.set(k, obj[k]);\n  &#125;\n  return strMap;\n&#125;\n\nobjToStrMap(&#123;yes: true, no: false&#125;)\n// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;\n</code></pre>\n<p><strong>（5）Map 转为 JSON</strong></p>\n<p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p>\n<pre><code class=\"javascript\">function strMapToJson(strMap) &#123;\n  return JSON.stringify(strMapToObj(strMap));\n&#125;\n\nlet myMap = new Map().set(&#39;yes&#39;, true).set(&#39;no&#39;, false);\nstrMapToJson(myMap)\n// &#39;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#39;\n</code></pre>\n<p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p>\n<pre><code class=\"javascript\">function mapToArrayJson(map) &#123;\n  return JSON.stringify([...map]);\n&#125;\n\nlet myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&#39;abc&#39;]);\nmapToArrayJson(myMap)\n// &#39;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#39;\n</code></pre>\n<p><strong>（6）JSON 转为 Map</strong></p>\n<p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p>\n<pre><code class=\"javascript\">function jsonToStrMap(jsonStr) &#123;\n  return objToStrMap(JSON.parse(jsonStr));\n&#125;\n\njsonToStrMap(&#39;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#39;)\n// Map &#123;&#39;yes&#39; =&gt; true, &#39;no&#39; =&gt; false&#125;\n</code></pre>\n<p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p>\n<pre><code class=\"javascript\">function jsonToMap(jsonStr) &#123;\n  return new Map(JSON.parse(jsonStr));\n&#125;\n\njsonToMap(&#39;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#39;)\n// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#39;abc&#39;]&#125;\n</code></pre>\n<hr>\n<h4 id=\"4-WeakMap\"><a href=\"#4-WeakMap\" class=\"headerlink\" title=\"4. WeakMap\"></a>4. WeakMap</h4><p><strong>含义</strong></p>\n<p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p>\n<pre><code class=\"javascript\">// WeakMap 可以使用 set 方法添加成员\nconst wm1 = new WeakMap();\nconst key = &#123;foo: 1&#125;;\nwm1.set(key, 2);\nwm1.get(key) // 2\n\n// WeakMap 也可以接受一个数组，\n// 作为构造函数的参数\nconst k1 = [1, 2, 3];\nconst k2 = [4, 5, 6];\nconst wm2 = new WeakMap([[k1, &#39;foo&#39;], [k2, &#39;bar&#39;]]);\nwm2.get(k2) // &quot;bar&quot;\n</code></pre>\n<p><code>WeakMap</code>与<code>Map</code>的区别有两点。</p>\n<p><strong>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</strong></p>\n<pre><code class=\"javascript\">const map = new WeakMap();\nmap.set(1, 2)\n// TypeError: 1 is not an object!\nmap.set(Symbol(), 2)\n// TypeError: Invalid value used as weak map key\nmap.set(null, 2)\n// TypeError: Invalid value used as weak map key\n</code></pre>\n<p>上面代码中，如果将数值<code>1</code>和<code>Symbol</code>值作为 WeakMap 的键名，都会报错。</p>\n<p><strong>其次，<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</strong></p>\n<p><code>WeakMap</code>的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。</p>\n<pre><code class=\"javascript\">const e1 = document.getElementById(&#39;foo&#39;);\nconst e2 = document.getElementById(&#39;bar&#39;);\nconst arr = [\n  [e1, &#39;foo 元素&#39;],\n  [e2, &#39;bar 元素&#39;],\n];\n</code></pre>\n<p>上面代码中，<code>e1</code>和<code>e2</code>是两个对象，我们通过<code>arr</code>数组对这两个对象添加一些文字说明。这就形成了<code>arr</code>对<code>e1</code>和<code>e2</code>的引用。</p>\n<p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放<code>e1</code>和<code>e2</code>占用的内存。</p>\n<pre><code class=\"javascript\">// 不需要 e1 和 e2 的时候\n// 必须手动删除引用\narr [0] = null;\narr [1] = null;\n</code></pre>\n<p>上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。</p>\n<p>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，<strong>一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</strong></p>\n<p><strong>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</strong></p>\n<pre><code class=\"javascript\">const wm = new WeakMap();\n\nconst element = document.getElementById(&#39;example&#39;);\n\nwm.set(element, &#39;some information&#39;);\nwm.get(element) // &quot;some information&quot;\n</code></pre>\n<p>上面代码中，先新建一个 WeakMap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p>\n<p>也就是说，上面的 DOM 节点对象除了 WeakMap 的弱引用外，其他位置对该对象的引用一旦消除，该对象占用的内存就会被垃圾回收机制释放。WeakMap 保存的这个键值对，也会自动消失。</p>\n<p><strong>总之，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</strong></p>\n<p><strong>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</strong></p>\n<pre><code class=\"javascript\">const wm = new WeakMap();\nlet key = &#123;&#125;;\nlet obj = &#123;foo: 1&#125;;\n\nwm.set(key, obj);\nobj = null;\nwm.get(key)\n// Object &#123;foo: 1&#125;\n</code></pre>\n<p>上面代码中，键值<code>obj</code>是正常引用。所以，即使在 WeakMap 外部消除了<code>obj</code>的引用，WeakMap 内部的引用依然存在。</p>\n<p><strong>WeakMap 的语法</strong></p>\n<p>WeakMap 与 Map 在 API 上的区别主要是两个，<strong>一是没有遍历操作（即没有<code>keys()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性。</strong>因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。<strong>二是无法清空，即不支持<code>clear</code>方法。</strong>因此，**<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。**</p>\n<pre><code class=\"javascript\">const wm = new WeakMap();\n\n// size、forEach、clear 方法都不存在\nwm.size // undefined\nwm.forEach // undefined\nwm.clear // undefined\n</code></pre>\n<p><strong>WeakMap 的示例</strong></p>\n<p>WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。</p>\n<p>贺师俊老师<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3J1YW55Zi9lczZ0dXRvcmlhbC9pc3N1ZXMvMzYyI2lzc3VlY29tbWVudC0yOTIxMDkxMDQ=\">提示</span>，如果引用所指向的值占用特别多的内存，就可以通过 Node 的<code>process.memoryUsage</code>方法看出来。根据这个思路，网友<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3J1YW55Zi9lczZ0dXRvcmlhbC9pc3N1ZXMvMzYyI2lzc3VlY29tbWVudC0yOTI0NTE5MjU=\">vtxf</span>补充了下面的例子。</p>\n<p>首先，打开 Node 命令行。</p>\n<pre><code class=\"bash\">$ node --expose-gc\n</code></pre>\n<p>上面代码中，<code>--expose-gc</code>参数表示允许手动执行垃圾回收机制。</p>\n<p>然后，执行下面的代码。</p>\n<pre><code class=\"javascript\">// 手动执行一次垃圾回收，保证获取的内存使用状态准确\n&gt; global.gc();\nundefined\n\n// 查看内存占用的初始状态，heapUsed 为 4M 左右\n&gt; process.memoryUsage();\n&#123; rss: 21106688,\n  heapTotal: 7376896,\n  heapUsed: 4153936,\n  external: 9059 &#125;\n\n&gt; let wm = new WeakMap();\nundefined\n\n// 新建一个变量 key，指向一个 5*1024*1024 的数组\n&gt; let key = new Array(5 * 1024 * 1024);\nundefined\n\n// 设置 WeakMap 实例的键名，也指向 key 数组\n// 这时，key 数组实际被引用了两次，\n// 变量 key 引用一次，WeakMap 的键名引用了第二次\n// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1\n&gt; wm.set(key, 1);\nWeakMap &#123;&#125;\n\n&gt; global.gc();\nundefined\n\n// 这时内存占用 heapUsed 增加到 45M 了\n&gt; process.memoryUsage();\n&#123; rss: 67538944,\n  heapTotal: 7376896,\n  heapUsed: 45782816,\n  external: 8945 &#125;\n\n// 清除变量 key 对数组的引用，\n// 但没有手动清除 WeakMap 实例的键名对数组的引用\n&gt; key = null;\nnull\n\n// 再次执行垃圾回收\n&gt; global.gc();\nundefined\n\n// 内存占用 heapUsed 变回 4M 左右，\n// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收\n&gt; process.memoryUsage();\n&#123; rss: 20639744,\n  heapTotal: 8425472,\n  heapUsed: 3979792,\n  external: 8956 &#125;\n</code></pre>\n<p>上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。</p>\n<p>Chrome 浏览器的 Dev Tools 的 Memory 面板，有一个垃圾桶的按钮，可以强制垃圾回收（garbage collect）。这个按钮也能用来观察 WeakMap 里面的引用是否消失。</p>\n<p><strong>WeakMap 的用途</strong></p>\n<p>前文说过，<strong>WeakMap 应用的典型场合就是 DOM 节点作为键名</strong>。下面是一个例子。</p>\n<pre><code class=\"javascript\">let myWeakmap = new WeakMap();\n\nmyWeakmap.set(\n  document.getElementById(&#39;logo&#39;),\n  &#123;timesClicked: 0&#125;)\n;\n\ndocument.getElementById(&#39;logo&#39;).addEventListener(&#39;click&#39;, function() &#123;\n  let logoData = myWeakmap.get(document.getElementById(&#39;logo&#39;));\n  logoData.timesClicked++;\n&#125;, false);\n</code></pre>\n<p>上面代码中，<code>document.getElementById(&#39;logo&#39;)</code>是一个 DOM 节点，每当发生<code>click</code>事件，就更新一下状态。<strong>我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险</strong>。</p>\n<p><strong>WeakMap 的另一个用处是部署私有属性。</strong></p>\n<pre><code class=\"javascript\">const _counter = new WeakMap();\nconst _action = new WeakMap();\n\nclass Countdown &#123;\n  constructor(counter, action) &#123;\n    _counter.set(this, counter);\n    _action.set(this, action);\n  &#125;\n  dec() &#123;\n    let counter = _counter.get(this);\n    if (counter &lt; 1) return;\n    counter--;\n    _counter.set(this, counter);\n    if (counter === 0) &#123;\n      _action.get(this)();\n    &#125;\n  &#125;\n&#125;\n\nconst c = new Countdown(2, () =&gt; console.log(&#39;DONE&#39;));\n\nc.dec()\nc.dec()\n// DONE\n</code></pre>\n<p>上面代码中，<code>Countdown</code>类的两个内部属性<code>_counter</code>和<code>_action</code>，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>\n<hr>\n<h4 id=\"5-WeakRef\"><a href=\"#5-WeakRef\" class=\"headerlink\" title=\"5. WeakRef\"></a>5. WeakRef</h4><p>WeakSet 和 WeakMap 是基于弱引用的数据结构，**<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtd2Vha3JlZnM=\">ES2021</span> 更进一步，提供了 WeakRef 对象，用于直接创建对象的弱引用。**</p>\n<pre><code class=\"javascript\">let target = &#123;&#125;;\nlet wr = new WeakRef(target);\n</code></pre>\n<p>上面示例中，<code>target</code>是原始对象，构造函数<code>WeakRef()</code>创建了一个基于<code>target</code>的新对象<code>wr</code>。这里，<code>wr</code>就是一个 WeakRef 的实例，属于对<code>target</code>的弱引用，垃圾回收机制不会计入这个引用，也就是说，<code>wr</code>的引用不会妨碍原始对象<code>target</code>被垃圾回收机制清除。</p>\n<p><strong>WeakRef 实例对象有一个<code>deref()</code>方法，如果原始对象存在，该方法返回原始对象；如果原始对象已经被垃圾回收机制清除，该方法返回<code>undefined</code>。</strong></p>\n<pre><code class=\"javascript\">let target = &#123;&#125;;\nlet wr = new WeakRef(target);\n\nlet obj = wr.deref();\nif (obj) &#123; // target 未被垃圾回收机制清除\n  // ...\n&#125;\n</code></pre>\n<p>上面示例中，<code>deref()</code>方法可以判断原始对象是否已被清除。</p>\n<p>弱引用对象的一大用处，就是作为缓存，未被清除时可以从缓存取值，一旦清除缓存就自动失效。</p>\n<pre><code class=\"javascript\">function makeWeakCached(f) &#123;\n  const cache = new Map();\n  return key =&gt; &#123;\n    const ref = cache.get(key);\n    if (ref) &#123;\n      const cached = ref.deref();\n      if (cached !== undefined) return cached;\n    &#125;\n\n    const fresh = f(key);\n    cache.set(key, new WeakRef(fresh));\n    return fresh;\n  &#125;;\n&#125;\n\nconst getImageCached = makeWeakCached(getImage);\n</code></pre>\n<p>上面示例中，<code>makeWeakCached()</code>用于建立一个缓存，缓存里面保存对原始文件的弱引用。</p>\n<p>注意，标准规定，一旦使用<code>WeakRef()</code>创建了原始对象的弱引用，那么在本轮事件循环（event loop），原始对象肯定不会被清除，只会在后面的事件循环才会被清除。</p>\n<hr>\n<h4 id=\"6-FinalizationRegistry\"><a href=\"#6-FinalizationRegistry\" class=\"headerlink\" title=\"6. FinalizationRegistry\"></a>6. FinalizationRegistry</h4><p><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtd2Vha3JlZnMjZmluYWxpemVycw==\">ES2021</span> 引入了清理器注册表功能 FinalizationRegistry，用来指定目标对象被垃圾回收机制清除以后，所要执行的回调函数。</strong></p>\n<p>首先，新建一个注册表实例。</p>\n<pre><code class=\"javascript\">const registry = new FinalizationRegistry(heldValue =&gt; &#123;\n  // ....\n&#125;);\n</code></pre>\n<p>上面代码中，<code>FinalizationRegistry()</code>是系统提供的构造函数，返回一个清理器注册表实例，里面登记了所要执行的回调函数。回调函数作为<code>FinalizationRegistry()</code>的参数传入，它本身有一个参数<code>heldValue</code>。</p>\n<p>然后，注册表实例的<code>register()</code>方法，用来注册所要观察的目标对象。</p>\n<pre><code class=\"javascript\">registry.register(theObject, &quot;some value&quot;);\n</code></pre>\n<p>上面示例中，<code>theObject</code>就是所要观察的目标对象，一旦该对象被垃圾回收机制清除，注册表就会在清除完成后，调用早前注册的回调函数，并将<code>some value</code>作为参数（前面的<code>heldValue</code>）传入回调函数。</p>\n<p>注意，注册表不对目标对象<code>theObject</code>构成强引用，属于弱引用。因为强引用的话，原始对象就不会被垃圾回收机制清除，这就失去使用注册表的意义了。</p>\n<p>回调函数的参数<code>heldValue</code>可以是任意类型的值，字符串、数值、布尔值、对象，甚至可以是<code>undefined</code>。</p>\n<p><strong>最后，如果以后还想取消已经注册的回调函数，则要向<code>register()</code>传入第三个参数，作为标记值。这个标记值必须是对象，一般都用原始对象。接着，再使用注册表实例对象的<code>unregister()</code>方法取消注册。</strong></p>\n<pre><code class=\"javascript\">registry.register(theObject, &quot;some value&quot;, theObject);\n// ...其他操作...\nregistry.unregister(theObject);\n</code></pre>\n<p>上面代码中，<code>register()</code>方法的第三个参数就是标记值<code>theObject</code>。取消回调函数时，要使用<code>unregister()</code>方法，并将标记值作为该方法的参数。这里<code>register()</code>方法对第三个参数的引用，也属于弱引用。如果没有这个参数，则回调函数无法取消。</p>\n<p>由于回调函数被调用以后，就不再存在于注册表之中了，所以执行<code>unregister()</code>应该是在回调函数还没被调用之前。</p>\n<p>下面使用<code>FinalizationRegistry</code>，对前一节的缓存函数进行增强。</p>\n<pre><code class=\"javascript\">function makeWeakCached(f) &#123;\n  const cache = new Map();\n  const cleanup = new FinalizationRegistry(key =&gt; &#123;\n    const ref = cache.get(key);\n    if (ref &amp;&amp; !ref.deref()) cache.delete(key);\n  &#125;);\n\n  return key =&gt; &#123;\n    const ref = cache.get(key);\n    if (ref) &#123;\n      const cached = ref.deref();\n      if (cached !== undefined) return cached;\n    &#125;\n\n    const fresh = f(key);\n    cache.set(key, new WeakRef(fresh));\n    cleanup.register(fresh, key);\n    return fresh;\n  &#125;;\n&#125;\n\nconst getImageCached = makeWeakCached(getImage);\n</code></pre>\n<p>上面示例与前一节的例子相比，就是增加一个清理器注册表，一旦缓存的原始对象被垃圾回收机制清除，会自动执行一个回调函数。该回调函数会清除缓存里面已经失效的键。</p>\n<p>下面是另一个例子。</p>\n<pre><code class=\"javascript\">class Thingy &#123;\n  #file;\n  #cleanup = file =&gt; &#123;\n    console.error(\n      `The \\`release\\` method was never called for the \\`Thingy\\` for the file &quot;$&#123;file.name&#125;&quot;`\n    );\n  &#125;;\n  #registry = new FinalizationRegistry(this.#cleanup);\n\n  constructor(filename) &#123;\n    this.#file = File.open(filename);\n    this.#registry.register(this, this.#file, this.#file);\n  &#125;\n\n  release() &#123;\n    if (this.#file) &#123;\n      this.#registry.unregister(this.#file);\n      File.close(this.#file);\n      this.#file = null;\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p>上面示例中，如果由于某种原因，<code>Thingy</code>类的实例对象没有调用<code>release()</code>方法，就被垃圾回收机制清除了，那么清理器就会调用回调函数<code>#cleanup()</code>，输出一条错误信息。</p>\n<p><strong>由于无法知道清理器何时会执行，所以最好避免使用它</strong>。另外，如果浏览器窗口关闭或者进程意外退出，清理器则不会运行。</p>\n",
            "tags": [
                "前端",
                "ES6",
                "前端"
            ]
        },
        {
            "id": "https://1234cas.github.io/1234cas.github.io/qianduan/TCP%E5%8D%8F%E8%AE%AE/",
            "url": "https://1234cas.github.io/1234cas.github.io/qianduan/TCP%E5%8D%8F%E8%AE%AE/",
            "title": "TCP协议",
            "date_published": "2021-11-27T02:18:44.936Z",
            "content_html": "<p><img data-src=\"/images/TCP%E5%8D%8F%E8%AE%AE.assets/cc9bc77b97b06659f29baec794f80ef2.png\" alt=\"cc9bc77b97b06659f29baec794f80ef2\"></p>\n<h3 id=\"01-TCP-和-UDP-的区别？\"><a href=\"#01-TCP-和-UDP-的区别？\" class=\"headerlink\" title=\"01.TCP 和 UDP 的区别？\"></a>01.TCP 和 UDP 的区别？</h3><p><strong>TCP 是一个面向连接的，可靠的，基于字节流的传输层协议</strong></p>\n<p><strong>UDP 是一个面向无连接的传输层协议</strong></p>\n<p>和 UDP 相比，TCP 有三大核心特征：</p>\n<p>1.<strong>面向连接</strong>。在客户端和服务端互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程</p>\n<p>2.<strong>可靠性</strong>。可靠性体现在两方面，一是<strong>有状态</strong>，二是<strong>可控制</strong></p>\n<p>TCP 会精确记录哪些数据发送了，哪些数据被对面接收了，哪些数据未被对面接收，并且保证数据包按序到达。这是<strong>有状态</strong></p>\n<p>当意识到丢包或者网络环境不佳时，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是<strong>可控制</strong></p>\n<p>3.<strong>基于字节流</strong>。UDP 的数据传输是基于数据报的，这是因为仅仅只继承了 IP 层的特性，而 TCP 为了维护状态，把一个一个 IP 变成了字节流</p>\n<hr>\n<h3 id=\"02-TCP-三次握手的过程。为什么不是两次？不是四次\"><a href=\"#02-TCP-三次握手的过程。为什么不是两次？不是四次\" class=\"headerlink\" title=\"02.TCP 三次握手的过程。为什么不是两次？不是四次\"></a>02.TCP 三次握手的过程。为什么不是两次？不是四次</h3><p>TCP 的三次握手是为了确认双方的发送和接收能力</p>\n<h4 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h4><p><img data-src=\"/images/TCP%E5%8D%8F%E8%AE%AE.assets/d666610353017ffe36cf8eb3e2c24939.png\" alt=\"d666610353017ffe36cf8eb3e2c24939\"></p>\n<p>从最开始双方都处于<code>CLOSED</code>状态，然后服务端开始监听某个端口，进入了<code>LISTEN</code>状态</p>\n<p>然后客户端主动发起连接，发送<code>SYN</code>，自己变成了<code>SYN-SEND</code>状态</p>\n<p>服务端接收到，并返回<code>SYN</code>和<code>ACK</code>，自己变成了<code>SYN-RCVD</code>状态</p>\n<p>之后客户端再发送<code>ACK</code>给服务端，自己变成了<code>ESTABLISHED</code>状态；服务端收到<code>ACK</code>之后，也变成了<code>ESTABLISHED</code>状态</p>\n<p>SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加 1</p>\n<blockquote>\n<p>凡是需要对端确认的，一定会消耗 TCP 报文的序列号</p>\n</blockquote>\n<p>SYN 需要对端确认，而 ACK 不需要，因此 SYN 消耗一个序列号而 ACK 不需要</p>\n<h4 id=\"为什么不是两次？\"><a href=\"#为什么不是两次？\" class=\"headerlink\" title=\"为什么不是两次？\"></a>为什么不是两次？</h4><p>根本原因：无法确认客户端的接收能力</p>\n<p>如果是两次，客户端发送了 SYN 报文想握手，但是这个包<strong>滞留</strong>在了网络中，TCP 以为是丢包，于是重传，然后两次握手就建立了连接。</p>\n<p>看似没有问题，但是连接关闭后，如果这个<strong>滞留</strong>在网络中的包到达了服务端，由于是两次握手，服务端接收到<strong>滞留</strong>的包同时发送相应的数据包就建立了连接，可是这时客户端是不会响应的，但是服务端会一直等待客户端发送数据，导致了服务端连接资源的浪费</p>\n<h4 id=\"为什么不是四次？\"><a href=\"#为什么不是四次？\" class=\"headerlink\" title=\"为什么不是四次？\"></a>为什么不是四次？</h4><p>TCP 的三次握手是为了确认双方的发送和接收能力，四次自然也是可以，但是三次就足够了</p>\n<h4 id=\"三次握手过程中可以携带数据么？\"><a href=\"#三次握手过程中可以携带数据么？\" class=\"headerlink\" title=\"三次握手过程中可以携带数据么？\"></a>三次握手过程中可以携带数据么？</h4><p>第三次握手时可以携带，前两次握手不能携带数据</p>\n<p>如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放入大量的数据，那么服务器就势必会消耗更多的时间和内存空间去处理这些数据，增加了服务器被攻击的风险</p>\n<p>第三次握手的时候，客户端已经处于<code>ESTABLISHED</code>状态，并且已经确认了服务器的接收发送能力，这时相对安全，可以携带数据</p>\n<h4 id=\"同时发起握手会怎样\"><a href=\"#同时发起握手会怎样\" class=\"headerlink\" title=\"同时发起握手会怎样\"></a>同时发起握手会怎样</h4><p><img data-src=\"/images/TCP%E5%8D%8F%E8%AE%AE.assets/57f1cc50167613e9ce02641095b56dbe.png\" alt=\"57f1cc50167613e9ce02641095b56dbe\"></p>\n<p>客户端和服务端同时给对面发送<code>SYN</code>，发完两者的状态皆变为<code>SYN-SENT</code></p>\n<p>在各自收到对方的<code>SYN</code>之后，两者的状态都变成<code>SYN-RCVD</code></p>\n<p>接着会回复对应的<code>SYN+ACK</code>，这个报文在对方接收之后会一起变成<code>ESTABLISHED</code></p>\n<hr>\n<h3 id=\"03-四次挥手的过程\"><a href=\"#03-四次挥手的过程\" class=\"headerlink\" title=\"03.四次挥手的过程\"></a>03.四次挥手的过程</h3><h4 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h4><p><img data-src=\"/images/TCP%E5%8D%8F%E8%AE%AE.assets/982a7c427e18571f51b529e70c2a961b.png\" alt=\"982a7c427e18571f51b529e70c2a961b\"></p>\n<p>刚开始双方都处于<code>ESTABLISHED</code></p>\n<p>客户端要断开，向服务端发送<code>FIN</code>报文，然后客户端变成了<code>FIN-WAIT-1</code>状态，注意，客户端同时也变成<code>half-close(半关闭)</code>状态，即无法向服务端发送报文，只能接收</p>\n<p>服务端接收后向客户端发送<code>ACK</code>确认，变成了<code>CLOSE-WAIT</code>状态</p>\n<p>客户端接收到了客户端的确认，变成了<code>FIN-WAIT2</code>状态</p>\n<p>随后服务端向客户端发送<code>FIN</code>，自己进入<code>LAST-ACK</code>状态</p>\n<p>客户端收到服务端的<code>FIN</code>后，自己变成<code>TIME-WAIT</code>状态，然后向服务端发送<code>ACK</code></p>\n<p>此时客户端需要等待足够长的时间，具体来说，还是 2 个<code>MSL(Maximum Segment Lifetime,报文最大生存时间)</code>，在这段时间如果客户端没有收到服务端的重发请求，那么就表示<code>ACK</code>成功送达，挥手介绍，否则客户端重发<code>ACK</code></p>\n<h4 id=\"等待-2MSL-的意义\"><a href=\"#等待-2MSL-的意义\" class=\"headerlink\" title=\"等待 2MSL 的意义\"></a>等待 2MSL 的意义</h4><p>如果不等待会怎样？</p>\n<p>如果不等待，客户端直接断开连接，当服务端还有很多数据包要发给客户端，且还在路上的时候，若客户端的端口此时刚好被新的应用，那么就接收到了无用数据包，导致数据包混乱，所以，最保险的做法是等服务端发完的数据包再启动新的应用</p>\n<ul>\n<li>1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文能最终送达对端</li>\n<li>1 个 MSL 确保对端没有收到 ACK 而重传的 FIN 报文可以到达</li>\n</ul>\n<h4 id=\"为什么是四次挥手而不是三次？\"><a href=\"#为什么是四次挥手而不是三次？\" class=\"headerlink\" title=\"为什么是四次挥手而不是三次？\"></a>为什么是四次挥手而不是三次？</h4><p>因为服务端在收到<code>FIN</code>时，往往不会立即反回<code>FIN</code>，必须等服务端此前所有的报文都发送完毕了，才能发<code>FIN</code>。因此先发一个<code>ACK</code>表示已经收到客户端的<code>FIN</code>，延长一段再发<code>FIN</code>。</p>\n<p>如果是三次挥手会有什么问题？</p>\n<p>等于说服务端把<code>ACK</code>和<code>FIN</code>的发送合并为一次挥手，这会造成长时间的延迟，导致客户端误以为<code>FIN</code>没有到达服务端，从而不断重发<code>FIN</code></p>\n<h4 id=\"同时关闭会怎样？\"><a href=\"#同时关闭会怎样？\" class=\"headerlink\" title=\"同时关闭会怎样？\"></a>同时关闭会怎样？</h4><p><img data-src=\"/images/TCP%E5%8D%8F%E8%AE%AE.assets/19ebe3ed769f299bd212544892b97a0f.png\" alt=\"19ebe3ed769f299bd212544892b97a0f\"></p>\n<hr>\n<h3 id=\"04-半连接队列和-SYN-Flood-攻击的关系\"><a href=\"#04-半连接队列和-SYN-Flood-攻击的关系\" class=\"headerlink\" title=\"04.半连接队列和 SYN Flood 攻击的关系\"></a>04.半连接队列和 SYN Flood 攻击的关系</h3><p>三次握手前，服务端的状态从<code>CLOSED</code>变成<code>LISTEN</code>，同时在内部创建了两个队列：<strong>半连接队列</strong>和<strong>全连接队列</strong>，即<code>SYN</code>队列和<code>ACCEPT</code>队列</p>\n<h4 id=\"半连接队列\"><a href=\"#半连接队列\" class=\"headerlink\" title=\"半连接队列\"></a>半连接队列</h4><p>当客户端发送<code>SYN</code>到服务端，服务端收到后回复<code>ACK</code>和<code>SYN</code>，状态由<code>LISTEN</code>变为<code>SYN-RCVD</code>，此时这个连接就会被推入<strong>SYN 队列</strong>，也就是<strong>半连接队列</strong></p>\n<h4 id=\"全连接队列\"><a href=\"#全连接队列\" class=\"headerlink\" title=\"全连接队列\"></a>全连接队列</h4><p>当客户端返回<code>ACK</code>，服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走前，它会被推入另一个 TCP 维护的队列，也就是<strong>全连接队列(Accept Queue)</strong></p>\n<h4 id=\"SYN-Flood-攻击原理\"><a href=\"#SYN-Flood-攻击原理\" class=\"headerlink\" title=\"SYN Flood 攻击原理\"></a>SYN Flood 攻击原理</h4><p>SYN Flood 属于典型的 DoS/DDoS 攻击。其攻击原理就是用客户端再短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送<code>SYN</code>。对于服务端而言，会产生两个威胁的后果：</p>\n<ol>\n<li>处理大量的<code>SYN</code>包并返回对应的<code>ACK</code>，势必有大量的连接处于<code>SYN-RCVD</code>状态，从而占满整个<strong>半连接队列</strong>，无法处理正常的请求</li>\n<li>由于是不存在的 IP，服务端长时间收不到客户端的<code>ACK</code>，会导致服务端不断重发数据，直到耗尽服务端的资源</li>\n</ol>\n<h4 id=\"如何应对-SYN-Flood-攻击？\"><a href=\"#如何应对-SYN-Flood-攻击？\" class=\"headerlink\" title=\"如何应对 SYN Flood 攻击？\"></a>如何应对 SYN Flood 攻击？</h4><ol>\n<li>增加 SYN 连接，也就是增加半连接队列的容量</li>\n<li>减少 SYN+ACK 重试次数，避免大量的超时重发</li>\n<li>利用 SYN Cookie 技术，在服务端收到<code>SYN</code>后不立即分配连接资源，而是根据这个<code>SYN</code>计算出一个<code>Cookie</code>，连同第二次握手一起回复给客户端，在客户端回复<code>ACK</code>的时候带上这个<code>Cookie</code>值，服务端验证<code>Cookie</code>的合法性之后才会分配资源</li>\n</ol>\n<hr>\n<h3 id=\"05-TCP-报文的头部字段\"><a href=\"#05-TCP-报文的头部字段\" class=\"headerlink\" title=\"05.TCP 报文的头部字段\"></a>05.TCP 报文的头部字段</h3><p>报文头部结构如下(单位为字节)：</p>\n<p><img data-src=\"/images/TCP%E5%8D%8F%E8%AE%AE.assets/9309f3c439fac129c56b298d7ab7f992.png\" alt=\"9309f3c439fac129c56b298d7ab7f992\"></p>\n<h4 id=\"源端口、目标端口\"><a href=\"#源端口、目标端口\" class=\"headerlink\" title=\"源端口、目标端口\"></a>源端口、目标端口</h4><p>如果标识唯一的一个连接？答案是 TCP 连接的<code>四元组</code>——源 IP、源端口、目标 IP、目标端口</p>\n<p>那 TCP 报文为什么没有源 IP 和目标 IP 呢？这是因为在 IP 层就已经处理了 IP。TCP 只需要记录两者的端口即可</p>\n<h4 id=\"序列号\"><a href=\"#序列号\" class=\"headerlink\" title=\"序列号\"></a>序列号</h4><p>即<code>Sequence number</code>，指的是本报文第一个字节的序列号</p>\n<p>从图中可以看出，序列号是一个长为 4 个字节，也就是 32 位的无符号整数，表示范围为 0 ~ 2^32 - 1。如果到达最大值了后就循环到 0</p>\n<p>序列号在 TCP 通信的过程中有两个作用：</p>\n<ol>\n<li>在 SYN 报文中交换彼此的初始序列号</li>\n<li>保证数据包按正确的顺序组装</li>\n</ol>\n<h4 id=\"ISN-初始序列号\"><a href=\"#ISN-初始序列号\" class=\"headerlink\" title=\"ISN(初始序列号)\"></a>ISN(初始序列号)</h4><p>即<code>Initial Sequence Number(初始序列号)</code>，在三次握手的过程当中，双方会用<code>SYN</code>报文来交换彼此的<code>ISN</code></p>\n<p><code>ISN</code>并不是一个固定的值，而是每 4ms 加一，溢出则回到 0，这个算法使得猜测<code>ISN</code>变得很困难。为什么这么做呢？</p>\n<p>如果<code>ISN</code>被攻击者预测到，要知道 IP 和源端口号都是很容易伪造的，当攻击者猜测到<code>ISN</code>之后，直接伪造一个<code>RST</code>后，就可以强制关闭连接，这是非常危险的</p>\n<p>而动态增长的<code>ISN</code>大大提高了猜测<code>ISN</code>的难度</p>\n<h4 id=\"确认号\"><a href=\"#确认号\" class=\"headerlink\" title=\"确认号\"></a>确认号</h4><p>即<code>ACK(Acknowlegment number)</code>。用于告诉对方下一个期望接收的序列号，小于<strong>ACK</strong>的所有字节都已经收到</p>\n<h4 id=\"标记号\"><a href=\"#标记号\" class=\"headerlink\" title=\"标记号\"></a>标记号</h4><p>常见的标记有<code>SYN</code>,<code>ACK</code>,<code>FIN</code>,<code>RST</code>,<code>PSH</code></p>\n<p><code>SYN</code>和<code>ACK</code>已经在上文中说过，后三个解释如下:</p>\n<p><code>FIN</code>： 即 Finish，表示发送方准备断开连接。</p>\n<p><code>RST</code>：即 Reset，用来强制断开连接。</p>\n<p><code>PSH</code>： 即 Push，告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。</p>\n<h4 id=\"窗口大小\"><a href=\"#窗口大小\" class=\"headerlink\" title=\"窗口大小\"></a>窗口大小</h4><p>占用两个字节，也就是 16 位，但实际上是不够用的。因此 TCP 引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0~14，比例因子可以将窗口的值扩大为原来的 2^n 次方</p>\n<h4 id=\"校验和\"><a href=\"#校验和\" class=\"headerlink\" title=\"校验和\"></a>校验和</h4><p>占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃，等待重传</p>\n<h4 id=\"可选项\"><a href=\"#可选项\" class=\"headerlink\" title=\"可选项\"></a>可选项</h4><p>可选项格式如下</p>\n<p><img data-src=\"/images/TCP%E5%8D%8F%E8%AE%AE.assets/417e77f83b34540a5b170e5b898b08f8.png\" alt=\"417e77f83b34540a5b170e5b898b08f8\"></p>\n<p>常用的可选项有以下几个：</p>\n<ul>\n<li>TimeStamp:TCP 时间戳，后文有详细介绍</li>\n<li>MSS:指的是 TCP 允许对方接收的最大报文段</li>\n<li>SACK:选择确认选项</li>\n<li>Window Scale:窗口缩放选项</li>\n</ul>\n<hr>\n<h3 id=\"06-TCP-快速打开的原理-TFO\"><a href=\"#06-TCP-快速打开的原理-TFO\" class=\"headerlink\" title=\"06.TCP 快速打开的原理(TFO)\"></a>06.TCP 快速打开的原理(TFO)</h3><p>优化后的 TCP 握手流程，也就是 TCP 快速打开(TCP Fast Open，即 TFO)</p>\n<p>优化是利用 SYN Cookie 来实现的 TFO</p>\n<h4 id=\"TFO-流程\"><a href=\"#TFO-流程\" class=\"headerlink\" title=\"TFO 流程\"></a>TFO 流程</h4><p><strong>首轮三次握手</strong></p>\n<p>首先客户端发送<code>SYN</code>给服务端，服务端收到</p>\n<p>此时，服务端不是立即返回<code>SYN+ACK</code>，而是通过计算得到一个<code>SYN Cookie</code>，将这个<code>Cookie</code>放到 TCP 报文的<code>Fast Open</code>选项中，然后返回给客户端</p>\n<p>客户端拿到这个<code>Cookie</code>的值并缓存下来。后面正常完成三次握手</p>\n<p><strong>后续的三次握手</strong></p>\n<p>在后续的三次握手中，客户端会将之前缓存的<code>Cookie</code>、<code>SYN</code>和<code>HTTP请求</code>发送给服务端，服务端验证了<code>Cookie</code>的合法性，如果不合法直接丢弃；如果合法，就正常返回<code>SYN+ACK</code></p>\n<p>重点来了，现在服务端就可以向客户端发 HTTP 响应了！这是最显著的改变，三次握手还没有建立，仅仅验证了<code>Cookie</code>的合法性就可以返回 HTTP 响应</p>\n<p>当然，客户端的<code>ACK</code>还得正常传过来，不然怎么叫三次握手</p>\n<p>流程如下：</p>\n<p><img data-src=\"/images/TCP%E5%8D%8F%E8%AE%AE.assets/0ff20d5a9e4295e773c1380a82954afd.png\" alt=\"0ff20d5a9e4295e773c1380a82954afd\"></p>\n<p><strong>注意</strong>：客户端最后握手的<code>ACK</code>不需要等到服务端的 HTTP 响应送达才发送，两者没有任何关系</p>\n<h4 id=\"TFO-的优势\"><a href=\"#TFO-的优势\" class=\"headerlink\" title=\"TFO 的优势\"></a>TFO 的优势</h4><p>TFO 的优势并不在首轮三次握手，而在于后面的握手，在拿到客户端的<code>Cookie</code>并验证通过以后，可以直接返回 HTTP 响应，充分利用了<strong>1 个 RTT</strong>(Round-Trip Time，往返时延)的时间<strong>提前进行数据传输</strong>，积累起来还是一个比较大的优势</p>\n<hr>\n<h3 id=\"07-TCP-报文中的时间戳\"><a href=\"#07-TCP-报文中的时间戳\" class=\"headerlink\" title=\"07.TCP 报文中的时间戳\"></a>07.TCP 报文中的时间戳</h3><p><code>timestamp</code>是 TCP 报文首部的一个可选项，一共占 10 个字节，格式如下：</p>\n<pre><code class=\"HTTP\">kind(1 字节) + length(1 字节) + info(8 个字节)\n</code></pre>\n<p>其中 kind = 8，length = 10，info 有两部分构成：<strong>timestamp</strong>和<strong>timestamp echo</strong>，各占 4 个字节</p>\n<p>TCP 的时间戳主要解决两大问题：</p>\n<ul>\n<li>计算 往返时延 RTT(Round-Trip Time)</li>\n<li>防止序列号的回绕问题</li>\n</ul>\n<h4 id=\"计算-往返时延-RTT\"><a href=\"#计算-往返时延-RTT\" class=\"headerlink\" title=\"计算 往返时延 RTT\"></a>计算 往返时延 RTT</h4><p>在没有时间戳的时候，计算 RTT 会遇到如下图所示的问题</p>\n<p><img data-src=\"/images/TCP%E5%8D%8F%E8%AE%AE.assets/d3d95220996ad83cbafd120a31a84d30.png\" alt=\"d3d95220996ad83cbafd120a31a84d30\"></p>\n<p>如果以第一次发包为开始时间的话，就会出现左图的问题，RTT 明显偏大</p>\n<p>如果以第二次发包为开始时间的话，就会导致右图的问题，RTT 明显偏小</p>\n<p>实际上无论开始时间以第一次发包还是第二次发包为准，都是不准确的</p>\n<p>这个时候引入时间戳就很好的解决了这个问题</p>\n<p>比如现在 a 向 b 发送一个报文 s1，b 向 a 回复一个含<code>ACK</code>的报文 s2，那么：</p>\n<ul>\n<li><p><strong>step1：</strong>a 向 b 发送的时候，<code>timestamp</code>中存放的内容就是 a 主机发送时的内核时刻<code>ta1</code></p>\n</li>\n<li><p><strong>step2：</strong>b 向 a 回复 s2 报文时，<code>timestamp</code>中存放的是 b 主机的时刻<code>tb</code>，<code>timestamp echo</code>字段为从 s1 报文中解析出来的<code>ta1</code></p>\n</li>\n<li><p><strong>step3：</strong>a 收到 b 的 s2 报文之后，此时 a 主机的内核时刻是<code>ta2</code>，而在 s2 报文中的<code>timestamp echo</code>选项可以得到<code>ta1</code>，也就是 s2 对应的报文最初的发送时刻。然后直接用<code>ta2</code>-<code>ta1</code>就得到了 RTT 的值</p>\n</li>\n</ul>\n<h4 id=\"防止序列号的回绕问题\"><a href=\"#防止序列号的回绕问题\" class=\"headerlink\" title=\"防止序列号的回绕问题\"></a>防止序列号的回绕问题</h4><p>现在我们来模拟一下这个问题。</p>\n<p>序列号的范围其实是在 0 ~ 2 ^ 32 - 1, 为了方便演示，我们缩小一下这个区间，假设范围是 0 ~ 4，那么到达 4 的时候会回到 0。</p>\n<table>\n<thead>\n<tr>\n<th>第几次发包</th>\n<th>发送字节</th>\n<th>对应序列号</th>\n<th>状态</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>0 ~ 1</td>\n<td>0 ~ 1</td>\n<td>成功接收</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1 ~ 2</td>\n<td>1 ~ 2</td>\n<td>滞留在网络中</td>\n</tr>\n<tr>\n<td>3</td>\n<td>2 ~ 3</td>\n<td>2 ~ 3</td>\n<td>成功接收</td>\n</tr>\n<tr>\n<td>4</td>\n<td>3 ~ 4</td>\n<td>3 ~ 4</td>\n<td>成功接收</td>\n</tr>\n<tr>\n<td>5</td>\n<td>4 ~ 5</td>\n<td>0 ~ 1</td>\n<td>成功接收，序列号从 0 开始</td>\n</tr>\n<tr>\n<td>6</td>\n<td>5 ~ 6</td>\n<td>1 ~ 2</td>\n<td>？？？</td>\n</tr>\n</tbody></table>\n<p>假设在第 6 次的时候，之前滞留在网络中的包送达了，那么就会有两个序列号为<code>1 ~ 2 </code>的数据包，无法区分，这时候就产生了序列号的回绕问题</p>\n<p>那么用<code>timestamp</code>就能很好的解决这个问题，因为每次发包的时候都会将发包机器当时的内核时间记录在报文中，即使两次发包的序列号相同，时间戳也不可能相同，这样子就可以区分开两个数据包了</p>\n<hr>\n<h3 id=\"08-TCP-的超时重连\"><a href=\"#08-TCP-的超时重连\" class=\"headerlink\" title=\"08.TCP 的超时重连\"></a>08.TCP 的超时重连</h3><p>TCP 具有超时重连的机制，即每个一段时间没有等到数据包的回复时，就重传这个数据包</p>\n<p>这个重传间隔是如何来计算的呢？</p>\n<p>这个重传间隔也叫做<strong>超时重传时间(Retransmission TimeOut，简称为 RTO)<strong>，它的计算跟上一节的</strong>RTT</strong>密切相关。这我们将介绍两种重要的方法，一个是经典方法，一个是标准方法</p>\n<h4 id=\"经典方法\"><a href=\"#经典方法\" class=\"headerlink\" title=\"经典方法\"></a>经典方法</h4><p>经典方法引入了一个新的概念——**SRTT(Smoothed Round Trip Time，即平滑往返时间)**，每产生一次新的 RTT，就会根据一定的算法对 SRTT 进行更新，具体而言，计算方式如下(SRTT 的初始值为 0)</p>\n<pre><code class=\"HTTP\">SRTT =  (α * SRTT) + ((1 - α) * RTT)\n</code></pre>\n<p>其中，α 是<strong>平滑因子</strong>，建议值是<code>0.8</code>，范围是<code>0.8 ~ 0.9</code></p>\n<p>拿到 SRTT，我们就可以计算 RTO 的值了：</p>\n<pre><code class=\"HTTP\">RTO = min(ubound, max(lbound, β * SRTT))\n</code></pre>\n<p>β 是加权因子，一般为<code>1.3 ~ 2.0</code>， <strong>lbound</strong> 是下界，<strong>ubound</strong> 是上界。</p>\n<p>这个算法的过程还算是简单，但是也存在着一定的局限，就是在 RTT 稳定的地方表现还可以，而在 RTT 变化较大的地方就不行了，因为平滑因子 α 的范围是<code>0.8 ~ 0.9</code>，RTT 对于 RTO 的影响太小</p>\n<h4 id=\"标准方法\"><a href=\"#标准方法\" class=\"headerlink\" title=\"标准方法\"></a>标准方法</h4><p>为了解决经典方法对于 RTT 变化不敏感的问题，后面又引出了标准方法，也叫<code>Jacobson / Karels 算法</code></p>\n<p>一共三步</p>\n<p><strong>第一步：</strong>计算<code>SRTT</code>，公式如下：</p>\n<pre><code class=\"HTTP\">SRTT = (1 - α) * SRTT + α * RTT\n</code></pre>\n<p>注意这个时候的<code>α</code>就和经典方法中的<code>α</code>取值不同了，建议值是<code>1/8</code>，也就是<code>0.125</code></p>\n<p><strong>第二步：</strong>计算<code>RTTVAR</code>（Round-Trip Time Variation）这个中间变量</p>\n<pre><code class=\"HTTP\">RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|)\n</code></pre>\n<p>β 的建议值为<code>0.25</code>。这个值是这个算法中出彩的地方，也就是说，它记录了最新的 RTT 与当前 SRTT 之间的差值，给我们在后续感知到 RTT 的变化提供了抓手</p>\n<p><strong>第三步：</strong>计算最终的<code>RTO</code></p>\n<pre><code class=\"HTTP\">RTO = µ * SRTT + ∂ * RTTVAR\n</code></pre>\n<p><code>µ</code>建议值取<code>1</code>，<code>∂</code>建议值取<code>4</code></p>\n<p>这个公式在 SRTT 的基础上加上了最新 RTT 与它的偏移，从而很好的感知了 RTT 的变化，这种算法下，RTO 与 RTT 变化的差值关系更加密切</p>\n<hr>\n<h3 id=\"09-TCP-的流量控制\"><a href=\"#09-TCP-的流量控制\" class=\"headerlink\" title=\"09.TCP 的流量控制\"></a>09.TCP 的流量控制</h3><p>对于发送端和接收端而言，TCP 需要把发送的数据放到<strong>发送缓存区</strong>，将接收的数据放到<strong>接收缓存区</strong></p>\n<p>而流量控制所要做的事情，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能在继续发送了</p>\n<p>要具体理解流量控制，首先需要了解<code>滑动窗口</code>的概念</p>\n<h4 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h4><p>TCP 滑动窗口分为两种：<strong>发送窗口</strong>和<strong>接收窗口</strong></p>\n<h4 id=\"发送窗口\"><a href=\"#发送窗口\" class=\"headerlink\" title=\"发送窗口\"></a>发送窗口</h4><p>发送端的滑动窗口结构如下</p>\n<p><img data-src=\"/images/TCP%E5%8D%8F%E8%AE%AE.assets/4e618cbb8649a1617fc5594f40a23632.png\" alt=\"4e618cbb8649a1617fc5594f40a23632\"></p>\n<p>其中包含四大部分：</p>\n<ul>\n<li>已发送且已接收</li>\n<li>已发送但未确认</li>\n<li>未发送但可发送</li>\n<li>未发送且不可发送</li>\n</ul>\n<p>其中有一些重要的概念，我标注在图中：</p>\n<p><img data-src=\"/images/TCP%E5%8D%8F%E8%AE%AE.assets/364c7d48f0d1e503a7de1af5879b47e2-16353120181391.png\" alt=\"364c7d48f0d1e503a7de1af5879b47e2\"></p>\n<p>发送窗口就是图中被框住的范围。SND 即<code>send</code>，WND 即<code>window</code>，UNA 即<code>unacknowledged</code>，表示未被确认，NXT 即<code>next</code>，表示下一个发送的位置</p>\n<h4 id=\"接收窗口\"><a href=\"#接收窗口\" class=\"headerlink\" title=\"接收窗口\"></a>接收窗口</h4><p>接收端的窗口结构如下：</p>\n<p><img data-src=\"/images/TCP%E5%8D%8F%E8%AE%AE.assets/06c5ca9fe18976392fce8f158bb75249.png\" alt=\"06c5ca9fe18976392fce8f158bb75249\"></p>\n<p>REV 即<code>receive</code>，NXT 表示下一个接收的位置，WND 表示接收窗口大小。</p>\n<h4 id=\"流量控制过程\"><a href=\"#流量控制过程\" class=\"headerlink\" title=\"流量控制过程\"></a>流量控制过程</h4><p>这里我们不用太复杂的例子，以一个最简单的来回来模拟一下流量控制的过程，方便大家的理解</p>\n<p>首先双方三次握手，初始化各自的窗口大小，均为 200 个字节</p>\n<p>假如当前发送端给接收端发送 100 个字节，那么此时对应发送端而言，SND.NXT 当然要右移 100 个字节，也就是说当前的可用窗口减少了 100 个字节，这很好理解</p>\n<p>现在这 100 个到达了接收端，被放到接收端的缓冲队列中。不过此时由于大量负载的原因，接收端处理不了这么多字节，只能处理 40 个字节即被应用取走 40 个字节，剩下<code>60</code>个字节被留在了缓冲队列中</p>\n<p>注意了，此时接收端的情况是处理能力不足，你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说，缩小 60 个字节，由 200 个字节变成 140 个字节，因为缓冲队列还有 60 个字节没被应用拿走(还差多少就减少多少)</p>\n<p>因此，接收端会在 ACK 的报文头部带上缩小后的滑动窗口 140 字节，发送端对应的调整发送窗口的大小为 140 字节</p>\n<p>此时对应发送端而言，已发送且已接收的部分增加 40 字节，也就是 SND.UNA 右移 40 个字节，同时<strong>发送窗口</strong>缩小为 140 个字节</p>\n<p>这就是<strong>流量控制</strong>的过程。尽管回合再多，整个控制的过程和原理是一样的</p>\n<hr>\n<h3 id=\"10-TCP-的拥塞控制\"><a href=\"#10-TCP-的拥塞控制\" class=\"headerlink\" title=\"10.TCP 的拥塞控制\"></a>10.TCP 的拥塞控制</h3><p>上一节所说的<strong>流量控制</strong>发送在发送端和接收端之间，并没有考虑到整个网络环境的影响，如果说当前网络特别差，特别容易丢包，那么发送端就应该注意一些了。而这，也正是<code>拥塞控制</code>需要处理的问题</p>\n<p>对于拥塞控制来说，TCP 每条连接都需要维护两个核心状态：</p>\n<ul>\n<li>拥塞窗口(Congestion Window ，cwnd)</li>\n<li>慢启动阈值(Slow Start Threshold，ssthresh)</li>\n</ul>\n<p>涉及的算法有这几个：</p>\n<ul>\n<li>慢启动</li>\n<li>拥塞避免</li>\n<li>快速重传和快速恢复</li>\n</ul>\n<p>接下来，我们就来一一拆解这些状态和算法。首先，从拥塞窗口说起</p>\n<h4 id=\"拥塞窗口\"><a href=\"#拥塞窗口\" class=\"headerlink\" title=\"拥塞窗口\"></a>拥塞窗口</h4><p>拥塞窗口(Congestion Window ，cwnd)是指目前自己还能传输的数据量大小</p>\n<p>那么之前介绍了接收窗口的概念，两者有什么区别呢？</p>\n<ul>\n<li>接收窗口(rwnd)是<code>接收端</code>给的限制</li>\n<li>拥塞窗口(cwnd)是<code>发送端</code>的限制</li>\n</ul>\n<p>限制谁呢？</p>\n<p>限制的是<code>发送窗口</code>的大小</p>\n<p>有了这两个窗口，如何来计算<code>发送窗口</code>？</p>\n<pre><code class=\"HTTP\">发送窗口 = min(rwnd, cwnd)\n</code></pre>\n<p>取两者的较小值，而拥塞控制，就是来控制 cwnd 的变化</p>\n<h4 id=\"慢启动\"><a href=\"#慢启动\" class=\"headerlink\" title=\"慢启动\"></a>慢启动</h4><p>刚开始进入传输数据的时候，是不知道现在的网络到底是稳定还是拥堵的，如果做的太激进，发包太急，就会疯狂丢包，造成雪崩式的网络灾难</p>\n<p>因此，拥塞控制首先就是要采用一种保守的算法来慢慢的适应整个网络，这种算法叫<code>慢启动</code>。运作过程如下：</p>\n<ul>\n<li>首先，三次握手，双方宣告自己的接收窗口大小</li>\n<li>双方初始化自己的<strong>拥塞窗口</strong>(cwnd)的大小</li>\n<li>在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说，每经过一个 RTT，cwnd 翻倍。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，cwnd 变为 20，第二轮变为 40，第三轮变为 80，以此类推</li>\n</ul>\n<p>难道就这么无止境的翻倍下去？当然不可能。它的阈值叫做<strong>慢启动阈值</strong>，当 cwnd 到达这个阈值后，就好比踩了刹车</p>\n<p>在到达阈值后，如何控制 cwnd 的大小呢？</p>\n<p>这就是拥塞避免做的事情了</p>\n<h4 id=\"拥塞避免\"><a href=\"#拥塞避免\" class=\"headerlink\" title=\"拥塞避免\"></a>拥塞避免</h4><p>原来每收到一个 ACK，cwnd 加 1，现在到达阈值了，cwnd 只能加这么一点：<strong>1 / cwnd</strong>。这样一轮 RTT 下来，收到 cwnd 个 ACK，那最后拥塞窗口的大小 cwnd 总共才增加 1</p>\n<p>也就是说，以前一个 RTT 下来，<code>cwnd</code>翻倍，现在<code>cwnd</code>只是增加 1 而已</p>\n<p>当然，<strong>慢启动</strong>和<strong>拥塞避免</strong>是一起作用的，是一体的</p>\n<h4 id=\"快速重传和快速回复\"><a href=\"#快速重传和快速回复\" class=\"headerlink\" title=\"快速重传和快速回复\"></a>快速重传和快速回复</h4><p><strong>快速重传</strong></p>\n<p>在 TCP 传输过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的 ACK</p>\n<p>比如第 5 个包丢了，即使第 6、7 个包到达了接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传，不用等到一个 RTO 的时间到了才重传</p>\n<p>这就是<strong>快速重传</strong>，它解决的是<strong>是否需要重传</strong>的问题</p>\n<p><strong>快速恢复</strong>（？）</p>\n<p>当然，发送端收到三次重复 ACK 之后，发现丢包，觉得现在的网络有些拥塞了，自己会进入<strong>快速恢复</strong>阶段</p>\n<p>在这个阶段，发送端如下改变：</p>\n<ul>\n<li>拥塞阈值降低为 cwnd 的一半</li>\n<li>cwnd 的大小变为拥塞阈值</li>\n<li>cwnd 线性增加</li>\n</ul>\n<p>以上就是 TCP 拥塞控制的经典算法：<strong>慢启动、拥塞避免、快速重传和快速恢复</strong></p>\n<hr>\n<h3 id=\"11-Nagle-算法和延迟确认\"><a href=\"#11-Nagle-算法和延迟确认\" class=\"headerlink\" title=\"11.Nagle 算法和延迟确认\"></a>11.Nagle 算法和延迟确认</h3><h4 id=\"Nagle-算法\"><a href=\"#Nagle-算法\" class=\"headerlink\" title=\"Nagle 算法\"></a>Nagle 算法</h4><p>试想一个场景，发送端不停的给接收端发很小的包，一次只发 1 个字节，那么发 1 千个字节需要发 1000 次。这种频繁的发送是存在问题的，不光是传输的时延消耗，发送和确认本身也是需要耗时的，频繁的发送接收带来了巨大的时延</p>\n<p>而避免小包的频繁发送，这就是<strong>Nagle 算法</strong>要做的事</p>\n<p>具体来说，Nagle 算法的规则如下：</p>\n<ul>\n<li>当第一次发送数据时不用等待，就算是 1byte 的小包也立即发送</li>\n<li>后面发送满足下面条件之一就可以发送：<ul>\n<li>数据包大小达到最大段大小(Max Segment Size，即 MSS)</li>\n<li>之前所有包的 ACK 都已接收到</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"延迟确认\"><a href=\"#延迟确认\" class=\"headerlink\" title=\"延迟确认\"></a>延迟确认</h4><p>试想一个场景，当我收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那是要一个个回复，还是稍等一下，把两个包的 ACK 合并后一起回复呢？</p>\n<p><strong>延迟确认</strong>(delayed ack)所做的事情就是后者，稍稍延迟，然后合并 ACK，最后才回复给发送端。TCP 要求这个延迟的时延必须小于 500ms，一般操作系统实现都不会超过 200ms</p>\n<p>不过主要的是，有一些场景是不能延迟确认的，收到了就要马上回复：</p>\n<ul>\n<li>接收到了大于一个 frame 的报文，且需要调整窗口大小</li>\n<li>TCP 处于 quickack 模式(通过<code>tcp_in_quickack_mode</code>设置)</li>\n<li>发现了乱序包</li>\n</ul>\n<h4 id=\"两者一起使用会怎样？\"><a href=\"#两者一起使用会怎样？\" class=\"headerlink\" title=\"两者一起使用会怎样？\"></a>两者一起使用会怎样？</h4><p>前者意味着延迟发送，后者意味着延迟接收，会造成更大的延迟，产生性能问题。</p>\n<hr>\n<h3 id=\"12-TCP-的-keep-alive\"><a href=\"#12-TCP-的-keep-alive\" class=\"headerlink\" title=\"12.TCP 的 keep-alive\"></a>12.TCP 的 keep-alive</h3><p>大家都听说过 HTTP 的<code>keep-alive</code>，不过 TCP 层面也是有<code>keep-alive</code>机制，而且跟应用层不太一样</p>\n<p>试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端对连接失效的情况是一无所知的</p>\n<p>这个时候就出现了<code>keep-alive</code>，它的作用就是探测对端的连接有没有失效</p>\n<p>在 Linux 下，可以这样查看相关的配置</p>\n<pre><code>sudo sysctl -a | grep keepalive\n\n// 每隔 7200 s 检测一次\nnet.ipv4.tcp_keepalive_time = 7200\n// 一次最多重传 9 个包\nnet.ipv4.tcp_keepalive_probes = 9\n// 每个包的间隔重传间隔 75 s\nnet.ipv4.tcp_keepalive_intvl = 75\n</code></pre>\n<p>不过，现状是大部分的应用并没有默认开启 TCP 的<code>keep-alive</code>选项，为什么？</p>\n<p>站在应用的角度:</p>\n<ul>\n<li>7200s 也就是两个小时检测一次，时间太长</li>\n<li>时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接</li>\n</ul>\n<p>因此是一个比较尴尬的设计。</p>\n",
            "tags": [
                "前端",
                "前端"
            ]
        },
        {
            "id": "https://1234cas.github.io/1234cas.github.io/qianduan/Vue/vue%E9%9D%A2%E8%AF%95%E9%A2%98/",
            "url": "https://1234cas.github.io/1234cas.github.io/qianduan/Vue/vue%E9%9D%A2%E8%AF%95%E9%A2%98/",
            "title": "Vue面试题",
            "date_published": "2021-11-27T01:47:08.289Z",
            "content_html": "<h3 id=\"1-说说你对-SPA-单页面的理解，它的优缺点分别是什么？\"><a href=\"#1-说说你对-SPA-单页面的理解，它的优缺点分别是什么？\" class=\"headerlink\" title=\"1. 说说你对 SPA 单页面的理解，它的优缺点分别是什么？\"></a>1. 说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h3><hr>\n<p>SPA（single-page application）仅在 Web 页面初始化时加载相应的 HTML，CSS 和 JS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转，取而代之的是利用路由机制实现 HTML 内容的切换，UI 和用户的交互，避免页面的重新加载</p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染</li>\n<li>基于上面一点，SPA 相对对服务器压力小</li>\n<li>前后端职责分离，架构清晰，前端进行逻辑交互，后端负责数据处理</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>初次加载耗时多：需要在加载页面的时候将 JS、CSS 统一加载，部分页面按需加载</li>\n<li>前进后退路由管理：由于单页应用在一个页面中显示所有内容，所以不能使用浏览器的前进后退功能，所有的页面切换都需要自己建立堆栈管理</li>\n<li>SEO 难度较大：因为所有内容都在一个页面中动态替换显示，所以在 SEO 上有着天然的劣势</li>\n</ul>\n<h3 id=\"2-v-show-和-v-if-有什么区别？\"><a href=\"#2-v-show-和-v-if-有什么区别？\" class=\"headerlink\" title=\"2. v-show 和 v-if 有什么区别？\"></a>2. v-show 和 v-if 有什么区别？</h3><hr>\n<p><strong>v-if</strong> 是真正的条件渲染，因为它会在切换过程中将条件块内的事件监听器和子组件适当的销毁和重建；同时也是<strong>惰性的：</strong>初始条件为假，则什么也不做，直到条件为真，才进行渲染</p>\n<p><strong>v-show</strong> 无论条件为何，元素总是会被渲染，只是基于 CSS 的 display 属性进行显示切换</p>\n<p>所以，v-if 适合用于不需要频繁切换条件的场景；v-show 则反之</p>\n<h3 id=\"3-Class-与-Style-如何动态绑定？\"><a href=\"#3-Class-与-Style-如何动态绑定？\" class=\"headerlink\" title=\"3. Class 与 Style 如何动态绑定？\"></a>3. Class 与 Style 如何动态绑定？</h3><hr>\n<p>Class 可以通过对象语法和数组语法进行动态绑定：</p>\n<ul>\n<li>对象语法：</li>\n</ul>\n<pre><code>&lt;div :class=&quot;&#123; active: isActive, &#39;text-danger&#39;: hasError &#125;&quot;&gt;&lt;/div&gt;\n\ndata: &#123;\n  isActive: true,\n  hasError: false\n&#125;\n</code></pre>\n<p>带连字符的要加引号，通过 true/false 控制类名</p>\n<ul>\n<li>数组语法：</li>\n</ul>\n<pre><code>&lt;div :class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;\n\ndata: &#123;\n  activeClass: &#39;active&#39;,\n  errorClass: &#39;text-danger&#39;\n&#125;\n</code></pre>\n<p>通过属性名来渲染为类名的属性值</p>\n<p>Style 也可以通过对象语法和数组语法进行动态绑定：</p>\n<ul>\n<li>对象语法：</li>\n</ul>\n<pre><code>&lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &#39;px&#39; &#125;&quot;&gt;&lt;/div&gt;\n\ndata: &#123;\n  activeColor: &#39;red&#39;,\n  fontSize: 30\n&#125;\n</code></pre>\n<p>可以在里面拼接字符串，也可以进行一些简单的运算</p>\n<ul>\n<li>数组语法：</li>\n</ul>\n<pre><code>&lt;div :style=&quot;[styleColor, styleSize]&quot;&gt;&lt;/div&gt;\n\ndata: &#123;\n  styleColor: &#123;\n     color: &#39;red&#39;\n   &#125;,\n  styleSize:&#123;\n     fontSize:&#39;23px&#39;\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"4-Vue-的单向数据流\"><a href=\"#4-Vue-的单向数据流\" class=\"headerlink\" title=\"4. Vue 的单向数据流\"></a>4. Vue 的单向数据流</h3><hr>\n<p>所有的 porp 都会使其父子 prop 之间形成一个<strong>单向下行绑定</strong>：父级 prop 的更新会影响子组件的值，但是反之不行。这样可以防止子组件意外改变父组件的值，从而导致你的引应用数据流向难以理解</p>\n<p>还有，每次父组件发生更新，子组件中所有的 prop 都会刷新为最新的值。</p>\n<p>无法在子组件直接修改 prop，vue 会报错，想在子组件中修改 prop 只能通过$emit 派发一个自定义事件，父组件接收到后，由父组件修改</p>\n<p>有两种常见的试图改变一个 prop 的情形 :</p>\n<ul>\n<li><strong>这个 prop 传递一个初始值，并且这个子组件接下来下午将其作为一个本地的 prop 数据来使用。</strong>就把 prop 转存到 data 中</li>\n</ul>\n<pre><code>props: [&#39;initialCounter&#39;],\ndata: function () &#123;\n  return &#123;\n    counter: this.initialCounter\n  &#125;\n&#125;\n</code></pre>\n<ul>\n<li><strong>这个 prop 以一种原始的值传入且需要进行转换</strong>。使用这个 prop 来定义一个计算属性</li>\n</ul>\n<pre><code>props: [&#39;size&#39;],\ncomputed: &#123;\n  normalizedSize: function () &#123;\n    return this.size.trim().toLowerCase()\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"5-computed-和-watch-的区别和应用场景？\"><a href=\"#5-computed-和-watch-的区别和应用场景？\" class=\"headerlink\" title=\"5. computed 和 watch 的区别和应用场景？\"></a>5. computed 和 watch 的区别和应用场景？</h3><hr>\n<p><strong>computed：</strong>是计算属性，依赖其他属性值，并且 computed 的值有缓存，只要依赖项发生改变，computed 就会重新计算</p>\n<p><strong>watch：</strong>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p>\n<p><strong>运用场景：</strong></p>\n<ul>\n<li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li>\n<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>\n</ul>\n<h3 id=\"6-直接给一个数组项赋值，Vue-能检测到变化吗？\"><a href=\"#6-直接给一个数组项赋值，Vue-能检测到变化吗？\" class=\"headerlink\" title=\"6. 直接给一个数组项赋值，Vue 能检测到变化吗？\"></a>6. 直接给一个数组项赋值，Vue 能检测到变化吗？</h3><hr>\n<p>由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p>\n<ul>\n<li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>\n<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>\n</ul>\n<p>为了解决第一个问题，Vue 提供了以下操作方法：</p>\n<pre><code>// Vue.set\nVue.set(vm.items, indexOfItem, newValue)\n// vm.$set，Vue.set的一个别名\nvm.$set(vm.items, indexOfItem, newValue)\n// Array.prototype.splice\nvm.items.splice(indexOfItem, 1, newValue)\n复制代码\n</code></pre>\n<p>为了解决第二个问题，Vue 提供了以下操作方法：</p>\n<pre><code>// Array.prototype.splice\nvm.items.splice(newLength)\n</code></pre>\n<h3 id=\"7-对-Vue-生命周期的理解？\"><a href=\"#7-对-Vue-生命周期的理解？\" class=\"headerlink\" title=\"7. 对 Vue 生命周期的理解？\"></a>7. 对 Vue 生命周期的理解？</h3><hr>\n<p><strong>（1）生命周期是什么？</strong></p>\n<p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>\n<p><strong>（2）各个生命周期的作用</strong></p>\n<table>\n<thead>\n<tr>\n<th>生命周期</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>beforeCreate</td>\n<td>组件实例被创建之初，组件的属性生效之前</td>\n</tr>\n<tr>\n<td>created</td>\n<td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td>\n</tr>\n<tr>\n<td>beforeMount</td>\n<td>在挂载开始之前被调用：相关的 render 函数首次被调用</td>\n</tr>\n<tr>\n<td>mounted</td>\n<td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td>\n</tr>\n<tr>\n<td>beforeUpdate</td>\n<td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>\n</tr>\n<tr>\n<td>update</td>\n<td>组件数据更新之后</td>\n</tr>\n<tr>\n<td>activited</td>\n<td>keep-alive 专属，组件被激活时调用</td>\n</tr>\n<tr>\n<td>deactivated</td>\n<td>keep-alive 专属，组件被销毁时调用</td>\n</tr>\n<tr>\n<td>beforeDestory</td>\n<td>组件销毁前调用</td>\n</tr>\n<tr>\n<td>destoryed</td>\n<td>组件销毁后调用</td>\n</tr>\n</tbody></table>\n<h3 id=\"8-Vue-的父组件和子组件生命周期钩子函数执行顺序？\"><a href=\"#8-Vue-的父组件和子组件生命周期钩子函数执行顺序？\" class=\"headerlink\" title=\"8. Vue 的父组件和子组件生命周期钩子函数执行顺序？\"></a>8. Vue 的父组件和子组件生命周期钩子函数执行顺序？</h3><hr>\n<p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>\n<ul>\n<li><p>加载渲染过程</p>\n<p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>\n</li>\n<li><p>子组件更新过程</p>\n<p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>\n</li>\n<li><p>父组件更新过程</p>\n<p>父 beforeUpdate -&gt; 父 updated</p>\n</li>\n<li><p>销毁过程</p>\n<p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>\n</li>\n</ul>\n<h3 id=\"9-在哪个生命周期内调用异步请求？\"><a href=\"#9-在哪个生命周期内调用异步请求？\" class=\"headerlink\" title=\"9. 在哪个生命周期内调用异步请求？\"></a>9. 在哪个生命周期内调用异步请求？</h3><hr>\n<p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是推荐在 created 钩子函数中调用异步请求，因为：</p>\n<ul>\n<li>能更快获取到服务端数据，减少页面 loading 时间；</li>\n<li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li>\n</ul>\n<h3 id=\"10-在什么阶段才能访问操作-DOM？\"><a href=\"#10-在什么阶段才能访问操作-DOM？\" class=\"headerlink\" title=\"10. 在什么阶段才能访问操作 DOM？\"></a>10. 在什么阶段才能访问操作 DOM？</h3><p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。</p>\n",
            "tags": [
                "前端",
                "Vue",
                "前端",
                "Vue"
            ]
        },
        {
            "id": "https://1234cas.github.io/1234cas.github.io/hexo/hello-world/",
            "url": "https://1234cas.github.io/1234cas.github.io/hexo/hello-world/",
            "title": "Hello World",
            "date_published": "2021-11-26T14:28:24.686Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": [
                "hexo"
            ]
        }
    ]
}