<!-- build time:Tue Mar 29 2022 11:15:37 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="前端"><link rel="canonical" href="https://1234cas.github.io/1234cas.github.io/qianduan/ES6/ES6%E4%B8%8B/"><title>ES6下 - ES6 - 前端 | Sparkle = Sparkle = 加油</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">ES6下</h1><div class="meta"><span class="item" title="创建时间：2022-03-27 16:52:28"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-03-27T16:52:28+08:00">2022-03-27</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Sparkle</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipexw3o58j20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclfdu6exj20zk0m87hw.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giciuja1j1j20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicljitigmj20zk0m87fp.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giciukx8a7j20zk0m8aio.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclhnx9glj20zk0m8npd.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/qianduan/" itemprop="item" rel="index" title="分类于 前端"><span itemprop="name">前端</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/qianduan/ES6/" itemprop="item" rel="index" title="分类于 ES6"><span itemprop="name">ES6</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://1234cas.github.io/1234cas.github.io/qianduan/ES6/ES6%E4%B8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="sparkle"><meta itemprop="description" content="加油, 好好读书"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sparkle"></span><div class="body md" itemprop="articleBody"><h3 id="14、-Proxy"><a href="#14、-Proxy" class="headerlink" title="14、 Proxy"></a>14、 Proxy</h3><hr><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><strong>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</strong></p><p><strong>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</strong></p><pre><code class="javascript">var obj = new Proxy(&#123;&#125;, &#123;
  get: function (target, propKey, receiver) &#123;
    console.log(`getting $&#123;propKey&#125;!`);
    return Reflect.get(target, propKey, receiver);
  &#125;,
  set: function (target, propKey, value, receiver) &#123;
    console.log(`setting $&#123;propKey&#125;!`);
    return Reflect.set(target, propKey, value, receiver);
  &#125;
&#125;);
</code></pre><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p><pre><code class="javascript">obj.count = 1
//  setting count!
++obj.count
//  getting count!
//  setting count!
//  2
</code></pre><p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p><p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p><pre><code class="javascript">var proxy = new Proxy(target, handler);
</code></pre><p><strong>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</strong></p><p>下面是另一个拦截读取属性行为的例子。</p><pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, propKey) &#123;
    return 35;
  &#125;
&#125;);

proxy.time // 35
proxy.name // 35
proxy.title // 35
</code></pre><p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p><p><strong>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</strong></p><p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p><pre><code class="javascript">var target = &#123;&#125;;
var handler = &#123;&#125;;
var proxy = new Proxy(target, handler);
proxy.a = &#39;b&#39;;
target.a // &quot;b&quot;
</code></pre><p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>proxy</code>就等同于访问<code>target</code>。</p><p>一个技巧是将 Proxy 对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。</p><pre><code class="javascript">var object = &#123; proxy: new Proxy(target, handler) &#125;;
</code></pre><p>Proxy 实例也可以作为其他对象的原型对象。</p><pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, propKey) &#123;
    return 35;
  &#125;
&#125;);

let obj = Object.create(proxy);
obj.time // 35
</code></pre><p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p><p>同一个拦截器函数，可以设置拦截多个操作。</p><pre><code class="javascript">var handler = &#123;
  get: function(target, name) &#123;
    if (name === &#39;prototype&#39;) &#123;
      return Object.prototype;
    &#125;
    return &#39;Hello, &#39; + name;
  &#125;,

  apply: function(target, thisBinding, args) &#123;
    return args[0];
  &#125;,

  construct: function(target, args) &#123;
    return &#123;value: args[1]&#125;;
  &#125;
&#125;;

var fproxy = new Proxy(function(x, y) &#123;
  return x + y;
&#125;, handler);

fproxy(1, 2) // 1
new fproxy(1, 2) // &#123;value: 2&#125;
fproxy.prototype === Object.prototype // true
fproxy.foo === &quot;Hello, foo&quot; // true
</code></pre><p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p><p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p><ul><li>**get(target, propKey, receiver)**：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li><li>**set(target, propKey, value, receiver)**：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li><li>**has(target, propKey)**：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li><li>**deleteProperty(target, propKey)**：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li><li>**ownKeys(target)**：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li><li>**getOwnPropertyDescriptor(target, propKey)**：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li><li>**defineProperty(target, propKey, propDesc)**：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li><li>**preventExtensions(target)**：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li><li>**getPrototypeOf(target)**：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li><li>**isExtensible(target)**：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li><li>**setPrototypeOf(target, proto)**：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li>**apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li><li>**construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li></ul><hr><h4 id="2-Proxy-实例的方法"><a href="#2-Proxy-实例的方法" class="headerlink" title="2. Proxy 实例的方法"></a>2. Proxy 实例的方法</h4><p><strong>get</strong>()</p><p><strong><code>get</code>方法用于拦截某个属性的读取操作</strong>，可以接受三个参数，<strong>依次为目标对象、属性名和 proxy 实例本身</strong>（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p><p><code>get</code>方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p><pre><code class="javascript">var person = &#123;
  name: &quot;张三&quot;
&#125;;

var proxy = new Proxy(person, &#123;
  get: function(target, propKey) &#123;
    if (propKey in target) &#123;
      return target[propKey];
    &#125; else &#123;
      throw new ReferenceError(&quot;Prop name \&quot;&quot; + propKey + &quot;\&quot; does not exist.&quot;);
    &#125;
  &#125;
&#125;);

proxy.name // &quot;张三&quot;
proxy.age // 抛出一个错误
</code></pre><p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回<code>undefined</code>。</p><p><code>get</code>方法可以继承。</p><pre><code class="javascript">let proto = new Proxy(&#123;&#125;, &#123;
  get(target, propertyKey, receiver) &#123;
    console.log(&#39;GET &#39; + propertyKey);
    return target[propertyKey];
  &#125;
&#125;);

let obj = Object.create(proto);
obj.foo // &quot;GET foo&quot;
</code></pre><p>上面代码中，拦截操作定义在<code>Prototype</code>对象上面，所以如果读取<code>obj</code>对象继承的属性时，拦截会生效。</p><p>下面的例子使用<code>get</code>拦截，实现数组读取负数的索引。</p><pre><code class="javascript">function createArray(...elements) &#123;
  let handler = &#123;
    get(target, propKey, receiver) &#123;
      let index = Number(propKey);
      if (index &lt; 0) &#123;
        propKey = String(target.length + index);
      &#125;
      return Reflect.get(target, propKey, receiver);
    &#125;
  &#125;;

  let target = [];
  target.push(...elements);
  return new Proxy(target, handler);
&#125;

let arr = createArray(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);
arr[-1] // c
</code></pre><p>上面代码中，数组的位置参数是<code>-1</code>，就会输出数组的倒数第一个成员。</p><p><strong>利用 Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</strong></p><pre><code class="javascript">var pipe = function (value) &#123;
  var funcStack = [];
  var oproxy = new Proxy(&#123;&#125; , &#123;
    get : function (pipeObject, fnName) &#123;
      if (fnName === &#39;get&#39;) &#123;
        return funcStack.reduce(function (val, fn) &#123;
          return fn(val);
        &#125;,value);
      &#125;
      funcStack.push(window[fnName]);
      return oproxy;
    &#125;
  &#125;);

  return oproxy;
&#125;

var double = n =&gt; n * 2;
var pow    = n =&gt; n * n;
var reverseInt = n =&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;

pipe(3).double.pow.reverseInt.get; // 63
</code></pre><p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</p><p>下面的例子则是利用<code>get</code>拦截，实现一个生成各种 DOM 节点的通用函数<code>dom</code>。</p><pre><code class="javascript">const dom = new Proxy(&#123;&#125;, &#123;
  get(target, property) &#123;
    return function(attrs = &#123;&#125;, ...children) &#123;
      const el = document.createElement(property);
      for (let prop of Object.keys(attrs)) &#123;
        el.setAttribute(prop, attrs[prop]);
      &#125;
      for (let child of children) &#123;
        if (typeof child === &#39;string&#39;) &#123;
          child = document.createTextNode(child);
        &#125;
        el.appendChild(child);
      &#125;
      return el;
    &#125;
  &#125;
&#125;);

const el = dom.div(&#123;&#125;,
  &#39;Hello, my name is &#39;,
  dom.a(&#123;href: &#39;//example.com&#39;&#125;, &#39;Mark&#39;),
  &#39;. I like:&#39;,
  dom.ul(&#123;&#125;,
    dom.li(&#123;&#125;, &#39;The web&#39;),
    dom.li(&#123;&#125;, &#39;Food&#39;),
    dom.li(&#123;&#125;, &#39;…actually that\&#39;s it&#39;)
  )
);

document.body.appendChild(el);
</code></pre><p>下面是一个<code>get</code>方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</p><pre><code class="javascript">const proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, key, receiver) &#123;
    return receiver;
  &#125;
&#125;);
proxy.getReceiver === proxy // true
</code></pre><p>上面代码中，**<code>proxy</code>对象的<code>getReceiver</code>属性是由<code>proxy</code>对象提供的，所以<code>receiver</code>指向<code>proxy</code>对象。**</p><pre><code class="javascript">const proxy = new Proxy(&#123;&#125;, &#123;
  get: function(target, key, receiver) &#123;
    return receiver;
  &#125;
&#125;);

const d = Object.create(proxy);
d.a === d // true
</code></pre><p>上面代码中，<code>d</code>对象本身没有<code>a</code>属性，所以读取<code>d.a</code>的时候，会去<code>d</code>的原型<code>proxy</code>对象找。这时，<code>receiver</code>就指向<code>d</code>，代表原始的读操作所在的那个对象。</p><p><strong>如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</strong></p><pre><code class="javascript">const target = Object.defineProperties(&#123;&#125;, &#123;
  foo: &#123;
    value: 123,
    writable: false,
    configurable: false
  &#125;,
&#125;);

const handler = &#123;
  get(target, propKey) &#123;
    return &#39;abc&#39;;
  &#125;
&#125;;

const proxy = new Proxy(target, handler);

proxy.foo
// TypeError: Invariant check failed
</code></pre><hr><p><strong>set()</strong></p><p><strong><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</strong></p><p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求。</p><pre><code class="javascript">let validator = &#123;
  set: function(obj, prop, value) &#123;
    if (prop === &#39;age&#39;) &#123;
      if (!Number.isInteger(value)) &#123;
        throw new TypeError(&#39;The age is not an integer&#39;);
      &#125;
      if (value &gt; 200) &#123;
        throw new RangeError(&#39;The age seems invalid&#39;);
      &#125;
    &#125;

    // 对于满足条件的 age 属性以及其他属性，直接保存
    obj[prop] = value;
    return true;
  &#125;
&#125;;

let person = new Proxy(&#123;&#125;, validator);

person.age = 100;

person.age // 100
person.age = &#39;young&#39; // 报错
person.age = 300 // 报错
</code></pre><p>上面代码中，由于设置了存值函数<code>set</code>，任何不符合要求的<code>age</code>属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。<strong>利用<code>set</code>方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</strong></p><p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合<code>get</code>和<code>set</code>方法，就可以做到防止这些内部属性被外部读写。</p><pre><code class="javascript">const handler = &#123;
  get (target, key) &#123;
    invariant(key, &#39;get&#39;);
    return target[key];
  &#125;,
  set (target, key, value) &#123;
    invariant(key, &#39;set&#39;);
    target[key] = value;
    return true;
  &#125;
&#125;;
function invariant (key, action) &#123;
  if (key[0] === &#39;_&#39;) &#123;
    throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`);
  &#125;
&#125;
const target = &#123;&#125;;
const proxy = new Proxy(target, handler);
proxy._prop
// Error: Invalid attempt to get private &quot;_prop&quot; property
proxy._prop = &#39;c&#39;
// Error: Invalid attempt to set private &quot;_prop&quot; property
</code></pre><p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p><p>下面是<code>set</code>方法第四个参数的例子。</p><pre><code class="javascript">const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
    return true;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);
proxy.foo = &#39;bar&#39;;
proxy.foo === proxy // true
</code></pre><p>上面代码中，<code>set</code>方法的第四个参数<code>receiver</code>，指的是原始的操作行为所在的那个对象，一般情况下是<code>proxy</code>实例本身，请看下面的例子。</p><pre><code class="javascript">const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
    return true;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);
const myObj = &#123;&#125;;
Object.setPrototypeOf(myObj, proxy);

myObj.foo = &#39;bar&#39;;
myObj.foo === myObj // true
</code></pre><p>上面代码中，设置<code>myObj.foo</code>属性的值时，<code>myObj</code>并没有<code>foo</code>属性，因此引擎会到<code>myObj</code>的原型链去找<code>foo</code>属性。<code>myObj</code>的原型对象<code>proxy</code>是一个 Proxy 实例，设置它的<code>foo</code>属性会触发<code>set</code>方法。这时，第四个参数<code>receiver</code>就指向原始赋值行为所在的对象<code>myObj</code>。</p><p><strong>注意，如果目标对象自身的某个属性不可写，那么<code>set</code>方法将不起作用。</strong></p><pre><code class="javascript">const obj = &#123;&#125;;
Object.defineProperty(obj, &#39;foo&#39;, &#123;
  value: &#39;bar&#39;,
  writable: false
&#125;);

const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = &#39;baz&#39;;
    return true;
  &#125;
&#125;;

const proxy = new Proxy(obj, handler);
proxy.foo = &#39;baz&#39;;
proxy.foo // &quot;bar&quot;
</code></pre><p>上面代码中，<code>obj.foo</code>属性不可写，Proxy 对这个属性的<code>set</code>代理将不会生效。</p><p><strong>注意，<code>set</code>代理应当返回一个布尔值。严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错。</strong></p><pre><code class="javascript">&#39;use strict&#39;;
const handler = &#123;
  set: function(obj, prop, value, receiver) &#123;
    obj[prop] = receiver;
    // 无论有没有下面这一行，都会报错
    return false;
  &#125;
&#125;;
const proxy = new Proxy(&#123;&#125;, handler);
proxy.foo = &#39;bar&#39;;
// TypeError: &#39;set&#39; on proxy: trap returned falsish for property &#39;foo&#39;
</code></pre><p>上面代码中，严格模式下，<code>set</code>代理返回<code>false</code>或者<code>undefined</code>，都会报错。</p><hr><p><strong>apply()</strong></p><p><strong><code>apply</code>方法拦截函数的调用、<code>call</code>和<code>apply</code>操作。</strong>**</p><p><strong><code>apply</code>方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</strong></p><pre><code class="javascript">var handler = &#123;
  apply (target, ctx, args) &#123;
    return Reflect.apply(...arguments);
  &#125;
&#125;;
</code></pre><p>下面是一个例子。</p><pre><code class="javascript">var target = function () &#123; return &#39;I am the target&#39;; &#125;;
var handler = &#123;
  apply: function () &#123;
    return &#39;I am the proxy&#39;;
  &#125;
&#125;;

var p = new Proxy(target, handler);

p()
// &quot;I am the proxy&quot;
</code></pre><p>上面代码中，变量<code>p</code>是 Proxy 的实例，当它作为函数调用时（<code>p()</code>），就会被<code>apply</code>方法拦截，返回一个字符串。</p><p>下面是另外一个例子。</p><pre><code class="javascript">var twice = &#123;
  apply (target, ctx, args) &#123;
    return Reflect.apply(...arguments) * 2;
  &#125;
&#125;;
function sum (left, right) &#123;
  return left + right;
&#125;;
var proxy = new Proxy(sum, twice);
proxy(1, 2) // 6
proxy.call(null, 5, 6) // 22
proxy.apply(null, [7, 8]) // 30
</code></pre><p>上面代码中，每当执行<code>proxy</code>函数（直接调用或<code>call</code>和<code>apply</code>调用），就会被<code>apply</code>方法拦截。</p><p>另外，直接调用<code>Reflect.apply</code>方法，也会被拦截。</p><pre><code class="javascript">Reflect.apply(proxy, null, [9, 10]) // 38
</code></pre><hr><p><strong>has()</strong></p><p><strong><code>has()</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</strong></p><p><strong><code>has()</code>方法可以接受两个参数，分别是目标对象、需查询的属性名。</strong></p><p>下面的例子使用<code>has()</code>方法隐藏某些属性，不被<code>in</code>运算符发现。</p><pre><code class="javascript">var handler = &#123;
  has (target, key) &#123;
    if (key[0] === &#39;_&#39;) &#123;
      return false;
    &#125;
    return key in target;
  &#125;
&#125;;
var target = &#123; _prop: &#39;foo&#39;, prop: &#39;foo&#39; &#125;;
var proxy = new Proxy(target, handler);
&#39;_prop&#39; in proxy // false
</code></pre><p>上面代码中，如果原对象的属性名的第一个字符是下划线，<code>proxy.has()</code>就会返回<code>false</code>，从而不会被<code>in</code>运算符发现。</p><p><strong>如果原对象不可配置或者禁止扩展，这时<code>has()</code>拦截会报错。</strong></p><pre><code class="javascript">var obj = &#123; a: 10 &#125;;
Object.preventExtensions(obj);

var p = new Proxy(obj, &#123;
  has: function(target, prop) &#123;
    return false;
  &#125;
&#125;);

&#39;a&#39; in p // TypeError is thrown
</code></pre><p>上面代码中，<code>obj</code>对象禁止扩展，结果使用<code>has</code>拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则<code>has()</code>方法就不得“隐藏”（即返回<code>false</code>）目标对象的该属性。</p><p><strong>值得注意的是，<code>has()</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has()</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</strong></p><p><strong>另外，虽然<code>for...in</code>循环也用到了<code>in</code>运算符，但是<code>has()</code>拦截对<code>for...in</code>循环不生效。</strong></p><pre><code class="javascript">let stu1 = &#123;name: &#39;张三&#39;, score: 59&#125;;
let stu2 = &#123;name: &#39;李四&#39;, score: 99&#125;;

let handler = &#123;
  has(target, prop) &#123;
    if (prop === &#39;score&#39; &amp;&amp; target[prop] &lt; 60) &#123;
      console.log(`$&#123;target.name&#125; 不及格`);
      return false;
    &#125;
    return prop in target;
  &#125;
&#125;

let oproxy1 = new Proxy(stu1, handler);
let oproxy2 = new Proxy(stu2, handler);

&#39;score&#39; in oproxy1
// 张三 不及格
// false

&#39;score&#39; in oproxy2
// true

for (let a in oproxy1) &#123;
  console.log(oproxy1[a]);
&#125;
// 张三
// 59

for (let b in oproxy2) &#123;
  console.log(oproxy2[b]);
&#125;
// 李四
// 99
</code></pre><p>上面代码中，<code>has()</code>拦截只对<code>in</code>运算符生效，对<code>for...in</code>循环不生效，导致不符合要求的属性没有被<code>for...in</code>循环所排除。</p><p><strong>construct()</strong></p><p><strong><code>construct()</code>方法用于拦截<code>new</code>命令</strong>，下面是拦截对象的写法。</p><pre><code class="javascript">const handler = &#123;
  construct (target, args, newTarget) &#123;
    return new target(...args);
  &#125;
&#125;;
</code></pre><p><code>construct()</code>方法可以接受三个参数。</p><ul><li><code>target</code>：目标对象。</li><li><code>args</code>：构造函数的参数数组。</li><li><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的<code>p</code>）。</li></ul><pre><code class="javascript">const p = new Proxy(function () &#123;&#125;, &#123;
  construct: function(target, args) &#123;
    console.log(&#39;called: &#39; + args.join(&#39;, &#39;));
    return &#123; value: args[0] * 10 &#125;;
  &#125;
&#125;);

(new p(1)).value
// &quot;called: 1&quot;
// 10
</code></pre><p><strong><code>construct()</code>方法返回的必须是一个对象，否则会报错。</strong></p><pre><code class="javascript">const p = new Proxy(function() &#123;&#125;, &#123;
  construct: function(target, argumentsList) &#123;
    return 1;
  &#125;
&#125;);

new p() // 报错
// Uncaught TypeError: &#39;construct&#39; on proxy: trap returned non-object (&#39;1&#39;)
</code></pre><p><strong>另外，由于<code>construct()</code>拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。</strong></p><pre><code class="javascript">const p = new Proxy(&#123;&#125;, &#123;
  construct: function(target, argumentsList) &#123;
    return &#123;&#125;;
  &#125;
&#125;);

new p() // 报错
// Uncaught TypeError: p is not a constructor
</code></pre><p>上面例子中，拦截的目标对象不是一个函数，而是一个对象（<code>new Proxy()</code>的第一个参数），导致报错。</p><p><strong>注意，<code>construct()</code>方法中的<code>this</code>指向的是<code>handler</code>，而不是实例对象。</strong></p><pre><code class="javascript">const handler = &#123;
  construct: function(target, args) &#123;
    console.log(this === handler);
    return new target(...args);
  &#125;
&#125;

let p = new Proxy(function () &#123;&#125;, handler);
new p() // true
</code></pre><p><strong>deleteProperty()</strong></p><p><strong><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</strong></p><pre><code class="javascript">var handler = &#123;
  deleteProperty (target, key) &#123;
    invariant(key, &#39;delete&#39;);
    delete target[key];
    return true;
  &#125;
&#125;;
function invariant (key, action) &#123;
  if (key[0] === &#39;_&#39;) &#123;
    throw new Error(`Invalid attempt to $&#123;action&#125; private &quot;$&#123;key&#125;&quot; property`);
  &#125;
&#125;

var target = &#123; _prop: &#39;foo&#39; &#125;;
var proxy = new Proxy(target, handler);
delete proxy._prop
// Error: Invalid attempt to delete private &quot;_prop&quot; property
</code></pre><p>上面代码中，<code>deleteProperty</code>方法拦截了<code>delete</code>操作符，删除第一个字符为下划线的属性会报错。</p><p><strong>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错。</strong></p><hr><p><strong>defineProperty()</strong></p><p><strong><code>defineProperty()</code>方法拦截了<code>Object.defineProperty()</code>操作。</strong></p><pre><code class="javascript">var handler = &#123;
  defineProperty (target, key, descriptor) &#123;
    return false;
  &#125;
&#125;;
var target = &#123;&#125;;
var proxy = new Proxy(target, handler);
proxy.foo = &#39;bar&#39; // 不会生效
</code></pre><p>上面代码中，<code>defineProperty()</code>方法内部没有任何操作，只返回<code>false</code>，导致添加新属性总是无效。注意，这里的<code>false</code>只是用来提示操作失败，本身并不能阻止添加新属性。</p><p><strong>注意，如果目标对象不可扩展（non-extensible），则<code>defineProperty()</code>不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则<code>defineProperty()</code>方法不得改变这两个设置。</strong></p><hr><p><strong>getOwnPropertyDescriptor()</strong></p><p><strong><code>getOwnPropertyDescriptor()</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个属性描述对象或者<code>undefined</code>。</strong></p><pre><code class="javascript">var handler = &#123;
  getOwnPropertyDescriptor (target, key) &#123;
    if (key[0] === &#39;_&#39;) &#123;
      return;
    &#125;
    return Object.getOwnPropertyDescriptor(target, key);
  &#125;
&#125;;
var target = &#123; _foo: &#39;bar&#39;, baz: &#39;tar&#39; &#125;;
var proxy = new Proxy(target, handler);
Object.getOwnPropertyDescriptor(proxy, &#39;wat&#39;)
// undefined
Object.getOwnPropertyDescriptor(proxy, &#39;_foo&#39;)
// undefined
Object.getOwnPropertyDescriptor(proxy, &#39;baz&#39;)
// &#123; value: &#39;tar&#39;, writable: true, enumerable: true, configurable: true &#125;
</code></pre><p>上面代码中，<code>handler.getOwnPropertyDescriptor()</code>方法对于第一个字符为下划线的属性名会返回<code>undefined</code>。</p><hr><p><strong>getPrototypeOf()</strong></p><p><strong><code>getPrototypeOf()</code>方法主要用来拦截获取对象原型</strong>。具体来说，拦截下面这些操作。</p><ul><li><code>Object.prototype.__proto__</code></li><li><code>Object.prototype.isPrototypeOf()</code></li><li><code>Object.getPrototypeOf()</code></li><li><code>Reflect.getPrototypeOf()</code></li><li><code>instanceof</code></li></ul><p>下面是一个例子。</p><pre><code class="javascript">var proto = &#123;&#125;;
var p = new Proxy(&#123;&#125;, &#123;
  getPrototypeOf(target) &#123;
    return proto;
  &#125;
&#125;);
Object.getPrototypeOf(p) === proto // true
</code></pre><p>上面代码中，<code>getPrototypeOf()</code>方法拦截<code>Object.getPrototypeOf()</code>，返回<code>proto</code>对象。</p><p><strong>注意，<code>getPrototypeOf()</code>方法的返回值必须是对象或者<code>null</code>，否则报错。另外，如果目标对象不可扩展（non-extensible）， <code>getPrototypeOf()</code>方法必须返回目标对象的原型对象。</strong></p><hr><p><strong>isExtensible()</strong></p><p><strong><code>isExtensible()</code>方法拦截<code>Object.isExtensible()</code>操作。</strong></p><pre><code class="javascript">var p = new Proxy(&#123;&#125;, &#123;
  isExtensible: function(target) &#123;
    console.log(&quot;called&quot;);
    return true;
  &#125;
&#125;);

Object.isExtensible(p)
// &quot;called&quot;
// true
</code></pre><p>上面代码设置了<code>isExtensible()</code>方法，在调用<code>Object.isExtensible</code>时会输出<code>called</code>。</p><p><strong>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</strong></p><p><strong>这个方法有一个强限制，它的返回值必须与目标对象的<code>isExtensible</code>属性保持一致，否则就会抛出错误。</strong></p><pre><code class="javascript">Object.isExtensible(proxy) === Object.isExtensible(target)
</code></pre><p>下面是一个例子。</p><pre><code class="javascript">var p = new Proxy(&#123;&#125;, &#123;
  isExtensible: function(target) &#123;
    return false;
  &#125;
&#125;);

Object.isExtensible(p)
// Uncaught TypeError: &#39;isExtensible&#39; on proxy: trap result does not reflect extensibility of proxy target (which is &#39;true&#39;)
</code></pre><hr><p><strong>ownKeys()</strong></p><p><strong><code>ownKeys()</code>方法用来拦截对象自身属性的读取操作。</strong>具体来说，拦截以下操作。</p><ul><li><code>Object.getOwnPropertyNames()</code></li><li><code>Object.getOwnPropertySymbols()</code></li><li><code>Object.keys()</code></li><li><code>for...in</code>循环</li></ul><p>下面是拦截<code>Object.keys()</code>的例子。</p><pre><code class="javascript">let target = &#123;
  a: 1,
  b: 2,
  c: 3
&#125;;

let handler = &#123;
  ownKeys(target) &#123;
    return [&#39;a&#39;];
  &#125;
&#125;;

let proxy = new Proxy(target, handler);

Object.keys(proxy)
// [ &#39;a&#39; ]
</code></pre><p>上面代码拦截了对于<code>target</code>对象的<code>Object.keys()</code>操作，只返回<code>a</code>、<code>b</code>、<code>c</code>三个属性之中的<code>a</code>属性。</p><p>下面的例子是拦截第一个字符为下划线的属性名。</p><pre><code class="javascript">let target = &#123;
  _bar: &#39;foo&#39;,
  _prop: &#39;bar&#39;,
  prop: &#39;baz&#39;
&#125;;

let handler = &#123;
  ownKeys (target) &#123;
    return Reflect.ownKeys(target).filter(key =&gt; key[0] !== &#39;_&#39;);
  &#125;
&#125;;

let proxy = new Proxy(target, handler);
for (let key of Object.keys(proxy)) &#123;
  console.log(target[key]);
&#125;
// &quot;baz&quot;
</code></pre><p><strong>注意，使用<code>Object.keys()</code>方法时，有三类属性会被<code>ownKeys()</code>方法自动过滤，不会返回。</strong></p><ul><li>目标对象上不存在的属性</li><li>属性名为 Symbol 值</li><li>不可遍历（<code>enumerable</code>）的属性</li></ul><pre><code class="javascript">let target = &#123;
  a: 1,
  b: 2,
  c: 3,
  [Symbol.for(&#39;secret&#39;)]: &#39;4&#39;,
&#125;;

Object.defineProperty(target, &#39;key&#39;, &#123;
  enumerable: false,
  configurable: true,
  writable: true,
  value: &#39;static&#39;
&#125;);

let handler = &#123;
  ownKeys(target) &#123;
    return [&#39;a&#39;, &#39;d&#39;, Symbol.for(&#39;secret&#39;), &#39;key&#39;];
  &#125;
&#125;;

let proxy = new Proxy(target, handler);

Object.keys(proxy)
// [&#39;a&#39;]
</code></pre><p>上面代码中，<code>ownKeys()</code>方法之中，显式返回不存在的属性（<code>d</code>）、Symbol 值（<code>Symbol.for(&#39;secret&#39;)</code>）、不可遍历的属性（<code>key</code>），结果都被自动过滤掉。</p><p><strong><code>ownKeys()</code>方法还可以拦截<code>Object.getOwnPropertyNames()</code>。</strong></p><pre><code class="javascript">var p = new Proxy(&#123;&#125;, &#123;
  ownKeys: function(target) &#123;
    return [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
  &#125;
&#125;);

Object.getOwnPropertyNames(p)
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]
</code></pre><p><strong><code>for...in</code>循环也受到<code>ownKeys()</code>方法的拦截。</strong></p><pre><code class="javascript">const obj = &#123; hello: &#39;world&#39; &#125;;
const proxy = new Proxy(obj, &#123;
  ownKeys: function () &#123;
    return [&#39;a&#39;, &#39;b&#39;];
  &#125;
&#125;);

for (let key in proxy) &#123;
  console.log(key); // 没有任何输出
&#125;
</code></pre><p>上面代码中，<code>ownkeys()</code>指定只返回<code>a</code>和<code>b</code>属性，由于<code>obj</code>没有这两个属性，因此<code>for...in</code>循环不会有任何输出。</p><p><strong><code>ownKeys()</code>方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</strong></p><pre><code class="javascript">var obj = &#123;&#125;;

var p = new Proxy(obj, &#123;
  ownKeys: function(target) &#123;
    return [123, true, undefined, null, &#123;&#125;, []];
  &#125;
&#125;);

Object.getOwnPropertyNames(p)
// Uncaught TypeError: 123 is not a valid property name
</code></pre><p>上面代码中，<code>ownKeys()</code>方法虽然返回一个数组，但是每一个数组成员都不是字符串或 Symbol 值，因此就报错了。</p><p><strong>如果目标对象自身包含不可配置的属性，则该属性必须被<code>ownKeys()</code>方法返回，否则报错。</strong></p><pre><code class="javascript">var obj = &#123;&#125;;
Object.defineProperty(obj, &#39;a&#39;, &#123;
  configurable: false,
  enumerable: true,
  value: 10 &#125;
);

var p = new Proxy(obj, &#123;
  ownKeys: function(target) &#123;
    return [&#39;b&#39;];
  &#125;
&#125;);

Object.getOwnPropertyNames(p)
// Uncaught TypeError: &#39;ownKeys&#39; on proxy: trap result did not include &#39;a&#39;
</code></pre><p>上面代码中，<code>obj</code>对象的<code>a</code>属性是不可配置的，这时<code>ownKeys()</code>方法返回的数组之中，必须包含<code>a</code>，否则会报错。</p><p><strong>另外，如果目标对象是不可扩展的（non-extensible），这时<code>ownKeys()</code>方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</strong></p><pre><code class="javascript">var obj = &#123;
  a: 1
&#125;;

Object.preventExtensions(obj);

var p = new Proxy(obj, &#123;
  ownKeys: function(target) &#123;
    return [&#39;a&#39;, &#39;b&#39;];
  &#125;
&#125;);

Object.getOwnPropertyNames(p)
// Uncaught TypeError: &#39;ownKeys&#39; on proxy: trap returned extra keys but proxy target is non-extensible
</code></pre><p>上面代码中，<code>obj</code>对象是不可扩展的，这时<code>ownKeys()</code>方法返回的数组之中，包含了<code>obj</code>对象的多余属性<code>b</code>，所以导致了报错。</p><hr><p><strong>preventExtensions()</strong></p><p><strong><code>preventExtensions()</code>方法拦截<code>Object.preventExtensions()</code>。该方法必须返回一个布尔值，否则会被自动转为布尔值。</strong></p><p>这个方法有一个限制，只有目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>），<code>proxy.preventExtensions</code>才能返回<code>true</code>，否则会报错。</p><pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;
  preventExtensions: function(target) &#123;
    return true;
  &#125;
&#125;);

Object.preventExtensions(proxy)
// Uncaught TypeError: &#39;preventExtensions&#39; on proxy: trap returned truish but the proxy target is extensible
</code></pre><p>上面代码中，<code>proxy.preventExtensions()</code>方法返回<code>true</code>，但这时<code>Object.isExtensible(proxy)</code>会返回<code>true</code>，因此报错。</p><p><strong>为了防止出现这个问题，通常要在<code>proxy.preventExtensions()</code>方法里面，调用一次<code>Object.preventExtensions()</code>。</strong></p><pre><code class="javascript">var proxy = new Proxy(&#123;&#125;, &#123;
  preventExtensions: function(target) &#123;
    console.log(&#39;called&#39;);
    Object.preventExtensions(target);
    return true;
  &#125;
&#125;);

Object.preventExtensions(proxy)
// &quot;called&quot;
// Proxy &#123;&#125;
</code></pre><p><strong>setPrototypeOf()</strong></p><p><strong><code>setPrototypeOf()</code>方法主要用来拦截<code>Object.setPrototypeOf()</code>方法。</strong></p><p>下面是一个例子。</p><pre><code class="javascript">var handler = &#123;
  setPrototypeOf (target, proto) &#123;
    throw new Error(&#39;Changing the prototype is forbidden&#39;);
  &#125;
&#125;;
var proto = &#123;&#125;;
var target = function () &#123;&#125;;
var proxy = new Proxy(target, handler);
Object.setPrototypeOf(proxy, proto);
// Error: Changing the prototype is forbidden
</code></pre><p>上面代码中，只要修改<code>target</code>的原型对象，就会报错。</p><p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），<code>setPrototypeOf()</code>方法不得改变目标对象的原型。</p><hr><h4 id="3-Proxy-revocable"><a href="#3-Proxy-revocable" class="headerlink" title="3. Proxy.revocable()"></a>3. Proxy.revocable()</h4><p><strong><code>Proxy.revocable()</code>方法返回一个可取消的 Proxy 实例。</strong></p><pre><code class="javascript">let target = &#123;&#125;;
let handler = &#123;&#125;;

let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);

proxy.foo = 123;
proxy.foo // 123

revoke();
proxy.foo // TypeError: Revoked
</code></pre><p><code>Proxy.revocable()</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p><p><strong><code>Proxy.revocable()</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</strong></p><hr><h4 id="4-this-问题"><a href="#4-this-问题" class="headerlink" title="4. this 问题"></a>4. this 问题</h4><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，<strong>即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</strong></p><pre><code class="javascript">const target = &#123;
  m: function () &#123;
    console.log(this === proxy);
  &#125;
&#125;;
const handler = &#123;&#125;;

const proxy = new Proxy(target, handler);

target.m() // false
proxy.m()  // true
</code></pre><p>上面代码中，一旦<code>proxy</code>代理<code>target</code>，<code>target.m()</code>内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p><p>下面是一个例子，由于<code>this</code>指向的变化，导致 Proxy 无法代理目标对象。</p><pre><code class="javascript">const _name = new WeakMap();

class Person &#123;
  constructor(name) &#123;
    _name.set(this, name);
  &#125;
  get name() &#123;
    return _name.get(this);
  &#125;
&#125;

const jane = new Person(&#39;Jane&#39;);
jane.name // &#39;Jane&#39;

const proxy = new Proxy(jane, &#123;&#125;);
proxy.name // undefined
</code></pre><p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p><p><strong>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</strong></p><pre><code class="javascript">const target = new Date();
const handler = &#123;&#125;;
const proxy = new Proxy(target, handler);

proxy.getDate();
// TypeError: this is not a Date object.
</code></pre><p>上面代码中，<code>getDate()</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。<strong>这时，<code>this</code>绑定原始对象，就可以解决这个问题。</strong></p><pre><code class="javascript">const target = new Date(&#39;2015-01-01&#39;);
const handler = &#123;
  get(target, prop) &#123;
    if (prop === &#39;getDate&#39;) &#123;
      return target.getDate.bind(target);
    &#125;
    return Reflect.get(target, prop);
  &#125;
&#125;;
const proxy = new Proxy(target, handler);

proxy.getDate() // 1
</code></pre><p><strong>另外，Proxy 拦截函数内部的<code>this</code>，指向的是<code>handler</code>对象。</strong></p><pre><code class="javascript">const handler = &#123;
  get: function (target, key, receiver) &#123;
    console.log(this === handler);
    return &#39;Hello, &#39; + key;
  &#125;,
  set: function (target, key, value) &#123;
    console.log(this === handler);
    target[key] = value;
    return true;
  &#125;
&#125;;

const proxy = new Proxy(&#123;&#125;, handler);

proxy.foo
// true
// Hello, foo

proxy.foo = 1
// true
</code></pre><p>上面例子中，<code>get()</code>和<code>set()</code>拦截函数内部的<code>this</code>，指向的都是<code>handler</code>对象。</p><hr><h4 id="5-实例：Web-服务的客户端"><a href="#5-实例：Web-服务的客户端" class="headerlink" title="5. 实例：Web 服务的客户端"></a>5. 实例：Web 服务的客户端</h4><p>Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。</p><pre><code class="javascript">const service = createWebService(&#39;http://example.com/data&#39;);

service.employees().then(json =&gt; &#123;
  const employees = JSON.parse(json);
  // ···
&#125;);
</code></pre><p>上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。</p><pre><code class="javascript">function createWebService(baseUrl) &#123;
  return new Proxy(&#123;&#125;, &#123;
    get(target, propKey, receiver) &#123;
      return () =&gt; httpGet(baseUrl + &#39;/&#39; + propKey);
    &#125;
  &#125;);
&#125;
</code></pre><p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p><h3 id="15、-Reflect"><a href="#15、-Reflect" class="headerlink" title="15、 Reflect"></a>15、 Reflect</h3><hr><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h4><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p><p><strong>（1） 将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</strong>移动</p><p><strong>（2） 修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</strong>修改</p><pre><code class="javascript">// 老写法
try &#123;
  Object.defineProperty(target, property, attributes);
  // success
&#125; catch (e) &#123;
  // failure
&#125;

// 新写法
if (Reflect.defineProperty(target, property, attributes)) &#123;
  // success
&#125; else &#123;
  // failure
&#125;
</code></pre><p><strong>（3） 让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</strong>函数</p><pre><code class="javascript">// 老写法
&#39;assign&#39; in Object // true

// 新写法
Reflect.has(Object, &#39;assign&#39;) // true
</code></pre><p><strong>（4）<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</strong>proxy</p><pre><code class="javascript">Proxy(target, &#123;
  set: function(target, name, value, receiver) &#123;
    var success = Reflect.set(target, name, value, receiver);
    if (success) &#123;
      console.log(&#39;property &#39; + name + &#39; on &#39; + target + &#39; set to &#39; + value);
    &#125;
    return success;
  &#125;
&#125;);
</code></pre><p>上面代码中，<code>Proxy</code>方法拦截<code>target</code>对象的属性赋值行为。它采用<code>Reflect.set</code>方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。</p><p>下面是另一个例子。</p><pre><code class="javascript">var loggedObj = new Proxy(obj, &#123;
  get(target, name) &#123;
    console.log(&#39;get&#39;, target, name);
    return Reflect.get(target, name);
  &#125;,
  deleteProperty(target, name) &#123;
    console.log(&#39;delete&#39; + name);
    return Reflect.deleteProperty(target, name);
  &#125;,
  has(target, name) &#123;
    console.log(&#39;has&#39; + name);
    return Reflect.has(target, name);
  &#125;
&#125;);
</code></pre><p>上面代码中，每一个<code>Proxy</code>对象的拦截操作（<code>get</code>、<code>delete</code>、<code>has</code>），内部都调用对应的<code>Reflect</code>方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p><p>有了<code>Reflect</code>对象以后，很多操作会更易读。</p><pre><code class="javascript">// 老写法
Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1

// 新写法
Reflect.apply(Math.floor, undefined, [1.75]) // 1
</code></pre><hr><h4 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h4><p><code>Reflect</code>对象一共有 13 个静态方法。</p><ul><li>Reflect.apply(target, thisArg, args)</li><li>Reflect.construct(target, args)</li><li>Reflect.get(target, name, receiver)</li><li>Reflect.set(target, name, value, receiver)</li><li>Reflect.defineProperty(target, name, desc)</li><li>Reflect.deleteProperty(target, name)</li><li>Reflect.has(target, name)</li><li>Reflect.ownKeys(target)</li><li>Reflect.isExtensible(target)</li><li>Reflect.preventExtensions(target)</li><li>Reflect.getOwnPropertyDescriptor(target, name)</li><li>Reflect.getPrototypeOf(target)</li><li>Reflect.setPrototypeOf(target, prototype)</li></ul><p>上面这些方法的作用，大部分与<code>Object</code>对象的同名方法的作用都是相同的，而且它与<code>Proxy</code>对象的方法是一一对应的。下面是对它们的解释。</p><p><strong>如果第一个参数不是对象，<code>Reflect</code>的这些方法会报错。</strong></p><hr><p><strong>Reflect.get(target, name, receiver)</strong></p><p><strong><code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code>。</strong></p><pre><code class="javascript">var myObject = &#123;
  foo: 1,
  bar: 2,
  get baz() &#123;
    return this.foo + this.bar;
  &#125;,
&#125;

Reflect.get(myObject, &#39;foo&#39;) // 1
Reflect.get(myObject, &#39;bar&#39;) // 2
Reflect.get(myObject, &#39;baz&#39;) // 3
</code></pre><p><strong>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定<code>receiver</code>。</strong></p><pre><code class="javascript">var myObject = &#123;
  foo: 1,
  bar: 2,
  get baz() &#123;
    return this.foo + this.bar;
  &#125;,
&#125;;

var myReceiverObject = &#123;
  foo: 4,
  bar: 4,
&#125;;

Reflect.get(myObject, &#39;baz&#39;, myReceiverObject) // 8
</code></pre><p>如果第一个参数不是对象，<code>Reflect.get</code>方法会报错。</p><pre><code class="javascript">Reflect.get(1, &#39;foo&#39;) // 报错
Reflect.get(false, &#39;foo&#39;) // 报错
</code></pre><hr><p><strong>Reflect.set(target, name, value, receiver)</strong></p><p><strong><code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code>。</strong></p><pre><code class="javascript">var myObject = &#123;
  foo: 1,
  set bar(value) &#123;
    return this.foo = value;
  &#125;,
&#125;

myObject.foo // 1

Reflect.set(myObject, &#39;foo&#39;, 2);
myObject.foo // 2

Reflect.set(myObject, &#39;bar&#39;, 3)
myObject.foo // 3
</code></pre><p><strong>如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定<code>receiver</code>。</strong></p><pre><code class="javascript">var myObject = &#123;
  foo: 4,
  set bar(value) &#123;
    return this.foo = value;
  &#125;,
&#125;;

var myReceiverObject = &#123;
  foo: 0,
&#125;;

Reflect.set(myObject, &#39;bar&#39;, 1, myReceiverObject);
myObject.foo // 4
myReceiverObject.foo // 1
</code></pre><p>注意，如果 <code>Proxy</code>对象和 <code>Reflect</code>对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了<code>receiver</code>，那么<code>Reflect.set</code>会触发<code>Proxy.defineProperty</code>拦截。</p><pre><code class="javascript">let p = &#123;
  a: &#39;a&#39;
&#125;;

let handler = &#123;
  set(target, key, value, receiver) &#123;
    console.log(&#39;set&#39;);
    Reflect.set(target, key, value, receiver)
  &#125;,
  defineProperty(target, key, attribute) &#123;
    console.log(&#39;defineProperty&#39;);
    Reflect.defineProperty(target, key, attribute);
  &#125;
&#125;;

let obj = new Proxy(p, handler);
obj.a = &#39;A&#39;;
// set
// defineProperty
</code></pre><p>上面代码中，<code>Proxy.set</code>拦截里面使用了<code>Reflect.set</code>，而且传入了<code>receiver</code>，导致触发<code>Proxy.defineProperty</code>拦截。这是因为<code>Proxy.set</code>的<code>receiver</code>参数总是指向当前的 <code>Proxy</code>实例（即上例的<code>obj</code>），而<code>Reflect.set</code>一旦传入<code>receiver</code>，就会将属性赋值到<code>receiver</code>上面（即<code>obj</code>），导致触发<code>defineProperty</code>拦截。<strong>如果<code>Reflect.set</code>没有传入<code>receiver</code>，那么就不会触发<code>defineProperty</code>拦w截。</strong></p><pre><code class="javascript">let p = &#123;
  a: &#39;a&#39;
&#125;;

let handler = &#123;
  set(target, key, value, receiver) &#123;
    console.log(&#39;set&#39;);
    Reflect.set(target, key, value)
  &#125;,
  defineProperty(target, key, attribute) &#123;
    console.log(&#39;defineProperty&#39;);
    Reflect.defineProperty(target, key, attribute);
  &#125;
&#125;;

let obj = new Proxy(p, handler);
obj.a = &#39;A&#39;;
// set
</code></pre><p>如果第一个参数不是对象，<code>Reflect.set</code>会报错。</p><pre><code class="javascript">Reflect.set(1, &#39;foo&#39;, &#123;&#125;) // 报错
Reflect.set(false, &#39;foo&#39;, &#123;&#125;) // 报错
</code></pre><hr><p><strong>Reflect.has(obj, name)</strong></p><p><strong><code>Reflect.has</code>方法对应<code>name in obj</code>里面的<code>in</code>运算符。</strong></p><pre><code class="javascript">var myObject = &#123;
  foo: 1,
&#125;;

// 旧写法
&#39;foo&#39; in myObject // true

// 新写法
Reflect.has(myObject, &#39;foo&#39;) // true
</code></pre><p>如果<code>Reflect.has()</code>方法的第一个参数不是对象，会报错。</p><hr><p><strong>Reflect.deleteProperty(obj, name)</strong></p><p><strong><code>Reflect.deleteProperty</code>方法等同于<code>delete obj[name]</code>，用于删除对象的属性。</strong></p><pre><code class="javascript">const myObj = &#123; foo: &#39;bar&#39; &#125;;

// 旧写法
delete myObj.foo;

// 新写法
Reflect.deleteProperty(myObj, &#39;foo&#39;);
</code></pre><p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回<code>true</code>；删除失败，被删除的属性依然存在，返回<code>false</code>。</p><p>如果<code>Reflect.deleteProperty()</code>方法的第一个参数不是对象，会报错。</p><hr><p><strong>Reflect.construct(target, args)</strong></p><p><code>Reflect.construct</code>方法等同于<code>new target(...args)</code>，这提供了一种不使用<code>new</code>，来调用构造函数的方法。</p><pre><code class="javascript">function Greeting(name) &#123;
  this.name = name;
&#125;

// new 的写法
const instance = new Greeting(&#39;张三&#39;);

// Reflect.construct 的写法
const instance = Reflect.construct(Greeting, [&#39;张三&#39;]);
</code></pre><p>如果<code>Reflect.construct()</code>方法的第一个参数不是函数，会报错。</p><hr><p><strong>Reflect.getPrototypeOf(obj)</strong></p><p><code>Reflect.getPrototypeOf</code>方法用于读取对象的<code>__proto__</code>属性，对应<code>Object.getPrototypeOf(obj)</code>。</p><pre><code class="javascript">const myObj = new FancyThing();

// 旧写法
Object.getPrototypeOf(myObj) === FancyThing.prototype;

// 新写法
Reflect.getPrototypeOf(myObj) === FancyThing.prototype;
</code></pre><p><code>Reflect.getPrototypeOf</code>和<code>Object.getPrototypeOf</code>的一个区别是，如果参数不是对象，<code>Object.getPrototypeOf</code>会将这个参数转为对象，然后再运行，而<code>Reflect.getPrototypeOf</code>会报错。</p><pre><code class="javascript">Object.getPrototypeOf(1) // Number &#123;[[PrimitiveValue]]: 0&#125;
Reflect.getPrototypeOf(1) // 报错
</code></pre><hr><p><strong>Reflect.setPrototypeOf(obj, newProto)</strong></p><p><code>Reflect.setPrototypeOf</code>方法用于设置目标对象的原型（prototype），对应<code>Object.setPrototypeOf(obj, newProto)</code>方法。它返回一个布尔值，表示是否设置成功。</p><pre><code class="javascript">const myObj = &#123;&#125;;

// 旧写法
Object.setPrototypeOf(myObj, Array.prototype);

// 新写法
Reflect.setPrototypeOf(myObj, Array.prototype);

myObj.length // 0
</code></pre><p><strong>如果无法设置目标对象的原型（比如，目标对象禁止扩展），<code>Reflect.setPrototypeOf</code>方法返回<code>false</code>。</strong></p><pre><code class="javascript">Reflect.setPrototypeOf(&#123;&#125;, null)
// true
Reflect.setPrototypeOf(Object.freeze(&#123;&#125;), null)
// false
</code></pre><p>如果第一个参数不是对象，<code>Object.setPrototypeOf</code>会返回第一个参数本身，而<code>Reflect.setPrototypeOf</code>会报错。</p><pre><code class="javascript">Object.setPrototypeOf(1, &#123;&#125;)
// 1

Reflect.setPrototypeOf(1, &#123;&#125;)
// TypeError: Reflect.setPrototypeOf called on non-object
</code></pre><p>如果第一个参数是<code>undefined</code>或<code>null</code>，<code>Object.setPrototypeOf</code>和<code>Reflect.setPrototypeOf</code>都会报错。</p><pre><code class="javascript">Object.setPrototypeOf(null, &#123;&#125;)
// TypeError: Object.setPrototypeOf called on null or undefined

Reflect.setPrototypeOf(null, &#123;&#125;)
// TypeError: Reflect.setPrototypeOf called on non-object
</code></pre><hr><p><strong>Reflect.apply(func, thisArg, args)</strong></p><p><code>Reflect.apply</code>方法等同于<code>Function.prototype.apply.call(func, thisArg, args)</code>，用于绑定<code>this</code>对象后执行给定函数。</p><p>一般来说，如果要绑定一个函数的<code>this</code>对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的<code>apply</code>方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用<code>Reflect</code>对象可以简化这种操作。</p><pre><code class="javascript">const ages = [11, 33, 12, 54, 18, 96];

// 旧写法
const youngest = Math.min.apply(Math, ages);
const oldest = Math.max.apply(Math, ages);
const type = Object.prototype.toString.call(youngest);

// 新写法
const youngest = Reflect.apply(Math.min, Math, ages);
const oldest = Reflect.apply(Math.max, Math, ages);
const type = Reflect.apply(Object.prototype.toString, youngest, []);
</code></pre><hr><p><strong>Reflect.defineProperty(target, propertyKey, attributes)</strong></p><p><code>Reflect.defineProperty</code>方法基本等同于<code>Object.defineProperty</code>，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用<code>Reflect.defineProperty</code>代替它。</p><pre><code class="javascript">function MyDate() &#123;
  /*…*/
&#125;

// 旧写法
Object.defineProperty(MyDate, &#39;now&#39;, &#123;
  value: () =&gt; Date.now()
&#125;);

// 新写法
Reflect.defineProperty(MyDate, &#39;now&#39;, &#123;
  value: () =&gt; Date.now()
&#125;);
</code></pre><p>如果<code>Reflect.defineProperty</code>的第一个参数不是对象，就会抛出错误，比如<code>Reflect.defineProperty(1, &#39;foo&#39;)</code>。</p><p>这个方法可以与<code>Proxy.defineProperty</code>配合使用。</p><pre><code class="javascript">const p = new Proxy(&#123;&#125;, &#123;
  defineProperty(target, prop, descriptor) &#123;
    console.log(descriptor);
    return Reflect.defineProperty(target, prop, descriptor);
  &#125;
&#125;);

p.foo = &#39;bar&#39;;
// &#123;value: &quot;bar&quot;, writable: true, enumerable: true, configurable: true&#125;

p.foo // &quot;bar&quot;
</code></pre><p>上面代码中，<code>Proxy.defineProperty</code>对属性赋值设置了拦截，然后使用<code>Reflect.defineProperty</code>完成了赋值。</p><hr><p><strong>Reflect.getOwnPropertyDescriptor(target, propertyKey)</strong></p><p><code>Reflect.getOwnPropertyDescriptor</code>基本等同于<code>Object.getOwnPropertyDescriptor</code>，用于得到指定属性的描述对象，将来会替代掉后者。</p><pre><code class="javascript">var myObject = &#123;&#125;;
Object.defineProperty(myObject, &#39;hidden&#39;, &#123;
  value: true,
  enumerable: false,
&#125;);

// 旧写法
var theDescriptor = Object.getOwnPropertyDescriptor(myObject, &#39;hidden&#39;);

// 新写法
var theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, &#39;hidden&#39;);
</code></pre><p><code>Reflect.getOwnPropertyDescriptor</code>和<code>Object.getOwnPropertyDescriptor</code>的一个区别是，如果第一个参数不是对象，<code>Object.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>不报错，返回<code>undefined</code>，而<code>Reflect.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>会抛出错误，表示参数非法。</p><hr><p><strong>Reflect.isExtensible (target)</strong></p><p><code>Reflect.isExtensible</code>方法对应<code>Object.isExtensible</code>，返回一个布尔值，表示当前对象是否可扩展。</p><pre><code class="javascript">const myObject = &#123;&#125;;

// 旧写法
Object.isExtensible(myObject) // true

// 新写法
Reflect.isExtensible(myObject) // true
</code></pre><p>如果参数不是对象，<code>Object.isExtensible</code>会返回<code>false</code>，因为非对象本来就是不可扩展的，而<code>Reflect.isExtensible</code>会报错。</p><pre><code class="javascript">Object.isExtensible(1) // false
Reflect.isExtensible(1) // 报错
</code></pre><hr><p><strong>Reflect.preventExtensions(target)</strong></p><p><code>Reflect.preventExtensions</code>对应<code>Object.preventExtensions</code>方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</p><pre><code class="javascript">var myObject = &#123;&#125;;

// 旧写法
Object.preventExtensions(myObject) // Object &#123;&#125;

// 新写法
Reflect.preventExtensions(myObject) // true
</code></pre><p>如果参数不是对象，<code>Object.preventExtensions</code>在 ES5 环境报错，在 ES6 环境返回传入的参数，而<code>Reflect.preventExtensions</code>会报错。</p><pre><code class="javascript">// ES5 环境
Object.preventExtensions(1) // 报错

// ES6 环境
Object.preventExtensions(1) // 1

// 新写法
Reflect.preventExtensions(1) // 报错
</code></pre><hr><p><strong>Reflect.ownKeys (target)</strong></p><p><code>Reflect.ownKeys</code>方法用于返回对象的所有属性，基本等同于<code>Object.getOwnPropertyNames</code>与<code>Object.getOwnPropertySymbols</code>之和。</p><pre><code class="javascript">var myObject = &#123;
  foo: 1,
  bar: 2,
  [Symbol.for(&#39;baz&#39;)]: 3,
  [Symbol.for(&#39;bing&#39;)]: 4,
&#125;;

// 旧写法
Object.getOwnPropertyNames(myObject)
// [&#39;foo&#39;, &#39;bar&#39;]

Object.getOwnPropertySymbols(myObject)
//[Symbol(baz), Symbol(bing)]

// 新写法
Reflect.ownKeys(myObject)
// [&#39;foo&#39;, &#39;bar&#39;, Symbol(baz), Symbol(bing)]
</code></pre><p>如果<code>Reflect.ownKeys()</code>方法的第一个参数不是对象，会报错。</p><hr><h4 id="3-实例：使用-Proxy-实现观察者模式"><a href="#3-实例：使用-Proxy-实现观察者模式" class="headerlink" title="3. 实例：使用 Proxy 实现观察者模式"></a>3. 实例：使用 Proxy 实现观察者模式</h4><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p><pre><code class="javascript">const person = observable(&#123;
  name: &#39;张三&#39;,
  age: 20
&#125;);

function print() &#123;
  console.log(`$&#123;person.name&#125;, $&#123;person.age&#125;`)
&#125;

observe(print);
person.name = &#39;李四&#39;;
// 输出
// 李四, 20
</code></pre><p>上面代码中，数据对象<code>person</code>是观察目标，函数<code>print</code>是观察者。一旦数据对象发生变化，<code>print</code>就会自动执行。</p><p>下面，使用 Proxy 写一个观察者模式的最简单实现，即实现<code>observable</code>和<code>observe</code>这两个函数。思路是<code>observable</code>函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。</p><pre><code class="javascript">const queuedObservers = new Set();

const observe = fn =&gt; queuedObservers.add(fn);
const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);

function set(target, key, value, receiver) &#123;
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer =&gt; observer());
  return result;
&#125;
</code></pre><p>上面代码中，<strong>先定义了一个<code>Set</code>集合，所有观察者函数都放进这个集合。然后，<code>observable</code>函数返回原始对象的代理，拦截赋值操作。拦截函数<code>set</code>之中，会自动执行所有观察者。</strong></p><h3 id="16、-Promise-对象"><a href="#16、-Promise-对象" class="headerlink" title="16、 Promise 对象"></a>16、 Promise 对象</h3><hr><h4 id="1-Promise-的含义"><a href="#1-Promise-的含义" class="headerlink" title="1. Promise 的含义"></a>1. Promise 的含义</h4><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p><p><strong>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</strong></p><p><code>Promise</code>对象有以下两个特点。</p><p>（1）<strong>对象的状态不受外界影响</strong>。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p><p>（2）<strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果。</strong><code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p><p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p><p><code>Promise</code>也有一些缺点。<strong>首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。</strong>其次，<strong>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部</strong>。第三，<strong>当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</strong>。</p><p>如果某些事件不断地反复发生，一般来说，使用 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbA==">Stream</span> 模式是比部署<code>Promise</code>更好的选择。</p><h4 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2. 基本用法"></a>2. 基本用法</h4><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p><p>下面代码创造了一个<code>Promise</code>实例。</p><pre><code class="javascript">const promise = new Promise(function(resolve, reject) &#123;
  // ... some code

  if (/* 异步操作成功 */)&#123;
    resolve(value);
  &#125; else &#123;
    reject(error);
  &#125;
&#125;);
</code></pre><p>**<code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>**。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p><strong><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”</strong>（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；**<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”**（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p><pre><code class="javascript">promise.then(function(value) &#123;
  // success
&#125;, function(error) &#123;
  // failure
&#125;);
</code></pre><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。这两个函数都是可选的，不一定要提供。它们都接受<code>Promise</code>对象传出的值作为参数。</p><p>下面是一个<code>Promise</code>对象的简单例子。</p><pre><code class="javascript">function timeout(ms) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    setTimeout(resolve, ms, &#39;done&#39;);
  &#125;);
&#125;

timeout(100).then((value) =&gt; &#123;
  console.log(value);
&#125;);
</code></pre><p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p><p>Promise 新建后就会立即执行。</p><pre><code class="javascript">let promise = new Promise(function(resolve, reject) &#123;
  console.log(&#39;Promise&#39;);
  resolve();
&#125;);

promise.then(function() &#123;
  console.log(&#39;resolved.&#39;);
&#125;);

console.log(&#39;Hi!&#39;);

// Promise
// Hi!
// resolved
</code></pre><p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p><p>下面是异步加载图片的例子。</p><pre><code class="javascript">function loadImageAsync(url) &#123;
  return new Promise(function(resolve, reject) &#123;
    const image = new Image();

    image.onload = function() &#123;
      resolve(image);
    &#125;;

    image.onerror = function() &#123;
      reject(new Error(&#39;Could not load image at &#39; + url));
    &#125;;

    image.src = url;
  &#125;);
&#125;
</code></pre><p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p><p>下面是一个用<code>Promise</code>对象实现的 Ajax 操作的例子。</p><pre><code class="javascript">const getJSON = function(url) &#123;
  const promise = new Promise(function(resolve, reject)&#123;
    const handler = function() &#123;
      if (this.readyState !== 4) &#123;
        return;
      &#125;
      if (this.status === 200) &#123;
        resolve(this.response);
      &#125; else &#123;
        reject(new Error(this.statusText));
      &#125;
    &#125;;
    const client = new XMLHttpRequest();
    client.open(&quot;GET&quot;, url);
    client.onreadystatechange = handler;
    client.responseType = &quot;json&quot;;
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
    client.send();

  &#125;);

  return promise;
&#125;;

getJSON(&quot;/posts.json&quot;).then(function(json) &#123;
  console.log(&#39;Contents: &#39; + json);
&#125;, function(error) &#123;
  console.error(&#39;出错了&#39;, error);
&#125;);
</code></pre><p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p><p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p><pre><code class="javascript">const p1 = new Promise(function (resolve, reject) &#123;
  // ...
&#125;);

const p2 = new Promise(function (resolve, reject) &#123;
  // ...
  resolve(p1);
&#125;)
</code></pre><p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p><pre><code class="javascript">const p1 = new Promise(function (resolve, reject) &#123;
  setTimeout(() =&gt; reject(new Error(&#39;fail&#39;)), 3000)
&#125;)

const p2 = new Promise(function (resolve, reject) &#123;
  setTimeout(() =&gt; resolve(p1), 1000)
&#125;)

p2
  .then(result =&gt; console.log(result))
  .catch(error =&gt; console.log(error))
// Error: fail
</code></pre><p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p><p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p><pre><code class="javascript">new Promise((resolve, reject) =&gt; &#123;
  resolve(1);
  console.log(2);
&#125;).then(r =&gt; &#123;
  console.log(r);
&#125;);
// 2
// 1
</code></pre><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p><pre><code class="javascript">new Promise((resolve, reject) =&gt; &#123;
  return resolve(1);
  // 后面的语句不会执行
  console.log(2);
&#125;)
</code></pre><h4 id="3-Promise-prototype-then"><a href="#3-Promise-prototype-then" class="headerlink" title="3. Promise.prototype.then()"></a>3. Promise.prototype.then()</h4><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数，它们都是可选的。</p><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><pre><code class="javascript">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;
  return json.post;
&#125;).then(function(post) &#123;
  // ...
&#125;);
</code></pre><p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p><p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p><pre><code class="javascript">getJSON(&quot;/post/1.json&quot;).then(function(post) &#123;
  return getJSON(post.commentURL);
&#125;).then(function (comments) &#123;
  console.log(&quot;resolved: &quot;, comments);
&#125;, function (err)&#123;
  console.log(&quot;rejected: &quot;, err);
&#125;);
</code></pre><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p><p>如果采用箭头函数，上面的代码可以写得更简洁。</p><pre><code class="javascript">getJSON(&quot;/post/1.json&quot;).then(
  post =&gt; getJSON(post.commentURL)
).then(
  comments =&gt; console.log(&quot;resolved: &quot;, comments),
  err =&gt; console.log(&quot;rejected: &quot;, err)
);
</code></pre><hr><h4 id="4-Promise-prototype-catch"><a href="#4-Promise-prototype-catch" class="headerlink" title="4. Promise.prototype.catch()"></a>4. Promise.prototype.catch()</h4><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><pre><code class="javascript">getJSON(&#39;/posts.json&#39;).then(function(posts) &#123;
  // ...
&#125;).catch(function(error) &#123;
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log(&#39;发生错误！&#39;, error);
&#125;);
</code></pre><p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象，<strong>如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</strong></p><pre><code class="javascript">p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))
  .catch((err) =&gt; console.log(&#39;rejected&#39;, err));

// 等同于
p.then((val) =&gt; console.log(&#39;fulfilled:&#39;, val))
  .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err));
</code></pre><p>下面是一个例子。</p><pre><code class="javascript">const promise = new Promise(function(resolve, reject) &#123;
  throw new Error(&#39;test&#39;);
&#125;);
promise.catch(function(error) &#123;
  console.log(error);
&#125;);
// Error: test
</code></pre><p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p><pre><code class="javascript">// 写法一
const promise = new Promise(function(resolve, reject) &#123;
  try &#123;
    throw new Error(&#39;test&#39;);
  &#125; catch(e) &#123;
    reject(e);
  &#125;
&#125;);
promise.catch(function(error) &#123;
  console.log(error);
&#125;);

// 写法二
const promise = new Promise(function(resolve, reject) &#123;
  reject(new Error(&#39;test&#39;));
&#125;);
promise.catch(function(error) &#123;
  console.log(error);
&#125;);
</code></pre><p>比较上面两种写法，<strong>可以发现<code>reject()</code>方法的作用，等同于抛出错误。</strong></p><p>如果 Promise 状态已经变成<code>resolved</code>，再抛出错误是无效的。</p><pre><code class="javascript">const promise = new Promise(function(resolve, reject) &#123;
  resolve(&#39;ok&#39;);
  throw new Error(&#39;test&#39;);
&#125;);
promise
  .then(function(value) &#123; console.log(value) &#125;)
  .catch(function(error) &#123; console.log(error) &#125;);
// ok
</code></pre><p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p><pre><code class="javascript">getJSON(&#39;/post/1.json&#39;).then(function(post) &#123;
  return getJSON(post.commentURL);
&#125;).then(function(comments) &#123;
  // some code
&#125;).catch(function(error) &#123;
  // 处理前面三个Promise产生的错误
&#125;);
</code></pre><p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p><p><strong>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</strong></p><pre><code class="javascript">// bad
promise
  .then(function(data) &#123;
    // success
  &#125;, function(err) &#123;
    // error
  &#125;);

// good
promise
  .then(function(data) &#123; //cb
    // success
  &#125;)
  .catch(function(err) &#123;
    // error
  &#125;);
</code></pre><p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</p><p><strong>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</strong></p><pre><code class="javascript">const someAsyncThing = function() &#123;
  return new Promise(function(resolve, reject) &#123;
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  &#125;);
&#125;;

someAsyncThing().then(function() &#123;
  console.log(&#39;everything is great&#39;);
&#125;);

setTimeout(() =&gt; &#123; console.log(123) &#125;, 2000);
// Uncaught (in promise) ReferenceError: x is not defined
// 123
</code></pre><p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程、终止脚本执行，2 秒之后还是会输出<code>123</code>。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p><p>这个脚本放在服务器执行，退出码就是<code>0</code>（即表示执行成功）。不过，Node.js 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p><pre><code class="javascript">process.on(&#39;unhandledRejection&#39;, function (err, p) &#123;
  throw err;
&#125;);
</code></pre><p>上面代码中，<code>unhandledRejection</code>事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</p><p>注意，Node 有计划在未来废除<code>unhandledRejection</code>事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p><p>再看下面的例子。</p><pre><code class="javascript">const promise = new Promise(function (resolve, reject) &#123;
  resolve(&#39;ok&#39;);
  setTimeout(function () &#123; throw new Error(&#39;test&#39;) &#125;, 0)
&#125;);
promise.then(function (value) &#123; console.log(value) &#125;);
// ok
// Uncaught Error: test
</code></pre><p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p><p><strong>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。</strong><code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p><pre><code class="javascript">const someAsyncThing = function() &#123;
  return new Promise(function(resolve, reject) &#123;
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  &#125;);
&#125;;

someAsyncThing()
.catch(function(error) &#123;
  console.log(&#39;oh no&#39;, error);
&#125;)
.then(function() &#123;
  console.log(&#39;carry on&#39;);
&#125;);
// oh no [ReferenceError: x is not defined]
// carry on
</code></pre><p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。如果没有报错，则会跳过<code>catch()</code>方法。</p><pre><code class="javascript">Promise.resolve()
.catch(function(error) &#123;
  console.log(&#39;oh no&#39;, error);
&#125;)
.then(function() &#123;
  console.log(&#39;carry on&#39;);
&#125;);
// carry on
</code></pre><p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p><p><code>catch()</code>方法之中，还能再抛出错误。</p><pre><code class="javascript">const someAsyncThing = function() &#123;
  return new Promise(function(resolve, reject) &#123;
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  &#125;);
&#125;;

someAsyncThing().then(function() &#123;
  return someOtherAsyncThing();
&#125;).catch(function(error) &#123;
  console.log(&#39;oh no&#39;, error);
  // 下面一行会报错，因为 y 没有声明
  y + 2;
&#125;).then(function() &#123;
  console.log(&#39;carry on&#39;);
&#125;);
// oh no [ReferenceError: x is not defined]
</code></pre><p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p><pre><code class="javascript">someAsyncThing().then(function() &#123;
  return someOtherAsyncThing();
&#125;).catch(function(error) &#123;
  console.log(&#39;oh no&#39;, error);
  // 下面一行会报错，因为y没有声明
  y + 2;
&#125;).catch(function(error) &#123;
  console.log(&#39;carry on&#39;, error);
&#125;);
// oh no [ReferenceError: x is not defined]
// carry on [ReferenceError: y is not defined]
</code></pre><p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p><hr><h4 id="5-Promise-prototype-finally"><a href="#5-Promise-prototype-finally" class="headerlink" title="5. Promise.prototype.finally()"></a>5. Promise.prototype.finally()</h4><p><strong><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</strong></p><pre><code class="javascript">promise
.then(result =&gt; &#123;···&#125;)
.catch(error =&gt; &#123;···&#125;)
.finally(() =&gt; &#123;···&#125;);
</code></pre><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p><pre><code class="javascript">server.listen(port)
  .then(function () &#123;
    // ...
  &#125;)
  .finally(server.stop);
</code></pre><p><strong><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果</strong>。</p><p><code>finally</code>本质上是<code>then</code>方法的特例。</p><pre><code class="javascript">promise
.finally(() =&gt; &#123;
  // 语句
&#125;);

// 等同于
promise
.then(
  result =&gt; &#123;
    // 语句
    return result;
  &#125;,
  error =&gt; &#123;
    // 语句
    throw error;
  &#125;
);
</code></pre><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p><p>它的实现也很简单。</p><pre><code class="javascript">Promise.prototype.finally = function (callback) &#123;
  let P = this.constructor;
  return this.then(
    value  =&gt; P.resolve(callback()).then(() =&gt; value),
    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;)
  );
&#125;;
</code></pre><p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p><p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值。</p><pre><code class="javascript">// resolve 的值是 undefined
Promise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)

// resolve 的值是 2
Promise.resolve(2).finally(() =&gt; &#123;&#125;)

// reject 的值是 undefined
Promise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)

// reject 的值是 3
Promise.reject(3).finally(() =&gt; &#123;&#125;)
</code></pre><hr><h4 id="6-Promise-all"><a href="#6-Promise-all" class="headerlink" title="6. Promise.all()"></a>6. Promise.all()</h4><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><pre><code class="javascript">const p = Promise.all([p1, p2, p3]);
</code></pre><p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，<strong>如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例</strong>，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><p><strong>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</strong></p><p><strong>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</strong></p><p>下面是一个具体的例子。</p><pre><code class="javascript">// 生成一个Promise对象的数组
const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123;
  return getJSON(&#39;/post/&#39; + id + &quot;.json&quot;);
&#125;);

Promise.all(promises).then(function (posts) &#123;
  // ...
&#125;).catch(function(reason)&#123;
  // ...
&#125;);
</code></pre><p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p><p>下面是另一个例子。</p><pre><code class="javascript">const databasePromise = connectDatabase();

const booksPromise = databasePromise
  .then(findAllBooks);

const userPromise = databasePromise
  .then(getCurrentUser);

Promise.all([
  booksPromise,
  userPromise
])
.then(([books, user]) =&gt; pickTopRecommendations(books, user));
</code></pre><p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p><p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p><pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;hello&#39;);
&#125;)
.then(result =&gt; result)
.catch(e =&gt; e);

const p2 = new Promise((resolve, reject) =&gt; &#123;
  throw new Error(&#39;报错了&#39;);
&#125;)
.then(result =&gt; result)
.catch(e =&gt; e);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// [&quot;hello&quot;, Error: 报错了]
</code></pre><p>上面代码中，<code>p1</code>会<code>resolved</code>，**<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>**，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p><p><strong>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</strong></p><pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;hello&#39;);
&#125;)
.then(result =&gt; result);

const p2 = new Promise((resolve, reject) =&gt; &#123;
  throw new Error(&#39;报错了&#39;);
&#125;)
.then(result =&gt; result);

Promise.all([p1, p2])
.then(result =&gt; console.log(result))
.catch(e =&gt; console.log(e));
// Error: 报错了
</code></pre><hr><h4 id="7-Promise-race"><a href="#7-Promise-race" class="headerlink" title="7. Promise.race()"></a>7. Promise.race()</h4><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><pre><code class="javascript">const p = Promise.race([p1, p2, p3]);
</code></pre><p>上面代码中<strong>，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</strong></p><p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p><p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p><pre><code class="javascript">const p = Promise.race([
  fetch(&#39;/resource-that-may-take-a-while&#39;),
  new Promise(function (resolve, reject) &#123;
    setTimeout(() =&gt; reject(new Error(&#39;request timeout&#39;)), 5000)
  &#125;)
]);

p
.then(console.log)
.catch(console.error);
</code></pre><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p><hr><h4 id="8-Promise-allSettled"><a href="#8-Promise-allSettled" class="headerlink" title="8. Promise.allSettled()"></a>8. Promise.allSettled()</h4><p>有时候，我们希望等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。但是，现有的 Promise 方法很难实现这个要求。</p><p><code>Promise.all()</code>方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求。</p><pre><code class="javascript">const urls = [url_1, url_2, url_3];
const requests = urls.map(x =&gt; fetch(x));

try &#123;
  await Promise.all(requests);
  console.log(&#39;所有请求都成功。&#39;);
&#125; catch &#123;
  console.log(&#39;至少一个请求失败，其他请求可能还没结束。&#39;);
&#125;
</code></pre><p>上面示例中，<code>Promise.all()</code>可以确定所有请求都成功了，但是只要有一个请求失败，它就会报错，而不管另外的请求是否结束。</p><p>为了解决这个问题，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJvbWlzZS1hbGxTZXR0bGVk">ES2020</span> 引入了<code>Promise.allSettled()</code>方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。</p><p><code>Promise.allSettled()</code>方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。<strong>只有等到参数数组的所有 Promise 对象都发生状态变更（不管是<code>fulfilled</code>还是<code>rejected</code>），返回的 Promise 对象才会发生状态变更。</strong></p><pre><code class="javascript">const promises = [
  fetch(&#39;/api-1&#39;),
  fetch(&#39;/api-2&#39;),
  fetch(&#39;/api-3&#39;),
];

await Promise.allSettled(promises);
removeLoadingIndicator();
</code></pre><p>上面示例中，数组<code>promises</code>包含了三个请求，只有等到这三个请求都结束了（不管请求成功还是失败），<code>removeLoadingIndicator()</code>才会执行。</p><p>该方法返回的新的 Promise 实例，一旦发生状态变更，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。</p><pre><code class="javascript">const resolved = Promise.resolve(42);
const rejected = Promise.reject(-1);

const allSettledPromise = Promise.allSettled([resolved, rejected]);

allSettledPromise.then(function (results) &#123;
  console.log(results);
&#125;);
// [
//    &#123; status: &#39;fulfilled&#39;, value: 42 &#125;,
//    &#123; status: &#39;rejected&#39;, reason: -1 &#125;
// ]
</code></pre><p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。它的回调函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应传入<code>Promise.allSettled()</code>的数组里面的两个 Promise 对象。</p><p><code>results</code>的每个成员是一个对象，对象的格式是固定的，对应异步操作的结果。</p><pre><code class="javascript">// 异步操作成功时
&#123;status: &#39;fulfilled&#39;, value: value&#125;

// 异步操作失败时
&#123;status: &#39;rejected&#39;, reason: reason&#125;
</code></pre><p>成员对象的<code>status</code>属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>，用来区分异步操作是成功还是失败。如果是成功（<code>fulfilled</code>），对象会有<code>value</code>属性，如果是失败（<code>rejected</code>），会有<code>reason</code>属性，对应两种状态时前面异步操作的返回值。</p><p>下面是返回值的用法例子。</p><pre><code class="javascript">const promises = [ fetch(&#39;index.html&#39;), fetch(&#39;https://does-not-exist/&#39;) ];
const results = await Promise.allSettled(promises);

// 过滤出成功的请求
const successfulPromises = results.filter(p =&gt; p.status === &#39;fulfilled&#39;);

// 过滤出失败的请求，并输出原因
const errors = results
  .filter(p =&gt; p.status === &#39;rejected&#39;)
  .map(p =&gt; p.reason);
</code></pre><hr><h4 id="9-Promise-any"><a href="#9-Promise-any" class="headerlink" title="9. Promise.any()"></a>9. Promise.any()</h4><p>ES2021 引入了<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。</p><pre><code class="javascript">Promise.any([
  fetch(&#39;https://v8.dev/&#39;).then(() =&gt; &#39;home&#39;),
  fetch(&#39;https://v8.dev/blog&#39;).then(() =&gt; &#39;blog&#39;),
  fetch(&#39;https://v8.dev/docs&#39;).then(() =&gt; &#39;docs&#39;)
]).then((first) =&gt; &#123;  // 只要有一个 fetch() 请求成功
  console.log(first);
&#125;).catch((error) =&gt; &#123; // 所有三个 fetch() 全部请求失败
  console.log(error);
&#125;);
</code></pre><p><strong>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</strong></p><p><strong><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是<code>Promise.any()</code>不会因为某个 Promise 变成<code>rejected</code>状态而结束，必须等到所有参数 Promise 变成<code>rejected</code>状态才会结束。</strong></p><p>下面是<code>Promise()</code>与<code>await</code>命令结合使用的例子。</p><pre><code class="javascript">const promises = [
  fetch(&#39;/endpoint-a&#39;).then(() =&gt; &#39;a&#39;),
  fetch(&#39;/endpoint-b&#39;).then(() =&gt; &#39;b&#39;),
  fetch(&#39;/endpoint-c&#39;).then(() =&gt; &#39;c&#39;),
];

try &#123;
  const first = await Promise.any(promises);
  console.log(first);
&#125; catch (error) &#123;
  console.log(error);
&#125;
</code></pre><p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p><p><code>Promise.any()</code>抛出的错误，不是一个一般的 Error 错误对象，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p><pre><code class="javascript">// new AggregateError() extends Array

const err = new AggregateError();
err.push(new Error(&quot;first error&quot;));
err.push(new Error(&quot;second error&quot;));
// ...
throw err;
</code></pre><p>下面是一个例子。</p><pre><code class="javascript">var resolved = Promise.resolve(42);
var rejected = Promise.reject(-1);
var alsoRejected = Promise.reject(Infinity);

Promise.any([resolved, rejected, alsoRejected]).then(function (result) &#123;
  console.log(result); // 42
&#125;);

Promise.any([rejected, alsoRejected]).catch(function (results) &#123;
  console.log(results); // [-1, Infinity]
&#125;);
</code></pre><hr><h4 id="10-Promise-resolve"><a href="#10-Promise-resolve" class="headerlink" title="10. Promise.resolve()"></a>10. Promise.resolve()</h4><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p><pre><code class="javascript">const jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;));
</code></pre><p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p><p><code>Promise.resolve()</code>等价于下面的写法。</p><pre><code class="javascript">Promise.resolve(&#39;foo&#39;)
// 等价于
new Promise(resolve =&gt; resolve(&#39;foo&#39;))
</code></pre><p><code>Promise.resolve()</code>方法的参数分成四种情况。</p><p><strong>（1）参数是一个 Promise 实例</strong></p><p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p><p><strong>（2）参数是一个<code>thenable</code>对象</strong></p><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p><pre><code class="javascript">let thenable = &#123;
  then: function(resolve, reject) &#123;
    resolve(42);
  &#125;
&#125;;
</code></pre><p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p><pre><code class="javascript">let thenable = &#123;
  then: function(resolve, reject) &#123;
    resolve(42);
  &#125;
&#125;;

let p1 = Promise.resolve(thenable);
p1.then(function (value) &#123;
  console.log(value);  // 42
&#125;);
</code></pre><p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出42。</p><p><strong>（3）参数不是具有<code>then()</code>方法的对象，或根本就不是对象</strong></p><p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p><pre><code class="javascript">const p = Promise.resolve(&#39;Hello&#39;);

p.then(function (s) &#123;
  console.log(s)
&#125;);
// Hello
</code></pre><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve()</code>方法的参数，会同时传给回调函数。</p><p><strong>（4）不带有任何参数</strong></p><p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p><p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p><pre><code class="javascript">const p = Promise.resolve();

p.then(function () &#123;
  // ...
&#125;);
</code></pre><p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p><p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p><pre><code class="javascript">setTimeout(function () &#123;
  console.log(&#39;three&#39;);
&#125;, 0);

Promise.resolve().then(function () &#123;
  console.log(&#39;two&#39;);
&#125;);

console.log(&#39;one&#39;);

// one
// two
// three
</code></pre><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p><hr><h4 id="11-Promise-reject"><a href="#11-Promise-reject" class="headerlink" title="11. Promise.reject()"></a>11. Promise.reject()</h4><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><pre><code class="javascript">const p = Promise.reject(&#39;出错了&#39;);
// 等同于
const p = new Promise((resolve, reject) =&gt; reject(&#39;出错了&#39;))

p.then(null, function (s) &#123;
  console.log(s)
&#125;);
// 出错了
</code></pre><p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p><p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p><pre><code class="javascript">Promise.reject(&#39;出错了&#39;)
.catch(e =&gt; &#123;
  console.log(e === &#39;出错了&#39;)
&#125;)
// true
</code></pre><p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p><hr><h4 id="12-应用"><a href="#12-应用" class="headerlink" title="12. 应用"></a>12. 应用</h4><p><strong>加载图片</strong></p><p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p><pre><code class="javascript">const preloadImage = function (path) &#123;
  return new Promise(function (resolve, reject) &#123;
    const image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  &#125;);
&#125;;
</code></pre><p><strong>Generator 函数与 Promise 的结合</strong></p><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p><pre><code class="javascript">function getFoo () &#123;
  return new Promise(function (resolve, reject)&#123;
    resolve(&#39;foo&#39;);
  &#125;);
&#125;

const g = function* () &#123;
  try &#123;
    const foo = yield getFoo();
    console.log(foo);
  &#125; catch (e) &#123;
    console.log(e);
  &#125;
&#125;;

function run (generator) &#123;
  const it = generator();

  function go(result) &#123;
    if (result.done) return result.value;

    return result.value.then(function (value) &#123;
      return go(it.next(value));
    &#125;, function (error) &#123;
      return go(it.throw(error));
    &#125;);
  &#125;

  go(it.next());
&#125;

run(g);
</code></pre><p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p><hr><h4 id="13-Promise-try"><a href="#13-Promise-try" class="headerlink" title="13. Promise.try()"></a>13. Promise.try()</h4><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p><pre><code class="javascript">Promise.resolve().then(f)
</code></pre><p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p><pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);
Promise.resolve().then(f);
console.log(&#39;next&#39;);
// next
// now
</code></pre><p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用<code>async</code>函数来写。</p><pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);
(async () =&gt; f())();
console.log(&#39;next&#39;);
// now
// next
</code></pre><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p><pre><code class="javascript">(async () =&gt; f())()
.then(...)
</code></pre><p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p><pre><code class="javascript">(async () =&gt; f())()
.then(...)
.catch(...)
</code></pre><p>第二种写法是使用<code>new Promise()</code>。</p><pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);
(
  () =&gt; new Promise(
    resolve =&gt; resolve(f())
  )
)();
console.log(&#39;next&#39;);
// now
// next
</code></pre><p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p><p>鉴于这是一个很常见的需求，所以现在有一个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1wcm9taXNlLXRyeQ==">提案</span>，提供<code>Promise.try</code>方法替代上面的写法。</p><pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);
Promise.try(f);
console.log(&#39;next&#39;);
// now
// next
</code></pre><p>事实上，<code>Promise.try</code>存在已久，Promise 库<a target="_blank" rel="noopener" href="http://bluebirdjs.com/docs/api/promise.try.html"><code>Bluebird</code></a>、<a target="_blank" rel="noopener" href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs"><code>Q</code></a>和<a target="_blank" rel="noopener" href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry"><code>when</code></a>，早就提供了这个方法。</p><p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<span class="exturl" data-url="aHR0cDovL2NyeXRvLm5ldC9+am9lcGllOTEvYmxvZy8yMDE2LzA1LzExL3doYXQtaXMtcHJvbWlzZS10cnktYW5kLXdoeS1kb2VzLWl0LW1hdHRlci8=">许多好处</span>，其中一点就是可以更好地管理异常。</p><pre><code class="javascript">function getUsername(userId) &#123;
  return database.users.get(&#123;id: userId&#125;)
  .then(function(user) &#123;
    return user.name;
  &#125;);
&#125;
</code></pre><p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p><pre><code class="javascript">database.users.get(&#123;id: userId&#125;)
.then(...)
.catch(...)
</code></pre><p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p><pre><code class="javascript">try &#123;
  database.users.get(&#123;id: userId&#125;)
  .then(...)
  .catch(...)
&#125; catch (e) &#123;
  // ...
&#125;
</code></pre><p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p><pre><code class="javascript">Promise.try(() =&gt; database.users.get(&#123;id: userId&#125;))
  .then(...)
  .catch(...)
</code></pre><p><strong>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</strong></p><h3 id="17、-Iterator-和-for…of-循环"><a href="#17、-Iterator-和-for…of-循环" class="headerlink" title="17、 Iterator 和 for…of 循环"></a>17、 Iterator 和 for…of 循环</h3><h4 id="1-Iterator（遍历器）的概念"><a href="#1-Iterator（遍历器）的概念" class="headerlink" title="1. Iterator（遍历器）的概念"></a>1. Iterator（遍历器）的概念</h4><p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p><p><strong>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</strong></p><p>Iterator 的作用有三个：<strong>一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</strong></p><p>Iterator 的遍历过程是这样的。</p><p><strong>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</strong></p><p><strong>（2）第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</strong></p><p>（3）第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</p><p>（4）不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，<strong>就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</strong></p><p>下面是一个模拟<code>next</code>方法返回值的例子。</p><pre><code class="javascript">var it = makeIterator([&#39;a&#39;, &#39;b&#39;]);

it.next() // &#123; value: &quot;a&quot;, done: false &#125;
it.next() // &#123; value: &quot;b&quot;, done: false &#125;
it.next() // &#123; value: undefined, done: true &#125;

function makeIterator(array) &#123;
  var nextIndex = 0;
  return &#123;
    next: function() &#123;
      return nextIndex &lt; array.length ?
        &#123;value: array[nextIndex++], done: false&#125; :
        &#123;value: undefined, done: true&#125;;
    &#125;
  &#125;;
&#125;
</code></pre><p>上面代码定义了一个<code>makeIterator</code>函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组<code>[&#39;a&#39;, &#39;b&#39;]</code>执行这个函数，就会返回该数组的遍历器对象（即指针对象）<code>it</code>。</p><p>指针对象的<code>next</code>方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用<code>next</code>方法，指针就会指向数组的下一个成员。第一次调用，指向<code>a</code>；第二次调用，指向<code>b</code>。</p><p><code>next</code>方法返回一个对象，表示当前数据成员的信息。这个对象具有<code>value</code>和<code>done</code>两个属性，<code>value</code>属性返回当前位置的成员，<code>done</code>属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用<code>next</code>方法。</p><p>总之，调用指针对象的<code>next</code>方法，就可以遍历事先给定的数据结构。</p><p>对于遍历器对象来说，<code>done: false</code>和<code>value: undefined</code>属性都是可以省略的，因此上面的<code>makeIterator</code>函数可以简写成下面的形式。</p><pre><code class="javascript">function makeIterator(array) &#123;
  var nextIndex = 0;
  return &#123;
    next: function() &#123;
      return nextIndex &lt; array.length ?
        &#123;value: array[nextIndex++]&#125; :
        &#123;done: true&#125;;
    &#125;
  &#125;;
&#125;
</code></pre><p>由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。</p><pre><code class="javascript">var it = idMaker();

it.next().value // 0
it.next().value // 1
it.next().value // 2
// ...

function idMaker() &#123;
  var index = 0;

  return &#123;
    next: function() &#123;
      return &#123;value: index++, done: false&#125;;
    &#125;
  &#125;;
&#125;
</code></pre><p>上面的例子中，遍历器生成函数<code>idMaker</code>，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。</p><p>如果使用 TypeScript 的写法，遍历器接口（Iterable）、指针对象（Iterator）和<code>next</code>方法返回值的规格可以描述如下。</p><pre><code class="javascript">interface Iterable &#123;
  [Symbol.iterator]() : Iterator,
&#125;

interface Iterator &#123;
  next(value?: any) : IterationResult,
&#125;

interface IterationResult &#123;
  value: any,
  done: boolean,
&#125;
</code></pre><hr><h4 id="2-默认-Iterator-接口"><a href="#2-默认-Iterator-接口" class="headerlink" title="2. 默认 Iterator 接口"></a>2. 默认 Iterator 接口</h4><p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环（详见下文）。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p><p><strong>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</strong></p><p>ES6 规定，默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名<code>Symbol.iterator</code>，它是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见《Symbol》一章）。</p><pre><code class="javascript">const obj = &#123;
  [Symbol.iterator] : function () &#123;
    return &#123;
      next: function () &#123;
        return &#123;
          value: 1,
          done: true
        &#125;;
      &#125;
    &#125;;
  &#125;
&#125;;
</code></pre><p>上面代码中，对象<code>obj</code>是可遍历的（iterable），因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有<code>next</code>方法。每次调用<code>next</code>方法，都会返回一个代表当前成员的信息对象，具有<code>value</code>和<code>done</code>两个属性。</p><p>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被<code>for...of</code>循环遍历。原因在于，这些数据结构原生部署了<code>Symbol.iterator</code>属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p><p>原生具备 Iterator 接口的数据结构如下。</p><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul><p>下面的例子是数组的<code>Symbol.iterator</code>属性。</p><pre><code class="javascript">let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
let iter = arr[Symbol.iterator]();

iter.next() // &#123; value: &#39;a&#39;, done: false &#125;
iter.next() // &#123; value: &#39;b&#39;, done: false &#125;
iter.next() // &#123; value: &#39;c&#39;, done: false &#125;
iter.next() // &#123; value: undefined, done: true &#125;
</code></pre><p>上面代码中，变量<code>arr</code>是一个数组，原生就具有遍历器接口，部署在<code>arr</code>的<code>Symbol.iterator</code>属性上面。所以，调用这个属性，就得到遍历器对象。</p><p>对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code>循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在<code>Symbol.iterator</code>属性上面部署，这样才会被<code>for...of</code>循环遍历。</p><p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。</p><p>一个对象如果要具备可被<code>for...of</code>循环调用的 Iterator 接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p><pre><code class="javascript">class RangeIterator &#123;
  constructor(start, stop) &#123;
    this.value = start;
    this.stop = stop;
  &#125;

  [Symbol.iterator]() &#123; return this; &#125;

  next() &#123;
    var value = this.value;
    if (value &lt; this.stop) &#123;
      this.value++;
      return &#123;done: false, value: value&#125;;
    &#125;
    return &#123;done: true, value: undefined&#125;;
  &#125;
&#125;

function range(start, stop) &#123;
  return new RangeIterator(start, stop);
&#125;

for (var value of range(0, 3)) &#123;
  console.log(value); // 0, 1, 2
&#125;
</code></pre><p>上面代码是一个类部署 Iterator 接口的写法。<code>Symbol.iterator</code>属性对应一个函数，执行后返回当前对象的遍历器对象。</p><p>下面是通过遍历器实现“链表”结构的例子。</p><pre><code class="javascript">function Obj(value) &#123;
  this.value = value;
  this.next = null;
&#125;

Obj.prototype[Symbol.iterator] = function() &#123;
  var iterator = &#123; next: next &#125;;

  var current = this;

  function next() &#123;
    if (current) &#123;
      var value = current.value;
      current = current.next;
      return &#123; done: false, value: value &#125;;
    &#125;
    return &#123; done: true &#125;;
  &#125;
  return iterator;
&#125;

var one = new Obj(1);
var two = new Obj(2);
var three = new Obj(3);

one.next = two;
two.next = three;

for (var i of one)&#123;
  console.log(i); // 1, 2, 3
&#125;
</code></pre><p>上面代码首先在构造函数的原型链上部署<code>Symbol.iterator</code>方法，调用该方法会返回遍历器对象<code>iterator</code>，调用该对象的<code>next</code>方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p><p>下面是另一个为对象添加 Iterator 接口的例子。</p><pre><code class="javascript">let obj = &#123;
  data: [ &#39;hello&#39;, &#39;world&#39; ],
  [Symbol.iterator]() &#123;
    const self = this;
    let index = 0;
    return &#123;
      next() &#123;
        if (index &lt; self.data.length) &#123;
          return &#123;
            value: self.data[index++],
            done: false
          &#125;;
        &#125;
        return &#123; value: undefined, done: true &#125;;
      &#125;
    &#125;;
  &#125;
&#125;;
</code></pre><p>对于类似数组的对象（存在数值键名和<code>length</code>属性），部署 Iterator 接口，有一个简便方法，就是<code>Symbol.iterator</code>方法直接引用数组的 Iterator 接口。</p><pre><code class="javascript">NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
// 或者
NodeList.prototype[Symbol.iterator] = [][Symbol.iterator];

[...document.querySelectorAll(&#39;div&#39;)] // 可以执行了
</code></pre><p>NodeList 对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的<code>Symbol.iterator</code>属性，可以看到没有任何影响。</p><p>下面是另一个类似数组的对象调用数组的<code>Symbol.iterator</code>方法的例子。</p><pre><code class="javascript">let iterable = &#123;
  0: &#39;a&#39;,
  1: &#39;b&#39;,
  2: &#39;c&#39;,
  length: 3,
  [Symbol.iterator]: Array.prototype[Symbol.iterator]
&#125;;
for (let item of iterable) &#123;
  console.log(item); // &#39;a&#39;, &#39;b&#39;, &#39;c&#39;
&#125;
</code></pre><p>注意，普通对象部署数组的<code>Symbol.iterator</code>方法，并无效果。</p><pre><code class="javascript">let iterable = &#123;
  a: &#39;a&#39;,
  b: &#39;b&#39;,
  c: &#39;c&#39;,
  length: 3,
  [Symbol.iterator]: Array.prototype[Symbol.iterator]
&#125;;
for (let item of iterable) &#123;
  console.log(item); // undefined, undefined, undefined
&#125;
</code></pre><p>如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。</p><pre><code class="javascript">var obj = &#123;&#125;;

obj[Symbol.iterator] = () =&gt; 1;

[...obj] // TypeError: [] is not a function
</code></pre><p>上面代码中，变量<code>obj</code>的<code>Symbol.iterator</code>方法对应的不是遍历器生成函数，因此报错。</p><p>有了遍历器接口，数据结构就可以用<code>for...of</code>循环遍历（详见下文），也可以使用<code>while</code>循环遍历。</p><pre><code class="javascript">var $iterator = ITERABLE[Symbol.iterator]();
var $result = $iterator.next();
while (!$result.done) &#123;
  var x = $result.value;
  // ...
  $result = $iterator.next();
&#125;
</code></pre><p>上面代码中，<code>ITERABLE</code>代表某种可遍历的数据结构，<code>$iterator</code>是它的遍历器对象。遍历器对象每次移动指针（<code>next</code>方法），都检查一下返回值的<code>done</code>属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（<code>next</code>方法），不断循环。</p><hr><h4 id="3-调用-Iterator-接口的场合"><a href="#3-调用-Iterator-接口的场合" class="headerlink" title="3. 调用 Iterator 接口的场合"></a>3. 调用 Iterator 接口的场合</h4><p>有一些场合会默认调用 Iterator 接口（即<code>Symbol.iterator</code>方法），除了下文会介绍的<code>for...of</code>循环，还有几个别的场合。</p><p><strong>（1）解构赋值</strong></p><p>对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p><pre><code class="javascript">let set = new Set().add(&#39;a&#39;).add(&#39;b&#39;).add(&#39;c&#39;)                                                                                              
let [x,y] = set;
// x=&#39;a&#39;; y=&#39;b&#39;

let [first, ...rest] = set;
// first=&#39;a&#39;; rest=[&#39;b&#39;,&#39;c&#39;];
</code></pre><p><strong>（2）扩展运算符</strong></p><p>扩展运算符（…）也会调用默认的 Iterator 接口。</p><pre><code class="javascript">// 例一
var str = &#39;hello&#39;;
[...str] //  [&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;]

// 例二
let arr = [&#39;b&#39;, &#39;c&#39;];
[&#39;a&#39;, ...arr, &#39;d&#39;]
// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
</code></pre><p>上面代码的扩展运算符内部就调用 Iterator 接口。</p><p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，<strong>只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</strong></p><pre><code class="javascript">let arr = [...iterable];
</code></pre><p><strong>（3）yield*</strong></p><p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p><pre><code class="javascript">let generator = function* () &#123;
  yield 1;
  yield* [2,3,4];
  yield 5;
&#125;;

var iterator = generator();

iterator.next() // &#123; value: 1, done: false &#125;
iterator.next() // &#123; value: 2, done: false &#125;
iterator.next() // &#123; value: 3, done: false &#125;
iterator.next() // &#123; value: 4, done: false &#125;
iterator.next() // &#123; value: 5, done: false &#125;
iterator.next() // &#123; value: undefined, done: true &#125;
</code></pre><p><strong>（4）其他场合</strong></p><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p><ul><li>for…of</li><li>Array.from()</li><li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li><li>Promise.all()</li><li>Promise.race()</li></ul><hr><h4 id="4-字符串的-Iterator-接口"><a href="#4-字符串的-Iterator-接口" class="headerlink" title="4. 字符串的 Iterator 接口"></a>4. 字符串的 Iterator 接口</h4><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。</p><pre><code class="javascript">var someString = &quot;hi&quot;;
typeof someString[Symbol.iterator]
// &quot;function&quot;

var iterator = someString[Symbol.iterator]();

iterator.next()  // &#123; value: &quot;h&quot;, done: false &#125;
iterator.next()  // &#123; value: &quot;i&quot;, done: false &#125;
iterator.next()  // &#123; value: undefined, done: true &#125;
</code></pre><p>上面代码中，调用<code>Symbol.iterator</code>方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。</p><p>可以覆盖原生的<code>Symbol.iterator</code>方法，达到修改遍历器行为的目的。</p><pre><code class="javascript">var str = new String(&quot;hi&quot;);

[...str] // [&quot;h&quot;, &quot;i&quot;]

str[Symbol.iterator] = function() &#123;
  return &#123;
    next: function() &#123;
      if (this._first) &#123;
        this._first = false;
        return &#123; value: &quot;bye&quot;, done: false &#125;;
      &#125; else &#123;
        return &#123; done: true &#125;;
      &#125;
    &#125;,
    _first: true
  &#125;;
&#125;;

[...str] // [&quot;bye&quot;]
str // &quot;hi&quot;
</code></pre><p>上面代码中，字符串 str 的<code>Symbol.iterator</code>方法被修改了，所以扩展运算符（<code>...</code>）返回的值变成了<code>bye</code>，而字符串本身还是<code>hi</code>。</p><hr><h4 id="5-Iterator-接口与-Generator-函数"><a href="#5-Iterator-接口与-Generator-函数" class="headerlink" title="5. Iterator 接口与 Generator 函数"></a>5. Iterator 接口与 Generator 函数</h4><p><strong><code>Symbol.iterator()</code>方法的最简单实现</strong>，还是使用下一章要介绍的 Generator 函数。</p><pre><code class="javascript">let myIterable = &#123;
  [Symbol.iterator]: function* () &#123;
    yield 1;
    yield 2;
    yield 3;
  &#125;
&#125;;
[...myIterable] // [1, 2, 3]

// 或者采用下面的简洁写法

let obj = &#123;
  * [Symbol.iterator]() &#123;
    yield &#39;hello&#39;;
    yield &#39;world&#39;;
  &#125;
&#125;;

for (let x of obj) &#123;
  console.log(x);
&#125;
// &quot;hello&quot;
// &quot;world&quot;
</code></pre><p>上面代码中，<code>Symbol.iterator()</code>方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。</p><hr><h4 id="6-遍历器对象的-return-，throw"><a href="#6-遍历器对象的-return-，throw" class="headerlink" title="6. 遍历器对象的 return()，throw()"></a>6. 遍历器对象的 return()，throw()</h4><p>遍历器对象除了具有<code>next()</code>方法，还可以具有<code>return()</code>方法和<code>throw()</code>方法。如果你自己写遍历器对象生成函数，那么<code>next()</code>方法是必须部署的，<code>return()</code>方法和<code>throw()</code>方法是否部署是可选的。</p><p><code>return()</code>方法的使用场合是，如果<code>for...of</code>循环提前退出（通常是因为出错，或者有<code>break</code>语句），就会调用<code>return()</code>方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署<code>return()</code>方法。</p><pre><code class="javascript">function readLinesSync(file) &#123;
  return &#123;
    [Symbol.iterator]() &#123;
      return &#123;
        next() &#123;
          return &#123; done: false &#125;;
        &#125;,
        return() &#123;
          file.close();
          return &#123; done: true &#125;;
        &#125;
      &#125;;
    &#125;,
  &#125;;
&#125;
</code></pre><p>上面代码中，函数<code>readLinesSync</code>接受一个文件对象作为参数，返回一个遍历器对象，其中除了<code>next()</code>方法，还部署了<code>return()</code>方法。下面的两种情况，都会触发执行<code>return()</code>方法。</p><pre><code class="javascript">// 情况一
for (let line of readLinesSync(fileName)) &#123;
  console.log(line);
  break;
&#125;

// 情况二
for (let line of readLinesSync(fileName)) &#123;
  console.log(line);
  throw new Error();
&#125;
</code></pre><p>上面代码中，情况一输出文件的第一行以后，就会执行<code>return()</code>方法，关闭这个文件；情况二会在执行<code>return()</code>方法关闭文件之后，再抛出错误。</p><p>注意，<code>return()</code>方法必须返回一个对象，这是 Generator 语法决定的。</p><p><code>throw()</code>方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。请参阅《Generator 函数》一章。</p><hr><h4 id="7-for…of-循环"><a href="#7-for…of-循环" class="headerlink" title="7. for…of 循环"></a>7. for…of 循环</h4><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了<code>for...of</code>循环，作为遍历所有数据结构的统一的方法。</p><p><strong>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</strong></p><p><code>for...of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p><hr><p><strong>数组</strong></p><p>数组原生具备<code>iterator</code>接口（即默认部署了<code>Symbol.iterator</code>属性），<code>for...of</code>循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p><pre><code class="javascript">const arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;];

for(let v of arr) &#123;
  console.log(v); // red green blue
&#125;

const obj = &#123;&#125;;
obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);

for(let v of obj) &#123;
  console.log(v); // red green blue
&#125;
</code></pre><p>上面代码中，空对象<code>obj</code>部署了数组<code>arr</code>的<code>Symbol.iterator</code>属性，结果<code>obj</code>的<code>for...of</code>循环，产生了与<code>arr</code>完全一样的结果。</p><p><code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法。</p><pre><code class="javascript">const arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;];

arr.forEach(function (element, index) &#123;
  console.log(element); // red green blue
  console.log(index);   // 0 1 2
&#125;);
</code></pre><p>JavaScript 原有的<code>for...in</code>循环，只能获得对象的键名，不能直接获取键值。ES6 提供<code>for...of</code>循环，允许遍历获得键值。</p><pre><code class="javascript">var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;];

for (let a in arr) &#123;
  console.log(a); // 0 1 2 3
&#125;

for (let a of arr) &#123;
  console.log(a); // a b c d
&#125;
</code></pre><p>上面代码表明，<code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。如果要通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法（参见《数组的扩展》一章）。</p><p><strong><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</strong></p><pre><code class="javascript">let arr = [3, 5, 7];
arr.foo = &#39;hello&#39;;

for (let i in arr) &#123;
  console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;
&#125;

for (let i of arr) &#123;
  console.log(i); //  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;
&#125;
</code></pre><p>上面代码中，<code>for...of</code>循环不会返回数组<code>arr</code>的<code>foo</code>属性。</p><hr><p><strong>Set 和 Map 结构</strong></p><p>Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用<code>for...of</code>循环。</p><pre><code class="javascript">var engines = new Set([&quot;Gecko&quot;, &quot;Trident&quot;, &quot;Webkit&quot;, &quot;Webkit&quot;]);
for (var e of engines) &#123;
  console.log(e);
&#125;
// Gecko
// Trident
// Webkit

var es6 = new Map();
es6.set(&quot;edition&quot;, 6);
es6.set(&quot;committee&quot;, &quot;TC39&quot;);
es6.set(&quot;standard&quot;, &quot;ECMA-262&quot;);
for (var [name, value] of es6) &#123;
  console.log(name + &quot;: &quot; + value);
&#125;
// edition: 6
// committee: TC39
// standard: ECMA-262
</code></pre><p>上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。</p><pre><code class="javascript">let map = new Map().set(&#39;a&#39;, 1).set(&#39;b&#39;, 2);
for (let pair of map) &#123;
  console.log(pair);
&#125;
// [&#39;a&#39;, 1]
// [&#39;b&#39;, 2]

for (let [key, value] of map) &#123;
  console.log(key + &#39; : &#39; + value);
&#125;
// a : 1
// b : 2
</code></pre><hr><p><strong>计算生成的数据结构</strong></p><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。</p><ul><li><code>entries()</code> 返回一个遍历器对象，用来遍历<code>[键名, 键值]</code>组成的数组。<strong>对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用<code>entries</code>方法。</strong></li><li><code>keys()</code> 返回一个遍历器对象，用来遍历所有的键名。</li><li><code>values()</code> 返回一个遍历器对象，用来遍历所有的键值。</li></ul><p>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p><pre><code class="javascript">let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
for (let pair of arr.entries()) &#123;
  console.log(pair);
&#125;
// [0, &#39;a&#39;]
// [1, &#39;b&#39;]
// [2, &#39;c&#39;]
</code></pre><hr><p><strong>类似数组的对象</strong></p><p>类似数组的对象包括好几类。下面是<code>for...of</code>循环用于字符串、DOM NodeList 对象、<code>arguments</code>对象的例子。</p><pre><code class="javascript">// 字符串
let str = &quot;hello&quot;;

for (let s of str) &#123;
  console.log(s); // h e l l o
&#125;

// DOM NodeList对象
let paras = document.querySelectorAll(&quot;p&quot;);

for (let p of paras) &#123;
  p.classList.add(&quot;test&quot;);
&#125;

// arguments对象
function printArgs() &#123;
  for (let x of arguments) &#123;
    console.log(x);
  &#125;
&#125;
printArgs(&#39;a&#39;, &#39;b&#39;);
// &#39;a&#39;
// &#39;b&#39;
</code></pre><p><strong>对于字符串来说，<code>for...of</code>循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。</strong></p><pre><code class="javascript">for (let x of &#39;a\uD83D\uDC0A&#39;) &#123;
  console.log(x);
&#125;
// &#39;a&#39;
// &#39;\uD83D\uDC0A&#39;
</code></pre><p><strong>并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用<code>Array.from</code>方法将其转为数组。</strong></p><pre><code class="javascript">let arrayLike = &#123; length: 2, 0: &#39;a&#39;, 1: &#39;b&#39; &#125;;

// 报错
for (let x of arrayLike) &#123;
  console.log(x);
&#125;

// 正确
for (let x of Array.from(arrayLike)) &#123;
  console.log(x);
&#125;
</code></pre><hr><p><strong>对象</strong></p><p><strong>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，<code>for...in</code>循环依然可以用来遍历键名。</strong></p><pre><code class="javascript">let es6 = &#123;
  edition: 6,
  committee: &quot;TC39&quot;,
  standard: &quot;ECMA-262&quot;
&#125;;

for (let e in es6) &#123;
  console.log(e);
&#125;
// edition
// committee
// standard

for (let e of es6) &#123;
  console.log(e);
&#125;
// TypeError: es6[Symbol.iterator] is not a function
</code></pre><p>上面代码表示，对于普通的对象，<code>for...in</code>循环可以遍历键名，<code>for...of</code>循环会报错。</p><p><strong>一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</strong></p><pre><code class="javascript">for (var key of Object.keys(someObject)) &#123;
  console.log(key + &#39;: &#39; + someObject[key]);
&#125;
</code></pre><p><strong>另一个方法是使用 Generator 函数将对象重新包装一下。</strong></p><pre><code class="javascript">const obj = &#123; a: 1, b: 2, c: 3 &#125;

function* entries(obj) &#123;
  for (let key of Object.keys(obj)) &#123;
    yield [key, obj[key]];
  &#125;
&#125;

for (let [key, value] of entries(obj)) &#123;
  console.log(key, &#39;-&gt;&#39;, value);
&#125;
// a -&gt; 1
// b -&gt; 2
// c -&gt; 3
</code></pre><hr><p><strong>与其他遍历语法的比较</strong></p><p>以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是<code>for</code>循环。</p><pre><code class="javascript">for (var index = 0; index &lt; myArray.length; index++) &#123;
  console.log(myArray[index]);
&#125;
</code></pre><p>这种写法比较麻烦，因此数组提供内置的<code>forEach</code>方法。</p><pre><code class="javascript">myArray.forEach(function (value) &#123;
  console.log(value);
&#125;);
</code></pre><p>这种写法的问题在于，无法中途跳出<code>forEach</code>循环，<code>break</code>命令或<code>return</code>命令都不能奏效。</p><p><code>for...in</code>循环可以遍历数组的键名。</p><pre><code class="javascript">for (var index in myArray) &#123;
  console.log(myArray[index]);
&#125;
</code></pre><p><code>for...in</code>循环有几个缺点。</p><ul><li>数组的键名是数字，但是<code>for...in</code>循环是以字符串作为键名“0”、“1”、“2”等等。</li><li><code>for...in</code>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li><li>某些情况下，<code>for...in</code>循环会以任意顺序遍历键名。</li></ul><p>总之，<code>for...in</code>循环主要是为遍历对象而设计的，不适用于遍历数组。</p><p><code>for...of</code>循环相比上面几种做法，有一些显著的优点。</p><pre><code class="javascript">for (let value of myArray) &#123;
  console.log(value);
&#125;
</code></pre><ul><li><strong>有着同<code>for...in</code>一样的简洁语法，但是没有<code>for...in</code>那些缺点。</strong></li><li><strong>不同于<code>forEach</code>方法，它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用。</strong></li><li><strong>提供了遍历所有数据结构的统一操作接口。</strong></li></ul><p>下面是一个使用 break 语句，跳出<code>for...of</code>循环的例子。</p><pre><code class="javascript">for (var n of fibonacci) &#123;
  if (n &gt; 1000)
    break;
  console.log(n);
&#125;
</code></pre><p>上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用<code>break</code>语句跳出<code>for...of</code>循环。</p><h3 id="18、-Generator-函数的语法"><a href="#18、-Generator-函数的语法" class="headerlink" title="18、 Generator 函数的语法"></a>18、 Generator 函数的语法</h3><hr><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><strong>基本概念</strong></p><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p><p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</p><pre><code class="javascript">function* helloWorldGenerator() &#123;
  yield &#39;hello&#39;;
  yield &#39;world&#39;;
  return &#39;ending&#39;;
&#125;

var hw = helloWorldGenerator();
</code></pre><p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p><p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p><p>下一步，<strong>必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态</strong>。也就是说，<strong>每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止</strong>。换言之，<strong>Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</strong></p><pre><code class="javascript">hw.next()
// &#123; value: &#39;hello&#39;, done: false &#125;

hw.next()
// &#123; value: &#39;world&#39;, done: false &#125;

hw.next()
// &#123; value: &#39;ending&#39;, done: true &#125;

hw.next()
// &#123; value: undefined, done: true &#125;
</code></pre><p>上面代码一共调用了四次<code>next</code>方法。</p><p>第一次调用，Generator 函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p><p>第二次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到下一个<code>yield</code>表达式。<code>next</code>方法返回的对象的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>world</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p><p>第三次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到<code>return</code>语句（如果没有<code>return</code>语句，就执行到函数结束）。<code>next</code>方法返回的对象的<code>value</code>属性，就是紧跟在<code>return</code>语句后面的表达式的值（如果没有<code>return</code>语句，则<code>value</code>属性的值为<code>undefined</code>），<code>done</code>属性的值<code>true</code>，表示遍历已经结束。</p><p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code>方法返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code>属性为<code>true</code>。以后再调用<code>next</code>方法，返回的都是这个值。</p><p><strong>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</strong></p><p>ES6 没有规定，<code>function</code>关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</p><pre><code class="javascript">function * foo(x, y) &#123; ··· &#125;
function *foo(x, y) &#123; ··· &#125;
function* foo(x, y) &#123; ··· &#125;
function*foo(x, y) &#123; ··· &#125;
</code></pre><p>由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在<code>function</code>关键字后面。本书也采用这种写法。</p><hr><p><strong>yield 表达式</strong></p><p>由于 Generator 函数返回的遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态，<strong>所以其实提供了一种可以暂停执行的函数。<code>yield</code>表达式就是暂停标志。</strong></p><p>遍历器对象的<code>next</code>方法的运行逻辑如下。</p><p>（1）遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</p><p>（2）下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</p><p>（3）如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</p><p>（4）如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</p><p>需要注意的是，**<code>yield</code>表达式后面的表达式，只有当调用<code>next</code>方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。**</p><pre><code class="javascript">function* gen() &#123;
  yield  123 + 456;
&#125;
</code></pre><p>上面代码中，<code>yield</code>后面的表达式<code>123 + 456</code>，不会立即求值，只会在<code>next</code>方法将指针移到这一句时，才会求值。</p><p><code>yield</code>表达式与<code>return</code>语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到<code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而<code>return</code>语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）<code>return</code>语句，但是可以执行多次（或者说多个）<code>yield</code>表达式。正常函数只能返回一个值，因为只能执行一次<code>return</code>；Generator 函数可以返回一系列的值，因为可以有任意多个<code>yield</code>。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。</p><p>Generator 函数可以不用<code>yield</code>表达式，这时就变成了一个单纯的暂缓执行函数。</p><pre><code class="javascript">function* f() &#123;
  console.log(&#39;执行了！&#39;)
&#125;

var generator = f();

setTimeout(function () &#123;
  generator.next()
&#125;, 2000);
</code></pre><p>上面代码中，函数<code>f</code>如果是普通函数，在为变量<code>generator</code>赋值时就会执行。但是，函数<code>f</code>是一个 Generator 函数，就变成只有调用<code>next</code>方法时，函数<code>f</code>才会执行。</p><p><strong>另外需要注意，<code>yield</code>表达式只能用在 Generator 函数里面，用在其他地方都会报错。</strong></p><pre><code class="javascript">(function ()&#123;
  yield 1;
&#125;)()
// SyntaxError: Unexpected number
</code></pre><p>上面代码在一个普通函数中使用<code>yield</code>表达式，结果产生一个句法错误。</p><p>下面是另外一个例子。</p><pre><code class="javascript">var arr = [1, [[2, 3], 4], [5, 6]];

var flat = function* (a) &#123;
  a.forEach(function (item) &#123;
    if (typeof item !== &#39;number&#39;) &#123;
      yield* flat(item);
    &#125; else &#123;
      yield item;
    &#125;
  &#125;);
&#125;;

for (var f of flat(arr))&#123;
  console.log(f);
&#125;
</code></pre><p><strong>上面代码也会产生句法错误，因为<code>forEach</code>方法的参数是一个普通函数，但是在里面使用了<code>yield</code>表达式</strong>（这个函数里面还使用了<code>yield*</code>表达式，详细介绍见后文）。<strong>一种修改方法是改用<code>for</code>循环。</strong></p><pre><code class="javascript">var arr = [1, [[2, 3], 4], [5, 6]];

var flat = function* (a) &#123;
  var length = a.length;
  for (var i = 0; i &lt; length; i++) &#123;
    var item = a[i];
    if (typeof item !== &#39;number&#39;) &#123;
      yield* flat(item);
    &#125; else &#123;
      yield item;
    &#125;
  &#125;
&#125;;

for (var f of flat(arr)) &#123;
  console.log(f);
&#125;
// 1, 2, 3, 4, 5, 6
</code></pre><p><strong>另外，<code>yield</code>表达式如果用在另一个表达式之中，必须放在圆括号里面。</strong></p><pre><code class="javascript">function* demo() &#123;
  console.log(&#39;Hello&#39; + yield); // SyntaxError
  console.log(&#39;Hello&#39; + yield 123); // SyntaxError

  console.log(&#39;Hello&#39; + (yield)); // OK
  console.log(&#39;Hello&#39; + (yield 123)); // OK
&#125;
</code></pre><p><strong><code>yield</code>表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</strong></p><pre><code class="javascript">function* demo() &#123;
  foo(yield &#39;a&#39;, yield &#39;b&#39;); // OK
  let input = yield; // OK
&#125;
</code></pre><hr><p><strong>与 Iterator 接口的关系</strong></p><p>上一章说过，任意一个对象的<code>Symbol.iterator</code>方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p><p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有 Iterator 接口。</p><pre><code class="javascript">var myIterable = &#123;&#125;;
myIterable[Symbol.iterator] = function* () &#123;
  yield 1;
  yield 2;
  yield 3;
&#125;;

[...myIterable] // [1, 2, 3]
</code></pre><p>上面代码中，Generator 函数赋值给<code>Symbol.iterator</code>属性，从而使得<code>myIterable</code>对象具有了 Iterator 接口，可以被<code>...</code>运算符遍历了。</p><p><strong>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有<code>Symbol.iterator</code>属性，执行后返回自身。</strong></p><pre><code class="javascript">function* gen()&#123;
  // some code
&#125;

var g = gen();

g[Symbol.iterator]() === g
// true
</code></pre><p>上面代码中，<code>gen</code>是一个 Generator 函数，调用它会生成一个遍历器对象<code>g</code>。它的<code>Symbol.iterator</code>属性，也是一个遍历器对象生成函数，执行后返回它自己。</p><hr><h4 id="2-next-方法的参数"><a href="#2-next-方法的参数" class="headerlink" title="2. next 方法的参数"></a>2. next 方法的参数</h4><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。**<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。**</p><pre><code class="javascript">function* f() &#123;
  for(var i = 0; true; i++) &#123;
    var reset = yield i;
    if(reset) &#123; i = -1; &#125;
  &#125;
&#125;

var g = f();

g.next() // &#123; value: 0, done: false &#125;
g.next() // &#123; value: 1, done: false &#125;
g.next(true) // &#123; value: 0, done: false &#125;
</code></pre><p>上面代码先定义了一个可以无限运行的 Generator 函数<code>f</code>，如果<code>next</code>方法没有参数，每次运行到<code>yield</code>表达式，变量<code>reset</code>的值总是<code>undefined</code>。当<code>next</code>方法带一个参数<code>true</code>时，变量<code>reset</code>就被重置为这个参数（即<code>true</code>），因此<code>i</code>会等于<code>-1</code>，下一轮循环就会从<code>-1</code>开始递增。</p><p>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过<code>next</code>方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，<strong>可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</strong></p><p>再看一个例子。</p><pre><code class="javascript">function* foo(x) &#123;
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
&#125;

var a = foo(5);
a.next() // Object&#123;value:6, done:false&#125;
a.next() // Object&#123;value:NaN, done:false&#125;
a.next() // Object&#123;value:NaN, done:true&#125;

var b = foo(5);
b.next() // &#123; value:6, done:false &#125;
b.next(12) // &#123; value:8, done:false &#125;
b.next(13) // &#123; value:42, done:true &#125;
</code></pre><p>上面代码中，第二次运行<code>next</code>方法的时候不带参数，导致 y 的值等于<code>2 * undefined</code>（即<code>NaN</code>），除以 3 以后还是<code>NaN</code>，因此返回对象的<code>value</code>属性也等于<code>NaN</code>。第三次运行<code>Next</code>方法的时候不带参数，所以<code>z</code>等于<code>undefined</code>，返回对象的<code>value</code>属性等于<code>5 + NaN + undefined</code>，即<code>NaN</code>。</p><p>如果向<code>next</code>方法提供参数，返回结果就完全不一样了。上面代码第一次调用<code>b</code>的<code>next</code>方法时，返回<code>x+1</code>的值<code>6</code>；第二次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>12</code>，因此<code>y</code>等于<code>24</code>，返回<code>y / 3</code>的值<code>8</code>；第三次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>13</code>，因此<code>z</code>等于<code>13</code>，这时<code>x</code>等于<code>5</code>，<code>y</code>等于<code>24</code>，所以<code>return</code>语句的值等于<code>42</code>。</p><p>注意，由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的。V8 引擎直接忽略第一次使用<code>next</code>方法时的参数，只有从第二次使用<code>next</code>方法开始，参数才是有效的。从语义上讲，第一个<code>next</code>方法用来启动遍历器对象，所以不用带有参数。</p><p>再看一个通过<code>next</code>方法的参数，向 Generator 函数内部输入值的例子。</p><pre><code class="javascript">function* dataConsumer() &#123;
  console.log(&#39;Started&#39;);
  console.log(`1. $&#123;yield&#125;`);
  console.log(`2. $&#123;yield&#125;`);
  return &#39;result&#39;;
&#125;

let genObj = dataConsumer();
genObj.next();
// Started
genObj.next(&#39;a&#39;)
// 1. a
genObj.next(&#39;b&#39;)
// 2. b
</code></pre><p>上面代码是一个很直观的例子，每次通过<code>next</code>方法向 Generator 函数输入值，然后打印出来。</p><p><strong>如果想要第一次调用<code>next</code>方法时，就能够输入值，可以在 Generator 函数外面再包一层。</strong></p><pre><code class="javascript">function wrapper(generatorFunction) &#123;
  return function (...args) &#123;
    let generatorObject = generatorFunction(...args);
    generatorObject.next();
    return generatorObject;
  &#125;;
&#125;

const wrapped = wrapper(function* () &#123;
  console.log(`First input: $&#123;yield&#125;`);
  return &#39;DONE&#39;;
&#125;);

wrapped().next(&#39;hello!&#39;)
// First input: hello!
</code></pre><p>上面代码中，Generator 函数如果不用<code>wrapper</code>先包一层，是无法第一次调用<code>next</code>方法，就输入参数的。</p><hr><h4 id="3-for…of-循环"><a href="#3-for…of-循环" class="headerlink" title="3. for…of 循环"></a>3. for…of 循环</h4><p><strong><code>for...of</code>循环可以自动遍历 Generator 函数运行时生成的<code>Iterator</code>对象，且此时不再需要调用<code>next</code>方法。</strong></p><pre><code class="javascript">function* foo() &#123;
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
&#125;

for (let v of foo()) &#123;
  console.log(v);
&#125;
// 1 2 3 4 5
</code></pre><p>上面代码使用<code>for...of</code>循环，依次显示 5 个<code>yield</code>表达式的值。这里需要注意，一旦<code>next</code>方法的返回对象的<code>done</code>属性为<code>true</code>，<code>for...of</code>循环就会中止，且不包含该返回对象，<strong>所以上面代码的<code>return</code>语句返回的<code>6</code>，不包括在<code>for...of</code>循环之中。</strong></p><p>下面是一个利用 Generator 函数和<code>for...of</code>循环，实现斐波那契数列的例子。</p><pre><code class="javascript">function* fibonacci() &#123;
  let [prev, curr] = [0, 1];
  for (;;) &#123;
    yield curr;
    [prev, curr] = [curr, prev + curr];
  &#125;
&#125;

for (let n of fibonacci()) &#123;
  if (n &gt; 1000) break;
  console.log(n);
&#125;
</code></pre><p>从上面代码可见，使用<code>for...of</code>语句时不需要使用<code>next</code>方法。</p><p>利用<code>for...of</code>循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用<code>for...of</code>循环，<strong>通过 Generator 函数为它加上这个接口，就可以用了。</strong></p><pre><code class="javascript">function* objectEntries(obj) &#123;
  let propKeys = Reflect.ownKeys(obj);

  for (let propKey of propKeys) &#123;
    yield [propKey, obj[propKey]];
  &#125;
&#125;

let jane = &#123; first: &#39;Jane&#39;, last: &#39;Doe&#39; &#125;;

for (let [key, value] of objectEntries(jane)) &#123;
  console.log(`$&#123;key&#125;: $&#123;value&#125;`);
&#125;
// first: Jane
// last: Doe
</code></pre><p>上面代码中，对象<code>jane</code>原生不具备 Iterator 接口，无法用<code>for...of</code>遍历。这时，我们通过 Generator 函数<code>objectEntries</code>为它加上遍历器接口，就可以用<code>for...of</code>遍历了。加上遍历器接口的另一种写法是，<strong>将 Generator 函数加到对象的<code>Symbol.iterator</code>属性上面。</strong></p><pre><code class="javascript">function* objectEntries() &#123;
  let propKeys = Object.keys(this);

  for (let propKey of propKeys) &#123;
    yield [propKey, this[propKey]];
  &#125;
&#125;

let jane = &#123; first: &#39;Jane&#39;, last: &#39;Doe&#39; &#125;;

jane[Symbol.iterator] = objectEntries;

for (let [key, value] of jane) &#123;
  console.log(`$&#123;key&#125;: $&#123;value&#125;`);
&#125;
// first: Jane
// last: Doe
</code></pre><p><strong>除了<code>for...of</code>循环以外，扩展运算符（<code>...</code>）、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。</strong></p><pre><code class="javascript">function* numbers () &#123;
  yield 1
  yield 2
  return 3
  yield 4
&#125;

// 扩展运算符
[...numbers()] // [1, 2]

// Array.from 方法
Array.from(numbers()) // [1, 2]

// 解构赋值
let [x, y] = numbers();
x // 1
y // 2

// for...of 循环
for (let n of numbers()) &#123;
  console.log(n)
&#125;
// 1
// 2
</code></pre><hr><h4 id="4-Generator-prototype-throw"><a href="#4-Generator-prototype-throw" class="headerlink" title="4. Generator.prototype.throw()"></a>4. Generator.prototype.throw()</h4><p>Generator 函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p><pre><code class="javascript">var g = function* () &#123;
  try &#123;
    yield;
  &#125; catch (e) &#123;
    console.log(&#39;内部捕获&#39;, e);
  &#125;
&#125;;

var i = g();
i.next();

try &#123;
  i.throw(&#39;a&#39;);
  i.throw(&#39;b&#39;);
&#125; catch (e) &#123;
  console.log(&#39;外部捕获&#39;, e);
&#125;
// 内部捕获 a
// 外部捕获 b
</code></pre><p>上面代码中，遍历器对象<code>i</code>连续抛出两个错误。第一个错误被 Generator 函数体内的<code>catch</code>语句捕获。**<code>i</code>第二次抛出错误，由于 Generator 函数内部的<code>catch</code>语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的<code>catch</code>语句捕获。**</p><p><strong><code>throw</code>方法可以接受一个参数，该参数会被<code>catch</code>语句接收，建议抛出<code>Error</code>对象的实例。</strong></p><pre><code class="javascript">var g = function* () &#123;
  try &#123;
    yield;
  &#125; catch (e) &#123;
    console.log(e);
  &#125;
&#125;;

var i = g();
i.next();
i.throw(new Error(&#39;出错了！&#39;));
// Error: 出错了！(…)
</code></pre><p>注意，不要混淆遍历器对象的<code>throw</code>方法和全局的<code>throw</code>命令。上面代码的错误，是用遍历器对象的<code>throw</code>方法抛出的，而不是用<code>throw</code>命令抛出的。<strong>后者只能被函数体外的<code>catch</code>语句捕获。</strong></p><pre><code class="javascript">var g = function* () &#123;
  while (true) &#123;
    try &#123;
      yield;
    &#125; catch (e) &#123;
      if (e != &#39;a&#39;) throw e;
      console.log(&#39;内部捕获&#39;, e);
    &#125;
  &#125;
&#125;;

var i = g();
i.next();

try &#123;
  throw new Error(&#39;a&#39;);
  throw new Error(&#39;b&#39;);
&#125; catch (e) &#123;
  console.log(&#39;外部捕获&#39;, e);
&#125;
// 外部捕获 [Error: a]
</code></pre><p>上面代码之所以只捕获了<code>a</code>，是因为函数体外的<code>catch</code>语句块，捕获了抛出的<code>a</code>错误以后，就不会再继续<code>try</code>代码块里面剩余的语句了。</p><p>如果 Generator 函数内部没有部署<code>try...catch</code>代码块，那么<code>throw</code>方法抛出的错误，将被外部<code>try...catch</code>代码块捕获。</p><pre><code class="javascript">var g = function* () &#123;
  while (true) &#123;
    yield;
    console.log(&#39;内部捕获&#39;, e);
  &#125;
&#125;;

var i = g();
i.next();

try &#123;
  i.throw(&#39;a&#39;);
  i.throw(&#39;b&#39;);
&#125; catch (e) &#123;
  console.log(&#39;外部捕获&#39;, e);
&#125;
// 外部捕获 a
</code></pre><p>上面代码中，Generator 函数<code>g</code>内部没有部署<code>try...catch</code>代码块，所以抛出的错误直接被外部<code>catch</code>代码块捕获。</p><p>如果 Generator 函数内部和外部，都没有部署<code>try...catch</code>代码块，那么程序将报错，直接中断执行。</p><pre><code class="javascript">var gen = function* gen()&#123;
  yield console.log(&#39;hello&#39;);
  yield console.log(&#39;world&#39;);
&#125;

var g = gen();
g.next();
g.throw();
// hello
// Uncaught undefined
</code></pre><p>上面代码中，<code>g.throw</code>抛出错误以后，没有任何<code>try...catch</code>代码块可以捕获这个错误，导致程序报错，中断执行。</p><p><code>throw</code>方法抛出的错误要被内部捕获，前提是必须至少执行过一次<code>next</code>方法。</p><pre><code class="javascript">function* gen() &#123;
  try &#123;
    yield 1;
  &#125; catch (e) &#123;
    console.log(&#39;内部捕获&#39;);
  &#125;
&#125;

var g = gen();
g.throw(1);
// Uncaught 1
</code></pre><p>上面代码中，<code>g.throw(1)</code>执行时，<code>next</code>方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行<code>next</code>方法，等同于启动执行 Generator 函数的内部代码，否则 Generator 函数还没有开始执行，这时<code>throw</code>方法抛错只可能抛出在函数外部。</p><p><strong><code>throw</code>方法被捕获以后，会附带执行下一条<code>yield</code>表达式。也就是说，会附带执行一次<code>next</code>方法。</strong></p><pre><code class="javascript">var gen = function* gen()&#123;
  try &#123;
    yield console.log(&#39;a&#39;);
  &#125; catch (e) &#123;
    // ...
  &#125;
  yield console.log(&#39;b&#39;);
  yield console.log(&#39;c&#39;);
&#125;

var g = gen();
g.next() // a
g.throw() // b
g.next() // c
</code></pre><p>上面代码中，<code>g.throw</code>方法被捕获以后，自动执行了一次<code>next</code>方法，所以会打印<code>b</code>。另外，也可以看到，<strong>只要 Generator 函数内部部署了<code>try...catch</code>代码块，那么遍历器的<code>throw</code>方法抛出的错误，不影响下一次遍历。</strong></p><p>另外，<code>throw</code>命令与<code>g.throw</code>方法是无关的，两者互不影响。</p><pre><code class="javascript">var gen = function* gen()&#123;
  yield console.log(&#39;hello&#39;);
  yield console.log(&#39;world&#39;);
&#125;

var g = gen();
g.next();

try &#123;
  throw new Error();
&#125; catch (e) &#123;
  g.next();
&#125;
// hello
// world
</code></pre><p>上面代码中，<code>throw</code>命令抛出的错误不会影响到遍历器的状态，所以两次执行<code>next</code>方法，都进行了正确的操作。</p><p>这种函数体内捕获错误的机制，大大方便了对错误的处理。多个<code>yield</code>表达式，可以只用一个<code>try...catch</code>代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次<code>catch</code>语句就可以了。</p><p>Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的<code>catch</code>捕获。</p><pre><code class="javascript">function* foo() &#123;
  var x = yield 3;
  var y = x.toUpperCase();
  yield y;
&#125;

var it = foo();

it.next(); // &#123; value:3, done:false &#125;

try &#123;
  it.next(42);
&#125; catch (err) &#123;
  console.log(err);
&#125;
</code></pre><p>上面代码中，第二个<code>next</code>方法向函数体内传入一个参数 42，数值是没有<code>toUpperCase</code>方法的，所以会抛出一个 TypeError 错误，被函数体外的<code>catch</code>捕获。</p><p><strong>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了</strong>。如果此后还调用<code>next</code>方法，将返回一个<code>value</code>属性等于<code>undefined</code>、<code>done</code>属性等于<code>true</code>的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</p><pre><code class="javascript">function* g() &#123;
  yield 1;
  console.log(&#39;throwing an exception&#39;);
  throw new Error(&#39;generator broke!&#39;);
  yield 2;
  yield 3;
&#125;

function log(generator) &#123;
  var v;
  console.log(&#39;starting generator&#39;);
  try &#123;
    v = generator.next();
    console.log(&#39;第一次运行next方法&#39;, v);
  &#125; catch (err) &#123;
    console.log(&#39;捕捉错误&#39;, v);
  &#125;
  try &#123;
    v = generator.next();
    console.log(&#39;第二次运行next方法&#39;, v);
  &#125; catch (err) &#123;
    console.log(&#39;捕捉错误&#39;, v);
  &#125;
  try &#123;
    v = generator.next();
    console.log(&#39;第三次运行next方法&#39;, v);
  &#125; catch (err) &#123;
    console.log(&#39;捕捉错误&#39;, v);
  &#125;
  console.log(&#39;caller done&#39;);
&#125;

log(g());
// starting generator
// 第一次运行next方法 &#123; value: 1, done: false &#125;
// throwing an exception
// 捕捉错误 &#123; value: 1, done: false &#125;
// 第三次运行next方法 &#123; value: undefined, done: true &#125;
// caller done
</code></pre><p>上面代码一共三次运行<code>next</code>方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator 函数就已经结束了，不再执行下去了。</p><hr><h4 id="5-Generator-prototype-return"><a href="#5-Generator-prototype-return" class="headerlink" title="5. Generator.prototype.return()"></a>5. Generator.prototype.return()</h4><p>Generator 函数返回的遍历器对象，<strong>还有一个<code>return()</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</strong></p><pre><code class="javascript">function* gen() &#123;
  yield 1;
  yield 2;
  yield 3;
&#125;

var g = gen();

g.next()        // &#123; value: 1, done: false &#125;
g.return(&#39;foo&#39;) // &#123; value: &quot;foo&quot;, done: true &#125;
g.next()        // &#123; value: undefined, done: true &#125;
</code></pre><p>上面代码中，遍历器对象<code>g</code>调用<code>return()</code>方法后，返回值的<code>value</code>属性就是<code>return()</code>方法的参数<code>foo</code>。并且，Generator 函数的遍历就终止了，返回值的<code>done</code>属性为<code>true</code>，以后再调用<code>next()</code>方法，<code>done</code>属性总是返回<code>true</code>。</p><p>如果<code>return()</code>方法调用时，不提供参数，则返回值的<code>value</code>属性为<code>undefined</code>。</p><pre><code class="javascript">function* gen() &#123;
  yield 1;
  yield 2;
  yield 3;
&#125;

var g = gen();

g.next() // &#123; value: 1, done: false &#125;
g.return() // &#123; value: undefined, done: true &#125;
</code></pre><p><strong>如果 Generator 函数内部有<code>try...finally</code>代码块，且正在执行<code>try</code>代码块，那么<code>return()</code>方法会导致立刻进入<code>finally</code>代码块，执行完以后，整个函数才会结束。</strong></p><pre><code class="javascript">function* numbers () &#123;
  yield 1;
  try &#123;
    yield 2;
    yield 3;
  &#125; finally &#123;
    yield 4;
    yield 5;
  &#125;
  yield 6;
&#125;
var g = numbers();
g.next() // &#123; value: 1, done: false &#125;
g.next() // &#123; value: 2, done: false &#125;
g.return(7) // &#123; value: 4, done: false &#125;
g.next() // &#123; value: 5, done: false &#125;
g.next() // &#123; value: 7, done: true &#125;
</code></pre><p>上面代码中，<strong>调用<code>return()</code>方法后，就开始执行<code>finally</code>代码块，不执行<code>try</code>里面剩下的代码了，然后等到<code>finally</code>代码块执行完，再返回<code>return()</code>方法指定的返回值。</strong></p><hr><h4 id="6-next-、throw-、return-的共同点"><a href="#6-next-、throw-、return-的共同点" class="headerlink" title="6. next()、throw()、return() 的共同点"></a>6. next()、throw()、return() 的共同点</h4><p><code>next()</code>、<code>throw()</code>、<code>return()</code>这三个方法本质上是同一件事，可以放在一起理解。<strong>它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式。</strong></p><p><code>next()</code>是将<code>yield</code>表达式替换成一个值。</p><pre><code class="javascript">const g = function* (x, y) &#123;
  let result = yield x + y;
  return result;
&#125;;

const gen = g(1, 2);
gen.next(); // Object &#123;value: 3, done: false&#125;

gen.next(1); // Object &#123;value: 1, done: true&#125;
// 相当于将 let result = yield x + y
// 替换成 let result = 1;
</code></pre><p>上面代码中，第二个<code>next(1)</code>方法就相当于将<code>yield</code>表达式替换成一个值<code>1</code>。如果<code>next</code>方法没有参数，就相当于替换成<code>undefined</code>。</p><p><code>throw()</code>是将<code>yield</code>表达式替换成一个<code>throw</code>语句。</p><pre><code class="javascript">gen.throw(new Error(&#39;出错了&#39;)); // Uncaught Error: 出错了
// 相当于将 let result = yield x + y
// 替换成 let result = throw(new Error(&#39;出错了&#39;));
</code></pre><p><code>return()</code>是将<code>yield</code>表达式替换成一个<code>return</code>语句。</p><pre><code class="javascript">gen.return(2); // Object &#123;value: 2, done: true&#125;
// 相当于将 let result = yield x + y
// 替换成 let result = return 2;
</code></pre><hr><h4 id="7-yield-表达式"><a href="#7-yield-表达式" class="headerlink" title="7. yield* 表达式"></a>7. yield* 表达式</h4><p>如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。</p><pre><code class="javascript">function* foo() &#123;
  yield &#39;a&#39;;
  yield &#39;b&#39;;
&#125;

function* bar() &#123;
  yield &#39;x&#39;;
  // 手动遍历 foo()
  for (let i of foo()) &#123;
    console.log(i);
  &#125;
  yield &#39;y&#39;;
&#125;

for (let v of bar())&#123;
  console.log(v);
&#125;
// x
// a
// b
// y
</code></pre><p>上面代码中，<code>foo</code>和<code>bar</code>都是 Generator 函数，在<code>bar</code>里面调用<code>foo</code>，就需要手动遍历<code>foo</code>。如果有多个 Generator 函数嵌套，写起来就非常麻烦。</p><p><strong>ES6 提供了<code>yield*</code>表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。</strong></p><pre><code class="javascript">function* bar() &#123;
  yield &#39;x&#39;;
  yield* foo();
  yield &#39;y&#39;;
&#125;

// 等同于
function* bar() &#123;
  yield &#39;x&#39;;
  yield &#39;a&#39;;
  yield &#39;b&#39;;
  yield &#39;y&#39;;
&#125;

// 等同于
function* bar() &#123;
  yield &#39;x&#39;;
  for (let v of foo()) &#123;
    yield v;
  &#125;
  yield &#39;y&#39;;
&#125;

for (let v of bar())&#123;
  console.log(v);
&#125;
// &quot;x&quot;
// &quot;a&quot;
// &quot;b&quot;
// &quot;y&quot;
</code></pre><p>再来看一个对比的例子。</p><pre><code class="javascript">function* inner() &#123;
  yield &#39;hello!&#39;;
&#125;

function* outer1() &#123;
  yield &#39;open&#39;;
  yield inner();
  yield &#39;close&#39;;
&#125;

var gen = outer1()
gen.next().value // &quot;open&quot;
gen.next().value // 返回一个遍历器对象
gen.next().value // &quot;close&quot;

function* outer2() &#123;
  yield &#39;open&#39;
  yield* inner()
  yield &#39;close&#39;
&#125;

var gen = outer2()
gen.next().value // &quot;open&quot;
gen.next().value // &quot;hello!&quot;
gen.next().value // &quot;close&quot;
</code></pre><p>上面例子中，**<code>outer2</code>使用了<code>yield*</code>，<code>outer1</code>没使用。结果就是，<code>outer1</code>返回一个遍历器对象，<code>outer2</code>返回该遍历器对象的内部值。**</p><p>从语法角度看，如果<code>yield</code>表达式后面跟的是一个遍历器对象，需要在<code>yield</code>表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为<code>yield*</code>表达式。</p><pre><code class="javascript">let delegatedIterator = (function* () &#123;
  yield &#39;Hello!&#39;;
  yield &#39;Bye!&#39;;
&#125;());

let delegatingIterator = (function* () &#123;
  yield &#39;Greetings!&#39;;
  yield* delegatedIterator;
  yield &#39;Ok, bye.&#39;;
&#125;());

for(let value of delegatingIterator) &#123;
  console.log(value);
&#125;
// &quot;Greetings!
// &quot;Hello!&quot;
// &quot;Bye!&quot;
// &quot;Ok, bye.&quot;
</code></pre><p>上面代码中，<code>delegatingIterator</code>是代理者，<code>delegatedIterator</code>是被代理者。由于<code>yield* delegatedIterator</code>语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个 Generator 函数，有递归的效果。</p><p><code>yield*</code>后面的 Generator 函数（没有<code>return</code>语句时），等同于在 Generator 函数内部，部署一个<code>for...of</code>循环。</p><pre><code class="javascript">function* concat(iter1, iter2) &#123;
  yield* iter1;
  yield* iter2;
&#125;

// 等同于

function* concat(iter1, iter2) &#123;
  for (var value of iter1) &#123;
    yield value;
  &#125;
  for (var value of iter2) &#123;
    yield value;
  &#125;
&#125;
</code></pre><p>上面代码说明，<code>yield*</code>后面的 Generator 函数（没有<code>return</code>语句时），不过是<code>for...of</code>的一种简写形式，完全可以用后者替代前者。反之，在有<code>return</code>语句时，则需要用<code>var value = yield* iterator</code>的形式获取<code>return</code>语句的值。</p><p>如果<code>yield*</code>后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</p><pre><code class="javascript">function* gen()&#123;
  yield* [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
&#125;

gen().next() // &#123; value:&quot;a&quot;, done:false &#125;
</code></pre><p><strong>上面代码中，<code>yield</code>命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。</strong></p><p><strong>实际上，任何数据结构只要有 Iterator 接口，就可以被<code>yield*</code>遍历。</strong></p><pre><code class="javascript">let read = (function* () &#123;
  yield &#39;hello&#39;;
  yield* &#39;hello&#39;;
&#125;)();

read.next().value // &quot;hello&quot;
read.next().value // &quot;h&quot;
</code></pre><p>上面代码中，<code>yield</code>表达式返回整个字符串，<code>yield*</code>语句返回单个字符。因为字符串具有 Iterator 接口，所以被<code>yield*</code>遍历。</p><p>如果被代理的 Generator 函数有<code>return</code>语句，那么就可以向代理它的 Generator 函数返回数据。</p><pre><code class="javascript">function* foo() &#123;
  yield 2;
  yield 3;
  return &quot;foo&quot;;
&#125;

function* bar() &#123;
  yield 1;
  var v = yield* foo();
  console.log(&quot;v: &quot; + v);
  yield 4;
&#125;

var it = bar();

it.next()
// &#123;value: 1, done: false&#125;
it.next()
// &#123;value: 2, done: false&#125;
it.next()
// &#123;value: 3, done: false&#125;
it.next();
// &quot;v: foo&quot;
// &#123;value: 4, done: false&#125;
it.next()
// &#123;value: undefined, done: true&#125;
</code></pre><p>上面代码在第四次调用<code>next</code>方法的时候，屏幕上会有输出，这是因为函数<code>foo</code>的<code>return</code>语句，向函数<code>bar</code>提供了返回值。</p><p>再看一个例子。</p><pre><code class="javascript">function* genFuncWithReturn() &#123;
  yield &#39;a&#39;;
  yield &#39;b&#39;;
  return &#39;The result&#39;;
&#125;
function* logReturned(genObj) &#123;
  let result = yield* genObj;
  console.log(result);
&#125;

[...logReturned(genFuncWithReturn())]
// The result
// 值为 [ &#39;a&#39;, &#39;b&#39; ]
</code></pre><p>上面代码中，存在两次遍历。第一次是扩展运算符遍历函数<code>logReturned</code>返回的遍历器对象，第二次是<code>yield*</code>语句遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。所以，最后的数据表达式得到的值等于<code>[ &#39;a&#39;, &#39;b&#39; ]</code>。但是，函数<code>genFuncWithReturn</code>的<code>return</code>语句的返回值<code>The result</code>，会返回给函数<code>logReturned</code>内部的<code>result</code>变量，因此会有终端输出。</p><p><code>yield*</code>命令可以很方便地取出嵌套数组的所有成员。</p><pre><code class="javascript">function* iterTree(tree) &#123;
  if (Array.isArray(tree)) &#123;
    for(let i=0; i &lt; tree.length; i++) &#123;
      yield* iterTree(tree[i]);
    &#125;
  &#125; else &#123;
    yield tree;
  &#125;
&#125;

const tree = [ &#39;a&#39;, [&#39;b&#39;, &#39;c&#39;], [&#39;d&#39;, &#39;e&#39;] ];

for(let x of iterTree(tree)) &#123;
  console.log(x);
&#125;
// a
// b
// c
// d
// e
</code></pre><p>由于扩展运算符<code>...</code>默认调用 Iterator 接口，所以上面这个函数也可以用于嵌套数组的平铺。</p><pre><code class="javascript">[...iterTree(tree)] // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
</code></pre><p>下面是一个稍微复杂的例子，使用<code>yield*</code>语句遍历完全二叉树。</p><pre><code class="javascript">// 下面是二叉树的构造函数，
// 三个参数分别是左树、当前节点和右树
function Tree(left, label, right) &#123;
  this.left = left;
  this.label = label;
  this.right = right;
&#125;

// 下面是中序（inorder）遍历函数。
// 由于返回的是一个遍历器，所以要用generator函数。
// 函数体内采用递归算法，所以左树和右树要用yield*遍历
function* inorder(t) &#123;
  if (t) &#123;
    yield* inorder(t.left);
    yield t.label;
    yield* inorder(t.right);
  &#125;
&#125;

// 下面生成二叉树
function make(array) &#123;
  // 判断是否为叶节点
  if (array.length == 1) return new Tree(null, array[0], null);
  return new Tree(make(array[0]), array[1], make(array[2]));
&#125;
let tree = make([[[&#39;a&#39;], &#39;b&#39;, [&#39;c&#39;]], &#39;d&#39;, [[&#39;e&#39;], &#39;f&#39;, [&#39;g&#39;]]]);

// 遍历二叉树
var result = [];
for (let node of inorder(tree)) &#123;
  result.push(node);
&#125;

result
// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]
</code></pre><hr><h4 id="8-作为对象属性的-Generator-函数"><a href="#8-作为对象属性的-Generator-函数" class="headerlink" title="8. 作为对象属性的 Generator 函数"></a>8. 作为对象属性的 Generator 函数</h4><p><strong>如果一个对象的属性是 Generator 函数，可以简写成下面的形式。</strong></p><pre><code class="javascript">let obj = &#123;
  * myGeneratorMethod() &#123;
    ···
  &#125;
&#125;;
</code></pre><p>上面代码中，<code>myGeneratorMethod</code>属性前面有一个星号，表示这个属性是一个 Generator 函数。</p><p>它的完整形式如下，与上面的写法是等价的。</p><pre><code class="javascript">let obj = &#123;
  myGeneratorMethod: function* () &#123;
    // ···
  &#125;
&#125;;
</code></pre><hr><h4 id="9-Generator-函数的this"><a href="#9-Generator-函数的this" class="headerlink" title="9. Generator 函数的this"></a>9. Generator 函数的this</h4><p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的<code>prototype</code>对象上的方法。</p><pre><code class="javascript">function* g() &#123;&#125;

g.prototype.hello = function () &#123;
  return &#39;hi!&#39;;
&#125;;

let obj = g();

obj instanceof g // true
obj.hello() // &#39;hi!&#39;
</code></pre><p>上面代码表明，Generator 函数<code>g</code>返回的遍历器<code>obj</code>，是<code>g</code>的实例，而且继承了<code>g.prototype</code>。但是，如果把<code>g</code>当作普通的构造函数，并不会生效，因为<code>g</code>返回的总是遍历器对象，而不是<code>this</code>对象。</p><pre><code class="javascript">function* g() &#123;
  this.a = 11;
&#125;

let obj = g();
obj.next();
obj.a // undefined
</code></pre><p>上面代码中，Generator 函数<code>g</code>在<code>this</code>对象上面添加了一个属性<code>a</code>，但是<code>obj</code>对象拿不到这个属性。</p><p><strong>Generator 函数也不能跟<code>new</code>命令一起用，会报错。</strong></p><pre><code class="javascript">function* F() &#123;
  yield this.x = 2;
  yield this.y = 3;
&#125;

new F()
// TypeError: F is not a constructor
</code></pre><p>上面代码中，<code>new</code>命令跟构造函数<code>F</code>一起使用，结果报错，因为<code>F</code>不是构造函数。</p><p><strong>那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用<code>next</code>方法，又可以获得正常的<code>this</code>？</strong></p><p><strong>下面是一个变通方法。首先，生成一个空对象，使用<code>call</code>方法绑定 Generator 函数内部的<code>this</code>。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。</strong></p><pre><code class="javascript">function* F() &#123;
  this.a = 1;
  yield this.b = 2;
  yield this.c = 3;
&#125;
var obj = &#123;&#125;;
var f = F.call(obj);

f.next();  // Object &#123;value: 2, done: false&#125;
f.next();  // Object &#123;value: 3, done: false&#125;
f.next();  // Object &#123;value: undefined, done: true&#125;

obj.a // 1
obj.b // 2
obj.c // 3
</code></pre><p>上面代码中，首先是<code>F</code>内部的<code>this</code>对象绑定<code>obj</code>对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次<code>next</code>方法（因为<code>F</code>内部有两个<code>yield</code>表达式），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在<code>obj</code>对象上了，因此<code>obj</code>对象也就成了<code>F</code>的实例。</p><p>上面代码中，执行的是遍历器对象<code>f</code>，但是生成的对象实例是<code>obj</code>，有没有办法将这两个对象统一呢？</p><p>一个办法就是将<code>obj</code>换成<code>F.prototype</code>。</p><pre><code class="javascript">function* F() &#123;
  this.a = 1;
  yield this.b = 2;
  yield this.c = 3;
&#125;
var f = F.call(F.prototype);

f.next();  // Object &#123;value: 2, done: false&#125;
f.next();  // Object &#123;value: 3, done: false&#125;
f.next();  // Object &#123;value: undefined, done: true&#125;

f.a // 1
f.b // 2
f.c // 3
</code></pre><p>再将<code>F</code>改成构造函数，就可以对它执行<code>new</code>命令了。</p><pre><code class="javascript">function* gen() &#123;
  this.a = 1;
  yield this.b = 2;
  yield this.c = 3;
&#125;

function F() &#123;
  return gen.call(gen.prototype);
&#125;

var f = new F();

f.next();  // Object &#123;value: 2, done: false&#125;
f.next();  // Object &#123;value: 3, done: false&#125;
f.next();  // Object &#123;value: undefined, done: true&#125;

f.a // 1
f.b // 2
f.c // 3
</code></pre><hr><h4 id="10-含义"><a href="#10-含义" class="headerlink" title="10. 含义"></a>10. 含义</h4><p><strong>Generator 与状态机</strong></p><p>Generator 是实现状态机的最佳结构。比如，下面的<code>clock</code>函数就是一个状态机。</p><pre><code class="javascript">var ticking = true;
var clock = function() &#123;
  if (ticking)
    console.log(&#39;Tick!&#39;);
  else
    console.log(&#39;Tock!&#39;);
  ticking = !ticking;
&#125;
</code></pre><p>上面代码的<code>clock</code>函数一共有两种状态（<code>Tick</code>和<code>Tock</code>），每运行一次，就改变一次状态。这个函数如果用 Generator 实现，就是下面这样。</p><pre><code class="javascript">var clock = function* () &#123;
  while (true) &#123;
    console.log(&#39;Tick!&#39;);
    yield;
    console.log(&#39;Tock!&#39;);
    yield;
  &#125;
&#125;;
</code></pre><p>上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量<code>ticking</code>，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p><p><strong>Generator 与协程</strong></p><p>协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p><p><strong>（1）协程与子例程的差异</strong></p><p><strong>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数</strong>。<strong>协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended）</strong>，线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p><p>从实现上看，<strong>在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</strong></p><p><strong>（2）协程与普通线程的差异</strong></p><p>不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p><p>由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p><p>Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p><p>如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用<code>yield</code>表达式交换控制权。</p><hr><p><strong>Generator 与上下文</strong></p><p>JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。</p><p><strong>这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。</strong></p><p><strong>Generator 函数不是这样，它执行产生的上下文环境，一旦遇到<code>yield</code>命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行<code>next</code>命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。</strong></p><pre><code class="javascript">function* gen() &#123;
  yield 1;
  return 2;
&#125;

let g = gen();

console.log(
  g.next().value,
  g.next().value,
);
</code></pre><p>上面代码中，第一次执行<code>g.next()</code>时，Generator 函数<code>gen</code>的上下文会加入堆栈，即开始运行<code>gen</code>内部的代码。等遇到<code>yield 1</code>时，<code>gen</code>上下文退出堆栈，内部状态冻结。第二次执行<code>g.next()</code>时，<code>gen</code>上下文重新加入堆栈，变成当前的上下文，重新恢复执行。</p><hr><h4 id="11-应用"><a href="#11-应用" class="headerlink" title="11. 应用"></a>11. 应用</h4><p>Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。</p><p><strong>（1）异步操作的同步化表达</strong></p><p>Generator 函数的暂停执行的效果，意味着可以把异步操作写在<code>yield</code>表达式里面，等到调用<code>next</code>方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在<code>yield</code>表达式下面，反正要等到调用<code>next</code>方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p><pre><code class="javascript">function* loadUI() &#123;
  showLoadingScreen();
  yield loadUIDataAsynchronously();
  hideLoadingScreen();
&#125;
var loader = loadUI();
// 加载UI
loader.next()

// 卸载UI
loader.next()
</code></pre><p>上面代码中，第一次调用<code>loadUI</code>函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用<code>next</code>方法，则会显示<code>Loading</code>界面（<code>showLoadingScreen</code>），并且异步加载数据（<code>loadUIDataAsynchronously</code>）。等到数据加载完成，再一次使用<code>next</code>方法，则会隐藏<code>Loading</code>界面。可以看到，这种写法的好处是所有<code>Loading</code>界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p><p><strong>Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。</strong></p><pre><code class="javascript">function* main() &#123;
  var result = yield request(&quot;http://some.url&quot;);
  var resp = JSON.parse(result);
    console.log(resp.value);
&#125;

function request(url) &#123;
  makeAjaxCall(url, function(response)&#123;
    it.next(response);
  &#125;);
&#125;

var it = main();
it.next();
</code></pre><p>上面代码的<code>main</code>函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个<code>yield</code>，它几乎与同步操作的写法完全一样。注意，**<code>makeAjaxCall</code>函数中的<code>next</code>方法，必须加上<code>response</code>参数，因为<code>yield</code>表达式，本身是没有值的，总是等于<code>undefined</code>。**</p><p>下面是另一个例子，通过 Generator 函数逐行读取文本文件。</p><pre><code class="javascript">function* numbers() &#123;
  let file = new FileReader(&quot;numbers.txt&quot;);
  try &#123;
    while(!file.eof) &#123;
      yield parseInt(file.readLine(), 10);
    &#125;
  &#125; finally &#123;
    file.close();
  &#125;
&#125;
</code></pre><p>上面代码打开文本文件，使用<code>yield</code>表达式可以手动逐行读取文件。</p><hr><p><strong>（2）控制流管理</strong></p><p>如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p><pre><code class="javascript">step1(function (value1) &#123;
  step2(value1, function(value2) &#123;
    step3(value2, function(value3) &#123;
      step4(value3, function(value4) &#123;
        // Do something with value4
      &#125;);
    &#125;);
  &#125;);
&#125;);
</code></pre><p>采用 Promise 改写上面的代码。</p><pre><code class="javascript">Promise.resolve(step1)
  .then(step2)
  .then(step3)
  .then(step4)
  .then(function (value4) &#123;
    // Do something with value4
  &#125;, function (error) &#123;
    // Handle any error from step1 through step4
  &#125;)
  .done();
</code></pre><p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。</p><pre><code class="javascript">function* longRunningTask(value1) &#123;
  try &#123;
    var value2 = yield step1(value1);
    var value3 = yield step2(value2);
    var value4 = yield step3(value3);
    var value5 = yield step4(value4);
    // Do something with value4
  &#125; catch (e) &#123;
    // Handle any error from step1 through step4
  &#125;
&#125;
</code></pre><p>然后，使用一个函数，按次序自动执行所有步骤。</p><pre><code class="javascript">scheduler(longRunningTask(initialValue));

function scheduler(task) &#123;
  var taskObj = task.next(task.value);
  // 如果Generator函数未结束，就继续调用
  if (!taskObj.done) &#123;
    task.value = taskObj.value
    scheduler(task);
  &#125;
&#125;
</code></pre><p>注意，上面这种做法，只适合同步操作，即所有的<code>task</code>都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。</p><p>下面，利用<code>for...of</code>循环会自动依次执行<code>yield</code>命令的特性，提供一种更一般的控制流管理的方法。</p><pre><code class="javascript">let steps = [step1Func, step2Func, step3Func];

function* iterateSteps(steps)&#123;
  for (var i=0; i&lt; steps.length; i++)&#123;
    var step = steps[i];
    yield step();
  &#125;
&#125;
</code></pre><p>上面代码中，数组<code>steps</code>封装了一个任务的多个步骤，Generator 函数<code>iterateSteps</code>则是依次为这些步骤加上<code>yield</code>命令。</p><p>将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。</p><pre><code class="javascript">let jobs = [job1, job2, job3];

function* iterateJobs(jobs)&#123;
  for (var i=0; i&lt; jobs.length; i++)&#123;
    var job = jobs[i];
    yield* iterateSteps(job.steps);
  &#125;
&#125;
</code></pre><p>上面代码中，数组<code>jobs</code>封装了一个项目的多个任务，Generator 函数<code>iterateJobs</code>则是依次为这些任务加上<code>yield*</code>命令。</p><p>最后，就可以用<code>for...of</code>循环一次性依次执行所有任务的所有步骤。</p><pre><code class="javascript">for (var step of iterateJobs(jobs))&#123;
  console.log(step.id);
&#125;
</code></pre><p>再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。</p><p><code>for...of</code>的本质是一个<code>while</code>循环，所以上面的代码实质上执行的是下面的逻辑。</p><pre><code class="javascript">var it = iterateJobs(jobs);
var res = it.next();

while (!res.done)&#123;
  var result = res.value;
  // ...
  res = it.next();
&#125;
</code></pre><hr><p><strong>（3）部署 Iterator 接口</strong></p><p>利用 Generator 函数，可以在任意对象上部署 Iterator 接口。</p><pre><code class="javascript">function* iterEntries(obj) &#123;
  let keys = Object.keys(obj);
  for (let i=0; i &lt; keys.length; i++) &#123;
    let key = keys[i];
    yield [key, obj[key]];
  &#125;
&#125;

let myObj = &#123; foo: 3, bar: 7 &#125;;

for (let [key, value] of iterEntries(myObj)) &#123;
  console.log(key, value);
&#125;

// foo 3
// bar 7
</code></pre><p>上述代码中，<code>myObj</code>是一个普通对象，通过<code>iterEntries</code>函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署<code>next</code>方法。</p><p>下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口。</p><pre><code class="javascript">function* makeSimpleGenerator(array)&#123;
  var nextIndex = 0;

  while(nextIndex &lt; array.length)&#123;
    yield array[nextIndex++];
  &#125;
&#125;

var gen = makeSimpleGenerator([&#39;yo&#39;, &#39;ya&#39;]);

gen.next().value // &#39;yo&#39;
gen.next().value // &#39;ya&#39;
gen.next().done  // true
</code></pre><hr><p><strong>（4）作为数据结构</strong></p><p>Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。</p><pre><code class="javascript">function* doStuff() &#123;
  yield fs.readFile.bind(null, &#39;hello.txt&#39;);
  yield fs.readFile.bind(null, &#39;world.txt&#39;);
  yield fs.readFile.bind(null, &#39;and-such.txt&#39;);
&#125;
</code></pre><p>上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。</p><pre><code class="javascript">for (task of doStuff()) &#123;
  // task是一个函数，可以像回调函数那样使用它
&#125;
</code></pre><p>实际上，如果用 ES5 表达，完全可以用数组模拟 Generator 的这种用法。</p><pre><code class="javascript">function doStuff() &#123;
  return [
    fs.readFile.bind(null, &#39;hello.txt&#39;),
    fs.readFile.bind(null, &#39;world.txt&#39;),
    fs.readFile.bind(null, &#39;and-such.txt&#39;)
  ];
&#125;
</code></pre><p>上面的函数，可以用一模一样的<code>for...of</code>循环处理！两相一比较，就不难看出 Generator 使得数据或者操作，具备了类似数组的接口。</p><h3 id="19、-Generator-函数的异步应用"><a href="#19、-Generator-函数的异步应用" class="headerlink" title="19、 Generator 函数的异步应用"></a>19、 Generator 函数的异步应用</h3><hr><h4 id="1-传统方法"><a href="#1-传统方法" class="headerlink" title="1. 传统方法"></a>1. 传统方法</h4><p>ES6 诞生以前，异步编程的方法，大概有下面四种。</p><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li><li>Promise 对象</li></ul><p>Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。</p><hr><h4 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h4><p><strong>异步</strong></p><p>所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p><p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p><p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p><hr><p><strong>回调函数</strong></p><p>JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字<code>callback</code>，直译过来就是”重新调用”。</p><p>读取文件进行处理，是这样写的。</p><pre><code class="javascript">fs.readFile(&#39;/etc/passwd&#39;, &#39;utf-8&#39;, function (err, data) &#123;
  if (err) throw err;
  console.log(data);
&#125;);
</code></pre><p>上面代码中，<code>readFile</code>函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p><p><strong>一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象<code>err</code>（如果没有错误，该参数就是<code>null</code>）？</strong></p><p><strong>原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。</strong></p><hr><p><strong>Promise</strong></p><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取<code>A</code>文件之后，再读取<code>B</code>文件，代码如下。</p><pre><code class="javascript">fs.readFile(fileA, &#39;utf-8&#39;, function (err, data) &#123;
  fs.readFile(fileB, &#39;utf-8&#39;, function (err, data) &#123;
    // ...
  &#125;);
&#125;);
</code></pre><p>不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为”回调函数地狱”（callback hell）。</p><p>Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。</p><pre><code class="javascript">var readFile = require(&#39;fs-readfile-promise&#39;);

readFile(fileA)
.then(function (data) &#123;
  console.log(data.toString());
&#125;)
.then(function () &#123;
  return readFile(fileB);
&#125;)
.then(function (data) &#123;
  console.log(data.toString());
&#125;)
.catch(function (err) &#123;
  console.log(err);
&#125;);
</code></pre><p>上面代码中，我使用了<code>fs-readfile-promise</code>模块，它的作用就是返回一个 Promise 版本的<code>readFile</code>函数。Promise 提供<code>then</code>方法加载回调函数，<code>catch</code>方法捕捉执行过程中抛出的错误。</p><p><strong>可以看到，Promise 的写法只是回调函数的改进，使用<code>then</code>方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</strong></p><p><strong>Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆<code>then</code>，原来的语义变得很不清楚。</strong></p><p>那么，有没有更好的写法呢？</p><hr><h4 id="3-Generator-函数"><a href="#3-Generator-函数" class="headerlink" title="3. Generator 函数"></a>3. Generator 函数</h4><p><strong>协程</strong></p><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。</p><p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p><ul><li>第一步，协程<code>A</code>开始执行。</li><li>第二步，协程<code>A</code>执行到一半，进入暂停，执行权转移到协程<code>B</code>。</li><li>第三步，（一段时间后）协程<code>B</code>交还执行权。</li><li>第四步，协程<code>A</code>恢复执行。</li></ul><p>上面流程的协程<code>A</code>，就是异步任务，因为它分成两段（或多段）执行。</p><p>举例来说，读取文件的协程写法如下。</p><pre><code class="javascript">function* asyncJob() &#123;
  // ...其他代码
  var f = yield readFile(fileA);
  // ...其他代码
&#125;
</code></pre><p>上面代码的函数<code>asyncJob</code>是一个协程，它的奥妙就在其中的<code>yield</code>命令。它表示执行到此处，执行权将交给其他协程。也就是说，<code>yield</code>命令是异步两个阶段的分界线。</p><p>协程遇到<code>yield</code>命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除<code>yield</code>命令，简直一模一样。</p><hr><p><strong>协程的 Generator 函数实现</strong></p><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p><p>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用<code>yield</code>语句注明。Generator 函数的执行方法如下。</p><pre><code class="javascript">function* gen(x) &#123;
  var y = yield x + 2;
  return y;
&#125;

var g = gen(1);
g.next() // &#123; value: 3, done: false &#125;
g.next() // &#123; value: undefined, done: true &#125;
</code></pre><p>上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）<code>g</code>。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针<code>g</code>的<code>next</code>方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的<code>yield</code>语句，上例是执行到<code>x + 2</code>为止。</p><p>换言之，<code>next</code>方法的作用是分阶段执行<code>Generator</code>函数。每次调用<code>next</code>方法，会返回一个对象，表示当前阶段的信息（<code>value</code>属性和<code>done</code>属性）。<code>value</code>属性是<code>yield</code>语句后面表达式的值，表示当前阶段的值；<code>done</code>属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p><hr><p><strong>Generator 函数的数据交换和错误处理</strong></p><p><strong>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因</strong>。除此之外，<strong>它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</strong></p><p><strong><code>next</code>返回值的 value 属性，是 Generator 函数向外输出数据；<code>next</code>方法还可以接受参数，向 Generator 函数体内输入数据。</strong></p><pre><code class="javascript">function* gen(x)&#123;
  var y = yield x + 2;
  return y;
&#125;

var g = gen(1);
g.next() // &#123; value: 3, done: false &#125;
g.next(2) // &#123; value: 2, done: true &#125;
</code></pre><p>上面代码中，第一个<code>next</code>方法的<code>value</code>属性，返回表达式<code>x + 2</code>的值<code>3</code>。第二个<code>next</code>方法带有参数<code>2</code>，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量<code>y</code>接收。因此，这一步的<code>value</code>属性，返回的就是<code>2</code>（变量<code>y</code>的值）。</p><p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p><pre><code class="javascript">function* gen(x)&#123;
  try &#123;
    var y = yield x + 2;
  &#125; catch (e)&#123;
    console.log(e);
  &#125;
  return y;
&#125;

var g = gen(1);
g.next();
g.throw(&#39;出错了&#39;);
// 出错了
</code></pre><p>上面代码的最后一行，Generator 函数体外，使用指针对象的<code>throw</code>方法抛出的错误，可以被函数体内的<code>try...catch</code>代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p><hr><p><strong>异步任务的封装</strong></p><p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p><pre><code class="javascript">var fetch = require(&#39;node-fetch&#39;);

function* gen()&#123;
  var url = &#39;https://api.github.com/users/github&#39;;
  var result = yield fetch(url);
  console.log(result.bio);
&#125;
</code></pre><p>上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了<code>yield</code>命令。</p><p>执行这段代码的方法如下。</p><pre><code class="javascript">var g = gen();
var result = g.next();

result.value.then(function(data)&#123;
  return data.json();
&#125;).then(function(data)&#123;
  g.next(data);
&#125;);
</code></pre><p>上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用<code>next</code>方法（第二行），执行异步任务的第一阶段。由于<code>Fetch</code>模块返回的是一个 Promise 对象，因此要用<code>then</code>方法调用下一个<code>next</code>方法。</p><p>可以看到，<strong>虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</strong></p><hr><h4 id="4-Thunk-函数"><a href="#4-Thunk-函数" class="headerlink" title="4. Thunk 函数"></a>4. Thunk 函数</h4><p>Thunk 函数是自动执行 Generator 函数的一种方法。</p><p><strong>参数的求值策略</strong></p><p>Thunk 函数早在上个世纪 60 年代就诞生了。</p><p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底应该何时求值。</p><pre><code class="javascript">var x = 1;

function f(m) &#123;
  return m * 2;
&#125;

f(x + 5)
</code></pre><p>上面代码先定义函数<code>f</code>，然后向它传入表达式<code>x + 5</code>。请问，这个表达式应该何时求值？</p><p><strong>一种意见是”传值调用”（call by value），即在进入函数体之前，就计算<code>x + 5</code>的值（等于 6），再将这个值传入函数<code>f</code>。C 语言就采用这种策略。</strong></p><pre><code class="javascript">f(x + 5)
// 传值调用时，等同于
f(6)
</code></pre><p><strong>另一种意见是“传名调用”（call by name），即直接将表达式<code>x + 5</code>传入函数体，只在用到它的时候求值。Haskell 语言采用这种策略。</strong></p><pre><code class="javascript">f(x + 5)
// 传名调用时，等同于
(x + 5) * 2
</code></pre><p>传值调用和传名调用，哪一种比较好？</p><p>回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p><pre><code class="javascript">function f(a, b)&#123;
  return b;
&#125;

f(3 * x * x - 2 * x - 1, x);
</code></pre><p>上面代码中，函数<code>f</code>的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于”传名调用”，即只在执行时求值。</p><hr><p><strong>Thunk 函数的含义</strong></p><p>编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。</p><pre><code class="javascript">function f(m) &#123;
  return m * 2;
&#125;

f(x + 5);

// 等同于

var thunk = function () &#123;
  return x + 5;
&#125;;

function f(thunk) &#123;
  return thunk() * 2;
&#125;
</code></pre><p>上面代码中，函数 f 的参数<code>x + 5</code>被一个函数替换了。凡是用到原参数的地方，对<code>Thunk</code>函数求值即可。</p><p>这就是 Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。</p><hr><p><strong>JavaScript 语言的 Thunk 函数</strong></p><p><strong>JavaScript 语言是传值调用</strong>，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，<strong>Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</strong></p><pre><code class="javascript">// 正常版本的readFile（多参数版本）
fs.readFile(fileName, callback);

// Thunk版本的readFile（单参数版本）
var Thunk = function (fileName) &#123;
  return function (callback) &#123;
    return fs.readFile(fileName, callback);
  &#125;;
&#125;;

var readFileThunk = Thunk(fileName);
readFileThunk(callback);
</code></pre><p>上面代码中，<code>fs</code>模块的<code>readFile</code>方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。</p><p>任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。</p><pre><code class="javascript">// ES5版本
var Thunk = function(fn)&#123;
  return function ()&#123;
    var args = Array.prototype.slice.call(arguments);
    return function (callback)&#123;
      args.push(callback);
      return fn.apply(this, args);
    &#125;
  &#125;;
&#125;;

// ES6版本
const Thunk = function(fn) &#123;
  return function (...args) &#123;
    return function (callback) &#123;
      return fn.call(this, ...args, callback);
    &#125;
  &#125;;
&#125;;
</code></pre><p>使用上面的转换器，生成<code>fs.readFile</code>的 Thunk 函数。</p><pre><code class="javascript">var readFileThunk = Thunk(fs.readFile);
readFileThunk(fileA)(callback);
</code></pre><p>下面是另一个完整的例子。</p><pre><code class="javascript">function f(a, cb) &#123;
  cb(a);
&#125;
const ft = Thunk(f);

ft(1)(console.log) // 1
</code></pre><hr><p><strong>Thunkify 模块</strong></p><p>生产环境的转换器，建议使用 Thunkify 模块。</p><p>首先是安装。</p><pre><code class="bash">$ npm install thunkify
</code></pre><p>使用方式如下。</p><pre><code class="javascript">var thunkify = require(&#39;thunkify&#39;);
var fs = require(&#39;fs&#39;);

var read = thunkify(fs.readFile);
read(&#39;package.json&#39;)(function(err, str)&#123;
  // ...
&#125;);
</code></pre><p>Thunkify 的源码与上一节那个简单的转换器非常像。</p><pre><code class="javascript">function thunkify(fn) &#123;
  return function() &#123;
    var args = new Array(arguments.length);
    var ctx = this;

    for (var i = 0; i &lt; args.length; ++i) &#123;
      args[i] = arguments[i];
    &#125;

    return function (done) &#123;
      var called;

      args.push(function () &#123;
        if (called) return;
        called = true;
        done.apply(null, arguments);
      &#125;);

      try &#123;
        fn.apply(ctx, args);
      &#125; catch (err) &#123;
        done(err);
      &#125;
    &#125;
  &#125;
&#125;;
</code></pre><p>它的源码主要多了一个检查机制，变量<code>called</code>确保回调函数只运行一次。这样的设计与下文的 Generator 函数相关。请看下面的例子。</p><pre><code class="javascript">function f(a, b, callback)&#123;
  var sum = a + b;
  callback(sum);
  callback(sum);
&#125;

var ft = thunkify(f);
var print = console.log.bind(console);
ft(1, 2)(print);
// 3
</code></pre><p>上面代码中，由于<code>thunkify</code>只允许回调函数执行一次，所以只输出一行结果。</p><hr><p><strong>Generator 函数的流程管理</strong></p><p>你可能会问， Thunk 函数有什么用？回答是以前确实没什么用，但是 ES6 有了 Generator 函数，Thunk 函数现在可以用于 Generator 函数的自动流程管理。</p><p>Generator 函数可以自动执行。</p><pre><code class="javascript">function* gen() &#123;
  // ...
&#125;

var g = gen();
var res = g.next();

while(!res.done)&#123;
  console.log(res.value);
  res = g.next();
&#125;
</code></pre><p>上面代码中，Generator 函数<code>gen</code>会自动执行完所有步骤。</p><p>但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk 函数就能派上用处。以读取文件为例。下面的 Generator 函数封装了两个异步操作。</p><pre><code class="javascript">var fs = require(&#39;fs&#39;);
var thunkify = require(&#39;thunkify&#39;);
var readFileThunk = thunkify(fs.readFile);

var gen = function* ()&#123;
  var r1 = yield readFileThunk(&#39;/etc/fstab&#39;);
  console.log(r1.toString());
  var r2 = yield readFileThunk(&#39;/etc/shells&#39;);
  console.log(r2.toString());
&#125;;
</code></pre><p><strong>上面代码中，<code>yield</code>命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。</strong></p><p><strong>这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。为了便于理解，我们先看如何手动执行上面这个 Generator 函数。</strong></p><pre><code class="javascript">var g = gen();

var r1 = g.next();
r1.value(function (err, data) &#123;
  if (err) throw err;
  var r2 = g.next(data);
  r2.value(function (err, data) &#123;
    if (err) throw err;
    g.next(data);
  &#125;);
&#125;);
</code></pre><p>上面代码中，变量<code>g</code>是 Generator 函数的内部指针，表示目前执行到哪一步。<code>next</code>方法负责将指针移动到下一步，并返回该步的信息（<code>value</code>属性和<code>done</code>属性）。</p><p>仔细查看上面的代码，可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入<code>next</code>方法的<code>value</code>属性。这使得我们可以用递归来自动完成这个过程。</p><p><strong>Thunk 函数的自动流程管理</strong></p><p>Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。</p><pre><code class="javascript">function run(fn) &#123;
  var gen = fn();

  function next(err, data) &#123;
    var result = gen.next(data);
    if (result.done) return;
    result.value(next);
  &#125;

  next();
&#125;

function* g() &#123;
  // ...
&#125;

run(g);
</code></pre><p>上面代码的<code>run</code>函数，就是一个 Generator 函数的自动执行器。内部的<code>next</code>函数就是 Thunk 的回调函数。<code>next</code>函数先将指针移到 Generator 函数的下一步（<code>gen.next</code>方法），然后判断 Generator 函数是否结束（<code>result.done</code>属性），如果没结束，就将<code>next</code>函数再传入 Thunk 函数（<code>result.value</code>属性），否则就直接退出。</p><p>有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入<code>run</code>函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在<code>yield</code>命令后面的必须是 Thunk 函数。</p><pre><code class="javascript">var g = function* ()&#123;
  var f1 = yield readFileThunk(&#39;fileA&#39;);
  var f2 = yield readFileThunk(&#39;fileB&#39;);
  // ...
  var fn = yield readFileThunk(&#39;fileN&#39;);
&#125;;

run(g);
</code></pre><p>上面代码中，函数<code>g</code>封装了<code>n</code>个异步的读取文件操作，只要执行<code>run</code>函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p><p>Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p><hr><h4 id="5-co-模块"><a href="#5-co-模块" class="headerlink" title="5. co 模块"></a>5. co 模块</h4><p><strong>基本用法</strong></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RqL2Nv">co 模块</span>是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行。</p><p>下面是一个 Generator 函数，用于依次读取两个文件。</p><pre><code class="javascript">var gen = function* () &#123;
  var f1 = yield readFile(&#39;/etc/fstab&#39;);
  var f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre><p>co 模块可以让你不用编写 Generator 函数的执行器。</p><pre><code class="javascript">var co = require(&#39;co&#39;);
co(gen);
</code></pre><p>上面代码中，Generator 函数只要传入<code>co</code>函数，就会自动执行。</p><p><code>co</code>函数返回一个<code>Promise</code>对象，因此可以用<code>then</code>方法添加回调函数。</p><pre><code class="javascript">co(gen).then(function ()&#123;
  console.log(&#39;Generator 函数执行完成&#39;);
&#125;);
</code></pre><p>上面代码中，等到 Generator 函数执行结束，就会输出一行提示。</p><hr><p><strong>co 模块的原理</strong></p><p>为什么 co 可以自动执行 Generator 函数？</p><p>前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p><p>两种方法可以做到这一点。</p><p>（1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</p><p>（2）Promise 对象。将异步操作包装成 Promise 对象，用<code>then</code>方法交回执行权。</p><p>co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的<code>yield</code>命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co，详见后文的例子。</p><p>上一节已经介绍了基于 Thunk 函数的自动执行器。下面来看，基于 Promise 对象的自动执行器。这是理解 co 模块必须的。</p><hr><p><strong>基于 Promise 对象的自动执行</strong></p><p>还是沿用上面的例子。首先，把<code>fs</code>模块的<code>readFile</code>方法包装成一个 Promise 对象。</p><pre><code class="javascript">var fs = require(&#39;fs&#39;);

var readFile = function (fileName)&#123;
  return new Promise(function (resolve, reject)&#123;
    fs.readFile(fileName, function(error, data)&#123;
      if (error) return reject(error);
      resolve(data);
    &#125;);
  &#125;);
&#125;;

var gen = function* ()&#123;
  var f1 = yield readFile(&#39;/etc/fstab&#39;);
  var f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre><p>然后，手动执行上面的 Generator 函数。</p><pre><code class="javascript">var g = gen();

g.next().value.then(function(data)&#123;
  g.next(data).value.then(function(data)&#123;
    g.next(data);
  &#125;);
&#125;);
</code></pre><p>手动执行其实就是用<code>then</code>方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p><pre><code class="javascript">function run(gen)&#123;
  var g = gen();

  function next(data)&#123;
    var result = g.next(data);
    if (result.done) return result.value;
    result.value.then(function(data)&#123;
      next(data);
    &#125;);
  &#125;

  next();
&#125;

run(gen);
</code></pre><p>上面代码中，只要 Generator 函数还没执行到最后一步，<code>next</code>函数就调用自身，以此实现自动执行。</p><hr><p><strong>co 模块的源码</strong></p><p>co 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p><p>首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。</p><pre><code class="javascript">function co(gen) &#123;
  var ctx = this;

  return new Promise(function(resolve, reject) &#123;
  &#125;);
&#125;
</code></pre><p>在返回的 Promise 对象里面，co 先检查参数<code>gen</code>是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为<code>resolved</code>。</p><pre><code class="javascript">function co(gen) &#123;
  var ctx = this;

  return new Promise(function(resolve, reject) &#123;
    if (typeof gen === &#39;function&#39;) gen = gen.call(ctx);
    if (!gen || typeof gen.next !== &#39;function&#39;) return resolve(gen);
  &#125;);
&#125;
</code></pre><p>接着，co 将 Generator 函数的内部指针对象的<code>next</code>方法，包装成<code>onFulfilled</code>函数。这主要是为了能够捕捉抛出的错误。</p><pre><code class="javascript">function co(gen) &#123;
  var ctx = this;

  return new Promise(function(resolve, reject) &#123;
    if (typeof gen === &#39;function&#39;) gen = gen.call(ctx);
    if (!gen || typeof gen.next !== &#39;function&#39;) return resolve(gen);

    onFulfilled();
    function onFulfilled(res) &#123;
      var ret;
      try &#123;
        ret = gen.next(res);
      &#125; catch (e) &#123;
        return reject(e);
      &#125;
      next(ret);
    &#125;
  &#125;);
&#125;
</code></pre><p>最后，就是关键的<code>next</code>函数，它会反复调用自身。</p><pre><code class="javascript">function next(ret) &#123;
  if (ret.done) return resolve(ret.value);
  var value = toPromise.call(ctx, ret.value);
  if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);
  return onRejected(
    new TypeError(
      &#39;You may only yield a function, promise, generator, array, or object, &#39;
      + &#39;but the following object was passed: &quot;&#39;
      + String(ret.value)
      + &#39;&quot;&#39;
    )
  );
&#125;
</code></pre><p>上面代码中，<code>next</code>函数的内部代码，一共只有四行命令。</p><p>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p><p>第二行，确保每一步的返回值，是 Promise 对象。</p><p>第三行，使用<code>then</code>方法，为返回值加上回调函数，然后通过<code>onFulfilled</code>函数再次调用<code>next</code>函数。</p><p>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为<code>rejected</code>，从而终止执行。</p><hr><p><strong>处理并发的异步操作</strong></p><p>co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p><p>这时，要把并发的操作都放在数组或对象里面，跟在<code>yield</code>语句后面。</p><pre><code class="javascript">// 数组的写法
co(function* () &#123;
  var res = yield [
    Promise.resolve(1),
    Promise.resolve(2)
  ];
  console.log(res);
&#125;).catch(onerror);

// 对象的写法
co(function* () &#123;
  var res = yield &#123;
    1: Promise.resolve(1),
    2: Promise.resolve(2),
  &#125;;
  console.log(res);
&#125;).catch(onerror);
</code></pre><p>下面是另一个例子。</p><pre><code class="javascript">co(function* () &#123;
  var values = [n1, n2, n3];
  yield values.map(somethingAsync);
&#125;);

function* somethingAsync(x) &#123;
  // do something async
  return y
&#125;
</code></pre><p>上面的代码允许并发三个<code>somethingAsync</code>异步操作，等到它们全部完成，才会进行下一步。</p><hr><p><strong>实例：处理 Stream</strong></p><p>Node 提供 Stream 模式读写数据，特点是一次只处理数据的一部分，数据分成一块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。Stream 模式使用 EventEmitter API，会释放三个事件。</p><ul><li><code>data</code>事件：下一块数据块已经准备好了。</li><li><code>end</code>事件：整个“数据流”处理完了。</li><li><code>error</code>事件：发生错误。</li></ul><p>使用<code>Promise.race()</code>函数，可以判断这三个事件之中哪一个最先发生，只有当<code>data</code>事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一个<code>while</code>循环，完成所有数据的读取。</p><pre><code class="javascript">const co = require(&#39;co&#39;);
const fs = require(&#39;fs&#39;);

const stream = fs.createReadStream(&#39;./les_miserables.txt&#39;);
let valjeanCount = 0;

co(function*() &#123;
  while(true) &#123;
    const res = yield Promise.race([
      new Promise(resolve =&gt; stream.once(&#39;data&#39;, resolve)),
      new Promise(resolve =&gt; stream.once(&#39;end&#39;, resolve)),
      new Promise((resolve, reject) =&gt; stream.once(&#39;error&#39;, reject))
    ]);
    if (!res) &#123;
      break;
    &#125;
    stream.removeAllListeners(&#39;data&#39;);
    stream.removeAllListeners(&#39;end&#39;);
    stream.removeAllListeners(&#39;error&#39;);
    valjeanCount += (res.toString().match(/valjean/ig) || []).length;
  &#125;
  console.log(&#39;count:&#39;, valjeanCount); // count: 1120
&#125;);
</code></pre><p>上面代码采用 Stream 模式读取《悲惨世界》的文本文件，对于每个数据块都使用<code>stream.once</code>方法，在<code>data</code>、<code>end</code>、<code>error</code>三个事件上添加一次性回调函数。变量<code>res</code>只有在<code>data</code>事件发生时才有值，然后累加每个数据块之中<code>valjean</code>这个词出现的次数。</p><h3 id="20、-async-函数"><a href="#20、-async-函数" class="headerlink" title="20、 async 函数"></a>20、 async 函数</h3><hr><h4 id="1-含义"><a href="#1-含义" class="headerlink" title="1. 含义"></a>1. 含义</h4><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p><p><strong>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</strong></p><p>前文有一个 Generator 函数，依次读取两个文件。</p><pre><code class="javascript">const fs = require(&#39;fs&#39;);

const readFile = function (fileName) &#123;
  return new Promise(function (resolve, reject) &#123;
    fs.readFile(fileName, function(error, data) &#123;
      if (error) return reject(error);
      resolve(data);
    &#125;);
  &#125;);
&#125;;

const gen = function* () &#123;
  const f1 = yield readFile(&#39;/etc/fstab&#39;);
  const f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre><p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样。</p><pre><code class="javascript">const asyncReadFile = async function () &#123;
  const f1 = await readFile(&#39;/etc/fstab&#39;);
  const f2 = await readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre><p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p><p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p><p><strong>（1）内置执行器。</strong></p><p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p><pre><code class="javascript">asyncReadFile();
</code></pre><p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p><p><strong>（2）更好的语义。</strong></p><p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。**<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。**</p><p><strong>（3）更广的适用性。</strong></p><p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p><p><strong>（4）返回值是 Promise。</strong></p><p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p><p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p><hr><h4 id="2-基本用法-1"><a href="#2-基本用法-1" class="headerlink" title="2. 基本用法"></a>2. 基本用法</h4><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><p>下面是一个例子。</p><pre><code class="javascript">async function getStockPriceByName(name) &#123;
  const symbol = await getStockSymbol(name);
  const stockPrice = await getStockPrice(symbol);
  return stockPrice;
&#125;

getStockPriceByName(&#39;goog&#39;).then(function (result) &#123;
  console.log(result);
&#125;);
</code></pre><p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p><p>下面是另一个例子，指定多少毫秒后输出一个值。</p><pre><code class="javascript">function timeout(ms) &#123;
  return new Promise((resolve) =&gt; &#123;
    setTimeout(resolve, ms);
  &#125;);
&#125;

async function asyncPrint(value, ms) &#123;
  await timeout(ms);
  console.log(value);
&#125;

asyncPrint(&#39;hello world&#39;, 50);
</code></pre><p>上面代码指定 50 毫秒以后，输出<code>hello world</code>。</p><p>由于<code>async</code>函数返回的是 Promise 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p><pre><code class="javascript">async function timeout(ms) &#123;
  await new Promise((resolve) =&gt; &#123;
    setTimeout(resolve, ms);
  &#125;);
&#125;

async function asyncPrint(value, ms) &#123;
  await timeout(ms);
  console.log(value);
&#125;

asyncPrint(&#39;hello world&#39;, 50);
</code></pre><p>async 函数有多种使用形式。</p><pre><code class="javascript">// 函数声明
async function foo() &#123;&#125;

// 函数表达式
const foo = async function () &#123;&#125;;

// 对象的方法
let obj = &#123; async foo() &#123;&#125; &#125;;
obj.foo().then(...)

// Class 的方法
class Storage &#123;
  constructor() &#123;
    this.cachePromise = caches.open(&#39;avatars&#39;);
  &#125;

  async getAvatar(name) &#123;
    const cache = await this.cachePromise;
    return cache.match(`/avatars/$&#123;name&#125;.jpg`);
  &#125;
&#125;

const storage = new Storage();
storage.getAvatar(&#39;jake&#39;).then(…);

// 箭头函数
const foo = async () =&gt; &#123;&#125;;
</code></pre><hr><h4 id="3-语法"><a href="#3-语法" class="headerlink" title="3. 语法"></a>3. 语法</h4><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p><p><strong>返回 Promise 对象</strong></p><p><code>async</code>函数返回一个 Promise 对象。</p><p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p><pre><code class="javascript">async function f() &#123;
  return &#39;hello world&#39;;
&#125;

f().then(v =&gt; console.log(v))
// &quot;hello world&quot;
</code></pre><p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p><p><strong><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</strong></p><pre><code class="javascript">async function f() &#123;
  throw new Error(&#39;出错了&#39;);
&#125;

f().then(
  v =&gt; console.log(&#39;resolve&#39;, v),
  e =&gt; console.log(&#39;reject&#39;, e)
)
//reject Error: 出错了
</code></pre><hr><p><strong>Promise 对象的状态变化</strong></p><p><strong><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</strong></p><p>下面是一个例子。</p><pre><code class="javascript">async function getTitle(url) &#123;
  let response = await fetch(url);
  let html = await response.text();
  return html.match(/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i)[1];
&#125;
getTitle(&#39;https://tc39.github.io/ecma262/&#39;).then(console.log)
// &quot;ECMAScript 2017 Language Specification&quot;
</code></pre><p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p><hr><p><strong>await 命令</strong></p><p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p><pre><code class="javascript">async function f() &#123;
  // 等同于
  // return 123;
  return await 123;
&#125;

f().then(v =&gt; console.log(v))
// 123
</code></pre><p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，这时等同于<code>return 123</code>。</p><p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p><pre><code class="javascript">class Sleep &#123;
  constructor(timeout) &#123;
    this.timeout = timeout;
  &#125;
  then(resolve, reject) &#123;
    const startTime = Date.now();
    setTimeout(
      () =&gt; resolve(Date.now() - startTime),
      this.timeout
    );
  &#125;
&#125;

(async () =&gt; &#123;
  const sleepTime = await new Sleep(1000);
  console.log(sleepTime);
&#125;)();
// 1000
</code></pre><p>上面代码中，<code>await</code>命令后面是一个<code>Sleep</code>对象的实例。这个实例不是 Promise 对象，但是因为定义了<code>then</code>方法，<code>await</code>会将其视为<code>Promise</code>处理。</p><p>这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助<code>await</code>命令就可以让程序停顿指定的时间。下面给出了一个简化的<code>sleep</code>实现。</p><pre><code class="javascript">function sleep(interval) &#123;
  return new Promise(resolve =&gt; &#123;
    setTimeout(resolve, interval);
  &#125;)
&#125;

// 用法
async function one2FiveInAsync() &#123;
  for(let i = 1; i &lt;= 5; i++) &#123;
    console.log(i);
    await sleep(1000);
  &#125;
&#125;

one2FiveInAsync();
</code></pre><p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p><pre><code class="javascript">async function f() &#123;
  await Promise.reject(&#39;出错了&#39;);
&#125;

f()
.then(v =&gt; console.log(v))
.catch(e =&gt; console.log(e))
// 出错了
</code></pre><p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p><p><strong>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</strong></p><pre><code class="javascript">async function f() &#123;
  await Promise.reject(&#39;出错了&#39;);
  await Promise.resolve(&#39;hello world&#39;); // 不会执行
&#125;
</code></pre><p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p><p><strong>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</strong></p><pre><code class="javascript">async function f() &#123;
  try &#123;
    await Promise.reject(&#39;出错了&#39;);
  &#125; catch(e) &#123;
  &#125;
  return await Promise.resolve(&#39;hello world&#39;);
&#125;

f()
.then(v =&gt; console.log(v))
// hello world
</code></pre><p><strong>另一种方法是<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</strong></p><pre><code class="javascript">async function f() &#123;
  await Promise.reject(&#39;出错了&#39;)
    .catch(e =&gt; console.log(e));
  return await Promise.resolve(&#39;hello world&#39;);
&#125;

f()
.then(v =&gt; console.log(v))
// 出错了
// hello world
</code></pre><hr><p><strong>错误处理</strong></p><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p><pre><code class="javascript">async function f() &#123;
  await new Promise(function (resolve, reject) &#123;
    throw new Error(&#39;出错了&#39;);
  &#125;);
&#125;

f()
.then(v =&gt; console.log(v))
.catch(e =&gt; console.log(e))
// Error：出错了
</code></pre><p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的 Promise 对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。</p><p><strong>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</strong></p><pre><code class="javascript">async function f() &#123;
  try &#123;
    await new Promise(function (resolve, reject) &#123;
      throw new Error(&#39;出错了&#39;);
    &#125;);
  &#125; catch(e) &#123;
  &#125;
  return await(&#39;hello world&#39;);
&#125;
</code></pre><p><strong>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</strong></p><pre><code class="javascript">async function main() &#123;
  try &#123;
    const val1 = await firstStep();
    const val2 = await secondStep(val1);
    const val3 = await thirdStep(val1, val2);

    console.log(&#39;Final: &#39;, val3);
  &#125;
  catch (err) &#123;
    console.error(err);
  &#125;
&#125;
</code></pre><p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p><pre><code class="javascript">const superagent = require(&#39;superagent&#39;);
const NUM_RETRIES = 3;

async function test() &#123;
  let i;
  for (i = 0; i &lt; NUM_RETRIES; ++i) &#123;
    try &#123;
      await superagent.get(&#39;http://google.com/this-throws-an-error&#39;);
      break;
    &#125; catch(err) &#123;&#125;
  &#125;
  console.log(i); // 3
&#125;

test();
</code></pre><p><strong>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</strong>因为操作失败会直接进入catch不会执行break</p><hr><p><strong>使用注意点</strong></p><p><strong>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</strong>或者后面加个catch</p><pre><code class="javascript">async function myFunction() &#123;
  try &#123;
    await somethingThatReturnsAPromise();
  &#125; catch (err) &#123;
    console.log(err);
  &#125;
&#125;

// 另一种写法

async function myFunction() &#123;
  await somethingThatReturnsAPromise()
  .catch(function (err) &#123;
    console.log(err);
  &#125;);
&#125;
</code></pre><p><strong>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</strong></p><pre><code class="javascript">let foo = await getFoo();
let bar = await getBar();
</code></pre><p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p><pre><code class="javascript">// 写法一
let [foo, bar] = await Promise.all([getFoo(), getBar()]);

// 写法二
let fooPromise = getFoo();
let barPromise = getBar();
let foo = await fooPromise;
let bar = await barPromise;
</code></pre><p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p><p><strong>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</strong></p><pre><code class="javascript">async function dbFuc(db) &#123;
  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];

  // 报错
  docs.forEach(function (doc) &#123;
    await db.post(doc);
  &#125;);
&#125;
</code></pre><p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p><pre><code class="javascript">function dbFuc(db) &#123; //这里不需要 async
  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];

  // 可能得到错误结果
  docs.forEach(async function (doc) &#123;
    await db.post(doc);
  &#125;);
&#125;
</code></pre><p>上面代码可能不会正常工作，原因是这时三个<code>db.post()</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p><pre><code class="javascript">async function dbFuc(db) &#123;
  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];

  for (let doc of docs) &#123;
    await db.post(doc);
  &#125;
&#125;
</code></pre><p>另一种方法是使用数组的<code>reduce()</code>方法。</p><pre><code class="javascript">async function dbFuc(db) &#123;
  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];

  await docs.reduce(async (_, doc) =&gt; &#123;
    await _;
    await db.post(doc);
  &#125;, undefined);
&#125;
</code></pre><p>上面例子中，<code>reduce()</code>方法的第一个参数是<code>async</code>函数，导致该函数的第一个参数是前一步操作返回的 Promise 对象，所以必须使用<code>await</code>等待它操作结束。另外，<code>reduce()</code>方法返回的是<code>docs</code>数组最后一个成员的<code>async</code>函数的执行结果，也是一个 Promise 对象，导致在它前面也必须加上<code>await</code>。</p><p>上面的<code>reduce()</code>的参数函数里面没有<code>return</code>语句，原因是这个函数的主要目的是<code>db.post()</code>操作，不是返回值。而且<code>async</code>函数不管有没有<code>return</code>语句，总是返回一个 Promise 对象，所以这里的<code>return</code>是不必要的。</p><p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。当三个请求都会<code>resolved</code>时，下面两种写法效果相同。</p><pre><code class="javascript">async function dbFuc(db) &#123;
  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];
  let promises = docs.map((doc) =&gt; db.post(doc));

  let results = await Promise.all(promises);
  console.log(results);
&#125;

// 或者使用下面的写法

async function dbFuc(db) &#123;
  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];
  let promises = docs.map((doc) =&gt; db.post(doc));

  let results = [];
  for (let promise of promises) &#123;
    results.push(await promise);
  &#125;
  console.log(results);
&#125;
</code></pre><p><strong>第四点，async 函数可以保留运行堆栈。</strong></p><pre><code class="javascript">const a = () =&gt; &#123;
  b().then(() =&gt; c());
&#125;;
</code></pre><p>上面代码中，函数<code>a</code>内部运行了一个异步任务<code>b()</code>。当<code>b()</code>运行的时候，函数<code>a()</code>不会中断，而是继续执行。等到<code>b()</code>运行结束，可能<code>a()</code>早就运行结束了，<code>b()</code>所在的上下文环境已经消失了。如果<code>b()</code>或<code>c()</code>报错，错误堆栈将不包括<code>a()</code>。</p><p>现在将这个例子改成<code>async</code>函数。</p><pre><code class="javascript">const a = async () =&gt; &#123;
  await b();
  c();
&#125;;
</code></pre><p>上面代码中，<code>b()</code>运行的时候，<code>a()</code>是暂停执行，上下文环境都保存着。一旦<code>b()</code>或<code>c()</code>报错，错误堆栈将包括<code>a()</code>。</p><hr><h4 id="4-async-函数的实现原理"><a href="#4-async-函数的实现原理" class="headerlink" title="4. async 函数的实现原理"></a>4. async 函数的实现原理</h4><p><strong>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</strong></p><pre><code class="javascript">async function fn(args) &#123;
  // ...
&#125;

// 等同于

function fn(args) &#123;
  return spawn(function* () &#123;
    // ...
  &#125;);
&#125;
</code></pre><p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p><p>下面给出<code>spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p><pre><code class="javascript">function spawn(genF) &#123;
  return new Promise(function(resolve, reject) &#123;
    const gen = genF();
    function step(nextF) &#123;
      let next;
      try &#123;
        next = nextF();
      &#125; catch(e) &#123;
        return reject(e);
      &#125;
      if(next.done) &#123;
        return resolve(next.value);
      &#125;
      Promise.resolve(next.value).then(function(v) &#123;
        step(function() &#123; return gen.next(v); &#125;);
      &#125;, function(e) &#123;
        step(function() &#123; return gen.throw(e); &#125;);
      &#125;);
    &#125;
    step(function() &#123; return gen.next(undefined); &#125;);
  &#125;);
&#125;
</code></pre><hr><h4 id="5-与其他异步处理方法的比较"><a href="#5-与其他异步处理方法的比较" class="headerlink" title="5.  与其他异步处理方法的比较"></a>5. 与其他异步处理方法的比较</h4><p>我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。</p><p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p><p>首先是 Promise 的写法。</p><pre><code class="javascript">function chainAnimationsPromise(elem, animations) &#123;

  // 变量ret用来保存上一个动画的返回值
  let ret = null;

  // 新建一个空的Promise
  let p = Promise.resolve();

  // 使用then方法，添加所有动画
  for(let anim of animations) &#123;
    p = p.then(function(val) &#123;
      ret = val;
      return anim(elem);
    &#125;);
  &#125;

  // 返回一个部署了错误捕捉机制的Promise
  return p.catch(function(e) &#123;
    /* 忽略错误，继续执行 */
  &#125;).then(function() &#123;
    return ret;
  &#125;);

&#125;
</code></pre><p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（<code>then</code>、<code>catch</code>等等），操作本身的语义反而不容易看出来。</p><p>接着是 Generator 函数的写法。</p><pre><code class="javascript">function chainAnimationsGenerator(elem, animations) &#123;

  return spawn(function*() &#123;
    let ret = null;
    try &#123;
      for(let anim of animations) &#123;
        ret = yield anim(elem);
      &#125;
    &#125; catch(e) &#123;
      /* 忽略错误，继续执行 */
    &#125;
    return ret;
  &#125;);

&#125;
</code></pre><p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在<code>spawn</code>函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，<strong>上面代码的<code>spawn</code>函数就是自动执行器，它返回一个 Promise 对象，而且必须保证<code>yield</code>语句后面的表达式，必须返回一个 Promise。</strong></p><p>最后是 async 函数的写法。</p><pre><code class="javascript">async function chainAnimationsAsync(elem, animations) &#123;
  let ret = null;
  try &#123;
    for(let anim of animations) &#123;
      ret = await anim(elem);
    &#125;
  &#125; catch(e) &#123;
    /* 忽略错误，继续执行 */
  &#125;
  return ret;
&#125;
</code></pre><p>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。<strong>如果使用 Generator 写法，自动执行器需要用户自己提供。</strong></p><hr><h4 id="6-实例：按顺序完成异步操作"><a href="#6-实例：按顺序完成异步操作" class="headerlink" title="6. 实例：按顺序完成异步操作"></a>6. 实例：按顺序完成异步操作</h4><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p><p>Promise 的写法如下。</p><pre><code class="javascript">function logInOrder(urls) &#123;
  // 远程读取所有URL
  const textPromises = urls.map(url =&gt; &#123;
    return fetch(url).then(response =&gt; response.text());
  &#125;);

  // 按次序输出
  textPromises.reduce((chain, textPromise) =&gt; &#123;
    return chain.then(() =&gt; textPromise)
      .then(text =&gt; console.log(text));
  &#125;, Promise.resolve());
&#125;
</code></pre><p>上面代码使用<code>fetch</code>方法，同时远程读取一组 URL。每个<code>fetch</code>操作都返回一个 Promise 对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个 Promise 对象，然后使用<code>then</code>，将所有 Promise 对象连起来，因此就可以依次输出结果。</p><p>这种写法不太直观，可读性比较差。下面是 async 函数实现。</p><pre><code class="javascript">async function logInOrder(urls) &#123;
  for (const url of urls) &#123;
    const response = await fetch(url);
    console.log(await response.text());
  &#125;
&#125;
</code></pre><p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p><pre><code class="javascript">async function logInOrder(urls) &#123;
  // 并发读取远程URL
  const textPromises = urls.map(async url =&gt; &#123;
    const response = await fetch(url);
    return response.text();
  &#125;);

  // 按次序输出
  for (const textPromise of textPromises) &#123;
    console.log(await textPromise);
  &#125;
&#125;
</code></pre><p><strong>上面代码中，虽然<code>map</code>方法的参数是<code>async</code>函数，但它是并发执行的，因为只有<code>async</code>函数内部是继发执行，外部不受影响。后面的<code>for..of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。</strong></p><hr><h4 id="7-顶层-await"><a href="#7-顶层-await" class="headerlink" title="7. 顶层 await"></a>7. 顶层 await</h4><p>根据语法规格，<code>await</code>命令只能出现在 async 函数内部，否则都会报错。</p><pre><code class="javascript">// 报错
const data = await fetch(&#39;https://api.example.com&#39;);
</code></pre><p>上面代码中，<code>await</code>命令独立使用，没有放在 async 函数里面，就会报错。</p><p>目前，有一个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtdG9wLWxldmVsLWF3YWl0">语法提案</span>，允许在模块的顶层独立使用<code>await</code>命令，使得上面那行代码不会报错了。这个提案的目的，是借用<code>await</code>解决模块异步加载的问题。</p><pre><code class="javascript">// awaiting.js
let output;
async function main() &#123;
  const dynamic = await import(someMission);
  const data = await fetch(url);
  output = someProcess(dynamic.default, data);
&#125;
main();
export &#123; output &#125;;
</code></pre><p>上面代码中，模块<code>awaiting.js</code>的输出值<code>output</code>，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量<code>output</code>才会有值，否则就返回<code>undefined</code>。</p><p>上面的代码也可以写成立即执行函数的形式。</p><pre><code class="javascript">// awaiting.js
let output;
(async function main() &#123;
  const dynamic = await import(someMission);
  const data = await fetch(url);
  output = someProcess(dynamic.default, data);
&#125;)();
export &#123; output &#125;;
</code></pre><p>下面是加载这个模块的写法。</p><pre><code class="javascript">// usage.js
import &#123; output &#125; from &quot;./awaiting.js&quot;;

function outputPlusValue(value) &#123; return output + value &#125;

console.log(outputPlusValue(100));
setTimeout(() =&gt; console.log(outputPlusValue(100)), 1000);
</code></pre><p>上面代码中，<code>outputPlusValue()</code>的执行结果，完全取决于执行的时间。如果<code>awaiting.js</code>里面的异步操作没执行完，加载进来的<code>output</code>的值就是<code>undefined</code>。</p><p>目前的解决方法，就是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束。</p><pre><code class="javascript">// awaiting.js
let output;
export default (async function main() &#123;
  const dynamic = await import(someMission);
  const data = await fetch(url);
  output = someProcess(dynamic.default, data);
&#125;)();
export &#123; output &#125;;
</code></pre><p>上面代码中，<code>awaiting.js</code>除了输出<code>output</code>，还默认输出一个 Promise 对象（async 函数立即执行后，返回一个 Promise 对象），从这个对象判断异步操作是否结束。</p><p>下面是加载这个模块的新的写法。</p><pre><code class="javascript">// usage.js
import promise, &#123; output &#125; from &quot;./awaiting.js&quot;;

function outputPlusValue(value) &#123; return output + value &#125;

promise.then(() =&gt; &#123;
  console.log(outputPlusValue(100));
  setTimeout(() =&gt; console.log(outputPlusValue(100)), 1000);
&#125;);
</code></pre><p>上面代码中，将<code>awaiting.js</code>对象的输出，放在<code>promise.then()</code>里面，这样就能保证异步操作完成以后，才去读取<code>output</code>。</p><p>这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的<code>usage.js</code>又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载。</p><p>顶层的<code>await</code>命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。</p><pre><code class="javascript">// awaiting.js
const dynamic = import(someMission);
const data = fetch(url);
export const output = someProcess((await dynamic).default, await data);
</code></pre><p>上面代码中，两个异步操作在输出的时候，都加上了<code>await</code>命令。只有等到异步操作完成，这个模块才会输出值。</p><p>加载这个模块的写法如下。</p><pre><code class="javascript">// usage.js
import &#123; output &#125; from &quot;./awaiting.js&quot;;
function outputPlusValue(value) &#123; return output + value &#125;

console.log(outputPlusValue(100));
setTimeout(() =&gt; console.log(outputPlusValue(100)), 1000);
</code></pre><p>上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。</p><p>这时，模块的加载会等待依赖模块（上例是<code>awaiting.js</code>）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的<code>output</code>，不会因为加载时机的不同，而得到不一样的值。</p><p><strong>注意，顶层<code>await</code>只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的<code>require()</code>是同步加载，如果有顶层<code>await</code>，就没法处理加载了。</strong></p><p>下面是顶层<code>await</code>的一些使用场景。</p><pre><code class="javascript">// import() 方法加载
const strings = await import(`/i18n/$&#123;navigator.language&#125;`);

// 数据库操作
const connection = await dbConnector();

// 依赖回滚
let jQuery;
try &#123;
  jQuery = await import(&#39;https://cdn-a.com/jQuery&#39;);
&#125; catch &#123;
  jQuery = await import(&#39;https://cdn-b.com/jQuery&#39;);
&#125;
</code></pre><p>注意，如果加载多个包含顶层<code>await</code>命令的模块，加载命令是同步执行的。</p><pre><code class="javascript">// x.js
console.log(&quot;X1&quot;);
await new Promise(r =&gt; setTimeout(r, 1000));
console.log(&quot;X2&quot;);

// y.js
console.log(&quot;Y&quot;);

// z.js
import &quot;./x.js&quot;;
import &quot;./y.js&quot;;
console.log(&quot;Z&quot;);
</code></pre><p>上面代码有三个模块，最后的<code>z.js</code>加载<code>x.js</code>和<code>y.js</code>，打印结果是<code>X1</code>、<code>Y</code>、<code>X2</code>、<code>Z</code>。这说明，<code>z.js</code>并没有等待<code>x.js</code>加载完成，再去加载<code>y.js</code>。</p><p><strong>顶层的<code>await</code>命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。</strong></p><h3 id="21、-Class-的基本语法"><a href="#21、-Class-的基本语法" class="headerlink" title="21、 Class 的基本语法"></a>21、 Class 的基本语法</h3><hr><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><p><strong>类的由来</strong></p><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p><pre><code class="javascript">function Point(x, y) &#123;
  this.x = x;
  this.y = y;
&#125;

Point.prototype.toString = function () &#123;
  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
&#125;;

var p = new Point(1, 2);
</code></pre><p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</p><p>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p><pre><code class="javascript">class Point &#123;
  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;

  toString() &#123;
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  &#125;
&#125;
</code></pre><p><strong>上面代码定义了一个“类”，可以看到里面有一个<code>constructor()</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。这种新的 Class 写法，本质上与本章开头的 ES5 的构造函数<code>Point</code>是一致的。</strong></p><p><code>Point</code>类除了构造方法，还定义了一个<code>toString()</code>方法。注意，<strong>定义<code>toString()</code>方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。</strong></p><p>ES6 的类，完全可以看作构造函数的另一种写法。</p><pre><code class="javascript">class Point &#123;
  // ...
&#125;

typeof Point // &quot;function&quot;
Point === Point.prototype.constructor // true
</code></pre><p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p><p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。</p><pre><code class="javascript">class Bar &#123;
  doStuff() &#123;
    console.log(&#39;stuff&#39;);
  &#125;
&#125;

const b = new Bar();
b.doStuff() // &quot;stuff&quot;
</code></pre><p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p><pre><code class="javascript">class Point &#123;
  constructor() &#123;
    // ...
  &#125;

  toString() &#123;
    // ...
  &#125;

  toValue() &#123;
    // ...
  &#125;
&#125;

// 等同于

Point.prototype = &#123;
  constructor() &#123;&#125;,
  toString() &#123;&#125;,
  toValue() &#123;&#125;,
&#125;;
</code></pre><p>上面代码中，<code>constructor()</code>、<code>toString()</code>、<code>toValue()</code>这三个方法，其实都是定义在<code>Point.prototype</code>上面。</p><p><strong>因此，在类的实例上面调用方法，其实就是调用原型上的方法。</strong></p><pre><code class="javascript">class B &#123;&#125;
const b = new B();

b.constructor === B.prototype.constructor // true
</code></pre><p>上面代码中，<code>b</code>是<code>B</code>类的实例，它的<code>constructor()</code>方法就是<code>B</code>类原型的<code>constructor()</code>方法。</p><p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign()</code>方法可以很方便地一次向类添加多个方法。</p><pre><code class="javascript">class Point &#123;
  constructor()&#123;
    // ...
  &#125;
&#125;

Object.assign(Point.prototype, &#123;
  toString()&#123;&#125;,
  toValue()&#123;&#125;
&#125;);
</code></pre><p><code>prototype</code>对象的<code>constructor()</code>属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</p><pre><code class="javascript">Point.prototype.constructor === Point // true
</code></pre><p><strong>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</strong></p><pre><code class="javascript">class Point &#123;
  constructor(x, y) &#123;
    // ...
  &#125;

  toString() &#123;
    // ...
  &#125;
&#125;

Object.keys(Point.prototype)
// []
Object.getOwnPropertyNames(Point.prototype)
// [&quot;constructor&quot;,&quot;toString&quot;]
</code></pre><p>上面代码中，<code>toString()</code>方法是<code>Point</code>类内部定义的方法，<strong>它是不可枚举的。这一点与 ES5 的行为不一致。</strong></p><pre><code class="javascript">var Point = function (x, y) &#123;
  // ...
&#125;;

Point.prototype.toString = function () &#123;
  // ...
&#125;;

Object.keys(Point.prototype)
// [&quot;toString&quot;]
Object.getOwnPropertyNames(Point.prototype)
// [&quot;constructor&quot;,&quot;toString&quot;]
</code></pre><p>上面代码采用 ES5 的写法，<code>toString()</code>方法就是可枚举的。</p><hr><p><strong>constructor 方法</strong></p><p><strong><code>constructor()</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的<code>constructor()</code>方法会被默认添加。</strong></p><pre><code class="javascript">class Point &#123;
&#125;

// 等同于
class Point &#123;
  constructor() &#123;&#125;
&#125;
</code></pre><p>上面代码中，定义了一个空的类<code>Point</code>，JavaScript 引擎会自动为它添加一个空的<code>constructor()</code>方法。</p><p><code>constructor()</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</p><pre><code class="javascript">class Foo &#123;
  constructor() &#123;
    return Object.create(null);
  &#125;
&#125;

new Foo() instanceof Foo
// false
</code></pre><p>上面代码中，<code>constructor()</code>函数返回一个全新的对象，结果导致实例对象不是<code>Foo</code>类的实例。</p><p><strong>类必须使用<code>new</code>调用</strong>，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p><pre><code class="javascript">class Foo &#123;
  constructor() &#123;
    return Object.create(null);
  &#125;
&#125;

Foo()
// TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;
</code></pre><hr><p><strong>类的实例</strong></p><p>生成类的实例的写法，与 ES5 完全一样，也是使用<code>new</code>命令。前面说过，<strong>如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</strong></p><pre><code class="javascript">class Point &#123;
  // ...
&#125;

// 报错
var point = Point(2, 3);

// 正确
var point = new Point(2, 3);
</code></pre><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p><pre><code class="javascript">//定义类
class Point &#123;

  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;

  toString() &#123;
    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;
  &#125;

&#125;

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty(&#39;x&#39;) // true
point.hasOwnProperty(&#39;y&#39;) // true
point.hasOwnProperty(&#39;toString&#39;) // false
point.__proto__.hasOwnProperty(&#39;toString&#39;) // true
</code></pre><p>上面代码中，**<code>x</code>和<code>y</code>都是实例对象<code>point</code>自身的属性（因为定义在<code>this</code>对象上），所以<code>hasOwnProperty()</code>方法返回<code>true</code>，而<code>toString()</code>是原型对象的属性（因为定义在<code>Point</code>类上），所以<code>hasOwnProperty()</code>方法返回<code>false</code>。这些**都与 ES5 的行为保持一致。</p><p>与 ES5 一样，类的所有实例共享一个原型对象。</p><pre><code class="javascript">var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__ === p2.__proto__
//true
</code></pre><p>上面代码中，<code>p1</code>和<code>p2</code>都是<code>Point</code>的实例，它们的原型都是<code>Point.prototype</code>，所以<code>__proto__</code>属性是相等的。</p><p>这也意味着，可以通过实例的<code>__proto__</code>属性为“类”添加方法。</p><blockquote><p><code>__proto__</code> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，<strong>但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 <code>Object.getPrototypeOf</code> 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</strong></p></blockquote><pre><code class="javascript">var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__.printName = function () &#123; return &#39;Oops&#39; &#125;;

p1.printName() // &quot;Oops&quot;
p2.printName() // &quot;Oops&quot;

var p3 = new Point(4,2);
p3.printName() // &quot;Oops&quot;
</code></pre><p>上面代码在<code>p1</code>的原型上添加了一个<code>printName()</code>方法，由于<code>p1</code>的原型就是<code>p2</code>的原型，因此<code>p2</code>也可以调用这个方法。而且，此后新建的实例<code>p3</code>也可以调用这个方法。这意味着，使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p><hr><p><strong>取值函数（getter）和存值函数（setter）</strong></p><p>与 ES5 一样，<strong>在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</strong></p><pre><code class="javascript">class MyClass &#123;
  constructor() &#123;
    // ...
  &#125;
  get prop() &#123;
    return &#39;getter&#39;;
  &#125;
  set prop(value) &#123;
    console.log(&#39;setter: &#39;+value);
  &#125;
&#125;

let inst = new MyClass();

inst.prop = 123;
// setter: 123

inst.prop
// &#39;getter&#39;
</code></pre><p>上面代码中，<code>prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p><p><strong>存值函数和取值函数是设置在属性的 Descriptor 对象上的。</strong></p><pre><code class="javascript">class CustomHTMLElement &#123;
  constructor(element) &#123;
    this.element = element;
  &#125;

  get html() &#123;
    return this.element.innerHTML;
  &#125;

  set html(value) &#123;
    this.element.innerHTML = value;
  &#125;
&#125;

var descriptor = Object.getOwnPropertyDescriptor(
  CustomHTMLElement.prototype, &quot;html&quot;
);

&quot;get&quot; in descriptor  // true
&quot;set&quot; in descriptor  // true
</code></pre><p>上面代码中，存值函数和取值函数是定义在<code>html</code>属性的描述对象上面，这与 ES5 完全一致。</p><hr><p><strong>属性表达式</strong></p><p><strong>类的属性名，可以采用表达式。</strong></p><pre><code class="javascript">let methodName = &#39;getArea&#39;;

class Square &#123;
  constructor(length) &#123;
    // ...
  &#125;

  [methodName]() &#123;
    // ...
  &#125;
&#125;
</code></pre><p>上面代码中，<code>Square</code>类的方法名<code>getArea</code>，是从表达式得到的。</p><hr><p><strong>Class 表达式</strong></p><p>与函数一样，类也可以使用表达式的形式定义。</p><pre><code class="javascript">const MyClass = class Me &#123;
  getClassName() &#123;
    return Me.name;
  &#125;
&#125;;
</code></pre><p>上面代码使用表达式定义了一个类。需要注意的是，<strong>这个类的名字是<code>Me</code>，但是<code>Me</code>只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用<code>MyClass</code>引用。</strong></p><pre><code class="javascript">let inst = new MyClass();
inst.getClassName() // Me
Me.name // ReferenceError: Me is not defined
</code></pre><p>上面代码表示，<code>Me</code>只在 Class 内部有定义。</p><p><strong>如果类的内部没用到的话，可以省略<code>Me</code>，</strong>也就是可以写成下面的形式。</p><pre><code class="javascript">const MyClass = class &#123; /* ... */ &#125;;
</code></pre><p><strong>采用 Class 表达式，可以写出立即执行的 Class。</strong></p><pre><code class="javascript">let person = new class &#123;
  constructor(name) &#123;
    this.name = name;
  &#125;

  sayName() &#123;
    console.log(this.name);
  &#125;
&#125;(&#39;张三&#39;);

person.sayName(); // &quot;张三&quot;
</code></pre><p>上面代码中，<code>person</code>是一个立即执行的类的实例。</p><hr><p><strong>注意点</strong></p><p><strong>（1）严格模式</strong></p><p><strong>类和模块的内部，默认就是严格模式</strong>，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p><p><strong>（2）不存在提升</strong></p><p><strong>类不存在变量提升（hoist</strong>），这一点与 ES5 完全不同。</p><pre><code class="javascript">new Foo(); // ReferenceError
class Foo &#123;&#125;
</code></pre><p>上面代码中，<code>Foo</code>类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。<strong>这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</strong></p><pre><code class="javascript">&#123;
  let Foo = class &#123;&#125;;
  class Bar extends Foo &#123;
  &#125;
&#125;
</code></pre><p>上面的代码不会报错，因为<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>已经有定义了。但是，<strong>如果存在<code>class</code>的提升，上面代码就会报错，因为<code>class</code>会被提升到代码头部，而<code>let</code>命令是不提升的，所以导致<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>还没有定义。</strong></p><p><strong>（3）name 属性</strong></p><p>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被<code>Class</code>继承，包括<code>name</code>属性。</p><pre><code class="javascript">class Point &#123;&#125;
Point.name // &quot;Point&quot;
</code></pre><p><strong><code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</strong></p><p><strong>（4）Generator 方法</strong></p><p><strong>如果某个方法之前加上星号（<code>*</code>），就表示该方法是一个 Generator 函数。</strong></p><pre><code class="javascript">class Foo &#123;
  constructor(...args) &#123;
    this.args = args;
  &#125;
  * [Symbol.iterator]() &#123;
    for (let arg of this.args) &#123;
      yield arg;
    &#125;
  &#125;
&#125;

for (let x of new Foo(&#39;hello&#39;, &#39;world&#39;)) &#123;
  console.log(x);
&#125;
// hello
// world
</code></pre><p>上面代码中，<code>Foo</code>类的<code>Symbol.iterator</code>方法前有一个星号，表示该方法是一个 Generator 函数。<code>Symbol.iterator</code>方法返回一个<code>Foo</code>类的默认遍历器，<code>for...of</code>循环会自动调用这个遍历器。</p><p><strong>（5）this 的指向</strong></p><p><strong>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</strong></p><pre><code class="javascript">class Logger &#123;
  printName(name = &#39;there&#39;) &#123;
    this.print(`Hello $&#123;name&#125;`);
  &#125;

  print(text) &#123;
    console.log(text);
  &#125;
&#125;

const logger = new Logger();
const &#123; printName &#125; = logger;
printName(); // TypeError: Cannot read property &#39;print&#39; of undefined
</code></pre><p>上面代码中，<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，<strong>如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到<code>print</code>方法而报错。</strong></p><p><strong>一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</strong></p><pre><code class="javascript">class Logger &#123;
  constructor() &#123;
    this.printName = this.printName.bind(this);
  &#125;

  // ...
&#125;
</code></pre><p><strong>另一种解决方法是使用箭头函数。</strong></p><pre><code class="javascript">class Obj &#123;
  constructor() &#123;
    this.getThis = () =&gt; this;
  &#125;
&#125;

const myObj = new Obj();
myObj.getThis() === myObj // true
</code></pre><p>箭头函数内部的<code>this</code>总是指向定义时所在的对象。上面代码中，箭头函数位于构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以<code>this</code>会总是指向实例对象。</p><p><strong>还有一种解决方法是使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code>。</strong></p><pre><code class="javascript">function selfish (target) &#123;
  const cache = new WeakMap();
  const handler = &#123;
    get (target, key) &#123;
      const value = Reflect.get(target, key);
      if (typeof value !== &#39;function&#39;) &#123;
        return value;
      &#125;
      if (!cache.has(value)) &#123;
        cache.set(value, value.bind(target));
      &#125;
      return cache.get(value);
    &#125;
  &#125;;
  const proxy = new Proxy(target, handler);
  return proxy;
&#125;

const logger = selfish(new Logger());
</code></pre><hr><h4 id="2-静态方法-1"><a href="#2-静态方法-1" class="headerlink" title="2. 静态方法"></a>2. 静态方法</h4><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。<strong>如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</strong></p><pre><code class="javascript">class Foo &#123;
  static classMethod() &#123;
    return &#39;hello&#39;;
  &#125;
&#125;

Foo.classMethod() // &#39;hello&#39;

var foo = new Foo();
foo.classMethod()
// TypeError: foo.classMethod is not a function
</code></pre><p>上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用（<code>Foo.classMethod()</code>），而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p><p>注意，如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</p><pre><code class="javascript">class Foo &#123;
  static bar() &#123;
    this.baz();
  &#125;
  static baz() &#123;
    console.log(&#39;hello&#39;);
  &#125;
  baz() &#123;
    console.log(&#39;world&#39;);
  &#125;
&#125;

Foo.bar() // hello
</code></pre><p>上面代码中，静态方法<code>bar</code>调用了<code>this.baz</code>，这里的<code>this</code>指的是<code>Foo</code>类，而不是<code>Foo</code>的实例，等同于调用<code>Foo.baz</code>。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p><p><strong>父类的静态方法，可以被子类继承。</strong></p><pre><code class="javascript">class Foo &#123;
  static classMethod() &#123;
    return &#39;hello&#39;;
  &#125;
&#125;

class Bar extends Foo &#123;
&#125;

Bar.classMethod() // &#39;hello&#39;
</code></pre><p>上面代码中，父类<code>Foo</code>有一个静态方法，子类<code>Bar</code>可以调用这个方法。</p><p>静态方法也是可以从<code>super</code>对象上调用的。</p><pre><code class="javascript">class Foo &#123;
  static classMethod() &#123;
    return &#39;hello&#39;;
  &#125;
&#125;

class Bar extends Foo &#123;
  static classMethod() &#123;
    return super.classMethod() + &#39;, too&#39;;
  &#125;
&#125;

Bar.classMethod() // &quot;hello, too&quot;
</code></pre><hr><h4 id="3-实例属性的新写法"><a href="#3-实例属性的新写法" class="headerlink" title="3. 实例属性的新写法"></a>3. 实例属性的新写法</h4><p><strong>实例属性除了定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类的最顶层。</strong></p><pre><code class="javascript">class IncreasingCounter &#123;
  constructor() &#123;
    this._count = 0;
  &#125;
  get value() &#123;
    console.log(&#39;Getting the current value!&#39;);
    return this._count;
  &#125;
  increment() &#123;
    this._count++;
  &#125;
&#125;
</code></pre><p>上面代码中，<strong>实例属性<code>this._count</code>定义在<code>constructor()</code>方法里面。另一种写法是，这个属性也可以定义在类的最顶层，其他都不变。</strong></p><pre><code class="javascript">class IncreasingCounter &#123;
  _count = 0;
  get value() &#123;
    console.log(&#39;Getting the current value!&#39;);
    return this._count;
  &#125;
  increment() &#123;
    this._count++;
  &#125;
&#125;
</code></pre><p>上面代码中，实例属性<code>_count</code>与取值函数<code>value()</code>和<code>increment()</code>方法，处于同一个层级。这时，<strong>不需要在实例属性前面加上<code>this</code>。</strong></p><p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p><pre><code class="javascript">class foo &#123;
  bar = &#39;hello&#39;;
  baz = &#39;world&#39;;

  constructor() &#123;
    // ...
  &#125;
&#125;
</code></pre><p>上面的代码，一眼就能看出，<code>foo</code>类有两个实例属性，一目了然。另外，写起来也比较简洁。</p><hr><h4 id="4-静态属性"><a href="#4-静态属性" class="headerlink" title="4. 静态属性"></a>4. 静态属性</h4><p><strong>静态属性指的是 Class 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性。</strong></p><pre><code class="javascript">class Foo &#123;
&#125;

Foo.prop = 1;
Foo.prop // 1
</code></pre><p>上面的写法为<code>Foo</code>类定义了一个静态属性<code>prop</code>。</p><p><strong>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtY2xhc3MtZmllbGRz">提案</span>提供了类的静态属性，写法是在实例属性的前面，加上<code>static</code>关键字。</strong></p><pre><code class="javascript">class MyClass &#123;
  static myStaticProp = 42;

  constructor() &#123;
    console.log(MyClass.myStaticProp); // 42
  &#125;
&#125;
</code></pre><p>这个新写法大大方便了静态属性的表达。</p><pre><code class="javascript">// 老写法
class Foo &#123;
  // ...
&#125;
Foo.prop = 1;

// 新写法
class Foo &#123;
  static prop = 1;
&#125;
</code></pre><p>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p><hr><h4 id="5-私有方法和私有属性"><a href="#5-私有方法和私有属性" class="headerlink" title="5. 私有方法和私有属性"></a>5. 私有方法和私有属性</h4><p><strong>现有的解决方案</strong></p><p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。</p><p>一种做法是在命名上加以区别。</p><pre><code class="javascript">class Widget &#123;

  // 公有方法
  foo (baz) &#123;
    this._bar(baz);
  &#125;

  // 私有方法
  _bar(baz) &#123;
    return this.snaf = baz;
  &#125;

  // ...
&#125;
</code></pre><p>上面代码中，<code>_bar()</code>方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p><p><strong>另一种方法就是索性将私有方法移出类，因为类内部的所有方法都是对外可见的。</strong></p><pre><code class="javascript">class Widget &#123;
  foo (baz) &#123;
    bar.call(this, baz);
  &#125;

  // ...
&#125;

function bar(baz) &#123;
  return this.snaf = baz;
&#125;
</code></pre><p>上面代码中，**<code>foo</code>是公开方法，内部调用了<code>bar.call(this, baz)</code>。这使得<code>bar()</code>实际上成为了当前类的私有方法。**</p><p><strong>还有一种方法是利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值。</strong></p><pre><code class="javascript">const bar = Symbol(&#39;bar&#39;);
const snaf = Symbol(&#39;snaf&#39;);

export default class myClass&#123;

  // 公有方法
  foo(baz) &#123;
    this[bar](baz);
  &#125;

  // 私有方法
  [bar](baz) &#123;
    return this[snaf] = baz;
  &#125;

  // ...
&#125;;
</code></pre><p>上面代码中，<code>bar</code>和<code>snaf</code>都是<code>Symbol</code>值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，<code>Reflect.ownKeys()</code>依然可以拿到它们。</p><pre><code class="javascript">const inst = new myClass();

Reflect.ownKeys(myClass.prototype)
// [ &#39;constructor&#39;, &#39;foo&#39;, Symbol(bar) ]
</code></pre><p>上面代码中，Symbol 值的属性名依然可以从类的外部拿到。</p><hr><p><strong>私有属性的提案</strong></p><p><strong>目前，有一个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJpdmF0ZS1tZXRob2Rz">提案</span>，为<code>class</code>加了私有属性。方法是在属性名之前，使用<code>#</code>表示。</strong></p><pre><code class="javascript">class IncreasingCounter &#123;
  #count = 0;
  get value() &#123;
    console.log(&#39;Getting the current value!&#39;);
    return this.#count;
  &#125;
  increment() &#123;
    this.#count++;
  &#125;
&#125;
</code></pre><p><strong>上面代码中，<code>#count</code>就是私有属性，只能在类的内部使用（<code>this.#count</code>）。如果在类的外部使用，就会报错。</strong></p><pre><code class="javascript">const counter = new IncreasingCounter();
counter.#count // 报错
counter.#count = 42 // 报错
</code></pre><p>上面代码在类的外部，读取私有属性，就会报错。</p><p>下面是另一个例子。</p><pre><code class="javascript">class Point &#123;
  #x;

  constructor(x = 0) &#123;
    this.#x = +x;
  &#125;

  get x() &#123;
    return this.#x;
  &#125;

  set x(value) &#123;
    this.#x = +value;
  &#125;
&#125;
</code></pre><p>上面代码中，<code>#x</code>就是私有属性，在<code>Point</code>类之外是读取不到这个属性的。由于井号<code>#</code>是属性名的一部分，使用时必须带有<code>#</code>一起使用，所以<code>#x</code>和<code>x</code>是两个不同的属性。</p><p>之所以要引入一个新的前缀<code>#</code>表示私有属性，而没有采用<code>private</code>关键字，是因为 JavaScript 是一门动态语言，没有类型声明，使用独立的符号似乎是唯一的比较方便可靠的方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用<code>@</code>表示私有属性，ES6 没有用这个符号而使用<code>#</code>，是因为<code>@</code>已经被留给了 Decorator。</p><p>这种写法不仅可以写私有属性，还可以用来写私有方法。</p><pre><code class="javascript">class Foo &#123;
  #a;
  #b;
  constructor(a, b) &#123;
    this.#a = a;
    this.#b = b;
  &#125;
  #sum() &#123;
    return this.#a + this.#b;
  &#125;
  printSum() &#123;
    console.log(this.#sum());
  &#125;
&#125;
</code></pre><p>上面代码中，<code>#sum()</code>就是一个私有方法。</p><p>另外，私有属性也可以设置 getter 和 setter 方法。</p><pre><code class="javascript">class Counter &#123;
  #xValue = 0;

  constructor() &#123;
    super();
    // ...
  &#125;

  get #x() &#123; return #xValue; &#125;
  set #x(value) &#123;
    this.#xValue = value;
  &#125;
&#125;
</code></pre><p>上面代码中，<code>#x</code>是一个私有属性，它的读写都通过<code>get #x()</code>和<code>set #x()</code>来完成。</p><p><strong>私有属性不限于从<code>this</code>引用，只要是在类的内部，实例也可以引用私有属性。</strong></p><pre><code class="javascript">class Foo &#123;
  #privateValue = 42;
  static getPrivateValue(foo) &#123;
    return foo.#privateValue;
  &#125;
&#125;

Foo.getPrivateValue(new Foo()); // 42
</code></pre><p>上面代码允许从实例<code>foo</code>上面引用私有属性。</p><p>私有属性和私有方法前面，也可以加上<code>static</code>关键字，表示这是一个静态的私有属性或私有方法。</p><pre><code class="javascript">class FakeMath &#123;
  static PI = 22 / 7;
  static #totallyRandomNumber = 4;

  static #computeRandomNumber() &#123;
    return FakeMath.#totallyRandomNumber;
  &#125;

  static random() &#123;
    console.log(&#39;I heard you like random numbers…&#39;)
    return FakeMath.#computeRandomNumber();
  &#125;
&#125;

FakeMath.PI // 3.142857142857143
FakeMath.random()
// I heard you like random numbers…
// 4
FakeMath.#totallyRandomNumber // 报错
FakeMath.#computeRandomNumber() // 报错
</code></pre><p>上面代码中，<code>#totallyRandomNumber</code>是私有属性，<code>#computeRandomNumber()</code>是私有方法，只能在<code>FakeMath</code>这个类的内部调用，外部调用就会报错。</p><hr><p><strong>in 运算符</strong></p><p><code>try...catch</code>结构可以用来判断是否存在某个私有属性。</p><pre><code class="javascript">class A &#123;
  use(obj) &#123;
    try &#123;
      obj.#foo;
    &#125; catch &#123;
      // 私有属性 #foo 不存在
    &#125;
  &#125;
&#125;

const a = new A();
a.use(a); // 报错
</code></pre><p>上面示例中，类<code>A</code>并不存在私有属性<code>#foo</code>，所以<code>try...catch</code>报错了。</p><p>这样的写法很麻烦，可读性很差，V8 引擎改进了<code>in</code>运算符，使它也可以用来判断私有属性。</p><pre><code class="javascript">class A &#123;
  use(obj) &#123;
    if (#foo in obj) &#123;
      // 私有属性 #foo 存在
    &#125; else &#123;
      // 私有属性 #foo 不存在
    &#125;
  &#125;
&#125;
</code></pre><p>上面示例中，<code>in</code>运算符判断当前类<code>A</code>的实例，是否有私有属性<code>#foo</code>，如果有返回<code>true</code>，否则返回<code>false</code>。</p><p><strong><code>in</code>也可以跟<code>this</code>一起配合使用。</strong></p><pre><code class="javascript">class A &#123;
  #foo = 0;
  m() &#123;
    console.log(#foo in this); // true
    console.log(#bar in this); // false
  &#125;
&#125;
</code></pre><p><strong>注意，判断私有属性时，<code>in</code>只能用在定义该私有属性的类的内部。</strong></p><pre><code class="javascript">class A &#123;
  #foo = 0;
  static test(obj) &#123;
    console.log(#foo in obj);
  &#125;
&#125;

A.test(new A()) // true
A.test(&#123;&#125;) // false

class B &#123;
  #foo = 0;
&#125;

A.test(new B()) // false
</code></pre><p>上面示例中，类<code>A</code>的私有属性<code>#foo</code>，只能在类<code>A</code>内部使用<code>in</code>运算符判断，而且只对<code>A</code>的实例返回<code>true</code>，对于其他对象都返回<code>false</code>。</p><p>子类从父类继承的私有属性，也可以使用<code>in</code>运算符来判断。</p><pre><code class="javascript">class A &#123;
  #foo = 0;
  static test(obj) &#123;
    console.log(#foo in obj);
  &#125;
&#125;

class SubA extends A &#123;&#125;;

A.test(new SubA()) // true
</code></pre><p>上面示例中，<code>SubA</code>从父类继承了私有属性<code>#foo</code>，<code>in</code>运算符也有效。</p><p>注意，<code>in</code>运算符对于<code>Object.create()</code>、<code>Object.setPrototypeOf</code>形成的继承，是无效的，因为这种继承不会传递私有属性。</p><pre><code class="javascript">class A &#123;
  #foo = 0;
  static test(obj) &#123;
    console.log(#foo in obj);
  &#125;
&#125;
const a = new A();

const o1 = Object.create(a);
A.test(o1) // false
A.test(o1.__proto__) // true

const o2 = &#123;&#125;;
Object.setPrototypeOf(o2, A);
A.test(o2) // false
A.test(o2.__proto__) // true
</code></pre><p>上面示例中，对于修改原型链形成的继承，子类都取不到父类的私有属性，所以<code>in</code>运算符无效。</p><hr><h4 id="6-静态块"><a href="#6-静态块" class="headerlink" title="6. 静态块"></a>6. 静态块</h4><p><strong>静态属性的一个问题是，它的初始化要么写在类的外部，要么写在<code>constructor()</code>方法里面。</strong></p><pre><code class="javascript">class C &#123;
  static x = 234;
  static y;
  static z;
&#125;

try &#123;
  const obj = doSomethingWith(C.x);
  C.y = obj.y
  C.z = obj.z;
&#125; catch &#123;
  C.y = ...;
  C.z = ...;
&#125;
</code></pre><p>上面示例中，静态属性<code>y</code>和<code>z</code>的值依赖静态属性<code>x</code>，它们的初始化写在类的外部（上例的<code>try...catch</code>代码块）。另一种方法是写到类的<code>constructor()</code>方法里面。这两种方法都不是很理想，前者是将类的内部逻辑写到了外部，后者则是每次新建实例都会运行一次。</p><p><strong>为了解决这个问题，ES2022 引入了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtY2xhc3Mtc3RhdGljLWJsb2Nr">静态块</span>（static block），允许在类的内部设置一个代码块，在类生成时运行一次，主要作用是对静态属性进行初始化。</strong></p><pre><code class="javascript">class C &#123;
  static x = ...;
  static y;
  static z;

  static &#123;
    try &#123;
      const obj = doSomethingWith(this.x);
      this.y = obj.y;
      this.z = obj.z;
    &#125;
    catch &#123;
      this.y = ...;
      this.z = ...;
    &#125;
  &#125;
&#125;
</code></pre><p><strong>上面代码中，类的内部有一个 static 代码块，这就是静态块。它的好处是将静态属性<code>y</code>和<code>z</code>的初始化逻辑，写入了类的内部，而且只运行一次。</strong></p><p><strong>每个类只能有一个静态块，在静态属性声明后运行。静态块的内部不能有<code>return</code>语句。</strong></p><p><strong>静态块内部可以使用类名或<code>this</code>，指代当前类。</strong></p><pre><code class="c">class C &#123;
  static x = 1;
  static &#123;
    this.x; // 1
    // 或者
    C.x; // 1
  &#125;
&#125;
</code></pre><p>上面示例中，<code>this.x</code>和<code>C.x</code>都能获取静态属性<code>x</code>。</p><p><strong>除了静态属性的初始化，静态块还有一个作用，就是将私有属性与类的外部代码分享。</strong></p><pre><code class="javascript">let getX;

export class C &#123;
  #x = 1;
  static &#123;
    getX = obj =&gt; obj.#x;
  &#125;
&#125;

console.log(getX(new C())); // 1
</code></pre><p>上面示例中，<code>#x</code>是类的私有属性，<strong>如果类外部的<code>getX()</code>方法希望获取这个属性</strong>，以前是要写在类的<code>constructor()</code>方法里面，这样的话，每次新建实例都会定义一次<code>getX()</code>方法。<strong>现在可以写在静态块里面，这样的话，只在类生成时定义一次。</strong></p><hr><h4 id="7-new-target-属性"><a href="#7-new-target-属性" class="headerlink" title="7. new.target 属性"></a>7. new.target 属性</h4><p><strong><code>new</code>是从构造函数生成实例对象的命令。ES6 为<code>new</code>命令引入了一个<code>new.target</code>属性，该属性一般用在构造函数之中，返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令或<code>Reflect.construct()</code>调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</strong></p><pre><code class="javascript">function Person(name) &#123;
  if (new.target !== undefined) &#123;
    this.name = name;
  &#125; else &#123;
    throw new Error(&#39;必须使用 new 命令生成实例&#39;);
  &#125;
&#125;

// 另一种写法
function Person(name) &#123;
  if (new.target === Person) &#123;
    this.name = name;
  &#125; else &#123;
    throw new Error(&#39;必须使用 new 命令生成实例&#39;);
  &#125;
&#125;

var person = new Person(&#39;张三&#39;); // 正确
var notAPerson = Person.call(person, &#39;张三&#39;);  // 报错
</code></pre><p>上面代码确保构造函数只能通过<code>new</code>命令调用。</p><p>Class 内部调用<code>new.target</code>，返回当前 Class。</p><pre><code class="javascript">class Rectangle &#123;
  constructor(length, width) &#123;
    console.log(new.target === Rectangle);
    this.length = length;
    this.width = width;
  &#125;
&#125;

var obj = new Rectangle(3, 4); // 输出 true
</code></pre><p><strong>需要注意的是，子类继承父类时，<code>new.target</code>会返回子类。</strong></p><pre><code class="javascript">class Rectangle &#123;
  constructor(length, width) &#123;
    console.log(new.target === Rectangle);
    // ...
  &#125;
&#125;

class Square extends Rectangle &#123;
  constructor(length, width) &#123;
    super(length, width);
  &#125;
&#125;

var obj = new Square(3); // 输出 false
</code></pre><p>上面代码中，<code>new.target</code>会返回子类。</p><p><strong>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</strong>new.target指向自己就是new 不是的话就可能是call或者extends</p><pre><code class="javascript">class Shape &#123;
  constructor() &#123;
    if (new.target === Shape) &#123;
      throw new Error(&#39;本类不能实例化&#39;);
    &#125;
  &#125;
&#125;

class Rectangle extends Shape &#123;
  constructor(length, width) &#123;
    super();
    // ...
  &#125;
&#125;

var x = new Shape();  // 报错
var y = new Rectangle(3, 4);  // 正确
</code></pre><p>上面代码中，<code>Shape</code>类不能被实例化，只能用于继承。</p><p>注意，在函数外部，使用<code>new.target</code>会报错。</p><h3 id="22、-Class-的继承"><a href="#22、-Class-的继承" class="headerlink" title="22、 Class 的继承"></a>22、 Class 的继承</h3><hr><h4 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1. 简介"></a>1. 简介</h4><p><strong>Class 可以通过<code>extends</code>关键字实现继承，</strong>这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><pre><code class="javascript">class Point &#123;
&#125;

class ColorPoint extends Point &#123;
&#125;
</code></pre><p>上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。下面，我们在<code>ColorPoint</code>内部加上代码。</p><pre><code class="javascript">class ColorPoint extends Point &#123;
  constructor(x, y, color) &#123;
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  &#125;

  toString() &#123;
    return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()
  &#125;
&#125;
</code></pre><p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，<strong>都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</strong></p><p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p><pre><code class="javascript">class Point &#123; /* ... */ &#125;

class ColorPoint extends Point &#123;
  constructor() &#123;
  &#125;
&#125;

let cp = new ColorPoint(); // ReferenceError
</code></pre><p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super</code>方法，导致新建实例时报错。</p><p><strong>ES5 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</strong></p><p>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法。</p><pre><code class="javascript">class ColorPoint extends Point &#123;
&#125;

// 等同于
class ColorPoint extends Point &#123;
  constructor(...args) &#123;
    super(...args);
  &#125;
&#125;
</code></pre><p>另一个需要注意的地方是，在子类的构造函数中，<strong>只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有<code>super</code>方法才能调用父类实例。</strong></p><pre><code class="javascript">class Point &#123;
  constructor(x, y) &#123;
    this.x = x;
    this.y = y;
  &#125;
&#125;

class ColorPoint extends Point &#123;
  constructor(x, y, color) &#123;
    this.color = color; // ReferenceError
    super(x, y);
    this.color = color; // 正确
  &#125;
&#125;
</code></pre><p>上面代码中，子类的<code>constructor</code>方法没有调用<code>super</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super</code>方法之后就是正确的。</p><p>下面是生成子类实例的代码。</p><pre><code class="javascript">let cp = new ColorPoint(25, 8, &#39;green&#39;);

cp instanceof ColorPoint // true
cp instanceof Point // true
</code></pre><p>上面代码中，实例对象<code>cp</code>同时是<code>ColorPoint</code>和<code>Point</code>两个类的实例，这与 ES5 的行为完全一致。</p><p>最后，父类的静态方法，也会被子类继承。</p><pre><code class="javascript">class A &#123;
  static hello() &#123;
    console.log(&#39;hello world&#39;);
  &#125;
&#125;

class B extends A &#123;
&#125;

B.hello()  // hello world
</code></pre><p>上面代码中，<code>hello()</code>是<code>A</code>类的静态方法，<code>B</code>继承<code>A</code>，也继承了<code>A</code>的静态方法。</p><hr><h4 id="2-Object-getPrototypeOf"><a href="#2-Object-getPrototypeOf" class="headerlink" title="2. Object.getPrototypeOf()"></a>2. Object.getPrototypeOf()</h4><p><strong><code>Object.getPrototypeOf</code>方法可以用来从子类上获取父类。</strong></p><pre><code class="javascript">Object.getPrototypeOf(ColorPoint) === Point
// true
</code></pre><p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><hr><h4 id="3-super-关键字"><a href="#3-super-关键字" class="headerlink" title="3. super 关键字"></a>3. super 关键字</h4><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p><p><strong>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</strong></p><pre><code class="javascript">class A &#123;&#125;

class B extends A &#123;
  constructor() &#123;
    super();
  &#125;
&#125;
</code></pre><p>上面代码中，子类<code>B</code>的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p><p><strong>注意，<code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是<code>B</code>的实例，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</strong></p><pre><code class="javascript">class A &#123;
  constructor() &#123;
    console.log(new.target.name);
  &#125;
&#125;
class B extends A &#123;
  constructor() &#123;
    super();
  &#125;
&#125;
new A() // A
new B() // B
</code></pre><p>上面代码中，<code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。</p><p>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p><pre><code class="javascript">class A &#123;&#125;

class B extends A &#123;
  m() &#123;
    super(); // 报错
  &#125;
&#125;
</code></pre><p>上面代码中，<code>super()</code>用在<code>B</code>类的<code>m</code>方法之中，就会造成语法错误。</p><p><strong>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</strong></p><pre><code class="javascript">class A &#123;
  p() &#123;
    return 2;
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super.p()); // 2
  &#125;
&#125;

let b = new B();
</code></pre><p>上面代码中，<strong>子类<code>B</code>当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。</strong>这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。</p><p><strong>这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</strong></p><pre><code class="javascript">class A &#123;
  constructor() &#123;
    this.p = 2;
  &#125;
&#125;

class B extends A &#123;
  get m() &#123;
    return super.p;
  &#125;
&#125;

let b = new B();
b.m // undefined
</code></pre><p>上面代码中，<code>p</code>是父类<code>A</code>实例的属性，<code>super.p</code>就引用不到它。</p><p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到。</p><pre><code class="javascript">class A &#123;&#125;
A.prototype.x = 2;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super.x) // 2
  &#125;
&#125;

let b = new B();
</code></pre><p>上面代码中，属性<code>x</code>是定义在<code>A.prototype</code>上面的，所以<code>super.x</code>可以取到它的值。</p><p><strong>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</strong></p><pre><code class="javascript">class A &#123;
  constructor() &#123;
    this.x = 1;
  &#125;
  print() &#123;
    console.log(this.x);
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    this.x = 2;
  &#125;
  m() &#123;
    super.print();
  &#125;
&#125;

let b = new B();
b.m() // 2
</code></pre><p>上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类<code>B</code>的实例，导致输出的是<code>2</code>，而不是<code>1</code>。也就是说，<strong>实际上执行的是<code>super.print.call(this)</code>。</strong></p><p><strong>由于<code>this</code>指向子类实例，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。</strong></p><pre><code class="javascript">class A &#123;
  constructor() &#123;
    this.x = 1;
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 3
  &#125;
&#125;

let b = new B();
</code></pre><p>上面代码中，<code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p><p><strong>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</strong></p><pre><code class="javascript">class Parent &#123;
  static myMethod(msg) &#123;
    console.log(&#39;static&#39;, msg);
  &#125;

  myMethod(msg) &#123;
    console.log(&#39;instance&#39;, msg);
  &#125;
&#125;

class Child extends Parent &#123;
  static myMethod(msg) &#123;
    super.myMethod(msg);
  &#125;

  myMethod(msg) &#123;
    super.myMethod(msg);
  &#125;
&#125;

Child.myMethod(1); // static 1

var child = new Child();
child.myMethod(2); // instance 2
</code></pre><p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p><p>另外，在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</p><pre><code class="javascript">class A &#123;
  constructor() &#123;
    this.x = 1;
  &#125;
  static print() &#123;
    console.log(this.x);
  &#125;
&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    this.x = 2;
  &#125;
  static m() &#123;
    super.print();
  &#125;
&#125;

B.x = 3;
B.m() // 3
</code></pre><p>上面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例。</p><p><strong>注意，使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</strong></p><pre><code class="javascript">class A &#123;&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super); // 报错
  &#125;
&#125;
</code></pre><p><strong>上面代码中，<code>console.log(super)</code>当中的<code>super</code>，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明<code>super</code>的数据类型，就不会报错。</strong></p><pre><code class="javascript">class A &#123;&#125;

class B extends A &#123;
  constructor() &#123;
    super();
    console.log(super.valueOf() instanceof B); // true
  &#125;
&#125;

let b = new B();
</code></pre><p>上面代码中，<code>super.valueOf()</code>表明<code>super</code>是一个对象，因此就不会报错。同时，由于<code>super</code>使得<code>this</code>指向<code>B</code>的实例，所以<code>super.valueOf()</code>返回的是一个<code>B</code>的实例。</p><p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</p><pre><code class="javascript">var obj = &#123;
  toString() &#123;
    return &quot;MyObject: &quot; + super.toString();
  &#125;
&#125;;

obj.toString(); // MyObject: [object Object]
</code></pre><hr><h4 id="4-类的-prototype-属性和-proto-属性"><a href="#4-类的-prototype-属性和-proto-属性" class="headerlink" title="4. 类的 prototype 属性和__proto__属性"></a>4. 类的 prototype 属性和__proto__属性</h4><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><p><strong>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</strong></p><p><strong>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</strong></p><pre><code class="javascript">class A &#123;
&#125;

class B extends A &#123;
&#125;

B.__proto__ === A // true
B.prototype.__proto__ === A.prototype // true
</code></pre><p>上面代码中，子类<code>B</code>的<code>__proto__</code>属性指向父类<code>A</code>，子类<code>B</code>的<code>prototype</code>属性的<code>__proto__</code>属性指向父类<code>A</code>的<code>prototype</code>属性。</p><p>这样的结果是因为，类的继承是按照下面的模式实现的。</p><pre><code class="javascript">class A &#123;
&#125;

class B &#123;
&#125;

// B 的实例继承 A 的实例
Object.setPrototypeOf(B.prototype, A.prototype);

// B 继承 A 的静态属性
Object.setPrototypeOf(B, A);

const b = new B();
</code></pre><p>《对象的扩展》一章给出过<code>Object.setPrototypeOf</code>方法的实现。</p><pre><code class="javascript">Object.setPrototypeOf = function (obj, proto) &#123;
  obj.__proto__ = proto;
  return obj;
&#125;
</code></pre><p>因此，就得到了上面的结果。</p><pre><code class="javascript">Object.setPrototypeOf(B.prototype, A.prototype);
// 等同于
B.prototype.__proto__ = A.prototype;

Object.setPrototypeOf(B, A);
// 等同于
B.__proto__ = A;
</code></pre><p>这两条继承链，可以这样理解：<strong>作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</strong></p><pre><code class="javascript">B.prototype = Object.create(A.prototype);
// 等同于
B.prototype.__proto__ = A.prototype;
</code></pre><p><strong><code>extends</code>关键字后面可以跟多种类型的值。</strong></p><pre><code class="javascript">class B extends A &#123;
&#125;
</code></pre><p>上面代码的<code>A</code>，只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p><p>下面，讨论两种情况。第一种，子类继承<code>Object</code>类。</p><pre><code class="javascript">class A extends Object &#123;
&#125;

A.__proto__ === Object // true
A.prototype.__proto__ === Object.prototype // true
</code></pre><p>这种情况下，**<code>A</code>其实就是构造函数<code>Object</code>的复制，<code>A</code>的实例就是<code>Object</code>的实例。**</p><p>第二种情况，不存在任何继承。</p><pre><code class="javascript">class A &#123;
&#125;

A.__proto__ === Function.prototype // true
A.prototype.__proto__ === Object.prototype // true
</code></pre><p>这种情况下，**<code>A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Function.prototype</code>。但是，<code>A</code>调用后返回一个空对象（即<code>Object</code>实例），所以<code>A.prototype.__proto__</code>指向构造函数（<code>Object</code>）的<code>prototype</code>属性。**</p><hr><p><strong>实例的 proto 属性</strong></p><p><strong>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</strong></p><pre><code class="javascript">var p1 = new Point(2, 3);
var p2 = new ColorPoint(2, 3, &#39;red&#39;);

p2.__proto__ === p1.__proto__ // false
p2.__proto__.__proto__ === p1.__proto__ // true
</code></pre><p><strong>上面代码中，<code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型。</strong></p><p>因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</p><pre><code class="javascript">p2.__proto__.__proto__.printName = function () &#123;
  console.log(&#39;Ha&#39;);
&#125;;

p1.printName() // &quot;Ha&quot;
</code></pre><p>上面代码在<code>ColorPoint</code>的实例<code>p2</code>上向<code>Point</code>类添加方法，结果影响到了<code>Point</code>的实例<code>p1</code>。</p><hr><h4 id="5-原生构造函数的继承"><a href="#5-原生构造函数的继承" class="headerlink" title="5. 原生构造函数的继承"></a>5. 原生构造函数的继承</h4><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p><ul><li>Boolean()</li><li>Number()</li><li>String()</li><li>Array()</li><li>Date()</li><li>Function()</li><li>RegExp()</li><li>Error()</li><li>Object()</li></ul><p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个<code>Array</code>的子类。</p><pre><code class="javascript">function MyArray() &#123;
  Array.apply(this, arguments);
&#125;

MyArray.prototype = Object.create(Array.prototype, &#123;
  constructor: &#123;
    value: MyArray,
    writable: true,
    configurable: true,
    enumerable: true
  &#125;
&#125;);
</code></pre><p>上面代码定义了一个继承 Array 的<code>MyArray</code>类。但是，这个类的行为与<code>Array</code>完全不一致。</p><pre><code class="javascript">var colors = new MyArray();
colors[0] = &quot;red&quot;;
colors.length  // 0

colors.length = 0;
colors[0]  // &quot;red&quot;
</code></pre><p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过<code>Array.apply()</code>或者分配给原型对象都不行。原生构造函数会忽略<code>apply</code>方法传入的<code>this</code>，也就是说，原生构造函数的<code>this</code>无法绑定，导致拿不到内部属性。</p><p><strong>ES5 是先新建子类的实例对象<code>this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。</strong>比如，<code>Array</code>构造函数有一个内部属性<code>[[DefineOwnProperty]]</code>，用来定义新属性时，更新<code>length</code>属性，这个内部属性无法在子类获取，导致子类的<code>length</code>属性行为不正常。</p><p>下面的例子中，我们想让一个普通对象继承<code>Error</code>对象。</p><pre><code class="javascript">var e = &#123;&#125;;

Object.getOwnPropertyNames(Error.call(e))
// [ &#39;stack&#39; ]

Object.getOwnPropertyNames(e)
// []
</code></pre><p>上面代码中，我们想通过<code>Error.call(e)</code>这种写法，让普通对象<code>e</code>具有<code>Error</code>对象的实例属性。但是，<code>Error.call()</code>完全忽略传入的第一个参数，而是返回一个新对象，<code>e</code>本身没有任何变化。这证明了<code>Error.call(e)</code>这种写法，无法继承原生构造函数。</p><p><strong>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子。</strong></p><pre><code class="javascript">class MyArray extends Array &#123;
  constructor(...args) &#123;
    super(...args);
  &#125;
&#125;

var arr = new MyArray();
arr[0] = 12;
arr.length // 1

arr.length = 0;
arr[0] // undefined
</code></pre><p>上面代码定义了一个<code>MyArray</code>类，继承了<code>Array</code>构造函数，因此就可以从<code>MyArray</code>生成数组的实例。这意味着，<strong>ES6 可以自定义原生数据结构（比如<code>Array</code>、<code>String</code>等）的子类，这是 ES5 无法做到的。</strong></p><p>上面这个例子也说明，<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p><pre><code class="javascript">class VersionedArray extends Array &#123;
  constructor() &#123;
    super();
    this.history = [[]];
  &#125;
  commit() &#123;
    this.history.push(this.slice());
  &#125;
  revert() &#123;
    this.splice(0, this.length, ...this.history[this.history.length - 1]);
  &#125;
&#125;

var x = new VersionedArray();

x.push(1);
x.push(2);
x // [1, 2]
x.history // [[]]

x.commit();
x.history // [[], [1, 2]]

x.push(3);
x // [1, 2, 3]
x.history // [[], [1, 2]]

x.revert();
x // [1, 2]
</code></pre><p>上面代码中，<code>VersionedArray</code>会通过<code>commit</code>方法，将自己的当前状态生成一个版本快照，存入<code>history</code>属性。<code>revert</code>方法用来将数组重置为最新一次保存的版本。除此之外，<code>VersionedArray</code>依然是一个普通数组，所有原生的数组方法都可以在它上面调用。</p><p>下面是一个自定义<code>Error</code>子类的例子，可以用来定制报错时的行为。</p><pre><code class="javascript">class ExtendableError extends Error &#123;
  constructor(message) &#123;
    super();
    this.message = message;
    this.stack = (new Error()).stack;
    this.name = this.constructor.name;
  &#125;
&#125;

class MyError extends ExtendableError &#123;
  constructor(m) &#123;
    super(m);
  &#125;
&#125;

var myerror = new MyError(&#39;ll&#39;);
myerror.message // &quot;ll&quot;
myerror instanceof Error // true
myerror.name // &quot;MyError&quot;
myerror.stack
// Error
//     at MyError.ExtendableError
//     ...
</code></pre><p>注意，继承<code>Object</code>的子类，有一个<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzYyMDM2MTQvc3VwZXItZG9lcy1ub3QtcGFzcy1hcmd1bWVudHMtd2hlbi1pbnN0YW50aWF0aW5nLWEtY2xhc3MtZXh0ZW5kZWQtZnJvbS1vYmplY3Q=">行为差异</span>。</p><pre><code class="javascript">class NewObj extends Object&#123;
  constructor()&#123;
    super(...arguments);
  &#125;
&#125;
var o = new NewObj(&#123;attr: true&#125;);
o.attr === true  // false
</code></pre><p>上面代码中，<code>NewObj</code>继承了<code>Object</code>，但是无法通过<code>super</code>方法向父类<code>Object</code>传参。这<strong>是因为 ES6 改变了<code>Object</code>构造函数的行为，一旦发现<code>Object</code>方法不是通过<code>new Object()</code>这种形式调用，ES6 规定<code>Object</code>构造函数会忽略参数。</strong></p><hr><h4 id="6-Mixin-模式的实现"><a href="#6-Mixin-模式的实现" class="headerlink" title="6. Mixin 模式的实现"></a>6. Mixin 模式的实现</h4><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p><pre><code class="javascript">const a = &#123;
  a: &#39;a&#39;
&#125;;
const b = &#123;
  b: &#39;b&#39;
&#125;;
const c = &#123;...a, ...b&#125;; // &#123;a: &#39;a&#39;, b: &#39;b&#39;&#125;
</code></pre><p>上面代码中，<code>c</code>对象是<code>a</code>对象和<code>b</code>对象的合成，具有两者的接口。</p><p>下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。</p><pre><code class="javascript">function mix(...mixins) &#123;
  class Mix &#123;
    constructor() &#123;
      for (let mixin of mixins) &#123;
        copyProperties(this, new mixin()); // 拷贝实例属性
      &#125;
    &#125;
  &#125;

  for (let mixin of mixins) &#123;
    copyProperties(Mix, mixin); // 拷贝静态属性
    copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性
  &#125;

  return Mix;
&#125;

function copyProperties(target, source) &#123;
  for (let key of Reflect.ownKeys(source)) &#123;
    if ( key !== &#39;constructor&#39;
      &amp;&amp; key !== &#39;prototype&#39;
      &amp;&amp; key !== &#39;name&#39;
    ) &#123;
      let desc = Object.getOwnPropertyDescriptor(source, key);
      Object.defineProperty(target, key, desc);
    &#125;
  &#125;
&#125;
</code></pre><p>上面代码的<code>mix</code>函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p><pre><code class="javascript">class DistributedEdit extends mix(Loggable, Serializable) &#123;
  // ...
&#125;
</code></pre><h3 id="23、-Module-的语法"><a href="#23、-Module-的语法" class="headerlink" title="23、 Module 的语法"></a>23、 Module 的语法</h3><hr><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p><pre><code class="javascript">// CommonJS模块
let &#123; stat, exists, readfile &#125; = require(&#39;fs&#39;);

// 等同于
let _fs = require(&#39;fs&#39;);
let stat = _fs.stat;
let exists = _fs.exists;
let readfile = _fs.readfile;
</code></pre><p>上面代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p><p>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</p><pre><code class="javascript">// ES6模块
import &#123; stat, exists, readFile &#125; from &#39;fs&#39;;
</code></pre><p>上面代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p><p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p><p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p><ul><li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li><li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li><li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li></ul><p>本章介绍 ES6 模块的语法，下一章介绍如何在浏览器和 Node 之中，加载 ES6 模块。</p><hr><h4 id="2-严格模式"><a href="#2-严格模式" class="headerlink" title="2. 严格模式"></a>2. 严格模式</h4><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p><p>严格模式主要有以下限制。</p><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用<code>with</code>语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li><li><code>eval</code>不会在它的外层作用域引入变量</li><li><code>eval</code>和<code>arguments</code>不能被重新赋值</li><li><code>arguments</code>不会自动反映函数参数的变化</li><li>不能使用<code>arguments.callee</code></li><li>不能使用<code>arguments.caller</code></li><li>禁止<code>this</code>指向全局对象</li><li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li><li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li></ul><p>上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本书不再详细介绍了。</p><p>其中，尤其需要注意<code>this</code>的限制。<strong>ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code>。</strong></p><hr><h4 id="3-export-命令"><a href="#3-export-命令" class="headerlink" title="3. export 命令"></a>3. export 命令</h4><p><strong>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</strong></p><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量。</p><pre><code class="javascript">// profile.js
export var firstName = &#39;Michael&#39;;
export var lastName = &#39;Jackson&#39;;
export var year = 1958;
</code></pre><p>上面代码是<code>profile.js</code>文件，保存了用户信息。ES6 将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p><p><code>export</code>的写法，除了像上面这样，还有另外一种。</p><pre><code class="javascript">// profile.js
var firstName = &#39;Michael&#39;;
var lastName = &#39;Jackson&#39;;
var year = 1958;

export &#123; firstName, lastName, year &#125;;
</code></pre><p>上面代码在<code>export</code>命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在<code>var</code>语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p><p><code>export</code>命令除了输出变量，还可以输出函数或类（class）。</p><pre><code class="javascript">export function multiply(x, y) &#123;
  return x * y;
&#125;;
</code></pre><p>上面代码对外输出一个函数<code>multiply</code>。</p><p><strong>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。</strong></p><pre><code class="javascript">function v1() &#123; ... &#125;
function v2() &#123; ... &#125;

export &#123;
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
&#125;;
</code></pre><p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p><p>需要特别注意的是，<code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p><pre><code class="javascript">// 报错
export 1;

// 报错
var m = 1;
export m;
</code></pre><p><strong>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量<code>m</code>，还是直接输出 1。<code>1</code>只是一个值，不是接口。得用 {} 包一下或者直接export</strong>。正确的写法是下面这样。</p><pre><code class="javascript">// 写法一
export var m = 1;

// 写法二
var m = 1;
export &#123;m&#125;;

// 写法三
var n = 1;
export &#123;n as m&#125;;
</code></pre><p>上面三种写法都是正确的，规定了对外的接口<code>m</code>。其他脚本可以通过这个接口，取到值<code>1</code>。<strong>它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</strong></p><p>同样的，<code>function</code>和<code>class</code>的输出，也必须遵守这样的写法。</p><pre><code class="javascript">// 报错
function f() &#123;&#125;
export f;

// 正确
export function f() &#123;&#125;;

// 正确
function f() &#123;&#125;
export &#123;f&#125;;
</code></pre><p>另外，**<code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。**</p><pre><code class="javascript">export var foo = &#39;bar&#39;;
setTimeout(() =&gt; foo = &#39;baz&#39;, 500);
</code></pre><p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500 毫秒之后变成<code>baz</code>。</p><p><strong>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新</strong>，详见下文《Module 的加载实现》一节。</p><p>最后，**<code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错**，下一节的<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p><pre><code class="javascript">function foo() &#123;
  export default &#39;bar&#39; // SyntaxError
&#125;
foo()
</code></pre><p>上面代码中，<code>export</code>语句放在函数之中，结果报错。</p><hr><h4 id="4-import-命令"><a href="#4-import-命令" class="headerlink" title="4. import 命令"></a>4. import 命令</h4><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p><pre><code class="javascript">// main.js
import &#123; firstName, lastName, year &#125; from &#39;./profile.js&#39;;

function setName(element) &#123;
  element.textContent = firstName + &#39; &#39; + lastName;
&#125;
</code></pre><p>上面代码的<code>import</code>命令，用于加载<code>profile.js</code>文件，并从中输入变量。<code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p><p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p><pre><code class="javascript">import &#123; lastName as surname &#125; from &#39;./profile.js&#39;;
</code></pre><p><strong><code>import</code>命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。</strong></p><pre><code class="javascript">import &#123;a&#125; from &#39;./xxx.js&#39;

a = &#123;&#125;; // Syntax Error : &#39;a&#39; is read-only;
</code></pre><p>上面代码中，脚本加载了变量<code>a</code>，对其重新赋值就会报错，因为<code>a</code>是一个只读的接口。但是，如果<code>a</code>是一个对象，改写<code>a</code>的属性是允许的。</p><pre><code class="javascript">import &#123;a&#125; from &#39;./xxx.js&#39;

a.foo = &#39;hello&#39;; // 合法操作
</code></pre><p>上面代码中，<code>a</code>的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，<strong>建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。</strong></p><p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径。如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p><pre><code class="javascript">import &#123; myMethod &#125; from &#39;util&#39;;
</code></pre><p>上面代码中，<code>util</code>是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p><p><strong>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</strong></p><pre><code class="javascript">foo();

import &#123; foo &#125; from &#39;my_module&#39;;
</code></pre><p><strong>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。</strong></p><p><strong>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</strong></p><pre><code class="javascript">// 报错
import &#123; &#39;f&#39; + &#39;oo&#39; &#125; from &#39;my_module&#39;;

// 报错
let module = &#39;my_module&#39;;
import &#123; foo &#125; from module;

// 报错
if (x === 1) &#123;
  import &#123; foo &#125; from &#39;module1&#39;;
&#125; else &#123;
  import &#123; foo &#125; from &#39;module2&#39;;
&#125;
</code></pre><p>上面三种写法都会报错，因为它们用到了表达式、变量和<code>if</code>结构。在静态分析阶段，这些语法都是没法得到值的。</p><p>最后，<code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p><pre><code class="javascript">import &#39;lodash&#39;;
</code></pre><p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p><p><strong>如果多次重复执行同一句<code>import</code>语句，那么只会执行一次，而不会执行多次。</strong></p><pre><code class="javascript">import &#39;lodash&#39;;
import &#39;lodash&#39;;
</code></pre><p>上面代码加载了两次<code>lodash</code>，但是只会执行一次。</p><pre><code class="javascript">import &#123; foo &#125; from &#39;my_module&#39;;
import &#123; bar &#125; from &#39;my_module&#39;;

// 等同于
import &#123; foo, bar &#125; from &#39;my_module&#39;;
</code></pre><p>上面代码中，虽然<code>foo</code>和<code>bar</code>在两个语句中加载，但是它们对应的是同一个<code>my_module</code>模块。也就是说，**<code>import</code>语句是 Singleton 模式。**</p><p>目前阶段，通过 Babel 转码，CommonJS 模块的<code>require</code>命令和 ES6 模块的<code>import</code>命令，可以写在同一个模块里面，但是最好不要这样做。因为<code>import</code>在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</p><pre><code class="javascript">require(&#39;core-js/modules/es6.symbol&#39;);
require(&#39;core-js/modules/es6.promise&#39;);
import React from &#39;React&#39;;
</code></pre><hr><h4 id="5-模块的整体加载"><a href="#5-模块的整体加载" class="headerlink" title="5. 模块的整体加载"></a>5. 模块的整体加载</h4><p><strong>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</strong></p><p>下面是一个<code>circle.js</code>文件，它输出两个方法<code>area</code>和<code>circumference</code>。</p><pre><code class="javascript">// circle.js

export function area(radius) &#123;
  return Math.PI * radius * radius;
&#125;

export function circumference(radius) &#123;
  return 2 * Math.PI * radius;
&#125;
</code></pre><p>现在，加载这个模块。</p><pre><code class="javascript">// main.js

import &#123; area, circumference &#125; from &#39;./circle&#39;;

console.log(&#39;圆面积：&#39; + area(4));
console.log(&#39;圆周长：&#39; + circumference(14));
</code></pre><p>上面写法是逐一指定要加载的方法，整体加载的写法如下。</p><pre><code class="javascript">import * as circle from &#39;./circle&#39;;

console.log(&#39;圆面积：&#39; + circle.area(4));
console.log(&#39;圆周长：&#39; + circle.circumference(14));
</code></pre><p><strong>注意，模块整体加载所在的那个对象（上例是<code>circle</code>），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。</strong></p><pre><code class="javascript">import * as circle from &#39;./circle&#39;;

// 下面两行都是不允许的
circle.foo = &#39;hello&#39;;
circle.area = function () &#123;&#125;;
</code></pre><hr><h4 id="6-export-default-命令"><a href="#6-export-default-命令" class="headerlink" title="6. export default 命令"></a>6. export default 命令</h4><p>从前面的例子可以看出，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p><p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到**<code>export default</code>命令，为模块指定默认输出。**</p><pre><code class="javascript">// export-default.js
export default function () &#123;
  console.log(&#39;foo&#39;);
&#125;
</code></pre><p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p><p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p><pre><code class="javascript">// import-default.js
import customName from &#39;./export-default&#39;;
customName(); // &#39;foo&#39;
</code></pre><p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p><p><code>export default</code>命令用在非匿名函数前，也是可以的。</p><pre><code class="javascript">// export-default.js
export default function foo() &#123;
  console.log(&#39;foo&#39;);
&#125;

// 或者写成

function foo() &#123;
  console.log(&#39;foo&#39;);
&#125;

export default foo;
</code></pre><p>上面代码中，<code>foo</code>函数的函数名<code>foo</code>，在模块外部是无效的。加载的时候，视同匿名函数加载。</p><p><strong>下面比较一下默认输出和正常输出。</strong></p><pre><code class="javascript">// 第一组
export default function crc32() &#123; // 输出
  // ...
&#125;

import crc32 from &#39;crc32&#39;; // 输入

// 第二组
export function crc32() &#123; // 输出
  // ...
&#125;;

import &#123;crc32&#125; from &#39;crc32&#39;; // 输入
</code></pre><p>上面代码的两组写法，第一组是使用<code>export default</code>时，对应的<code>import</code>语句不需要使用大括号；<strong>第二组是不使用<code>export default</code>时，对应的<code>import</code>语句需要使用大括号。</strong></p><p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令。</p><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><pre><code class="javascript">// modules.js
function add(x, y) &#123;
  return x * y;
&#125;
export &#123;add as default&#125;;
// 等同于
// export default add;

// app.js
import &#123; default as foo &#125; from &#39;modules&#39;;
// 等同于
// import foo from &#39;modules&#39;;
</code></pre><p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p><pre><code class="javascript">// 正确
export var a = 1;

// 正确
var a = 1;
export default a;

// 错误
export default var a = 1;
</code></pre><p>上面代码中，<code>export default a</code>的含义是将变量<code>a</code>的值赋给变量<code>default</code>。所以，最后一种写法会报错。</p><p>同样地，因为<code>export default</code>命令的本质是将后面的值，赋给<code>default</code>变量，所以可以直接将一个值写在<code>export default</code>之后。</p><pre><code class="javascript">// 正确
export default 42;

// 报错
export 42;
</code></pre><p><strong>上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为<code>default</code>。</strong></p><p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入 lodash 模块为例。</p><pre><code class="javascript">import _ from &#39;lodash&#39;;
</code></pre><p><strong>如果想在一条<code>import</code>语句中，同时输入默认方法和其他接口，可以写成下面这样。</strong></p><pre><code class="javascript">import _, &#123; each, forEach &#125; from &#39;lodash&#39;;
</code></pre><p>对应上面代码的<code>export</code>语句如下。</p><pre><code class="javascript">export default function (obj) &#123;
  // ···
&#125;

export function each(obj, iterator, context) &#123;
  // ···
&#125;

export &#123; each as forEach &#125;;
</code></pre><p>上面代码的最后一行的意思是，暴露出<code>forEach</code>接口，默认指向<code>each</code>接口，即<code>forEach</code>和<code>each</code>指向同一个方法。</p><p><code>export default</code>也可以用来输出类。</p><pre><code class="javascript">// MyClass.js
export default class &#123; ... &#125;

// main.js
import MyClass from &#39;MyClass&#39;;
let o = new MyClass();
</code></pre><hr><h4 id="7-export-与-import-的复合写法"><a href="#7-export-与-import-的复合写法" class="headerlink" title="7. export 与 import 的复合写法"></a>7. export 与 import 的复合写法</h4><p>如果在一个模块之中，先输入后输出同一个模块，<code>import</code>语句可以与<code>export</code>语句写在一起。</p><pre><code class="javascript">export &#123; foo, bar &#125; from &#39;my_module&#39;;

// 可以简单理解为
import &#123; foo, bar &#125; from &#39;my_module&#39;;
export &#123; foo, bar &#125;;
</code></pre><p>上面代码中，<code>export</code>和<code>import</code>语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，<code>foo</code>和<code>bar</code>实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用<code>foo</code>和<code>bar</code>。</p><p>模块的接口改名和整体输出，也可以采用这种写法。</p><pre><code class="javascript">// 接口改名
export &#123; foo as myFoo &#125; from &#39;my_module&#39;;

// 整体输出
export * from &#39;my_module&#39;;
</code></pre><p>默认接口的写法如下。</p><pre><code class="javascript">export &#123; default &#125; from &#39;foo&#39;;
</code></pre><p>具名接口改为默认接口的写法如下。</p><pre><code class="javascript">export &#123; es6 as default &#125; from &#39;./someModule&#39;;

// 等同于
import &#123; es6 &#125; from &#39;./someModule&#39;;
export default es6;
</code></pre><p>同样地，默认接口也可以改名为具名接口。</p><pre><code class="javascript">export &#123; default as es6 &#125; from &#39;./someModule&#39;;
</code></pre><p>ES2020 之前，有一种<code>import</code>语句，没有对应的复合写法。</p><pre><code class="javascript">import * as someIdentifier from &quot;someModule&quot;;
</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZXhwb3J0LW5zLWZyb20=">ES2020</span>补上了这个写法。</p><pre><code class="javascript">export * as ns from &quot;mod&quot;;

// 等同于
import * as ns from &quot;mod&quot;;
export &#123;ns&#125;;
</code></pre><hr><h4 id="8-模块的继承"><a href="#8-模块的继承" class="headerlink" title="8. 模块的继承"></a>8. 模块的继承</h4><p>模块之间也可以继承。</p><p>假设有一个<code>circleplus</code>模块，继承了<code>circle</code>模块。</p><pre><code class="javascript">// circleplus.js

export * from &#39;circle&#39;;
export var e = 2.71828182846;
export default function(x) &#123;
  return Math.exp(x);
&#125;
</code></pre><p>上面代码中的<code>export *</code>，表示再输出<code>circle</code>模块的所有属性和方法。注意，<code>export *</code>命令会忽略<code>circle</code>模块的<code>default</code>方法。然后，上面代码又输出了自定义的<code>e</code>变量和默认方法。</p><p>这时，也可以将<code>circle</code>的属性或方法，改名后再输出。</p><pre><code class="javascript">// circleplus.js

export &#123; area as circleArea &#125; from &#39;circle&#39;;
</code></pre><p>上面代码表示，只输出<code>circle</code>模块的<code>area</code>方法，且将其改名为<code>circleArea</code>。</p><p>加载上面模块的写法如下。</p><pre><code class="javascript">// main.js

import * as math from &#39;circleplus&#39;;
import exp from &#39;circleplus&#39;;
console.log(exp(math.e));
</code></pre><p>上面代码中的<code>import exp</code>表示，将<code>circleplus</code>模块的默认方法加载为<code>exp</code>方法。</p><hr><h4 id="9-跨模块常量"><a href="#9-跨模块常量" class="headerlink" title="9. 跨模块常量"></a>9. 跨模块常量</h4><p>本书介绍<code>const</code>命令的时候说过，<code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p><pre><code class="javascript">// constants.js 模块
export const A = 1;
export const B = 3;
export const C = 4;

// test1.js 模块
import * as constants from &#39;./constants&#39;;
console.log(constants.A); // 1
console.log(constants.B); // 3

// test2.js 模块
import &#123;A, B&#125; from &#39;./constants&#39;;
console.log(A); // 1
console.log(B); // 3
</code></pre><p>如果要使用的常量非常多，可以建一个专门的<code>constants</code>目录，将各种常量写在不同的文件里面，保存在该目录下。</p><pre><code class="javascript">// constants/db.js
export const db = &#123;
  url: &#39;http://my.couchdbserver.local:5984&#39;,
  admin_username: &#39;admin&#39;,
  admin_password: &#39;admin password&#39;
&#125;;

// constants/user.js
export const users = [&#39;root&#39;, &#39;admin&#39;, &#39;staff&#39;, &#39;ceo&#39;, &#39;chief&#39;, &#39;moderator&#39;];
</code></pre><p>然后，将这些文件输出的常量，合并在<code>index.js</code>里面。</p><pre><code class="javascript">// constants/index.js
export &#123;db&#125; from &#39;./db&#39;;
export &#123;users&#125; from &#39;./users&#39;;
</code></pre><p>使用的时候，直接加载<code>index.js</code>就可以了。</p><pre><code class="javascript">// script.js
import &#123;db, users&#125; from &#39;./constants/index&#39;;
</code></pre><hr><h4 id="10-import"><a href="#10-import" class="headerlink" title="10. import()"></a>10. import()</h4><p><strong>简介</strong></p><p>前面介绍过，<code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（<code>import</code>命令叫做“连接” binding 其实更合适）。所以，下面的代码会报错。</p><pre><code class="javascript">// 报错
if (x === 2) &#123;
  import MyModual from &#39;./myModual&#39;;
&#125;
</code></pre><p>上面代码中，<strong>引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报句法错误</strong>，而不是执行时错误。也就是说，<code>import</code>和<code>export</code>命令只能在模块的顶层，不能在代码块之中（比如，在<code>if</code>代码块之中，或在函数之中）。</p><p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果<code>import</code>命令要取代 Node 的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p><pre><code class="javascript">const path = &#39;./&#39; + fileName;
const myModual = require(path);
</code></pre><p>上面的语句就是动态加载，<code>require</code>到底加载哪一个模块，只有运行时才知道。<code>import</code>命令做不到这一点。</p><p><strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZHluYW1pYy1pbXBvcnQ=">ES2020提案</span> 引入<code>import()</code>函数，支持动态加载模块。</strong></p><pre><code class="javascript">import(specifier)
</code></pre><p>上面代码中，**<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。**</p><p><code>import()</code>返回一个 Promise 对象。下面是一个例子。</p><pre><code class="javascript">const main = document.querySelector(&#39;main&#39;);

import(`./section-modules/$&#123;someVariable&#125;.js`)
  .then(module =&gt; &#123;
    module.loadPageInto(main);
  &#125;)
  .catch(err =&gt; &#123;
    main.textContent = err.message;
  &#125;);
</code></pre><p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。**<code>import()</code>类似于 Node 的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。**</p><p><strong>适用场合</strong></p><p>下面是<code>import()</code>的一些适用场合。</p><p><strong>（1）按需加载。</strong></p><p><code>import()</code>可以在需要的时候，再加载某个模块。</p><pre><code class="javascript">button.addEventListener(&#39;click&#39;, event =&gt; &#123;
  import(&#39;./dialogBox.js&#39;)
  .then(dialogBox =&gt; &#123;
    dialogBox.open();
  &#125;)
  .catch(error =&gt; &#123;
    /* Error handling */
  &#125;)
&#125;);
</code></pre><p>上面代码中，<code>import()</code>方法放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p><p><strong>（2）条件加载</strong></p><p><code>import()</code>可以放在<code>if</code>代码块，根据不同的情况，加载不同的模块。</p><pre><code class="javascript">if (condition) &#123;
  import(&#39;moduleA&#39;).then(...);
&#125; else &#123;
  import(&#39;moduleB&#39;).then(...);
&#125;
</code></pre><p>上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。</p><p><strong>（3）动态的模块路径</strong></p><p><code>import()</code>允许模块路径动态生成。</p><pre><code class="javascript">import(f())
.then(...);
</code></pre><p>上面代码中，根据函数<code>f</code>的返回结果，加载不同的模块。</p><p><strong>注意点</strong></p><p><strong><code>import()</code>加载模块成功以后，这个模块会作为一个对象，当作<code>then</code>方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。</strong></p><pre><code class="javascript">import(&#39;./myModule.js&#39;)
.then((&#123;export1, export2&#125;) =&gt; &#123;
  // ...·
&#125;);
</code></pre><p>上面代码中，<code>export1</code>和<code>export2</code>都是<code>myModule.js</code>的输出接口，可以解构获得。</p><p>如果模块有<code>default</code>输出接口，可以用参数直接获得。</p><pre><code class="javascript">import(&#39;./myModule.js&#39;)
.then(myModule =&gt; &#123;
  console.log(myModule.default);
&#125;);
</code></pre><p>上面的代码也可以使用具名输入的形式。</p><pre><code class="javascript">import(&#39;./myModule.js&#39;)
.then((&#123;default: theDefault&#125;) =&gt; &#123;
  console.log(theDefault);
&#125;);
</code></pre><p>如果想同时加载多个模块，可以采用下面的写法。</p><pre><code class="javascript">Promise.all([
  import(&#39;./module1.js&#39;),
  import(&#39;./module2.js&#39;),
  import(&#39;./module3.js&#39;),
])
.then(([module1, module2, module3]) =&gt; &#123;
   ···
&#125;);
</code></pre><p><code>import()</code>也可以用在 async 函数之中。</p><pre><code class="javascript">async function main() &#123;
  const myModule = await import(&#39;./myModule.js&#39;);
  const &#123;export1, export2&#125; = await import(&#39;./myModule.js&#39;);
  const [module1, module2, module3] =
    await Promise.all([
      import(&#39;./module1.js&#39;),
      import(&#39;./module2.js&#39;),
      import(&#39;./module3.js&#39;),
    ]);
&#125;
main();
</code></pre><h3 id="24、-Module-的加载实现"><a href="#24、-Module-的加载实现" class="headerlink" title="24、 Module 的加载实现"></a>24、 Module 的加载实现</h3><hr><h4 id="1-浏览器加载"><a href="#1-浏览器加载" class="headerlink" title="1. 浏览器加载"></a>1. 浏览器加载</h4><p><strong>传统方法</strong></p><p>HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。</p><pre><code class="html">&lt;!-- 页面内嵌的脚本 --&gt;
&lt;script type=&quot;application/javascript&quot;&gt;
  // module code
&lt;/script&gt;

&lt;!-- 外部脚本 --&gt;
&lt;script type=&quot;application/javascript&quot; src=&quot;path/to/myModule.js&quot;&gt;
&lt;/script&gt;
</code></pre><p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略。</p><p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p><p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以<strong>浏览器允许脚本异步加载，下面就是两种异步加载的语法。</strong></p><pre><code class="html">&lt;script src=&quot;path/to/myModule.js&quot; defer&gt;&lt;/script&gt;
&lt;script src=&quot;path/to/myModule.js&quot; async&gt;&lt;/script&gt;
</code></pre><p>上面代码中，**<code>&lt;script&gt;</code>标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。**</p><p><strong><code>defer</code>与<code>async</code>的区别是：<code>defer</code>要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；<code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染</strong>。一句话，**<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”<strong>。另外，</strong>如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。**</p><hr><p><strong>加载规则</strong></p><p><strong>浏览器加载 ES6 模块，也使用<code>&lt;script&gt;</code>标签，但是要加入<code>type=&quot;module&quot;</code>属性。</strong></p><pre><code class="html">&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt;
</code></pre><p>上面代码在网页中插入一个模块<code>foo.js</code>，由于<code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个 ES6 模块。</p><p><strong>浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</strong></p><pre><code class="html">&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt;
&lt;!-- 等同于 --&gt;
&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; defer&gt;&lt;/script&gt;
</code></pre><p>如果网页有多个<code>&lt;script type=&quot;module&quot;&gt;</code>，它们会按照在页面出现的顺序依次执行。</p><p><strong>script 标签的async属性可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。</strong></p><pre><code class="html">&lt;script type=&quot;module&quot; src=&quot;./foo.js&quot; async&gt;&lt;/script&gt;
</code></pre><p>一旦使用了<code>async</code>属性，<code>&lt;script type=&quot;module&quot;&gt;</code>就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</p><p><strong>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</strong></p><pre><code class="html">&lt;script type=&quot;module&quot;&gt;
  import utils from &quot;./utils.js&quot;;

  // other code
&lt;/script&gt;
</code></pre><p>举例来说，jQuery 就支持模块加载。</p><pre><code class="html">&lt;script type=&quot;module&quot;&gt;
  import $ from &quot;./jquery/src/jquery.js&quot;;
  $(&#39;#message&#39;).text(&#39;Hi from jQuery!&#39;);
&lt;/script&gt;
</code></pre><p>对于外部的模块脚本（上例是<code>foo.js</code>），有几点需要注意。</p><ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li><li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li><li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li><li>同一个模块如果加载多次，将只执行一次。</li></ul><p>下面是一个示例模块。</p><pre><code class="javascript">import utils from &#39;https://example.com/js/utils.js&#39;;

const x = 1;

console.log(x === window.x); //false
console.log(this === undefined); // true
</code></pre><p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p><pre><code class="javascript">const isNotModuleScript = this !== undefined;
</code></pre><hr><h4 id="2-ES6-模块与-CommonJS-模块的差异"><a href="#2-ES6-模块与-CommonJS-模块的差异" class="headerlink" title="2. ES6 模块与 CommonJS 模块的差异"></a>2. ES6 模块与 CommonJS 模块的差异</h4><p>讨论 Node.js 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。</p><p>它们有三个重大差异。</p><ul><li><strong>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</strong></li><li><strong>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</strong></li><li><strong>CommonJS 模块的<code>require()</code>是同步加载模块，ES6 模块的<code>import</code>命令是异步加载，有一个独立的模块依赖的解析阶段。</strong></li></ul><p><strong>第二个差异是因为 CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</strong></p><p>下面重点解释第一个差异。</p><p><strong>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</strong>请看下面这个模块文件<code>lib.js</code>的例子。</p><pre><code class="javascript">// lib.js
var counter = 3;
function incCounter() &#123;
  counter++;
&#125;
module.exports = &#123;
  counter: counter,
  incCounter: incCounter,
&#125;;
</code></pre><p>上面代码输出内部变量<code>counter</code>和改写这个变量的内部方法<code>incCounter</code>。然后，在<code>main.js</code>里面加载这个模块。</p><pre><code class="javascript">// main.js
var mod = require(&#39;./lib&#39;);

console.log(mod.counter);  // 3
mod.incCounter();
console.log(mod.counter); // 3
</code></pre><p>上面代码说明，<code>lib.js</code>模块加载以后，它的内部变化就影响不到输出的<code>mod.counter</code>了。这是因为<code>mod.counter</code>是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p><pre><code class="javascript">// lib.js
var counter = 3;
function incCounter() &#123;
  counter++;
&#125;
module.exports = &#123;
  get counter() &#123;
    return counter
  &#125;,
  incCounter: incCounter,
&#125;;
</code></pre><p>上面代码中，输出的<code>counter</code>属性实际上是一个取值器函数。现在再执行<code>main.js</code>，就可以正确读取内部变量<code>counter</code>的变动了。</p><pre><code class="bash">$ node main.js
3
4
</code></pre><p>ES6 模块的运行机制与 CommonJS 不一样。<strong>JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</strong>换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p><p>还是举上面的例子。</p><pre><code class="javascript">// lib.js
export let counter = 3;
export function incCounter() &#123;
  counter++;
&#125;

// main.js
import &#123; counter, incCounter &#125; from &#39;./lib&#39;;
console.log(counter); // 3
incCounter();
console.log(counter); // 4
</code></pre><p>上面代码说明，ES6 模块输入的变量<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p><p>再举一个出现在<code>export</code>一节中的例子。</p><pre><code class="javascript">// m1.js
export var foo = &#39;bar&#39;;
setTimeout(() =&gt; foo = &#39;baz&#39;, 500);

// m2.js
import &#123;foo&#125; from &#39;./m1.js&#39;;
console.log(foo);
setTimeout(() =&gt; console.log(foo), 500);
</code></pre><p>上面代码中，<code>m1.js</code>的变量<code>foo</code>，在刚加载时等于<code>bar</code>，过了 500 毫秒，又变为等于<code>baz</code>。</p><p>让我们看看，<code>m2.js</code>能否正确读取这个变化。</p><pre><code class="bash">$ babel-node m2.js

bar
baz
</code></pre><p>上面代码表明，ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</p><p><strong>由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</strong></p><pre><code class="javascript">// lib.js
export let obj = &#123;&#125;;

// main.js
import &#123; obj &#125; from &#39;./lib&#39;;

obj.prop = 123; // OK
obj = &#123;&#125;; // TypeError
</code></pre><p>上面代码中，<code>main.js</code>从<code>lib.js</code>输入变量<code>obj</code>，可以对<code>obj</code>添加属性，但是重新赋值就会报错。因为变量<code>obj</code>指向的地址是只读的，不能重新赋值，这就好比<code>main.js</code>创造了一个名为<code>obj</code>的<code>const</code>变量。</p><p>最后，<code>export</code>通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</p><pre><code class="javascript">// mod.js
function C() &#123;
  this.sum = 0;
  this.add = function () &#123;
    this.sum += 1;
  &#125;;
  this.show = function () &#123;
    console.log(this.sum);
  &#125;;
&#125;

export let c = new C();
</code></pre><p>上面的脚本<code>mod.js</code>，输出的是一个<code>C</code>的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p><pre><code class="javascript">// x.js
import &#123;c&#125; from &#39;./mod&#39;;
c.add();

// y.js
import &#123;c&#125; from &#39;./mod&#39;;
c.show();

// main.js
import &#39;./x&#39;;
import &#39;./y&#39;;
</code></pre><p>现在执行<code>main.js</code>，输出的是<code>1</code>。</p><pre><code class="bash">$ babel-node main.js
1
</code></pre><p>这就证明了<code>x.js</code>和<code>y.js</code>加载的都是<code>C</code>的同一个实例。</p><hr><h4 id="3-Node-js-的模块加载方法"><a href="#3-Node-js-的模块加载方法" class="headerlink" title="3. Node.js 的模块加载方法"></a>3. Node.js 的模块加载方法</h4><p><strong>概述</strong></p><p>JavaScript 现在有两种模块。一种是 ES6 模块，简称 ESM；另一种是 CommonJS 模块，简称 CJS。</p><p>CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用<code>require()</code>和<code>module.exports</code>，ES6 模块使用<code>import</code>和<code>export</code>。</p><p>它们采用不同的加载方案。从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。</p><p>Node.js 要求 ES6 模块采用<code>.mjs</code>后缀文件名。也就是说，只要脚本文件里面使用<code>import</code>或者<code>export</code>命令，<strong>那么就必须采用<code>.mjs</code>后缀名</strong>。Node.js 遇到<code>.mjs</code>文件，就认为它是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定<code>&quot;use strict&quot;</code>。</p><p><strong>如果不希望将后缀名改成<code>.mjs</code>，可以在项目的<code>package.json</code>文件中，指定<code>type</code>字段为<code>module</code>。</strong></p><pre><code class="javascript">&#123;
   &quot;type&quot;: &quot;module&quot;
&#125;
</code></pre><p>一旦设置了以后，该项目的 JS 脚本，就被解释成 ES6 模块。</p><pre><code class="bash"># 解释成 ES6 模块
$ node my-app.js
</code></pre><p><strong>如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成<code>.cjs</code>。如果没有<code>type</code>字段，或者<code>type</code>字段为<code>commonjs</code>，则<code>.js</code>脚本会被解释成 CommonJS 模块。</strong></p><p>总结为一句话：**<code>.mjs</code>文件总是以 ES6 模块加载，<code>.cjs</code>文件总是以 CommonJS 模块加载，<code>.js</code>文件的加载取决于<code>package.json</code>里面<code>type</code>字段的设置。**</p><p>注意，ES6 模块与 CommonJS 模块尽量不要混用。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错，只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code>。</p><hr><p><strong>package.json 的 main 字段</strong></p><p><code>package.json</code>文件有两个字段可以指定模块的入口文件：<code>main</code>和<code>exports</code>。比较简单的模块，<strong>可以只使用<code>main</code>字段，指定模块加载的入口文件。</strong></p><pre><code class="javascript">// ./node_modules/es-module-package/package.json
&#123;
  &quot;type&quot;: &quot;module&quot;,
  &quot;main&quot;: &quot;./src/index.js&quot;
&#125;
</code></pre><p>上面代码指定项目的入口脚本为<code>./src/index.js</code>，它的格式为 ES6 模块。如果没有<code>type</code>字段，<code>index.js</code>就会被解释为 CommonJS 模块。</p><p>然后，<code>import</code>命令就可以加载这个模块。</p><pre><code class="javascript">// ./my-app.mjs

import &#123; something &#125; from &#39;es-module-package&#39;;
// 实际加载的是 ./node_modules/es-module-package/src/index.js
</code></pre><p>上面代码中，运行该脚本以后，Node.js 就会到<code>./node_modules</code>目录下面，寻找<code>es-module-package</code>模块，然后根据该模块<code>package.json</code>的<code>main</code>字段去执行入口文件。</p><p>这时，如果用 CommonJS 模块的<code>require()</code>命令去加载<code>es-module-package</code>模块会报错，因为 CommonJS 模块不能处理<code>export</code>命令。</p><hr><p><strong>package.json 的 exports 字段</strong></p><p><strong><code>exports</code>字段的优先级高于<code>main</code>字段。它有多种用法。</strong></p><p><strong>（1）子目录别名</strong></p><p><strong><code>package.json</code>文件的<code>exports</code>字段可以指定脚本或子目录的别名。</strong></p><pre><code class="javascript">// ./node_modules/es-module-package/package.json
&#123;
  &quot;exports&quot;: &#123;
    &quot;./submodule&quot;: &quot;./src/submodule.js&quot;
  &#125;
&#125;
</code></pre><p>上面的代码指定<code>src/submodule.js</code>别名为<code>submodule</code>，然后就可以从别名加载这个文件。</p><pre><code class="javascript">import submodule from &#39;es-module-package/submodule&#39;;
// 加载 ./node_modules/es-module-package/src/submodule.js
</code></pre><p>下面是子目录别名的例子。</p><pre><code class="javascript">// ./node_modules/es-module-package/package.json
&#123;
  &quot;exports&quot;: &#123;
    &quot;./features/&quot;: &quot;./src/features/&quot;
  &#125;
&#125;

import feature from &#39;es-module-package/features/x.js&#39;;
// 加载 ./node_modules/es-module-package/src/features/x.js
</code></pre><p>如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。</p><pre><code class="javascript">// 报错
import submodule from &#39;es-module-package/private-module.js&#39;;

// 不报错
import submodule from &#39;./node_modules/es-module-package/private-module.js&#39;;
</code></pre><p><strong>（2）main 的别名</strong></p><p><strong><code>exports</code>字段的别名如果是<code>.</code>，就代表模块的主入口，优先级高于<code>main</code>字段，并且可以直接简写成<code>exports</code>字段的值。</strong></p><pre><code class="javascript">&#123;
  &quot;exports&quot;: &#123;
    &quot;.&quot;: &quot;./main.js&quot;
  &#125;
&#125;

// 等同于
&#123;
  &quot;exports&quot;: &quot;./main.js&quot;
&#125;
</code></pre><p>由于<code>exports</code>字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。</p><pre><code class="javascript">&#123;
  &quot;main&quot;: &quot;./main-legacy.cjs&quot;,
  &quot;exports&quot;: &#123;
    &quot;.&quot;: &quot;./main-modern.cjs&quot;
  &#125;
&#125;
</code></pre><p>上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是<code>main-legacy.cjs</code>，新版本的 Node.js 的入口文件是<code>main-modern.cjs</code>。</p><p><strong>（3）条件加载</strong></p><p>利用<code>.</code>这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 Node.js 运行的时候，打开<code>--experimental-conditional-exports</code>标志。</p><pre><code class="javascript">&#123;
  &quot;type&quot;: &quot;module&quot;,
  &quot;exports&quot;: &#123;
    &quot;.&quot;: &#123;
      &quot;require&quot;: &quot;./main.cjs&quot;,
      &quot;default&quot;: &quot;./main.js&quot;
    &#125;
  &#125;
&#125;
</code></pre><p>上面代码中，别名<code>.</code>的<code>require</code>条件指定<code>require()</code>命令的入口文件（即 CommonJS 的入口），<code>default</code>条件指定其他情况的入口（即 ES6 的入口）。</p><p>上面的写法可以简写如下。</p><pre><code class="javascript">&#123;
  &quot;exports&quot;: &#123;
    &quot;require&quot;: &quot;./main.cjs&quot;,
    &quot;default&quot;: &quot;./main.js&quot;
  &#125;
&#125;
</code></pre><p>注意，如果同时还有其他别名，就不能采用简写，否则会报错。</p><pre><code class="javascript">&#123;
  // 报错
  &quot;exports&quot;: &#123;
    &quot;./feature&quot;: &quot;./lib/feature.js&quot;,
    &quot;require&quot;: &quot;./main.cjs&quot;,
    &quot;default&quot;: &quot;./main.js&quot;
  &#125;
&#125;
</code></pre><hr><p><strong>CommonJS 模块加载 ES6 模块</strong></p><p><strong>CommonJS 的<code>require()</code>命令不能加载 ES6 模块，会报错，只能使用<code>import()</code>这个方法加载。</strong></p><pre><code class="javascript">(async () =&gt; &#123;
  await import(&#39;./my-app.mjs&#39;);
&#125;)();
</code></pre><p>上面代码可以在 CommonJS 模块中运行。</p><p><code>require()</code>不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层<code>await</code>命令，导致无法被同步加载。</p><hr><p><strong>ES6 模块加载 CommonJS 模块</strong></p><p><strong>ES6 模块的<code>import</code>命令可以加载 CommonJS 模块，但是只能整体加载，不能只加载单一的输出项。</strong></p><pre><code class="javascript">// 正确
import packageMain from &#39;commonjs-package&#39;;

// 报错
import &#123; method &#125; from &#39;commonjs-package&#39;;
</code></pre><p>这是因为 ES6 模块需要支持静态代码分析，而 CommonJS 模块的输出接口是<code>module.exports</code>，是一个对象，无法被静态分析，所以只能整体加载。</p><p><strong>加载单一的输出项，可以写成下面这样。</strong></p><pre><code class="javascript">import packageMain from &#39;commonjs-package&#39;;
const &#123; method &#125; = packageMain;
</code></pre><p>还有一种变通的加载方法，就是使用 Node.js 内置的<code>module.createRequire()</code>方法。</p><pre><code class="javascript">// cjs.cjs
module.exports = &#39;cjs&#39;;

// esm.mjs
import &#123; createRequire &#125; from &#39;module&#39;;

const require = createRequire(import.meta.url);

const cjs = require(&#39;./cjs.cjs&#39;);
cjs === &#39;cjs&#39;; // true
</code></pre><p>上面代码中，ES6 模块通过<code>module.createRequire()</code>方法可以加载 CommonJS 模块。但是，这种写法等于将 ES6 和 CommonJS 混在一起了，所以不建议使用。</p><hr><p><strong>同时支持两种格式的模块</strong></p><p>一个模块同时要支持 CommonJS 和 ES6 两种格式，也很容易。</p><p>如果原始模块是 ES6 格式，那么需要给出一个整体输出接口，比如<code>export default obj</code>，使得 CommonJS 可以用<code>import()</code>进行加载。</p><p>如果原始模块是 CommonJS 格式，那么可以加一个包装层。</p><pre><code class="javascript">import cjsModule from &#39;../index.js&#39;;
export const foo = cjsModule.foo;
</code></pre><p>上面代码先整体输入 CommonJS 模块，然后再根据需要输出具名接口。</p><p>你可以把这个文件的后缀名改为<code>.mjs</code>，或者将它放在一个子目录，再在这个子目录里面放一个单独的<code>package.json</code>文件，指明<code>&#123; type: &quot;module&quot; &#125;</code>。</p><p>另一种做法是在<code>package.json</code>文件的<code>exports</code>字段，指明两种格式模块各自的加载入口。</p><pre><code class="javascript">&quot;exports&quot;：&#123;
  &quot;require&quot;: &quot;./index.js&quot;，
  &quot;import&quot;: &quot;./esm/wrapper.js&quot;
&#125;
</code></pre><p>上面代码指定<code>require()</code>和<code>import</code>，加载该模块会自动切换到不一样的入口文件。</p><hr><p><strong>Node.js 的内置模块</strong></p><p>Node.js 的内置模块可以整体加载，也可以加载指定的输出项。</p><pre><code class="javascript">// 整体加载
import EventEmitter from &#39;events&#39;;
const e = new EventEmitter();

// 加载指定的输出项
import &#123; readFile &#125; from &#39;fs&#39;;
readFile(&#39;./foo.txt&#39;, (err, source) =&gt; &#123;
  if (err) &#123;
    console.error(err);
  &#125; else &#123;
    console.log(source);
  &#125;
&#125;);
</code></pre><hr><p><strong>加载路径</strong></p><p>ES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。<code>import</code>命令和<code>package.json</code>文件的<code>main</code>字段如果省略脚本的后缀名，会报错。</p><pre><code class="javascript">// ES6 模块中将报错
import &#123; something &#125; from &#39;./index&#39;;
</code></pre><p>为了与浏览器的<code>import</code>加载规则相同，Node.js 的<code>.mjs</code>文件支持 URL 路径。</p><pre><code class="javascript">import &#39;./foo.mjs?query=1&#39;; // 加载 ./foo 传入参数 ?query=1
</code></pre><p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有<code>:</code>、<code>%</code>、<code>#</code>、<code>?</code>等特殊字符，最好对这些字符进行转义。</p><p>目前，Node.js 的<code>import</code>命令只支持加载本地模块（<code>file:</code>协议）和<code>data:</code>协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以<code>/</code>或<code>//</code>开头的路径）。</p><hr><p><strong>内部变量</strong></p><p>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node.js 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。</p><p><strong>首先，就是<code>this</code>关键字。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS 模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。</strong></p><p>其次，以下这些顶层变量在 ES6 模块之中都是不存在的。</p><ul><li><code>arguments</code></li><li><code>require</code></li><li><code>module</code></li><li><code>exports</code></li><li><code>__filename</code></li><li><code>__dirname</code></li></ul><hr><h4 id="4-循环加载"><a href="#4-循环加载" class="headerlink" title="4. 循环加载"></a>4. 循环加载</h4><p><strong>“循环加载”（circular dependency）指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本。</strong></p><pre><code class="javascript">// a.js
var b = require(&#39;b&#39;);

// b.js
var a = require(&#39;a&#39;);
</code></pre><p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</p><p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，<strong>很容易出现<code>a</code>依赖<code>b</code>，<code>b</code>依赖<code>c</code>，<code>c</code>又依赖<code>a</code>这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</strong></p><p><strong>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</strong></p><hr><p><strong>CommonJS 模块的加载原理</strong></p><p>介绍 ES6 如何处理“循环加载”之前，先介绍目前最流行的 CommonJS 模块格式的加载原理。</p><p><strong>CommonJS 的一个模块，就是一个脚本文件。<code>require</code>命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</strong></p><pre><code class="javascript">&#123;
  id: &#39;...&#39;,
  exports: &#123; ... &#125;,
  loaded: true,
  ...
&#125;
</code></pre><p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的<code>id</code>属性是模块名，<code>exports</code>属性是模块输出的各个接口，<code>loaded</code>属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。</p><p><strong>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。即使再次执行<code>require</code>命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</strong></p><hr><p><strong>CommonJS 模块的循环加载</strong></p><p><strong>CommonJS 模块的重要特性是加载时执行，即脚本代码在<code>require</code>的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</strong></p><p>让我们来看，Node <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2FwaS9tb2R1bGVzLmh0bWwjbW9kdWxlc19jeWNsZXM=">官方文档</span>里面的例子。脚本文件<code>a.js</code>代码如下。</p><pre><code class="javascript">exports.done = false;
var b = require(&#39;./b.js&#39;);
console.log(&#39;在 a.js 之中，b.done = %j&#39;, b.done);
exports.done = true;
console.log(&#39;a.js 执行完毕&#39;);
</code></pre><p>上面代码之中，<code>a.js</code>脚本先输出一个<code>done</code>变量，然后加载另一个脚本文件<code>b.js</code>。注意，此时<code>a.js</code>代码就停在这里，等待<code>b.js</code>执行完毕，再往下执行。</p><p>再看<code>b.js</code>的代码。</p><pre><code class="javascript">exports.done = false;
var a = require(&#39;./a.js&#39;);
console.log(&#39;在 b.js 之中，a.done = %j&#39;, a.done);
exports.done = true;
console.log(&#39;b.js 执行完毕&#39;);
</code></pre><p>上面代码之中，<code>b.js</code>执行到第二行，就会去加载<code>a.js</code>，这时，就发生了“循环加载”。系统会去<code>a.js</code>模块对应对象的<code>exports</code>属性取值，可是因为<code>a.js</code>还没有执行完，从<code>exports</code>属性只能取回已经执行的部分，而不是最后的值。</p><p><code>a.js</code>已经执行的部分，只有一行。</p><pre><code class="javascript">exports.done = false;
</code></pre><p>因此，对于<code>b.js</code>来说，它从<code>a.js</code>只输入一个变量<code>done</code>，值为<code>false</code>。</p><p>然后，<code>b.js</code>接着往下执行，等到全部执行完毕，再把执行权交还给<code>a.js</code>。于是，<code>a.js</code>接着往下执行，直到执行完毕。我们写一个脚本<code>main.js</code>，验证这个过程。</p><pre><code class="javascript">var a = require(&#39;./a.js&#39;);
var b = require(&#39;./b.js&#39;);
console.log(&#39;在 main.js 之中, a.done=%j, b.done=%j&#39;, a.done, b.done);
</code></pre><p>执行<code>main.js</code>，运行结果如下。</p><pre><code class="bash">$ node main.js

在 b.js 之中，a.done = false
b.js 执行完毕
在 a.js 之中，b.done = true
a.js 执行完毕
在 main.js 之中, a.done=true, b.done=true
</code></pre><p>上面的代码证明了两件事。一是，在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。二是，<code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，而是输出缓存的<code>b.js</code>的执行结果，即它的第四行。</p><pre><code class="javascript">exports.done = true;
</code></pre><p><strong>总之，CommonJS 输入的是被输出值的拷贝，不是引用。</strong></p><p><strong>另外，由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值</strong>，两者可能会有差异。所以，输入变量的时候，必须非常小心。</p><pre><code class="javascript">var a = require(&#39;a&#39;); // 安全的写法
var foo = require(&#39;a&#39;).foo; // 危险的写法

exports.good = function (arg) &#123;
  return a.foo(&#39;good&#39;, arg); // 使用的是 a.foo 的最新值
&#125;;

exports.bad = function (arg) &#123;
  return foo(&#39;bad&#39;, arg); // 使用的是一个部分加载时的值
&#125;;
</code></pre><p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code>的值很可能后面会被改写，改用<code>require(&#39;a&#39;)</code>会更保险一点。</p><hr><p><strong>ES6 模块的循环加载</strong></p><p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，<strong>如果使用<code>import</code>从一个模块加载变量（即<code>import foo from &#39;foo&#39;</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</strong></p><p>请看下面这个例子。</p><pre><code class="javascript">// a.mjs
import &#123;bar&#125; from &#39;./b&#39;;
console.log(&#39;a.mjs&#39;);
console.log(bar);
export let foo = &#39;foo&#39;;

// b.mjs
import &#123;foo&#125; from &#39;./a&#39;;
console.log(&#39;b.mjs&#39;);
console.log(foo);
export let bar = &#39;bar&#39;;
</code></pre><p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p><pre><code class="bash">$ node --experimental-modules a.mjs
b.mjs
ReferenceError: foo is not defined
</code></pre><p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？</p><p>让我们一行行来看，ES6 循环加载是怎么处理的。<strong>首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。</strong></p><p><strong>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，<code>foo</code>已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</strong></p><pre><code class="javascript">// a.mjs
import &#123;bar&#125; from &#39;./b&#39;;
console.log(&#39;a.mjs&#39;);
console.log(bar());
function foo() &#123; return &#39;foo&#39; &#125;
export &#123;foo&#125;;

// b.mjs
import &#123;foo&#125; from &#39;./a&#39;;
console.log(&#39;b.mjs&#39;);
console.log(foo());
function bar() &#123; return &#39;bar&#39; &#125;
export &#123;bar&#125;;
</code></pre><p>这时再执行<code>a.mjs</code>就可以得到预期结果。</p><pre><code class="bash">$ node --experimental-modules a.mjs
b.mjs
foo
a.mjs
bar
</code></pre><p><strong>这是因为函数具有提升作用，在执行<code>import &#123;bar&#125; from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。这也意味着，如果把函数<code>foo</code>改写成函数表达式，也会报错。</strong></p><pre><code class="javascript">// a.mjs
import &#123;bar&#125; from &#39;./b&#39;;
console.log(&#39;a.mjs&#39;);
console.log(bar());
const foo = () =&gt; &#39;foo&#39;;
export &#123;foo&#125;;
</code></pre><p>上面代码的第四行，改成了函数表达式，就不具有提升作用，执行就会报错。</p><p>我们再来看 ES6 模块加载器<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vZHVsZUxvYWRlci9lczYtbW9kdWxlLWxvYWRlci9ibG9iL21hc3Rlci9kb2NzL2NpcmN1bGFyLXJlZmVyZW5jZXMtYmluZGluZ3MubWQ=">SystemJS</span>给出的一个例子。</p><pre><code class="javascript">// even.js
import &#123; odd &#125; from &#39;./odd&#39;
export var counter = 0;
export function even(n) &#123;
  counter++;
  return n === 0 || odd(n - 1);
&#125;

// odd.js
import &#123; even &#125; from &#39;./even&#39;;
export function odd(n) &#123;
  return n !== 0 &amp;&amp; even(n - 1);
&#125;
</code></pre><p>上面代码中，<code>even.js</code>里面的函数<code>even</code>有一个参数<code>n</code>，只要不等于 0，就会减去 1，传入加载的<code>odd()</code>。<code>odd.js</code>也会做类似操作。</p><p>运行上面这段代码，结果如下。</p><pre><code class="javascript">$ babel-node
&gt; import * as m from &#39;./even.js&#39;;
&gt; m.even(10);
true
&gt; m.counter
6
&gt; m.even(20)
true
&gt; m.counter
17
</code></pre><p>上面代码中，参数<code>n</code>从 10 变为 0 的过程中，<code>even()</code>一共会执行 6 次，所以变量<code>counter</code>等于 6。第二次调用<code>even()</code>时，参数<code>n</code>从 20 变为 0，<code>even()</code>一共会执行 11 次，加上前面的 6 次，所以变量<code>counter</code>等于 17。</p><p>这个例子要是改写成 CommonJS，就根本无法执行，会报错。</p><pre><code class="javascript">// even.js
var odd = require(&#39;./odd&#39;);
var counter = 0;
exports.counter = counter;
exports.even = function (n) &#123;
  counter++;
  return n == 0 || odd(n - 1);
&#125;

// odd.js
var even = require(&#39;./even&#39;).even;
module.exports = function (n) &#123;
  return n != 0 &amp;&amp; even(n - 1);
&#125;
</code></pre><p>上面代码中，<code>even.js</code>加载<code>odd.js</code>，而<code>odd.js</code>又去加载<code>even.js</code>，形成“循环加载”。这时，执行引擎就会输出<code>even.js</code>已经执行的部分（不存在任何结果），所以在<code>odd.js</code>之中，变量<code>even</code>等于<code>undefined</code>，等到后面调用<code>even(n - 1)</code>就会报错。</p><pre><code class="bash">$ node
&gt; var m = require(&#39;./even&#39;);
&gt; m.even(10)
TypeError: even is not a function
</code></pre><h3 id="25、-编程风格"><a href="#25、-编程风格" class="headerlink" title="25、 编程风格"></a>25、 编程风格</h3><hr><h4 id="1-块级作用域"><a href="#1-块级作用域" class="headerlink" title="1. 块级作用域"></a>1. 块级作用域</h4><p><strong>（1）let 取代 var</strong></p><p>ES6 提出了两个新的声明变量的命令：<code>let</code>和<code>const</code>。其中，**<code>let</code>完全可以取代<code>var</code>，因为两者语义相同，而且<code>let</code>没有副作用。**</p><pre><code class="javascript">&#39;use strict&#39;;

if (true) &#123;
  let x = &#39;hello&#39;;
&#125;

for (let i = 0; i &lt; 10; i++) &#123;
  console.log(i);
&#125;
</code></pre><p>上面代码如果用<code>var</code>替代<code>let</code>，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，<code>var</code>命令做不到这一点。</p><p><code>var</code>命令存在变量提升效用，<code>let</code>命令没有这个问题。</p><pre><code class="javascript">&#39;use strict&#39;;

if (true) &#123;
  console.log(x); // ReferenceError
  let x = &#39;hello&#39;;
&#125;
</code></pre><p>上面代码如果使用<code>var</code>替代<code>let</code>，<code>console.log</code>那一行就不会报错，而是会输出<code>undefined</code>，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。</p><p>所以，建议不再使用<code>var</code>命令，而是使用<code>let</code>命令取代。</p><p><strong>（2）全局常量和线程安全</strong></p><p><strong>在<code>let</code>和<code>const</code>之间，建议优先使用<code>const</code>，尤其是在全局环境，不应该设置变量，只应设置常量。</strong></p><p><code>const</code>优于<code>let</code>有几个原因。一个是<code>const</code>可以提醒阅读程序的人，这个变量不应该改变；另一个是<code>const</code>比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；<strong>最后一个原因是 JavaScript 编译器会对<code>const</code>进行优化，所以多使用<code>const</code>，有利于提高程序的运行效率，也就是说<code>let</code>和<code>const</code>的本质区别，其实是编译器内部的处理不同。</strong></p><pre><code class="javascript">// bad
var a = 1, b = 2, c = 3;

// good
const a = 1;
const b = 2;
const c = 3;

// best
const [a, b, c] = [1, 2, 3];
</code></pre><p><strong><code>const</code>声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。</strong></p><p><strong>所有的函数都应该设置为常量。</strong></p><p>长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时<code>let</code>表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。</p><hr><h4 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. 字符串</h4><p><strong>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</strong></p><pre><code class="javascript">// bad
const a = &quot;foobar&quot;;
const b = &#39;foo&#39; + a + &#39;bar&#39;;

// acceptable
const c = `foobar`;

// good
const a = &#39;foobar&#39;;
const b = `foo$&#123;a&#125;bar`;
</code></pre><hr><h4 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="3. 解构赋值"></a>3. 解构赋值</h4><p><strong>使用数组成员对变量赋值时，优先使用解构赋值。</strong></p><pre><code class="javascript">const arr = [1, 2, 3, 4];

// bad
const first = arr[0];
const second = arr[1];

// good
const [first, second] = arr;
</code></pre><p><strong>函数的参数如果是对象的成员，优先使用解构赋值。</strong></p><pre><code class="javascript">// bad
function getFullName(user) &#123;
  const firstName = user.firstName;
  const lastName = user.lastName;
&#125;

// good
function getFullName(obj) &#123;
  const &#123; firstName, lastName &#125; = obj;
&#125;

// best
function getFullName(&#123; firstName, lastName &#125;) &#123;
&#125;
</code></pre><p><strong>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</strong>因为解构赋值时数组按顺序，对象不用</p><pre><code class="javascript">// bad
function processInput(input) &#123;
  return [left, right, top, bottom];
&#125;

// good
function processInput(input) &#123;
  return &#123; left, right, top, bottom &#125;;
&#125;

const &#123; left, right &#125; = processInput(input);
</code></pre><hr><h4 id="4-对象"><a href="#4-对象" class="headerlink" title="4. 对象"></a>4. 对象</h4><p><strong>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</strong></p><pre><code class="javascript">// bad
const a = &#123; k1: v1, k2: v2, &#125;;
const b = &#123;
  k1: v1,
  k2: v2
&#125;;

// good
const a = &#123; k1: v1, k2: v2 &#125;;
const b = &#123;
  k1: v1,
  k2: v2,
&#125;;
</code></pre><p><strong>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign</code>方法。</strong></p><pre><code class="javascript">// bad
const a = &#123;&#125;;
a.x = 3;

// if reshape unavoidable
const a = &#123;&#125;;
Object.assign(a, &#123; x: 3 &#125;);

// good
const a = &#123; x: null &#125;;
a.x = 3;
</code></pre><p><strong>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。</strong></p><pre><code class="javascript">// bad
const obj = &#123;
  id: 5,
  name: &#39;San Francisco&#39;,
&#125;;
obj[getKey(&#39;enabled&#39;)] = true;

// good
const obj = &#123;
  id: 5,
  name: &#39;San Francisco&#39;,
  [getKey(&#39;enabled&#39;)]: true,
&#125;;
</code></pre><p>上面代码中，对象<code>obj</code>的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建<code>obj</code>的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。</p><p><strong>另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。</strong></p><pre><code class="javascript">var ref = &#39;some value&#39;;

// bad
const atom = &#123;
  ref: ref,

  value: 1,

  addValue: function (value) &#123;
    return atom.value + value;
  &#125;,
&#125;;

// good
const atom = &#123;
  ref,

  value: 1,

  addValue(value) &#123;
    return atom.value + value;
  &#125;,
&#125;;
</code></pre><hr><h4 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h4><p><strong>使用扩展运算符（…）拷贝数组。</strong></p><pre><code class="javascript">// bad
const len = items.length;
const itemsCopy = [];
let i;

for (i = 0; i &lt; len; i++) &#123;
  itemsCopy[i] = items[i];
&#125;

// good
const itemsCopy = [...items];
</code></pre><p><strong>使用 Array.from 方法，将类似数组的对象转为数组。</strong></p><pre><code class="javascript">const foo = document.querySelectorAll(&#39;.foo&#39;);
const nodes = Array.from(foo);
</code></pre><hr><h4 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h4><p>立即执行函数可以<strong>写成</strong>箭头函数的形式。</p><pre><code class="javascript">(() =&gt; &#123;
  console.log(&#39;Welcome to the Internet.&#39;);
&#125;)();
</code></pre><p><strong>那些使用匿名函数当作参数的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。</strong></p><pre><code class="javascript">// bad
[1, 2, 3].map(function (x) &#123;
  return x * x;
&#125;);

// good
[1, 2, 3].map((x) =&gt; &#123;
  return x * x;
&#125;);

// best
[1, 2, 3].map(x =&gt; x * x);
</code></pre><p><strong>箭头函数取代<code>Function.prototype.bind</code>，不应再用 self/_this/that 绑定 this。</strong></p><pre><code class="javascript">// bad
const self = this;
const boundMethod = function(...params) &#123;
  return method.apply(self, params);
&#125;

// acceptable
const boundMethod = method.bind(this);

// best
const boundMethod = (...params) =&gt; method.apply(this, params);
</code></pre><p><strong>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。</strong></p><p><strong>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。</strong></p><pre><code class="javascript">// bad
function divide(a, b, option = false ) &#123;
&#125;

// good
function divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;
&#125;
</code></pre><p><strong>不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。</strong></p><pre><code class="javascript">// bad
function concatenateAll() &#123;
  const args = Array.prototype.slice.call(arguments);
  return args.join(&#39;&#39;);
&#125;

// good
function concatenateAll(...args) &#123;
  return args.join(&#39;&#39;);
&#125;
</code></pre><p><strong>使用默认值语法设置函数参数的默认值。</strong></p><pre><code class="javascript">// bad
function handleThings(opts) &#123;
  opts = opts || &#123;&#125;;
&#125;

// good
function handleThings(opts = &#123;&#125;) &#123;
  // ...
&#125;
</code></pre><hr><h4 id="7-Map-结构"><a href="#7-Map-结构" class="headerlink" title="7. Map 结构"></a>7. Map 结构</h4><p><strong>注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要<code>key: value</code>的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制</strong>。需要for of循环就用Map。</p><pre><code class="javascript">let map = new Map(arr);

for (let key of map.keys()) &#123;
  console.log(key);
&#125;

for (let value of map.values()) &#123;
  console.log(value);
&#125;

for (let item of map.entries()) &#123;
  console.log(item[0], item[1]);
&#125;
</code></pre><hr><h4 id="8-Class"><a href="#8-Class" class="headerlink" title="8. Class"></a>8. Class</h4><p><strong>总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。</strong></p><pre><code class="javascript">// bad
function Queue(contents = []) &#123;
  this._queue = [...contents];
&#125;
Queue.prototype.pop = function() &#123;
  const value = this._queue[0];
  this._queue.splice(0, 1);
  return value;
&#125;

// good
class Queue &#123;
  constructor(contents = []) &#123;
    this._queue = [...contents];
  &#125;
  pop() &#123;
    const value = this._queue[0];
    this._queue.splice(0, 1);
    return value;
  &#125;
&#125;
</code></pre><p><strong>使用<code>extends</code>实现继承，因为这样更简单，不会有破坏<code>instanceof</code>运算的危险。</strong></p><pre><code class="javascript">// bad
const inherits = require(&#39;inherits&#39;);
function PeekableQueue(contents) &#123;
  Queue.apply(this, contents);
&#125;
inherits(PeekableQueue, Queue);
PeekableQueue.prototype.peek = function() &#123;
  return this._queue[0];
&#125;

// good
class PeekableQueue extends Queue &#123;
  peek() &#123;
    return this._queue[0];
  &#125;
&#125;
</code></pre><hr><h4 id="9-模块"><a href="#9-模块" class="headerlink" title="9. 模块"></a>9. 模块</h4><p>ES6 模块语法是 JavaScript 模块的标准写法，坚持使用这种写法，取代 Node.js 的 CommonJS 语法。</p><p><strong>首先，使用<code>import</code>取代<code>require()</code>。</strong></p><pre><code class="javascript">// CommonJS 的写法
const moduleA = require(&#39;moduleA&#39;);
const func1 = moduleA.func1;
const func2 = moduleA.func2;

// ES6 的写法
import &#123; func1, func2 &#125; from &#39;moduleA&#39;;
</code></pre><p><strong>其次，使用<code>export</code>取代<code>module.exports</code>。</strong></p><pre><code class="javascript">// commonJS 的写法
var React = require(&#39;react&#39;);

var Breadcrumbs = React.createClass(&#123;
  render() &#123;
    return &lt;nav /&gt;;
  &#125;
&#125;);

module.exports = Breadcrumbs;

// ES6 的写法
import React from &#39;react&#39;;

class Breadcrumbs extends React.Component &#123;
  render() &#123;
    return &lt;nav /&gt;;
  &#125;
&#125;;

export default Breadcrumbs;
</code></pre><p><strong>如果模块只有一个输出值，就使用<code>export default</code>，如果模块有多个输出值，除非其中某个输出值特别重要，否则建议不要使用<code>export default</code>，即多个输出值如果是平等关系，<code>export default</code>与普通的<code>export</code>就不要同时使用。</strong></p><p><strong>如果模块默认输出一个函数，函数名的首字母应该小写，表示这是一个工具方法。</strong></p><pre><code class="javascript">function makeStyleGuide() &#123;
&#125;

export default makeStyleGuide;
</code></pre><p><strong>如果模块默认输出一个对象，对象名的首字母应该大写，表示这是一个配置值对象。</strong></p><pre><code class="javascript">const StyleGuide = &#123;
  es6: &#123;
  &#125;
&#125;;

export default StyleGuide;
</code></pre><hr><h4 id="10-ESLint-的使用"><a href="#10-ESLint-的使用" class="headerlink" title="10. ESLint 的使用"></a>10. ESLint 的使用</h4><p>ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。</p><p>首先，在项目的根目录安装 ESLint。</p><pre><code class="bash">$ npm install --save-dev eslint
</code></pre><p>然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。</p><pre><code class="bash">$ npm install --save-dev eslint-config-airbnb
$ npm install --save-dev eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react
</code></pre><p>最后，在项目的根目录下新建一个<code>.eslintrc</code>文件，配置 ESLint。</p><pre><code class="javascript">&#123;
  &quot;extends&quot;: &quot;eslint-config-airbnb&quot;
&#125;
</code></pre><p>现在就可以检查，当前项目的代码是否符合预设的规则。</p><p><code>index.js</code>文件的代码如下。</p><pre><code class="javascript">var unused = &#39;I have no purpose!&#39;;

function greet() &#123;
    var message = &#39;Hello, World!&#39;;
    console.log(message);
&#125;

greet();
</code></pre><p>使用 ESLint 检查这个文件，就会报出错误。</p><pre><code class="bash">$ npx eslint index.js
index.js
  1:1  error  Unexpected var, use let or const instead          no-var
  1:5  error  unused is defined but never used                 no-unused-vars
  4:5  error  Expected indentation of 2 characters but found 4  indent
  4:5  error  Unexpected var, use let or const instead          no-var
  5:5  error  Expected indentation of 2 characters but found 4  indent

✖ 5 problems (5 errors, 0 warnings)
</code></pre><p>上面代码说明，原文件有五个错误，其中两个是不应该使用<code>var</code>命令，而要使用<code>let</code>或<code>const</code>；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。</p><h3 id="26、-异步遍历器"><a href="#26、-异步遍历器" class="headerlink" title="26、 异步遍历器"></a>26、 异步遍历器</h3><hr><h4 id="1-同步遍历器的问题"><a href="#1-同步遍历器的问题" class="headerlink" title="1. 同步遍历器的问题"></a>1. 同步遍历器的问题</h4><p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>&#123;value, done&#125;</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p><pre><code class="javascript">function idMaker() &#123;
  let index = 0;

  return &#123;
    next: function() &#123;
      return &#123; value: index++, done: false &#125;;
    &#125;
  &#125;;
&#125;

const it = idMaker();

it.next().value // 0
it.next().value // 1
it.next().value // 2
// ...
</code></pre><p>上面代码中，变量<code>it</code>是一个遍历器（iterator）。每次调用<code>it.next()</code>方法，就返回一个对象，表示当前遍历位置的信息。</p><p>这里隐含着一个规定，<code>it.next()</code>方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行<code>it.next()</code>方法，就必须同步地得到<code>value</code>和<code>done</code>这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。</p><pre><code class="javascript">function idMaker() &#123;
  let index = 0;

  return &#123;
    next: function() &#123;
      return new Promise(function (resolve, reject) &#123;
        setTimeout(() =&gt; &#123;
          resolve(&#123; value: index++, done: false &#125;);
        &#125;, 1000);
      &#125;);
    &#125;
  &#125;;
&#125;
</code></pre><p>上面代码中，<code>next()</code>方法返回的是一个 Promise 对象，这样就不行，不符合 Iterator 协议，只要代码里面包含异步操作都不行。也就是说，Iterator 协议里面<code>next()</code>方法只能包含同步操作。</p><p>目前的解决方法是，将异步操作包装成 Thunk 函数或者 Promise 对象，即<code>next()</code>方法返回值的<code>value</code>属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而<code>done</code>属性则还是同步产生的。</p><pre><code class="javascript">function idMaker() &#123;
  let index = 0;

  return &#123;
    next: function() &#123;
      return &#123;
        value: new Promise(resolve =&gt; setTimeout(() =&gt; resolve(index++), 1000)),
        done: false
      &#125;;
    &#125;
  &#125;;
&#125;

const it = idMaker();

it.next().value.then(o =&gt; console.log(o)) // 0
it.next().value.then(o =&gt; console.log(o)) // 1
it.next().value.then(o =&gt; console.log(o)) // 2
// ...
</code></pre><p>上面代码中，<code>value</code>属性的返回值是一个 Promise 对象，用来放置异步操作。但是这样写很麻烦，不太符合直觉，语义也比较绕。</p><p><strong>ES2018 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXN5bmMtaXRlcmF0aW9u">引入</span>了“异步遍历器”（Async Iterator），为异步操作提供原生的遍历器接口，即<code>value</code>和<code>done</code>这两个属性都是异步产生。</strong></p><hr><h4 id="2-异步遍历的接口"><a href="#2-异步遍历的接口" class="headerlink" title="2. 异步遍历的接口"></a>2. 异步遍历的接口</h4><p><strong>异步遍历器的最大的语法特点，就是调用遍历器的<code>next</code>方法，返回的是一个 Promise 对象。</strong></p><pre><code class="javascript">asyncIterator
  .next()
  .then(
    (&#123; value, done &#125;) =&gt; /* ... */
  );
</code></pre><p>上面代码中，<code>asyncIterator</code>是一个异步遍历器，调用<code>next</code>方法以后，返回一个 Promise 对象。因此，可以使用<code>then</code>方法指定，这个 Promise 对象的状态变为<code>resolve</code>以后的回调函数。回调函数的参数，则是一个具有<code>value</code>和<code>done</code>两个属性的对象，这个跟同步遍历器是一样的。</p><p>我们知道，一个对象的同步遍历器的接口，部署在<code>Symbol.iterator</code>属性上面。同样地，对象的异步遍历器接口，部署在<code>Symbol.asyncIterator</code>属性上面。不管是什么样的对象，只要它的<code>Symbol.asyncIterator</code>属性有值，就表示应该对它进行异步遍历。</p><p>下面是一个异步遍历器的例子。</p><pre><code class="javascript">const asyncIterable = createAsyncIterable([&#39;a&#39;, &#39;b&#39;]);
const asyncIterator = asyncIterable[Symbol.asyncIterator]();

asyncIterator
.next()
.then(iterResult1 =&gt; &#123;
  console.log(iterResult1); // &#123; value: &#39;a&#39;, done: false &#125;
  return asyncIterator.next();
&#125;)
.then(iterResult2 =&gt; &#123;
  console.log(iterResult2); // &#123; value: &#39;b&#39;, done: false &#125;
  return asyncIterator.next();
&#125;)
.then(iterResult3 =&gt; &#123;
  console.log(iterResult3); // &#123; value: undefined, done: true &#125;
&#125;);
</code></pre><p>上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个 Promise 对象；等到 Promise 对象<code>resolve</code>了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回 Promise 对象，作为中介。</p><p>由于异步遍历器的<code>next</code>方法，返回的是一个 Promise 对象。因此，可以把它放在<code>await</code>命令后面。</p><pre><code class="javascript">async function f() &#123;
  const asyncIterable = createAsyncIterable([&#39;a&#39;, &#39;b&#39;]);
  const asyncIterator = asyncIterable[Symbol.asyncIterator]();
  console.log(await asyncIterator.next());
  // &#123; value: &#39;a&#39;, done: false &#125;
  console.log(await asyncIterator.next());
  // &#123; value: &#39;b&#39;, done: false &#125;
  console.log(await asyncIterator.next());
  // &#123; value: undefined, done: true &#125;
&#125;
</code></pre><p>上面代码中，**<code>next</code>方法用<code>await</code>处理以后，就不必使用<code>then</code>方法了。整个流程已经很接近同步处理了。**</p><p>注意，异步遍历器的<code>next</code>方法是可以连续调用的，不必等到上一步产生的 Promise 对象<code>resolve</code>以后再调用。这种情况下，<code>next</code>方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，<strong>把所有的<code>next</code>方法放在<code>Promise.all</code>方法里面。</strong></p><pre><code class="javascript">const asyncIterable = createAsyncIterable([&#39;a&#39;, &#39;b&#39;]);
const asyncIterator = asyncIterable[Symbol.asyncIterator]();
const [&#123;value: v1&#125;, &#123;value: v2&#125;] = await Promise.all([
  asyncIterator.next(), asyncIterator.next()
]);

console.log(v1, v2); // a b
</code></pre><p><strong>另一种用法是一次性调用所有的<code>next</code>方法，然后<code>await</code>最后一步操作。</strong></p><pre><code class="javascript">async function runner() &#123;
  const writer = openFile(&#39;someFile.txt&#39;);
  writer.next(&#39;hello&#39;);
  writer.next(&#39;world&#39;);
  await writer.return();
&#125;

runner();
</code></pre><hr><h4 id="3-for-await…of"><a href="#3-for-await…of" class="headerlink" title="3. for await…of"></a>3. for await…of</h4><p>前面介绍过，**<code>for...of</code>循环用于遍历同步的 Iterator 接口。新引入的<code>for await...of</code>循环，则是用于遍历异步的 Iterator 接口。**</p><pre><code class="javascript">async function f() &#123;
  for await (const x of createAsyncIterable([&#39;a&#39;, &#39;b&#39;])) &#123;
    console.log(x);
  &#125;
&#125;
// a
// b
</code></pre><p>上面代码中，<code>createAsyncIterable()</code>返回一个拥有异步遍历器接口的对象，<code>for...of</code>循环自动调用这个对象的异步遍历器的<code>next</code>方法，会得到一个 Promise 对象。<code>await</code>用来处理这个 Promise 对象，一旦<code>resolve</code>，就把得到的值（<code>x</code>）传入<code>for...of</code>的循环体。</p><p><code>for await...of</code>循环的一个用途，是部署了 asyncIterable 操作的异步接口，可以直接放入这个循环。</p><pre><code class="javascript">let body = &#39;&#39;;

async function f() &#123;
  for await(const data of req) body += data;
  const parsed = JSON.parse(body);
  console.log(&#39;got&#39;, parsed);
&#125;
</code></pre><p>上面代码中，<code>req</code>是一个 asyncIterable 对象，用来异步读取数据。可以看到，使用<code>for await...of</code>循环以后，代码会非常简洁。</p><p><strong>如果<code>next</code>方法返回的 Promise 对象被<code>reject</code>，<code>for await...of</code>就会报错，要用<code>try...catch</code>捕捉。</strong></p><pre><code class="javascript">async function () &#123;
  try &#123;
    for await (const x of createRejectingIterable()) &#123;
      console.log(x);
    &#125;
  &#125; catch (e) &#123;
    console.error(e);
  &#125;
&#125;
</code></pre><p><strong>注意，<code>for await...of</code>循环也可以用于同步遍历器。</strong></p><pre><code class="javascript">(async function () &#123;
  for await (const x of [&#39;a&#39;, &#39;b&#39;]) &#123;
    console.log(x);
  &#125;
&#125;)();
// a
// b
</code></pre><p>Node v10 支持异步遍历器，Stream 就部署了这个接口。下面是读取文件的传统写法与异步遍历器写法的差异。</p><pre><code class="javascript">// 传统写法
function main(inputFilePath) &#123;
  const readStream = fs.createReadStream(
    inputFilePath,
    &#123; encoding: &#39;utf8&#39;, highWaterMark: 1024 &#125;
  );
  readStream.on(&#39;data&#39;, (chunk) =&gt; &#123;
    console.log(&#39;&gt;&gt;&gt; &#39;+chunk);
  &#125;);
  readStream.on(&#39;end&#39;, () =&gt; &#123;
    console.log(&#39;### DONE ###&#39;);
  &#125;);
&#125;

// 异步遍历器写法
async function main(inputFilePath) &#123;
  const readStream = fs.createReadStream(
    inputFilePath,
    &#123; encoding: &#39;utf8&#39;, highWaterMark: 1024 &#125;
  );

  for await (const chunk of readStream) &#123;
    console.log(&#39;&gt;&gt;&gt; &#39;+chunk);
  &#125;
  console.log(&#39;### DONE ###&#39;);
&#125;
</code></pre><hr><h4 id="4-异步-Generator-函数"><a href="#4-异步-Generator-函数" class="headerlink" title="4. 异步 Generator 函数"></a>4. 异步 Generator 函数</h4><p>就像 Generator 函数返回一个同步遍历器对象一样，<strong>异步 Generator 函数的作用，是返回一个异步遍历器对象。</strong></p><p><strong>在语法上，异步 Generator 函数就是<code>async</code>函数与 Generator 函数的结合。</strong></p><pre><code class="javascript">async function* gen() &#123;
  yield &#39;hello&#39;;
&#125;
const genObj = gen();
genObj.next().then(x =&gt; console.log(x));
// &#123; value: &#39;hello&#39;, done: false &#125;
</code></pre><p>上面代码中，<code>gen</code>是一个异步 Generator 函数，执行后返回一个异步 Iterator 对象。对该对象调用<code>next</code>方法，返回一个 Promise 对象。</p><p><strong>异步遍历器的设计目的之一，就是 Generator 函数处理同步操作和异步操作时，能够使用同一套接口。</strong></p><pre><code class="javascript">// 同步 Generator 函数
function* map(iterable, func) &#123;
  const iter = iterable[Symbol.iterator]();
  while (true) &#123;
    const &#123;value, done&#125; = iter.next();
    if (done) break;
    yield func(value);
  &#125;
&#125;

// 异步 Generator 函数
async function* map(iterable, func) &#123;
  const iter = iterable[Symbol.asyncIterator]();
  while (true) &#123;
    const &#123;value, done&#125; = await iter.next();
    if (done) break;
    yield func(value);
  &#125;
&#125;
</code></pre><p>上面代码中，<code>map</code>是一个 Generator 函数，第一个参数是可遍历对象<code>iterable</code>，第二个参数是一个回调函数<code>func</code>。<code>map</code>的作用是将<code>iterable</code>每一步返回的值，使用<code>func</code>进行处理。上面有两个版本的<code>map</code>，前一个处理同步遍历器，后一个处理异步遍历器，可以看到两个版本的写法基本上是一致的。</p><p>下面是另一个异步 Generator 函数的例子。</p><pre><code class="javascript">async function* readLines(path) &#123;
  let file = await fileOpen(path);

  try &#123;
    while (!file.EOF) &#123;
      yield await file.readLine();
    &#125;
  &#125; finally &#123;
    await file.close();
  &#125;
&#125;
</code></pre><p>上面代码中，异步操作前面使用<code>await</code>关键字标明，即<code>await</code>后面的操作，应该返回 Promise 对象。凡是使用<code>yield</code>关键字的地方，就是<code>next</code>方法停下来的地方，它后面的表达式的值（即<code>await file.readLine()</code>的值），会作为<code>next()</code>返回对象的<code>value</code>属性，这一点是与同步 Generator 函数一致的。</p><p><strong>异步 Generator 函数内部，能够同时使用<code>await</code>和<code>yield</code>命令。可以这样理解，<code>await</code>命令用于将外部操作产生的值输入函数内部，<code>yield</code>命令用于将函数内部的值输出。</strong></p><p>上面代码定义的异步 Generator 函数的用法如下。</p><pre><code class="javascript">(async function () &#123;
  for await (const line of readLines(filePath)) &#123;
    console.log(line);
  &#125;
&#125;)()
</code></pre><p>异步 Generator 函数可以与<code>for await...of</code>循环结合起来使用。</p><pre><code class="javascript">async function* prefixLines(asyncIterable) &#123;
  for await (const line of asyncIterable) &#123;
    yield &#39;&gt; &#39; + line;
  &#125;
&#125;
</code></pre><p>异步 Generator 函数的返回值是一个异步 Iterator，即每次调用它的<code>next</code>方法，会返回一个 Promise 对象，也就是说，跟在<code>yield</code>命令后面的，应该是一个 Promise 对象。如果像上面那个例子那样，<code>yield</code>命令后面是一个字符串，会被自动包装成一个 Promise 对象。</p><pre><code class="javascript">function fetchRandom() &#123;
  const url = &#39;https://www.random.org/decimal-fractions/&#39;
    + &#39;?num=1&amp;dec=10&amp;col=1&amp;format=plain&amp;rnd=new&#39;;
  return fetch(url);
&#125;

async function* asyncGenerator() &#123;
  console.log(&#39;Start&#39;);
  const result = await fetchRandom(); // (A)
  yield &#39;Result: &#39; + await result.text(); // (B)
  console.log(&#39;Done&#39;);
&#125;

const ag = asyncGenerator();
ag.next().then((&#123;value, done&#125;) =&gt; &#123;
  console.log(value);
&#125;)
</code></pre><p>上面代码中，<code>ag</code>是<code>asyncGenerator</code>函数返回的异步遍历器对象。调用<code>ag.next()</code>以后，上面代码的执行顺序如下。</p><ol><li><code>ag.next()</code>立刻返回一个 Promise 对象。</li><li><code>asyncGenerator</code>函数开始执行，打印出<code>Start</code>。</li><li><code>await</code>命令返回一个 Promise 对象，<code>asyncGenerator</code>函数停在这里。</li><li>A 处变成 fulfilled 状态，产生的值放入<code>result</code>变量，<code>asyncGenerator</code>函数继续往下执行。</li><li>函数在 B 处的<code>yield</code>暂停执行，一旦<code>yield</code>命令取到值，<code>ag.next()</code>返回的那个 Promise 对象变成 fulfilled 状态。</li><li><code>ag.next()</code>后面的<code>then</code>方法指定的回调函数开始执行。该回调函数的参数是一个对象<code>&#123;value, done&#125;</code>，其中<code>value</code>的值是<code>yield</code>命令后面的那个表达式的值，<code>done</code>的值是<code>false</code>。</li></ol><p>A 和 B 两行的作用类似于下面的代码。</p><pre><code class="javascript">return new Promise((resolve, reject) =&gt; &#123;
  fetchRandom()
  .then(result =&gt; result.text())
  .then(result =&gt; &#123;
     resolve(&#123;
       value: &#39;Result: &#39; + result,
       done: false,
     &#125;);
  &#125;);
&#125;);
</code></pre><p><strong>如果异步 Generator 函数抛出错误，会导致 Promise 对象的状态变为<code>reject</code>，然后抛出的错误被<code>catch</code>方法捕获。</strong></p><pre><code class="javascript">async function* asyncGenerator() &#123;
  throw new Error(&#39;Problem!&#39;);
&#125;

asyncGenerator()
.next()
.catch(err =&gt; console.log(err)); // Error: Problem!
</code></pre><p>注意，<strong>普通的 async 函数返回的是一个 Promise 对象，而异步 Generator 函数返回的是一个异步 Iterator 对象</strong>。可以这样理解，<strong>async 函数和异步 Generator 函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过<code>for await...of</code>执行，或者自己编写执行器。下面就是一个异步 Generator 函数的执行器。</strong></p><pre><code class="javascript">async function takeAsync(asyncIterable, count = Infinity) &#123;
  const result = [];
  const iterator = asyncIterable[Symbol.asyncIterator]();
  while (result.length &lt; count) &#123;
    const &#123;value, done&#125; = await iterator.next();
    if (done) break;
    result.push(value);
  &#125;
  return result;
&#125;
</code></pre><p>上面代码中，异步 Generator 函数产生的异步遍历器，会通过<code>while</code>循环自动执行，每当<code>await iterator.next()</code>完成，就会进入下一轮循环。一旦<code>done</code>属性变为<code>true</code>，就会跳出循环，异步遍历器执行结束。</p><p>下面是这个自动执行器的一个使用实例。</p><pre><code class="javascript">async function f() &#123;
  async function* gen() &#123;
    yield &#39;a&#39;;
    yield &#39;b&#39;;
    yield &#39;c&#39;;
  &#125;

  return await takeAsync(gen());
&#125;

f().then(function (result) &#123;
  console.log(result); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&#125;)
</code></pre><p>异步 Generator 函数出现以后，<strong>JavaScript 就有了四种函数形式：普通函数、async 函数、Generator 函数和异步 Generator 函数。</strong>请注意区分每种函数的不同之处。基本上，<strong>如果是一系列按照顺序执行的异步操作（比如读取文件，然后写入新内容，再存入硬盘），可以使用 async 函数；如果是一系列产生相同数据结构的异步操作（比如一行一行读取文件），可以使用异步 Generator 函数。</strong></p><p><strong>异步 Generator 函数也可以通过<code>next</code>方法的参数，接收外部传入的数据。</strong></p><pre><code class="javascript">const writer = openFile(&#39;someFile.txt&#39;);
writer.next(&#39;hello&#39;); // 立即执行
writer.next(&#39;world&#39;); // 立即执行
await writer.return(); // 等待写入结束
</code></pre><p>上面代码中，<code>openFile</code>是一个异步 Generator 函数。<code>next</code>方法的参数，向该函数内部的操作传入数据。每次<code>next</code>方法都是同步执行的，最后的<code>await</code>命令用于等待整个写入操作结束。</p><p>最后，同步的数据结构，也可以使用异步 Generator 函数。</p><pre><code class="javascript">async function* createAsyncIterable(syncIterable) &#123;
  for (const elem of syncIterable) &#123;
    yield elem;
  &#125;
&#125;
</code></pre><p>上面代码中，由于没有异步操作，所以也就没有使用<code>await</code>关键字。</p><hr><h4 id="5-yield-语句"><a href="#5-yield-语句" class="headerlink" title="5. yield* 语句"></a>5. yield* 语句</h4><p><code>yield*</code>语句也可以跟一个异步遍历器。</p><pre><code class="javascript">async function* gen1() &#123;
  yield &#39;a&#39;;
  yield &#39;b&#39;;
  return 2;
&#125;

async function* gen2() &#123;
  // result 最终会等于 2
  const result = yield* gen1();
&#125;
</code></pre><p>上面代码中，<code>gen2</code>函数里面的<code>result</code>变量，最后的值是<code>2</code>。</p><p>与同步 Generator 函数一样，<code>for await...of</code>循环会展开<code>yield*</code>。</p><pre><code class="javascript">(async function () &#123;
  for await (const x of gen2()) &#123;
    console.log(x);
  &#125;
&#125;)();
// a
// b
</code></pre><div class="tags"><a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"><i class="ic i-tag"></i> 前端</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-03-27 17:00:43" itemprop="dateModified" datetime="2022-03-27T17:00:43+08:00">2022-03-27</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="sparkle 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="sparkle 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="sparkle 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>sparkle <i class="ic i-at"><em>@</em></i>Sparkle</li><li class="link"><strong>本文链接：</strong> <a href="https://1234cas.github.io/1234cas.github.io/qianduan/ES6/ES6%E4%B8%8B/" title="ES6下">https://1234cas.github.io/1234cas.github.io/qianduan/ES6/ES6下/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/qianduan/ES6/ES6%E4%B8%8A/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipevo9j1jj20zk0m8e81.jpg" title="ES6上"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> ES6</span><h3>ES6上</h3></a></div><div class="item right"><a href="/qianduan/Vue/vue-router/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicli3sbvtj20zk0m8x6p.jpg" title="Vue router"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Vue</span><h3>Vue router</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81-Proxy"><span class="toc-number">1.</span> <span class="toc-text">14、 Proxy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Proxy-%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">2. Proxy 实例的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Proxy-revocable"><span class="toc-number">1.3.</span> <span class="toc-text">3. Proxy.revocable()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-this-%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">4. this 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%AE%9E%E4%BE%8B%EF%BC%9AWeb-%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.5.</span> <span class="toc-text">5. 实例：Web 服务的客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81-Reflect"><span class="toc-number">2.</span> <span class="toc-text">15、 Reflect</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-1"><span class="toc-number">2.1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">2.静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-Proxy-%E5%AE%9E%E7%8E%B0%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">3. 实例：使用 Proxy 实现观察者模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81-Promise-%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">16、 Promise 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Promise-%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">1. Promise 的含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">2. 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Promise-prototype-then"><span class="toc-number">3.3.</span> <span class="toc-text">3. Promise.prototype.then()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Promise-prototype-catch"><span class="toc-number">3.4.</span> <span class="toc-text">4. Promise.prototype.catch()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Promise-prototype-finally"><span class="toc-number">3.5.</span> <span class="toc-text">5. Promise.prototype.finally()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Promise-all"><span class="toc-number">3.6.</span> <span class="toc-text">6. Promise.all()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Promise-race"><span class="toc-number">3.7.</span> <span class="toc-text">7. Promise.race()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Promise-allSettled"><span class="toc-number">3.8.</span> <span class="toc-text">8. Promise.allSettled()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-Promise-any"><span class="toc-number">3.9.</span> <span class="toc-text">9. Promise.any()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-Promise-resolve"><span class="toc-number">3.10.</span> <span class="toc-text">10. Promise.resolve()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-Promise-reject"><span class="toc-number">3.11.</span> <span class="toc-text">11. Promise.reject()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E5%BA%94%E7%94%A8"><span class="toc-number">3.12.</span> <span class="toc-text">12. 应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-Promise-try"><span class="toc-number">3.13.</span> <span class="toc-text">13. Promise.try()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81-Iterator-%E5%92%8C-for%E2%80%A6of-%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.</span> <span class="toc-text">17、 Iterator 和 for…of 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Iterator%EF%BC%88%E9%81%8D%E5%8E%86%E5%99%A8%EF%BC%89%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">1. Iterator（遍历器）的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%BB%98%E8%AE%A4-Iterator-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.</span> <span class="toc-text">2. 默认 Iterator 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%B0%83%E7%94%A8-Iterator-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9C%BA%E5%90%88"><span class="toc-number">4.3.</span> <span class="toc-text">3. 调用 Iterator 接口的场合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84-Iterator-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.4.</span> <span class="toc-text">4. 字符串的 Iterator 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Iterator-%E6%8E%A5%E5%8F%A3%E4%B8%8E-Generator-%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">5. Iterator 接口与 Generator 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%81%8D%E5%8E%86%E5%99%A8%E5%AF%B9%E8%B1%A1%E7%9A%84-return-%EF%BC%8Cthrow"><span class="toc-number">4.6.</span> <span class="toc-text">6. 遍历器对象的 return()，throw()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-for%E2%80%A6of-%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.7.</span> <span class="toc-text">7. for…of 循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81-Generator-%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">18、 Generator 函数的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-next-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">2. next 方法的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-for%E2%80%A6of-%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.3.</span> <span class="toc-text">3. for…of 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Generator-prototype-throw"><span class="toc-number">5.4.</span> <span class="toc-text">4. Generator.prototype.throw()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Generator-prototype-return"><span class="toc-number">5.5.</span> <span class="toc-text">5. Generator.prototype.return()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-next-%E3%80%81throw-%E3%80%81return-%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">5.6.</span> <span class="toc-text">6. next()、throw()、return() 的共同点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-yield-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.7.</span> <span class="toc-text">7. yield* 表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E4%BD%9C%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84-Generator-%E5%87%BD%E6%95%B0"><span class="toc-number">5.8.</span> <span class="toc-text">8. 作为对象属性的 Generator 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-Generator-%E5%87%BD%E6%95%B0%E7%9A%84this"><span class="toc-number">5.9.</span> <span class="toc-text">9. Generator 函数的this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%90%AB%E4%B9%89"><span class="toc-number">5.10.</span> <span class="toc-text">10. 含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%BA%94%E7%94%A8"><span class="toc-number">5.11.</span> <span class="toc-text">11. 应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81-Generator-%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">19、 Generator 函数的异步应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BC%A0%E7%BB%9F%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">1. 传统方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.2.</span> <span class="toc-text">2. 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Generator-%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">3. Generator 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Thunk-%E5%87%BD%E6%95%B0"><span class="toc-number">6.4.</span> <span class="toc-text">4. Thunk 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-co-%E6%A8%A1%E5%9D%97"><span class="toc-number">6.5.</span> <span class="toc-text">5. co 模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81-async-%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">20、 async 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%AB%E4%B9%89"><span class="toc-number">7.1.</span> <span class="toc-text">1. 含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1"><span class="toc-number">7.2.</span> <span class="toc-text">2. 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AF%AD%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">3. 语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-async-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">7.4.</span> <span class="toc-text">4. async 函数的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%8E%E5%85%B6%E4%BB%96%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">7.5.</span> <span class="toc-text">5. 与其他异步处理方法的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%AE%8C%E6%88%90%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">7.6.</span> <span class="toc-text">6. 实例：按顺序完成异步操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E9%A1%B6%E5%B1%82-await"><span class="toc-number">7.7.</span> <span class="toc-text">7. 顶层 await</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81-Class-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">21、 Class 的基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-number">8.1.</span> <span class="toc-text">1. 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-1"><span class="toc-number">8.2.</span> <span class="toc-text">2. 静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B0%E5%86%99%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">3. 实例属性的新写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7"><span class="toc-number">8.4.</span> <span class="toc-text">4. 静态属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E5%92%8C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="toc-number">8.5.</span> <span class="toc-text">5. 私有方法和私有属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%9D%99%E6%80%81%E5%9D%97"><span class="toc-number">8.6.</span> <span class="toc-text">6. 静态块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-new-target-%E5%B1%9E%E6%80%A7"><span class="toc-number">8.7.</span> <span class="toc-text">7. new.target 属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81-Class-%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">9.</span> <span class="toc-text">22、 Class 的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B-1"><span class="toc-number">9.1.</span> <span class="toc-text">1. 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Object-getPrototypeOf"><span class="toc-number">9.2.</span> <span class="toc-text">2. Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-super-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">9.3.</span> <span class="toc-text">3. super 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%B1%BB%E7%9A%84-prototype-%E5%B1%9E%E6%80%A7%E5%92%8C-proto-%E5%B1%9E%E6%80%A7"><span class="toc-number">9.4.</span> <span class="toc-text">4. 类的 prototype 属性和__proto__属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8E%9F%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">9.5.</span> <span class="toc-text">5. 原生构造函数的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Mixin-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.6.</span> <span class="toc-text">6. Mixin 模式的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81-Module-%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">23、 Module 的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-2"><span class="toc-number">10.1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.2.</span> <span class="toc-text">2. 严格模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-export-%E5%91%BD%E4%BB%A4"><span class="toc-number">10.3.</span> <span class="toc-text">3. export 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-import-%E5%91%BD%E4%BB%A4"><span class="toc-number">10.4.</span> <span class="toc-text">4. import 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%A8%A1%E5%9D%97%E7%9A%84%E6%95%B4%E4%BD%93%E5%8A%A0%E8%BD%BD"><span class="toc-number">10.5.</span> <span class="toc-text">5. 模块的整体加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-export-default-%E5%91%BD%E4%BB%A4"><span class="toc-number">10.6.</span> <span class="toc-text">6. export default 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-export-%E4%B8%8E-import-%E7%9A%84%E5%A4%8D%E5%90%88%E5%86%99%E6%B3%95"><span class="toc-number">10.7.</span> <span class="toc-text">7. export 与 import 的复合写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">10.8.</span> <span class="toc-text">8. 模块的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E8%B7%A8%E6%A8%A1%E5%9D%97%E5%B8%B8%E9%87%8F"><span class="toc-number">10.9.</span> <span class="toc-text">9. 跨模块常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-import"><span class="toc-number">10.10.</span> <span class="toc-text">10. import()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81-Module-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.</span> <span class="toc-text">24、 Module 的加载实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD"><span class="toc-number">11.1.</span> <span class="toc-text">1. 浏览器加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">11.2.</span> <span class="toc-text">2. ES6 模块与 CommonJS 模块的差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Node-js-%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%96%B9%E6%B3%95"><span class="toc-number">11.3.</span> <span class="toc-text">3. Node.js 的模块加载方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD"><span class="toc-number">11.4.</span> <span class="toc-text">4. 循环加载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81-%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC"><span class="toc-number">12.</span> <span class="toc-text">25、 编程风格</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">12.1.</span> <span class="toc-text">1. 块级作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">12.2.</span> <span class="toc-text">2. 字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">12.3.</span> <span class="toc-text">3. 解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.4.</span> <span class="toc-text">4. 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84"><span class="toc-number">12.5.</span> <span class="toc-text">5. 数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%87%BD%E6%95%B0"><span class="toc-number">12.6.</span> <span class="toc-text">6. 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Map-%E7%BB%93%E6%9E%84"><span class="toc-number">12.7.</span> <span class="toc-text">7. Map 结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Class"><span class="toc-number">12.8.</span> <span class="toc-text">8. Class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E6%A8%A1%E5%9D%97"><span class="toc-number">12.9.</span> <span class="toc-text">9. 模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-ESLint-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">12.10.</span> <span class="toc-text">10. ESLint 的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81-%E5%BC%82%E6%AD%A5%E9%81%8D%E5%8E%86%E5%99%A8"><span class="toc-number">13.</span> <span class="toc-text">26、 异步遍历器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%8C%E6%AD%A5%E9%81%8D%E5%8E%86%E5%99%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">13.1.</span> <span class="toc-text">1. 同步遍历器的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%82%E6%AD%A5%E9%81%8D%E5%8E%86%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">13.2.</span> <span class="toc-text">2. 异步遍历的接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-for-await%E2%80%A6of"><span class="toc-number">13.3.</span> <span class="toc-text">3. for await…of</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%BC%82%E6%AD%A5-Generator-%E5%87%BD%E6%95%B0"><span class="toc-number">13.4.</span> <span class="toc-text">4. 异步 Generator 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-yield-%E8%AF%AD%E5%8F%A5"><span class="toc-number">13.5.</span> <span class="toc-text">5. yield* 语句</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/qianduan/ES6/ES6%E4%B8%8A/" rel="bookmark" title="ES6上">ES6上</a></li><li class="active"><a href="/qianduan/ES6/ES6%E4%B8%8B/" rel="bookmark" title="ES6下">ES6下</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="sparkle" data-src="/images/avatar.jpg"><p class="name" itemprop="name">sparkle</p><div class="description" itemprop="description">好好读书</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">11</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">3</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></span> <span class="exturl item google" data-url="aHR0cHM6Ly9wbHVzLmdvb2dsZS5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;plus.google.com&#x2F;yourname"><i class="ic i-google"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnlvdXJuYW1lQG1haWwuY29t" title="mailto:yourname@mail.com"><i class="ic i-envelope"></i></span> <span class="exturl item facebook" data-url="aHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname"><i class="ic i-facebook"></i></span> <span class="exturl item stackoverflow" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname"><i class="ic i-stack-overflow"></i></span> <span class="exturl item youtube" data-url="aHR0cHM6Ly95b3V0dWJlLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;youtube.com&#x2F;yourname"><i class="ic i-youtube"></i></span> <span class="exturl item instagram" data-url="aHR0cHM6Ly9pbnN0YWdyYW0uY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;instagram.com&#x2F;yourname"><i class="ic i-instagram"></i></span> <span class="exturl item skype" data-url="c2t5cGU6eW91cm5hbWU/Y2FsbHxjaGF0" title="skype:yourname?call|chat"><i class="ic i-skype"></i></span> <span class="exturl item douban" data-url="aHR0cHM6Ly93d3cuZG91YmFuLmNvbS9wZW9wbGUveW91cm5hbWUv" title="https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;yourname&#x2F;"><i class="ic i-douban"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>链接</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/qianduan/ES6/ES6%E4%B8%8A/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/qianduan/Vue/vue-router/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/hexo/" title="分类于 hexo">hexo</a></div><span><a href="/hexo/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/qianduan/Vue/vue%E7%AC%94%E8%AE%B0/" title="Vue笔记">Vue笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reading-minutes/" title="分类于 读书笔记">读书笔记</a></div><span><a href="/reading-minutes/%E5%85%B3%E4%BA%8E%E8%AF%BB%E4%B9%A6/" title="关于读书">关于读书</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/ES6/" title="分类于 ES6">ES6</a></div><span><a href="/qianduan/ES6/ES6%E4%B8%8B/" title="ES6下">ES6下</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/ES6/" title="分类于 ES6">ES6</a></div><span><a href="/qianduan/ES6/ES6%E4%B8%8A/" title="ES6上">ES6上</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a></div><span><a href="/%E5%9F%BA%E7%A1%80/" title="基础">基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/qianduan/Vue/vue-router/" title="Vue router">Vue router</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/qianduan/Vue/vuex/" title="vuex">vuex</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reading-minutes/" title="分类于 读书笔记">读书笔记</a></div><span><a href="/reading-minutes/%E5%85%B3%E4%BA%8E%E7%AC%94%E8%AE%B0/" title="关于笔记">关于笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/qianduan/Vue/vue%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Vue面试题">Vue面试题</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">sparkle @ Sparkle</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"qianduan/ES6/ES6下/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:{placeholder:"1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"},fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->