<!-- build time:Tue Mar 29 2022 11:15:37 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="前端"><link rel="canonical" href="https://1234cas.github.io/1234cas.github.io/qianduan/ES6/ES6%E4%B8%8A/"><title>ES6上 - ES6 - 前端 | Sparkle = Sparkle = 加油</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">ES6上</h1><div class="meta"><span class="item" title="创建时间：2022-03-27 16:52:26"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-03-27T16:52:26+08:00">2022-03-27</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Sparkle</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipewf5l51j20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipewr8iypj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipexoj0moj20zk0m8kgu.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeudstjqj20zk0m8k3r.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeun65urj20zk0m81ii.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giciszlczyj20zk0m816d.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/qianduan/" itemprop="item" rel="index" title="分类于 前端"><span itemprop="name">前端</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/qianduan/ES6/" itemprop="item" rel="index" title="分类于 ES6"><span itemprop="name">ES6</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://1234cas.github.io/1234cas.github.io/qianduan/ES6/ES6%E4%B8%8A/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="sparkle"><meta itemprop="description" content="加油, 好好读书"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sparkle"></span><div class="body md" itemprop="articleBody"><h3 id="1、let-和-const-命令"><a href="#1、let-和-const-命令" class="headerlink" title="1、let 和 const 命令"></a>1、let 和 const 命令</h3><hr><h4 id="1-let-命令"><a href="#1-let-命令" class="headerlink" title="1. let 命令"></a>1. let 命令</h4><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>。</p><blockquote><pre><code class="javascript">var a = [];
for (let i = 0; i &lt; 10; i++) &#123;
  a[i] = function () &#123;
    console.log(i);
  &#125;;
&#125;
a[6](); // 6
</code></pre><p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是<code>6</code>。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算。</p><p><code>for</code>循环中设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域</p><pre><code class="javascript">for (let i = 0; i &lt; 3; i++) &#123;
  let i = &#39;abc&#39;;
  console.log(i);
&#125;
// abc
// abc
// abc
</code></pre><p>这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 <code>let</code> 重复声明同一个变量）。</p></blockquote><p><code>let</code>具有以下特点：</p><ol><li><p><strong>不存在变量提升</strong>。 在声明它之前，变量<code>bar</code>是不存在的，使用会报错ReferenceError。</p></li><li><p><strong>暂时性死区</strong>。在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。</p></li></ol><pre><code class="javascript">if (true) &#123;
  // TDZ开始
  tmp = &#39;abc&#39;; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
&#125;
</code></pre><pre><code class="javascript">function bar(x = y, y = 2) &#123;
  return [x, y];
&#125;

bar(); // 报错
</code></pre><pre><code class="javascript">// 不报错
var x = x;

// 报错
let x = x;
// ReferenceError: x is not defined
</code></pre><p>使用<code>let</code>声明变量时，只要变量在还没有声明完成前使用，就会报错。</p><ol start="3"><li><strong>不允许重复声明</strong>。</li></ol><hr><h4 id="2-块级作用域"><a href="#2-块级作用域" class="headerlink" title="2. 块级作用域"></a>2. 块级作用域</h4><p><code>let</code>实际上为 JavaScript 新增了块级作用域。</p><p>块级作用域的出现使得获得广泛应用的立即执行函数不再必要了。</p><p>应该避免在块级作用域内声明函数，如需要，优先使用函数表达式，不建议使用函数声明语句</p><hr><h4 id="3-const-命令"><a href="#3-const-命令" class="headerlink" title="3. const 命令"></a>3. const 命令</h4><p><strong>基本</strong></p><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变，否则报错。</p><p><code>const</code>一旦声明变量，就必须立即初始化，不能只声明不赋值，否则报错。</p><p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。存在暂时性死区。不可重复声明。</p><p><strong>本质</strong></p><p><code>const</code>实际上保证的，并不是变量的值不变，而是变量指向的内存地址不变。</p><p>对于简单数据类型的数据(Number、String、Boolean)，值就保存在变量所指向的内存地址，因此相当于常量。</p><p>对于复杂类型(Object、Array)，变量指向的内存地址只是实际内存地址的一个引用，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），但是可以修改其中的数据。</p><pre><code class="javascript">const foo = &#123;&#125;;

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only
</code></pre><p>常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p><blockquote><p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p><pre><code class="javascript">const foo = Object.freeze(&#123;&#125;);

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
</code></pre><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><pre><code class="javascript">var constantize = (obj) =&gt; &#123;
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) =&gt; &#123;
    if ( typeof obj[key] === &#39;object&#39; ) &#123;
      constantize( obj[key] );
    &#125;
  &#125;);
&#125;;
</code></pre></blockquote><hr><h4 id="4-顶层对象的属性"><a href="#4-顶层对象的属性" class="headerlink" title="4. 顶层对象的属性"></a>4. 顶层对象的属性</h4><p><strong>顶层对象</strong>，在浏览器环境指的是<code>window</code>对象，在 Node 指的是<code>global</code>对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p><p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6 为了改变这一点，，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p><pre><code class="javascript">var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
</code></pre><p>全局变量<code>a</code>由<code>var</code>命令声明，所以它是顶层对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是顶层对象的属性，返回<code>undefined</code>。</p><h3 id="2、变量的解构赋值"><a href="#2、变量的解构赋值" class="headerlink" title="2、变量的解构赋值"></a>2、变量的解构赋值</h3><hr><h4 id="1-数组的解构赋值"><a href="#1-数组的解构赋值" class="headerlink" title="1. 数组的解构赋值"></a>1. 数组的解构赋值</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>按照对应位置，对变量赋值。本质上，这种写法属于“<strong>模式匹配</strong>”，只要等号两边的<strong>模式</strong>相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子：</p><pre><code class="javascript">let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
third // &quot;baz&quot;

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = [&#39;a&#39;];
x // &quot;a&quot;
y // undefined
z // []
</code></pre><p>如果<strong>解构不成功</strong>，变量的值就等于<code>undefined</code>。</p><pre><code class="javascript">let [foo] = [];
let [bar, foo] = [1];
</code></pre><p>以上两种情况都属于解构不成功，<code>foo</code>的值都会等于<code>undefined</code>。</p><p>另一种情况是<strong>不完全解构</strong>，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><pre><code class="javascript">let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
</code></pre><p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p><pre><code class="javascript">// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = &#123;&#125;;
</code></pre><p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</p><p>对于 Set 结构，也可以使用数组的解构赋值。</p><pre><code class="javascript">let [x, y, z] = new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);
x // &quot;a&quot;
</code></pre><p>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p><pre><code class="javascript">function* fibs() &#123;
  let a = 0;
  let b = 1;
  while (true) &#123;
    yield a;
    [a, b] = [b, a + b];
  &#125;
&#125;

let [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5
</code></pre><p>上面代码中，<code>fibs</code>是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p><hr><h4 id="2-对象的解构赋值"><a href="#2-对象的解构赋值" class="headerlink" title="2. 对象的解构赋值"></a>2. 对象的解构赋值</h4><p>解构不仅可以用于数组，还可以用于对象。</p><pre><code class="javascript">let &#123; foo, bar &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;
</code></pre><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><pre><code class="javascript">let &#123; bar, foo &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let &#123; baz &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
baz // undefined
</code></pre><p>如果解构失败，变量的值等于<code>undefined</code>。</p><pre><code class="javascript">let &#123;foo&#125; = &#123;bar: &#39;baz&#39;&#125;;
foo // undefined
</code></pre><p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><pre><code class="javascript">// 例一
let &#123; log, sin, cos &#125; = Math;

// 例二
const &#123; log &#125; = console;
log(&#39;hello&#39;) // hello
</code></pre><p>上面代码的例一将<code>Math</code>对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将<code>console.log</code>赋值到<code>log</code>变量。</p><p>如果变量名与属性名不一致，必须写成下面这样。</p><pre><code class="javascript">let &#123; foo: baz &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
baz // &quot;aaa&quot;

let obj = &#123; first: &#39;hello&#39;, last: &#39;world&#39; &#125;;
let &#123; first: f, last: l &#125; = obj;
f // &#39;hello&#39;
l // &#39;world&#39;
</code></pre><p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p><pre><code class="javascript">let &#123; foo: foo, bar: bar &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
</code></pre><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><pre><code class="javascript">let &#123; foo: baz &#125; = &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;
baz // &quot;aaa&quot;
foo // error: foo is not defined
</code></pre><p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p><p>与数组一样，解构也可以用于嵌套结构的对象。</p><pre><code class="javascript">let obj = &#123;
  p: [
    &#39;Hello&#39;,
    &#123; y: &#39;World&#39; &#125;
  ]
&#125;;

let &#123; p: [x, &#123; y &#125;] &#125; = obj;
x // &quot;Hello&quot;
y // &quot;World&quot;
</code></pre><p>注意，这时<code>p</code>是<strong>模式</strong>，不是变量，因此不会被赋值。如果<code>p</code>也要作为变量赋值，可以写成下面这样。</p><pre><code class="javascript">let obj = &#123;
  p: [
    &#39;Hello&#39;,
    &#123; y: &#39;World&#39; &#125;
  ]
&#125;;

let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;
x // &quot;Hello&quot;
y // &quot;World&quot;
p // [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]
</code></pre><p>下面是嵌套赋值的例子。</p><pre><code class="javascript">let obj = &#123;&#125;;
let arr = [];

(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);

obj // &#123;prop:123&#125;
arr // [true]
</code></pre><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p><pre><code class="javascript">// 报错
let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: &#39;baz&#39;&#125;;
</code></pre><p>上面代码中，等号左边对象的<code>foo</code>属性，对应一个子对象。该子对象的<code>bar</code>属性，解构时会报错。原因很简单，因为<code>foo</code>这时等于<code>undefined</code>，再取子属性就会报错。</p><p><strong>默认值</strong></p><p>对象的解构也可以指定默认值。</p><pre><code class="javascript">var &#123;x = 3&#125; = &#123;&#125;;
x // 3

var &#123;x, y = 5&#125; = &#123;x: 1&#125;;
x // 1
y // 5

var &#123;x: y = 3&#125; = &#123;&#125;;
y // 3

var &#123;x: y = 3&#125; = &#123;x: 5&#125;;
y // 5

var &#123; message: msg = &#39;Something went wrong&#39; &#125; = &#123;&#125;;
msg // &quot;Something went wrong&quot;
</code></pre><p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p><pre><code class="javascript">var &#123;x = 3&#125; = &#123;x: undefined&#125;;
x // 3

var &#123;x = 3&#125; = &#123;x: null&#125;;
x // null
</code></pre><p>上面代码中，属性<code>x</code>等于<code>null</code>，因为<code>null</code>与<code>undefined</code>不严格相等，所以是个有效的赋值，导致默认值<code>3</code>不会生效。</p><hr><h4 id="3-函数参数的解构赋值"><a href="#3-函数参数的解构赋值" class="headerlink" title="3. 函数参数的解构赋值"></a>3. 函数参数的解构赋值</h4><p>函数的参数也可以使用解构赋值。</p><pre><code class="javascript">function add([x, y])&#123;
  return x + y;
&#125;

add([1, 2]); // 3
</code></pre><p>上面代码中，函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。</p><p>下面是另一个例子。</p><pre><code class="javascript">[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);
// [ 3, 7 ]
</code></pre><p>函数参数的解构也可以使用默认值。</p><pre><code class="javascript">function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;
  return [x, y];
&#125;

move(&#123;x: 3, y: 8&#125;); // [3, 8]
move(&#123;x: 3&#125;); // [3, 0]
move(&#123;&#125;); // [0, 0]
move(); // [0, 0]
</code></pre><p>上面代码中，函数<code>move</code>的参数是一个对象，通过对这个对象进行解构，得到变量<code>x</code>和<code>y</code>的值。如果解构失败，<code>x</code>和<code>y</code>等于默认值。</p><p>注意，下面的写法会得到不一样的结果。</p><pre><code class="javascript">function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;
  return [x, y];
&#125;

move(&#123;x: 3, y: 8&#125;); // [3, 8]
move(&#123;x: 3&#125;); // [3, undefined]
move(&#123;&#125;); // [undefined, undefined]
move(); // [0, 0]
</code></pre><p>上面代码是为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值，所以会得到与前一种写法不同的结果。</p><p><code>undefined</code>就会触发函数参数的默认值。</p><pre><code class="javascript">[1, undefined, 3].map((x = &#39;yes&#39;) =&gt; x);
// [ 1, &#39;yes&#39;, 3 ]
</code></pre><hr><h4 id="4-用途"><a href="#4-用途" class="headerlink" title="4. 用途"></a>4. 用途</h4><p>变量的解构赋值用途很多。</p><p><strong>（1）交换变量的值</strong></p><pre><code class="javascript">let x = 1;
let y = 2;

[x, y] = [y, x];
</code></pre><p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p><p><strong>（2）从函数返回多个值</strong></p><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p><pre><code class="javascript">// 返回一个数组

function example() &#123;
  return [1, 2, 3];
&#125;
let [a, b, c] = example();

// 返回一个对象

function example() &#123;
  return &#123;
    foo: 1,
    bar: 2
  &#125;;
&#125;
let &#123; foo, bar &#125; = example();
</code></pre><p><strong>（3）函数参数的定义</strong></p><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><pre><code class="javascript">// 参数是一组有次序的值
function f([x, y, z]) &#123; ... &#125;
f([1, 2, 3]);

// 参数是一组无次序的值
function f(&#123;x, y, z&#125;) &#123; ... &#125;
f(&#123;z: 3, y: 2, x: 1&#125;);
</code></pre><p><strong>（4）提取 JSON 数据</strong></p><p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p><pre><code class="javascript">let jsonData = &#123;
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
&#125;;

let &#123; id, status, data: number &#125; = jsonData;

console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]
</code></pre><p>上面代码可以快速提取 JSON 数据的值。</p><p><strong>（5）函数参数的默认值</strong></p><pre><code class="javascript">jQuery.ajax = function (url, &#123;
  async = true,
  beforeSend = function () &#123;&#125;,
  cache = true,
  complete = function () &#123;&#125;,
  crossDomain = false,
  global = true,
  // ... more config
&#125; = &#123;&#125;) &#123;
  // ... do stuff
&#125;;
</code></pre><p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p><p><strong>（6）遍历 Map 结构</strong></p><p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><pre><code class="javascript">const map = new Map();
map.set(&#39;first&#39;, &#39;hello&#39;);
map.set(&#39;second&#39;, &#39;world&#39;);

for (let [key, value] of map) &#123;
  console.log(key + &quot; is &quot; + value);
&#125;
// first is hello
// second is world
</code></pre><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p><pre><code class="javascript">// 获取键名
for (let [key] of map) &#123;
  // ...
&#125;

// 获取键值
for (let [,value] of map) &#123;
  // ...
&#125;
</code></pre><p><strong>（7）输入模块的指定方法</strong></p><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p><pre><code class="javascript">const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);
</code></pre><h3 id="3、字符串的扩展"><a href="#3、字符串的扩展" class="headerlink" title="3、字符串的扩展"></a>3、字符串的扩展</h3><hr><h4 id="1-字符的-Unicode-表示法"><a href="#1-字符的-Unicode-表示法" class="headerlink" title="1. 字符的 Unicode 表示法"></a>1. 字符的 Unicode 表示法</h4><p>ES6 加强了对 Unicode 的支持，允许采用<code>\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p><pre><code class="javascript">&quot;\u0061&quot;
// &quot;a&quot;
</code></pre><p>但是，这种表示法只限于码点在<code>\u0000</code>~`\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p><pre><code class="javascript">&quot;\uD842\uDFB7&quot;
// &quot;𠮷&quot;

&quot;\u20BB7&quot;
// &quot; 7&quot;
</code></pre><p>上面代码表示，如果直接在<code>\u</code>后面跟上超过<code>0xFFFF</code>的数值（比如<code>\u20BB7</code>），JavaScript 会理解成<code>\u20BB+7</code>。由于<code>\u20BB</code>是一个不可打印字符，所以只会显示一个空格，后面跟着一个<code>7</code>。</p><p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p><pre><code class="javascript">&quot;\u&#123;20BB7&#125;&quot;
// &quot;𠮷&quot;

&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;
// &quot;ABC&quot;

let hello = 123;
hell\u&#123;6F&#125; // 123

&#39;\u&#123;1F680&#125;&#39; === &#39;\uD83D\uDE80&#39;
// true
</code></pre><p>上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p><p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。</p><pre><code class="javascript">&#39;\z&#39; === &#39;z&#39;  // true
&#39;\172&#39; === &#39;z&#39; // true
&#39;\x7A&#39; === &#39;z&#39; // true
&#39;\u007A&#39; === &#39;z&#39; // true
&#39;\u&#123;7A&#125;&#39; === &#39;z&#39; // true
</code></pre><hr><h4 id="2-字符串的遍历器接口"><a href="#2-字符串的遍历器接口" class="headerlink" title="2. 字符串的遍历器接口"></a>2. 字符串的遍历器接口</h4><p>ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被<code>for...of</code>循环遍历。</p><pre><code class="javascript">for (let codePoint of &#39;foo&#39;) &#123;
  console.log(codePoint)
&#125;
// &quot;f&quot;
// &quot;o&quot;
// &quot;o&quot;
</code></pre><p>除了遍历字符串，这个遍历器最大的优点是可以识别大于<code>0xFFFF</code>的码点，传统的<code>for</code>循环无法识别这样的码点。</p><pre><code class="javascript">let text = String.fromCodePoint(0x20BB7);

for (let i = 0; i &lt; text.length; i++) &#123;
  console.log(text[i]);
&#125;
// &quot; &quot;
// &quot; &quot;

for (let i of text) &#123;
  console.log(i);
&#125;
// &quot;𠮷&quot;
</code></pre><p>上面代码中，字符串<code>text</code>只有一个字符，但是<code>for</code>循环会认为它包含两个字符（都不可打印），而<code>for...of</code>循环会正确识别出这一个字符。</p><hr><h4 id="3-模板字符串"><a href="#3-模板字符串" class="headerlink" title="3. 模板字符串"></a>3. 模板字符串</h4><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p><pre><code class="javascript">// 普通字符串
`In JavaScript &#39;\n&#39; is a line-feed.`

// 多行字符串
`In JavaScript this is
 not legal.`

console.log(`string text line 1
string text line 2`);

// 字符串中嵌入变量
let name = &quot;Bob&quot;, time = &quot;today&quot;;
`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`
</code></pre><p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p><pre><code class="javascript">let greeting = `\`Yo\` World!`;
</code></pre><p>所有模板字符串的空格和换行，都是被保留的，比如<code>&lt;ul&gt;</code>标签前面会有一个换行。如果你不想要这个换行，可以使用<code>trim</code>方法消除它。</p><pre><code class="javascript">$(&#39;#list&#39;).html(`
&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;
`.trim());
</code></pre><p><strong>模板字符串中嵌入变量，需要将变量名写在<code>$&#123;&#125;</code>之中。</strong></p><pre><code class="javascript">function authorize(user, action) &#123;
  if (!user.hasPrivilege(action)) &#123;
    throw new Error(
      // 传统写法为
      // &#39;User &#39;
      // + user.name
      // + &#39; is not authorized to do &#39;
      // + action
      // + &#39;.&#39;
      `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`);
  &#125;
&#125;
</code></pre><p><strong>大括号内部可以放入任意的 JavaScript 表达式</strong>，可以进行运算，以及引用对象属性。</p><pre><code class="javascript">let x = 1;
let y = 2;

`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`
// &quot;1 + 2 = 3&quot;

`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`
// &quot;1 + 4 = 5&quot;

let obj = &#123;x: 1, y: 2&#125;;
`$&#123;obj.x + obj.y&#125;`
// &quot;3&quot;
</code></pre><p><strong>模板字符串之中还能调用函数</strong>。</p><pre><code class="javascript">function fn() &#123;
  return &quot;Hello World&quot;;
&#125;

`foo $&#123;fn()&#125; bar`
// foo Hello World bar
</code></pre><p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法。</p><p>如果模板字符串中的变量没有声明，将报错。</p><pre><code class="javascript">// 变量place没有声明
let msg = `Hello, $&#123;place&#125;`;
// 报错
</code></pre><p>由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。</p><pre><code class="javascript">`Hello $&#123;&#39;World&#39;&#125;`
// &quot;Hello World&quot;
</code></pre><p>模板字符串甚至还能嵌套。</p><pre><code class="javascript">const tmpl = addrs =&gt; `
  &lt;table&gt;
  $&#123;addrs.map(addr =&gt; `
    &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt;
  `).join(&#39;&#39;)&#125;
  &lt;/table&gt;
`;
</code></pre><p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。</p><pre><code class="javascript">const data = [
    &#123; first: &#39;&lt;Jane&gt;&#39;, last: &#39;Bond&#39; &#125;,
    &#123; first: &#39;Lars&#39;, last: &#39;&lt;Croft&gt;&#39; &#125;,
];

console.log(tmpl(data));
// &lt;table&gt;
//
//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;
//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;
//
//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;
//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;
//
// &lt;/table&gt;
</code></pre><p>如果需要引用模板字符串本身，在需要时执行，可以写成函数。</p><pre><code class="javascript">let func = (name) =&gt; `Hello $&#123;name&#125;!`;
func(&#39;Jack&#39;) // &quot;Hello Jack!&quot;
</code></pre><p>上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。</p><hr><h4 id="4-实例：模板编译"><a href="#4-实例：模板编译" class="headerlink" title="4. 实例：模板编译"></a>4. 实例：模板编译</h4><p>下面，我们来看一个通过模板字符串，生成正式模板的实例。</p><pre><code class="javascript">let template = `
&lt;ul&gt;
  &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt;
    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;
  &lt;% &#125; %&gt;
&lt;/ul&gt;
`;
</code></pre><p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用<code>&lt;%...%&gt;</code>放置 JavaScript 代码，使用<code>&lt;%= ... %&gt;</code>输出 JavaScript 表达式。</p><p>怎么编译这个模板字符串呢？</p><p>一种思路是将其转换为 JavaScript 表达式字符串。</p><pre><code class="javascript">echo(&#39;&lt;ul&gt;&#39;);
for(let i=0; i &lt; data.supplies.length; i++) &#123;
  echo(&#39;&lt;li&gt;&#39;);
  echo(data.supplies[i]);
  echo(&#39;&lt;/li&gt;&#39;);
&#125;;
echo(&#39;&lt;/ul&gt;&#39;);
</code></pre><p>这个转换使用正则表达式就行了。</p><pre><code class="javascript">let evalExpr = /&lt;%=(.+?)%&gt;/g;
let expr = /&lt;%([\s\S]+?)%&gt;/g;

template = template
  .replace(evalExpr, &#39;`); \n  echo( $1 ); \n  echo(`&#39;)
  .replace(expr, &#39;`); \n $1 \n  echo(`&#39;);

template = &#39;echo(`&#39; + template + &#39;`);&#39;;
</code></pre><p>然后，将<code>template</code>封装在一个函数里面返回，就可以了。</p><pre><code class="javascript">let script =
`(function parse(data)&#123;
  let output = &quot;&quot;;

  function echo(html)&#123;
    output += html;
  &#125;

  $&#123; template &#125;

  return output;
&#125;)`;

return script;
</code></pre><p>将上面的内容拼装成一个模板编译函数<code>compile</code>。</p><pre><code class="javascript">function compile(template)&#123;
  const evalExpr = /&lt;%=(.+?)%&gt;/g;
  const expr = /&lt;%([\s\S]+?)%&gt;/g;

  template = template
    .replace(evalExpr, &#39;`); \n  echo( $1 ); \n  echo(`&#39;)
    .replace(expr, &#39;`); \n $1 \n  echo(`&#39;);

  template = &#39;echo(`&#39; + template + &#39;`);&#39;;

  let script =
  `(function parse(data)&#123;
    let output = &quot;&quot;;

    function echo(html)&#123;
      output += html;
    &#125;

    $&#123; template &#125;

    return output;
  &#125;)`;

  return script;
&#125;
</code></pre><p><code>compile</code>函数的用法如下。</p><pre><code class="javascript">let parse = eval(compile(template));
div.innerHTML = parse(&#123; supplies: [ &quot;broom&quot;, &quot;mop&quot;, &quot;cleaner&quot; ] &#125;);
//   &lt;ul&gt;
//     &lt;li&gt;broom&lt;/li&gt;
//     &lt;li&gt;mop&lt;/li&gt;
//     &lt;li&gt;cleaner&lt;/li&gt;
//   &lt;/ul&gt;
</code></pre><hr><h4 id="5-标签模板"><a href="#5-标签模板" class="headerlink" title="5. 标签模板"></a>5. 标签模板</h4><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p><pre><code class="javascript">alert`hello`
// 等同于
alert([&#39;hello&#39;])
</code></pre><p>标签模板其实不是模板，<strong>而是函数调用的一种特殊形式</strong>。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p><p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p><pre><code class="javascript">let a = 5;
let b = 10;

tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;
// 等同于
tag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 15, 50);
</code></pre><p>上面代码中，模板字符串前面有一个标识名<code>tag</code>，它是一个函数。整个表达式的返回值，就是<code>tag</code>函数处理模板字符串后的返回值。</p><p>函数<code>tag</code>依次会接收到多个参数。</p><pre><code class="javascript">function tag(stringArr, value1, value2)&#123;
  // ...
&#125;

// 等同于

function tag(stringArr, ...values)&#123;
  // ...
&#125;
</code></pre><p><code>tag</code>函数的第一个参数是一个数组，<strong>该数组的成员是模板字符串中那些没有变量替换的部分</strong>，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p><p><code>tag</code>函数的其他参数，都是<strong>模板字符串各个变量被替换后的值</strong>。由于本例中，模板字符串含有两个变量，因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数。</p><p><code>tag</code>函数所有参数的实际值如下。</p><ul><li>第一个参数：<code>[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;]</code></li><li>第二个参数: 15</li><li>第三个参数：50</li></ul><p>我们可以按照需要编写<code>tag</code>函数的代码。下面是<code>tag</code>函数的一种写法，以及运行结果。</p><pre><code class="javascript">let a = 5;
let b = 10;

function tag(s, v1, v2) &#123;
  console.log(s[0]);
  console.log(s[1]);
  console.log(s[2]);
  console.log(v1);
  console.log(v2);

  return &quot;OK&quot;;
&#125;

tag`Hello $&#123; a + b &#125; world $&#123; a * b&#125;`;
// &quot;Hello &quot;
// &quot; world &quot;
// &quot;&quot;
// 15
// 50
// &quot;OK&quot;
</code></pre><p>下面是一个更复杂的例子。</p><pre><code class="javascript">let total = 30;
let msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;

function passthru(literals) &#123;
  let result = &#39;&#39;;
  let i = 0;
//literals是形参 要求传入 arguments是实参 实际传入
  while (i &lt; literals.length) &#123;
    result += literals[i++];
    if (i &lt; arguments.length) &#123;
      result += arguments[i];
    &#125;
  &#125;

  return result;
&#125;

msg // &quot;The total is 30 (31.5 with tax)&quot;
</code></pre><p>上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。</p><p><code>passthru</code>函数采用 rest 参数的写法如下。</p><pre><code class="javascript">function passthru(literals, ...values) &#123;
  let output = &quot;&quot;;
  let index;
  for (index = 0; index &lt; values.length; index++) &#123;
    output += literals[index] + values[index];
  &#125;

  output += literals[index]
  return output;
&#125;
</code></pre><p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p><pre><code class="javascript">let message =
  SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;

function SaferHTML(templateData) &#123;
  let s = templateData[0];
  for (let i = 1; i &lt; arguments.length; i++) &#123;
    let arg = String(arguments[i]);

    // Escape special characters in the substitution.
    s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;)
            .replace(/&lt;/g, &quot;&amp;lt;&quot;)
            .replace(/&gt;/g, &quot;&amp;gt;&quot;);

    // Don&#39;t escape special characters in the template.
    s += templateData[i];
  &#125;
  return s;
&#125;
</code></pre><p>上面代码中，<code>sender</code>变量往往是用户提供的，经过<code>SaferHTML</code>函数处理，里面的特殊字符都会被转义。</p><pre><code class="javascript">let sender = &#39;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#39;; // 恶意代码
let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;

message
// &lt;p&gt;&amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;
</code></pre><p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p><pre><code class="javascript">i18n`Welcome to $&#123;siteName&#125;, you are visitor number $&#123;visitorNumber&#125;!`
// &quot;欢迎访问xxx，您是第xxxx位访问者！&quot;
</code></pre><p>模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。</p><pre><code class="javascript">// 下面的hashTemplate函数
// 是一个自定义的模板处理函数
let libraryHtml = hashTemplate`
  &lt;ul&gt;
    #for book in $&#123;myBooks&#125;
      &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;
    #end
  &lt;/ul&gt;
`;
</code></pre><p>模板处理函数的第一个参数（模板字符串数组），还有一个<code>raw</code>属性。</p><pre><code class="javascript">console.log`123`
// [&quot;123&quot;, raw: Array[1]]
</code></pre><p>上面代码中，<code>console.log</code>接受的参数，实际上是一个数组。该数组有一个<code>raw</code>属性，保存的是转义后的原字符串。</p><p>请看下面的例子。</p><pre><code class="javascript">tag`First line\nSecond line`

function tag(strings) &#123;
  console.log(strings.raw[0]);
  // strings.raw[0] 为 &quot;First line\\nSecond line&quot;
  // 打印输出 &quot;First line\nSecond line&quot;
&#125;
</code></pre><h3 id="4、字符串的新增方法"><a href="#4、字符串的新增方法" class="headerlink" title="4、字符串的新增方法"></a>4、字符串的新增方法</h3><hr><h4 id="1-String-fromCodePoint"><a href="#1-String-fromCodePoint" class="headerlink" title="1. String.fromCodePoint()"></a>1. String.fromCodePoint()</h4><p>ES5 提供<code>String.fromCharCode()</code>方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符。</p><pre><code class="javascript">String.fromCharCode(0x20BB7)
// &quot;ஷ&quot;
</code></pre><p>上面代码中，<code>String.fromCharCode()</code>不能识别大于<code>0xFFFF</code>的码点，所以<code>0x20BB7</code>就发生了溢出，最高位<code>2</code>被舍弃了，最后返回码点<code>U+0BB7</code>对应的字符，而不是码点<code>U+20BB7</code>对应的字符。</p><p><strong>ES6 提供了<code>String.fromCodePoint()</code>方法，可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode()</code>方法的不足。在作用上，正好与下面的<code>codePointAt()</code>方法相反。</strong></p><pre><code class="javascript">String.fromCodePoint(0x20BB7)
// &quot;𠮷&quot;
String.fromCodePoint(0x78, 0x1f680, 0x79) === &#39;x\uD83D\uDE80y&#39;
// true
</code></pre><p>上面代码中，如果<code>String.fromCodePoint</code>方法有多个参数，则它们会被合并成一个字符串返回。</p><p>注意，<code>fromCodePoint</code>方法定义在<code>String</code>对象上，而<code>codePointAt</code>方法定义在字符串的实例对象上。</p><hr><h4 id="2-String-raw"><a href="#2-String-raw" class="headerlink" title="2. String.raw()"></a>2. String.raw()</h4><p>ES6 还为原生的 String 对象，<strong>提供了一个<code>raw()</code>方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</strong></p><pre><code class="javascript">String.raw`Hi\n$&#123;2+3&#125;!`
// 实际返回 &quot;Hi\\n5!&quot;，显示的是转义后的结果 &quot;Hi\n5!&quot;

String.raw`Hi\u000A!`;
// 实际返回 &quot;Hi\\u000A!&quot;，显示的是转义后的结果 &quot;Hi\u000A!&quot;
</code></pre><p>如果原字符串的斜杠已经转义，那么<code>String.raw()</code>会进行再次转义。</p><pre><code class="javascript">String.raw`Hi\\n`
// 返回 &quot;Hi\\\\n&quot;

String.raw`Hi\\n` === &quot;Hi\\\\n&quot; // true
</code></pre><p><code>String.raw()</code>方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p><p><code>String.raw()</code>本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组，对应模板字符串解析后的值。</p><pre><code class="javascript">// `foo$&#123;1 + 2&#125;bar`
// 等同于
String.raw(&#123; raw: [&#39;foo&#39;, &#39;bar&#39;] &#125;, 1 + 2) // &quot;foo3bar&quot;
</code></pre><p>上面代码中，<code>String.raw()</code>方法的第一个参数是一个对象，它的<code>raw</code>属性等同于原始的模板字符串解析后得到的数组。</p><p>作为函数，<code>String.raw()</code>的代码实现基本如下。</p><pre><code class="javascript">String.raw = function (strings, ...values) &#123;
  let output = &#39;&#39;;
  let index;
  for (index = 0; index &lt; values.length; index++) &#123;
    output += strings.raw[index] + values[index];
  &#125;

  output += strings.raw[index]
  return output;
&#125;
</code></pre><hr><h4 id="3-实例方法：codePointAt"><a href="#3-实例方法：codePointAt" class="headerlink" title="3. 实例方法：codePointAt()"></a>3. 实例方法：codePointAt()</h4><p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为<code>2</code>个字节。对于那些需要<code>4</code>个字节储存的字符（Unicode 码点大于<code>0xFFFF</code>的字符），JavaScript 会认为它们是两个字符。</p><pre><code class="javascript">var s = &quot;𠮷&quot;;

s.length // 2
s.charAt(0) // &#39;&#39;
s.charAt(1) // &#39;&#39;
s.charCodeAt(0) // 55362
s.charCodeAt(1) // 57271
</code></pre><p>上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是<code>0x20BB7</code>，UTF-16 编码为<code>0xD842 0xDFB7</code>（十进制为<code>55362 57271</code>），<strong>需要<code>4</code>个字节储存</strong>。对于这种<code>4</code>个字节的字符，JavaScript 不能正确处理，字符串长度会误判为<code>2</code>，而且<code>charAt()</code>方法无法读取整个字符，<code>charCodeAt()</code>方法只能分别返回前两个字节和后两个字节的值。</p><p><strong>ES6 提供了<code>codePointAt()</code>方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</strong></p><pre><code class="javascript">let s = &#39;𠮷a&#39;;

s.codePointAt(0) // 134071
s.codePointAt(1) // 57271

s.codePointAt(2) // 97
</code></pre><p><code>codePointAt()</code>方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的<code>20BB7</code>）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，<code>codePointAt()</code>方法的结果与<code>charCodeAt()</code>方法相同。</p><p>总之，<code>codePointAt()</code>方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与<code>charCodeAt()</code>方法相同。</p><p><code>codePointAt()</code>方法返回的是码点的十进制值，如果想要十六进制的值，可以使用<code>toString()</code>方法转换一下。</p><pre><code class="javascript">let s = &#39;𠮷a&#39;;

s.codePointAt(0).toString(16) // &quot;20bb7&quot;
s.codePointAt(2).toString(16) // &quot;61&quot;
</code></pre><p>你可能注意到了，<code>codePointAt()</code>方法的参数，仍然是不正确的。比如，上面代码中，字符<code>a</code>在字符串<code>s</code>的正确位置序号应该是 1，但是必须向<code>codePointAt()</code>方法传入 2。解决这个问题的一个办法是使用<code>for...of</code>循环，因为它会正确识别 32 位的 UTF-16 字符。</p><pre><code class="javascript">let s = &#39;𠮷a&#39;;
for (let ch of s) &#123;
  console.log(ch.codePointAt(0).toString(16));
&#125;
// 20bb7
// 61
</code></pre><p>另一种方法也可以，使用扩展运算符（<code>...</code>）进行展开运算。</p><pre><code class="javascript">let arr = [...&#39;𠮷a&#39;]; // arr.length === 2
arr.forEach(
  ch =&gt; console.log(ch.codePointAt(0).toString(16))
);
// 20bb7
// 61
</code></pre><p><code>codePointAt()</code>方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p><pre><code class="javascript">function is32Bit(c) &#123;
  return c.codePointAt(0) &gt; 0xFFFF;
&#125;

is32Bit(&quot;𠮷&quot;) // true
is32Bit(&quot;a&quot;) // false
</code></pre><h4 id="4-实例方法：normalize"><a href="#4-实例方法：normalize" class="headerlink" title="4. 实例方法：normalize()"></a>4. 实例方法：normalize()</h4><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如<code>Ǒ</code>（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如<code>O</code>（\u004F）和<code>ˇ</code>（\u030C）合成<code>Ǒ</code>（\u004F\u030C）。</p><p>这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。</p><pre><code class="javascript">&#39;\u01D1&#39;===&#39;\u004F\u030C&#39; //false

&#39;\u01D1&#39;.length // 1
&#39;\u004F\u030C&#39;.length // 2
</code></pre><p>上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。</p><p><strong>ES6 提供字符串实例的<code>normalize()</code>方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</strong></p><pre><code class="javascript">&#39;\u01D1&#39;.normalize() === &#39;\u004F\u030C&#39;.normalize()
// true
</code></pre><p><code>normalize</code>方法可以接受一个参数来指定<code>normalize</code>的方式，参数的四个可选值如下。</p><ul><li><code>NFC</code>，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</li><li><code>NFD</code>，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</li><li><code>NFKC</code>，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，<code>normalize</code>方法不能识别中文。）</li><li><code>NFKD</code>，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</li></ul><pre><code class="javascript">&#39;\u004F\u030C&#39;.normalize(&#39;NFC&#39;).length // 1
&#39;\u004F\u030C&#39;.normalize(&#39;NFD&#39;).length // 2
</code></pre><p>上面代码表示，<code>NFC</code>参数返回字符的合成形式，<code>NFD</code>参数返回字符的分解形式。</p><p>不过，<code>normalize</code>方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断</p><hr><h4 id="5-实例方法：includes-startsWith-endsWith"><a href="#5-实例方法：includes-startsWith-endsWith" class="headerlink" title="5. 实例方法：includes(), startsWith(), endsWith()"></a>5. 实例方法：includes(), startsWith(), endsWith()</h4><p><strong>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</strong></p><ul><li>**includes()**：返回布尔值，表示是否找到了参数字符串。</li><li>**startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li>**endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><pre><code class="javascript">let s = &#39;Hello world!&#39;;

s.startsWith(&#39;Hello&#39;) // true
s.endsWith(&#39;!&#39;) // true
s.includes(&#39;o&#39;) // true
</code></pre><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p><pre><code class="javascript">let s = &#39;Hello world!&#39;;

s.startsWith(&#39;world&#39;, 6) // true
s.endsWith(&#39;Hello&#39;, 5) // true
s.includes(&#39;Hello&#39;, 6) // false
</code></pre><p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p><hr><h4 id="6-实例方法：repeat"><a href="#6-实例方法：repeat" class="headerlink" title="6. 实例方法：repeat()"></a>6. 实例方法：repeat()</h4><p><strong><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</strong></p><pre><code class="javascript">&#39;x&#39;.repeat(3) // &quot;xxx&quot;
&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;
&#39;na&#39;.repeat(0) // &quot;&quot;
</code></pre><p>参数如果是小数，会被取整。</p><pre><code class="javascript">&#39;na&#39;.repeat(2.9) // &quot;nana&quot;
</code></pre><p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。</p><pre><code class="javascript">&#39;na&#39;.repeat(Infinity)
// RangeError
&#39;na&#39;.repeat(-1)
// RangeError
</code></pre><p>但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为 0。</p><pre><code class="javascript">&#39;na&#39;.repeat(-0.9) // &quot;&quot;
</code></pre><p>参数<code>NaN</code>等同于 0。</p><pre><code class="javascript">&#39;na&#39;.repeat(NaN) // &quot;&quot;
</code></pre><p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。</p><pre><code class="javascript">&#39;na&#39;.repeat(&#39;na&#39;) // &quot;&quot;
&#39;na&#39;.repeat(&#39;3&#39;) // &quot;nanana&quot;
</code></pre><hr><h4 id="7-实例方法：padStart-，padEnd"><a href="#7-实例方法：padStart-，padEnd" class="headerlink" title="7. 实例方法：padStart()，padEnd()"></a>7. 实例方法：padStart()，padEnd()</h4><p><strong>ES2017 引入了字符串补全长度的功能</strong>。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p><pre><code class="javascript">&#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39;
&#39;x&#39;.padStart(4, &#39;ab&#39;) // &#39;abax&#39;

&#39;x&#39;.padEnd(5, &#39;ab&#39;) // &#39;xabab&#39;
&#39;x&#39;.padEnd(4, &#39;ab&#39;) // &#39;xaba&#39;
</code></pre><p>上面代码中，<code>padStart()</code>和<code>padEnd()</code>一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。</p><p>如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。</p><pre><code class="javascript">&#39;xxx&#39;.padStart(2, &#39;ab&#39;) // &#39;xxx&#39;
&#39;xxx&#39;.padEnd(2, &#39;ab&#39;) // &#39;xxx&#39;
</code></pre><p>如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。</p><pre><code class="javascript">&#39;abc&#39;.padStart(10, &#39;0123456789&#39;)
// &#39;0123456abc&#39;
</code></pre><p>如果省略第二个参数，默认使用空格补全长度。</p><pre><code class="javascript">&#39;x&#39;.padStart(4) // &#39;   x&#39;
&#39;x&#39;.padEnd(4) // &#39;x   &#39;
</code></pre><p><code>padStart()</code>的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</p><pre><code class="javascript">&#39;1&#39;.padStart(10, &#39;0&#39;) // &quot;0000000001&quot;
&#39;12&#39;.padStart(10, &#39;0&#39;) // &quot;0000000012&quot;
&#39;123456&#39;.padStart(10, &#39;0&#39;) // &quot;0000123456&quot;
</code></pre><p>另一个用途是提示字符串格式。</p><pre><code class="javascript">&#39;12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-MM-12&quot;
&#39;09-12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-09-12&quot;
</code></pre><hr><h4 id="8-实例方法：trimStart-，trimEnd"><a href="#8-实例方法：trimStart-，trimEnd" class="headerlink" title="8. 实例方法：trimStart()，trimEnd()"></a>8. 实例方法：trimStart()，trimEnd()</h4><p><strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbQ==">ES2019</span> 对字符串实例新增了<code>trimStart()</code>和<code>trimEnd()</code>这两个方法。</strong>它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</p><pre><code class="javascript">const s = &#39;  abc  &#39;;

s.trim() // &quot;abc&quot;
s.trimStart() // &quot;abc  &quot;
s.trimEnd() // &quot;  abc&quot;
</code></pre><p>上面代码中，<code>trimStart()</code>只消除头部的空格，保留尾部的空格。<code>trimEnd()</code>也是类似行为。</p><p>除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。</p><p>浏览器还部署了额外的两个方法，<code>trimLeft()</code>是<code>trimStart()</code>的别名，<code>trimRight()</code>是<code>trimEnd()</code>的别名。</p><hr><h4 id="9-实例方法：matchAll"><a href="#9-实例方法：matchAll" class="headerlink" title="9. 实例方法：matchAll()"></a>9. 实例方法：matchAll()</h4><p><code>matchAll()</code>方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。</p><hr><h4 id="10-实例方法：replaceAll"><a href="#10-实例方法：replaceAll" class="headerlink" title="10. 实例方法：replaceAll()"></a>10. 实例方法：replaceAll()</h4><p>之前，字符串的实例方法<code>replace()</code>只能替换第一个匹配。</p><pre><code class="javascript">&#39;aabbcc&#39;.replace(&#39;b&#39;, &#39;_&#39;)
// &#39;aa_bcc&#39;
</code></pre><p>上面例子中，<code>replace()</code>只将第一个<code>b</code>替换成了下划线。</p><p>如果要替换所有的匹配，不得不使用正则表达式的<code>g</code>修饰符。</p><pre><code class="javascript">&#39;aabbcc&#39;.replace(/b/g, &#39;_&#39;)
// &#39;aa__cc&#39;
</code></pre><p>正则表达式毕竟不是那么方便和直观，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXJlcGxhY2VhbGw=">ES2021</span> 引入了<code>replaceAll()</code>方法，可以一次性替换所有匹配。</p><pre><code class="javascript">&#39;aabbcc&#39;.replaceAll(&#39;b&#39;, &#39;_&#39;)
// &#39;aa__cc&#39;
</code></pre><p>它的用法与<code>replace()</code>相同，返回一个新字符串，不会改变原字符串。</p><pre><code class="javascript">String.prototype.replaceAll(searchValue, replacement)
</code></pre><p>上面代码中，<code>searchValue</code>是搜索模式，可以是一个字符串，也可以是一个全局的正则表达式（带有<code>g</code>修饰符）。</p><p>如果<code>searchValue</code>是一个不带有<code>g</code>修饰符的正则表达式，<code>replaceAll()</code>会报错。这一点跟<code>replace()</code>不同。</p><pre><code class="javascript">// 不报错
&#39;aabbcc&#39;.replace(/b/, &#39;_&#39;)

// 报错
&#39;aabbcc&#39;.replaceAll(/b/, &#39;_&#39;)
</code></pre><p>上面例子中，<code>/b/</code>不带有<code>g</code>修饰符，会导致<code>replaceAll()</code>报错。</p><p><code>replaceAll()</code>的第二个参数<code>replacement</code>是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。</p><ul><li><code>$&amp;</code>：匹配的字符串。</li><li><code>$</code> `：匹配结果前面的文本。</li><li><code>$&#39;</code>：匹配结果后面的文本。</li><li><code>$n</code>：匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式。</li><li><code>$$</code>：指代美元符号<code>$</code>。</li></ul><p>下面是一些例子。</p><pre><code class="javascript">// $&amp; 表示匹配的字符串，即`b`本身
// 所以返回结果与原字符串一致
&#39;abbc&#39;.replaceAll(&#39;b&#39;, &#39;$&amp;&#39;)
// &#39;abbc&#39;

// $` 表示匹配结果之前的字符串
// 对于第一个`b`，$` 指代`a`
// 对于第二个`b`，$` 指代`ab`
&#39;abbc&#39;.replaceAll(&#39;b&#39;, &#39;$`&#39;)
// &#39;aaabc&#39;

// $&#39; 表示匹配结果之后的字符串
// 对于第一个`b`，$&#39; 指代`bc`
// 对于第二个`b`，$&#39; 指代`c`
&#39;abbc&#39;.replaceAll(&#39;b&#39;, `$&#39;`)
// &#39;abccc&#39;

// $1 表示正则表达式的第一个组匹配，指代`ab`
// $2 表示正则表达式的第二个组匹配，指代`bc`
&#39;abbc&#39;.replaceAll(/(ab)(bc)/g, &#39;$2$1&#39;)
// &#39;bcab&#39;

// $$ 指代 $
&#39;abc&#39;.replaceAll(&#39;b&#39;, &#39;$$&#39;)
// &#39;a$c&#39;
</code></pre><p><code>replaceAll()</code>的第二个参数<code>replacement</code>除了为字符串，也可以是一个函数，该函数的返回值将替换掉第一个参数<code>searchValue</code>匹配的文本。</p><pre><code class="javascript">&#39;aabbcc&#39;.replaceAll(&#39;b&#39;, () =&gt; &#39;_&#39;)
// &#39;aa__cc&#39;
</code></pre><p>上面例子中，<code>replaceAll()</code>的第二个参数是一个函数，该函数的返回值会替换掉所有<code>b</code>的匹配。</p><p>这个替换函数可以接受多个参数。第一个参数是捕捉到的匹配内容，第二个参数捕捉到是组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。</p><pre><code class="javascript">const str = &#39;123abc456&#39;;
const regex = /(\d+)([a-z]+)(\d+)/g;

function replacer(match, p1, p2, p3, offset, string) &#123;
  return [p1, p2, p3].join(&#39; - &#39;);
&#125;

str.replaceAll(regex, replacer)
// 123 - abc - 456
</code></pre><p>上面例子中，正则表达式有三个组匹配，所以<code>replacer()</code>函数的第一个参数<code>match</code>是捕捉到的匹配内容（即字符串<code>123abc456</code>），后面三个参数<code>p1</code>、<code>p2</code>、<code>p3</code>则依次为三个组匹配。</p><h3 id="5、正则的扩展"><a href="#5、正则的扩展" class="headerlink" title="5、正则的扩展"></a>5、正则的扩展</h3><hr><h4 id="1-RegExp-构造函数"><a href="#1-RegExp-构造函数" class="headerlink" title="1. RegExp 构造函数"></a>1. RegExp 构造函数</h4><p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况。</p><p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p><pre><code class="javascript">var regex = new RegExp(&#39;xyz&#39;, &#39;i&#39;);
// 等价于
var regex = /xyz/i;
</code></pre><p>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</p><pre><code class="javascript">var regex = new RegExp(/xyz/i);
// 等价于
var regex = /xyz/i;
</code></pre><p>但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。</p><pre><code class="javascript">var regex = new RegExp(/xyz/, &#39;i&#39;);
// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another
</code></pre><p>ES6 改变了这种行为。如果<code>RegExp</code>构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p><pre><code class="javascript">new RegExp(/abc/ig, &#39;i&#39;).flags
// &quot;i&quot;
</code></pre><p>上面代码中，原有正则对象的修饰符是<code>ig</code>，它会被第二个参数<code>i</code>覆盖</p><hr><h4 id="2-字符串的正则方法"><a href="#2-字符串的正则方法" class="headerlink" title="2. 字符串的正则方法"></a>2. 字符串的正则方法</h4><p>ES6 出现之前，字符串对象共有 4 个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p><p>ES6 将这 4 个方法，在语言内部全部调用<code>RegExp</code>的实例方法，从而做到所有与正则相关的方法，全都定义在<code>RegExp</code>对象上。</p><ul><li><code>String.prototype.match</code> 调用 <code>RegExp.prototype[Symbol.match]</code></li><li><code>String.prototype.replace</code> 调用 <code>RegExp.prototype[Symbol.replace]</code></li><li><code>String.prototype.search</code> 调用 <code>RegExp.prototype[Symbol.search]</code></li><li><code>String.prototype.split</code> 调用 <code>RegExp.prototype[Symbol.split]</code></li></ul><hr><h4 id="3-u修饰符"><a href="#3-u修饰符" class="headerlink" title="3. u修饰符"></a>3. u修饰符</h4><p>ES6 对正则表达式添加了<code>u</code>修饰符，含义为“Unicode 模式”，用来正确处理大于<code>\uFFFF</code>的 Unicode 字符。也就是说，<strong>会正确处理四个字节的 UTF-16 编码。</strong></p><pre><code class="javascript">/^\uD83D/u.test(&#39;\uD83D\uDC2A&#39;) // false
/^\uD83D/.test(&#39;\uD83D\uDC2A&#39;) // true
</code></pre><p>上面代码中，<code>\uD83D\uDC2A</code>是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为<code>true</code>。加了<code>u</code>修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为<code>false</code>。</p><p>一旦加上<code>u</code>修饰符号，就会修改下面这些正则表达式的行为。</p><p><strong>（1）点字符</strong></p><p>点（<code>.</code>）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于<code>0xFFFF</code>的 Unicode 字符，点字符不能识别，<strong>必须加上<code>u</code>修饰符。</strong></p><pre><code class="javascript">var s = &#39;𠮷&#39;;

/^.$/.test(s) // false
/^.$/u.test(s) // true
</code></pre><p>上面代码表示，如果不添加<code>u</code>修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</p><p><strong>（2）Unicode 字符表示法</strong></p><p>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上<code>u</code>修饰符，才能识别当中的大括号，否则会被解读为量词。</p><pre><code class="javascript">/\u&#123;61&#125;/.test(&#39;a&#39;) // false
/\u&#123;61&#125;/u.test(&#39;a&#39;) // true
/\u&#123;20BB7&#125;/u.test(&#39;𠮷&#39;) // true
</code></pre><p>上面代码表示，如果不加<code>u</code>修饰符，正则表达式无法识别<code>\u&#123;61&#125;</code>这种表示法，只会认为这匹配 61 个连续的<code>u</code>。</p><p><strong>（3）量词</strong></p><p>使用<code>u</code>修饰符后，所有量词都会正确识别码点大于<code>0xFFFF</code>的 Unicode 字符。</p><pre><code class="javascript">/a&#123;2&#125;/.test(&#39;aa&#39;) // true
/a&#123;2&#125;/u.test(&#39;aa&#39;) // true
/𠮷&#123;2&#125;/.test(&#39;𠮷𠮷&#39;) // false
/𠮷&#123;2&#125;/u.test(&#39;𠮷𠮷&#39;) // true
</code></pre><p><strong>（4）预定义模式</strong></p><p><code>u</code>修饰符也影响到预定义模式，能否正确识别码点大于<code>0xFFFF</code>的 Unicode 字符。</p><pre><code class="javascript">/^\S$/.test(&#39;𠮷&#39;) // false
/^\S$/u.test(&#39;𠮷&#39;) // true
</code></pre><p>上面代码的<code>\S</code>是预定义模式，匹配所有非空白字符。只有加了<code>u</code>修饰符，它才能正确匹配码点大于<code>0xFFFF</code>的 Unicode 字符。</p><p>利用这一点，可以写出一个正确返回字符串长度的函数。</p><pre><code class="javascript">function codePointLength(text) &#123;
  var result = text.match(/[\s\S]/gu);
  return result ? result.length : 0;
&#125;

var s = &#39;𠮷𠮷&#39;;

s.length // 4
codePointLength(s) // 2
</code></pre><p><strong>（5）i 修饰符</strong></p><p>有些 Unicode 字符的编码不同，但是字型很相近，比如，<code>\u004B</code>与<code>\u212A</code>都是大写的<code>K</code>。</p><pre><code class="javascript">/[a-z]/i.test(&#39;\u212A&#39;) // false
/[a-z]/iu.test(&#39;\u212A&#39;) // true
</code></pre><p>上面代码中，不加<code>u</code>修饰符，就无法识别非规范的<code>K</code>字符。</p><p><strong>（6）转义</strong></p><p>没有<code>u</code>修饰符的情况下，正则中没有定义的转义（如逗号的转义<code>\,</code>）无效，而在<code>u</code>模式会报错。</p><pre><code class="javascript">/\,/ // /\,/
/\,/u // 报错
</code></pre><p>上面代码中，没有<code>u</code>修饰符时，逗号前面的反斜杠是无效的，加了<code>u</code>修饰符就报错。</p><hr><h4 id="4-RegExp-prototype-unicode-属性"><a href="#4-RegExp-prototype-unicode-属性" class="headerlink" title="4. RegExp.prototype.unicode 属性"></a>4. RegExp.prototype.unicode 属性</h4><p>正则实例对象新增<code>unicode</code>属性，表示是否设置了<code>u</code>修饰符。</p><pre><code class="javascript">const r1 = /hello/;
const r2 = /hello/u;

r1.unicode // false
r2.unicode // true
</code></pre><p>上面代码中，正则表达式是否设置了<code>u</code>修饰符，可以从<code>unicode</code>属性看出来</p><hr><h4 id="5-y-修饰符"><a href="#5-y-修饰符" class="headerlink" title="5. y 修饰符"></a>5. y 修饰符</h4><p>除了<code>u</code>修饰符，ES6 还为正则表达式添加了<code>y</code>修饰符，叫做“粘连”（sticky）修饰符。</p><p><code>y</code>修饰符的作用与<code>g</code>修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，**<code>g</code>修饰符只要剩余位置中存在匹配就可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始**，这也就是“粘连”的涵义。</p><pre><code class="javascript">var s = &#39;aaa_aa_a&#39;;
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // [&quot;aaa&quot;]
r2.exec(s) // [&quot;aaa&quot;]

r1.exec(s) // [&quot;aa&quot;]
r2.exec(s) // null
</code></pre><p>上面代码有两个正则表达式，一个使用<code>g</code>修饰符，另一个使用<code>y</code>修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是<code>_aa_a</code>。由于<code>g</code>修饰没有位置要求，所以第二次执行会返回结果，而<code>y</code>修饰符要求匹配必须从头部开始，所以返回<code>null</code>。</p><p>如果改一下正则表达式，保证每次都能头部匹配，<code>y</code>修饰符就会返回结果了。</p><pre><code class="javascript">var s = &#39;aaa_aa_a&#39;;
var r = /a+_/y;

r.exec(s) // [&quot;aaa_&quot;]
r.exec(s) // [&quot;aa_&quot;]
</code></pre><p>上面代码每次匹配，都是从剩余字符串的头部开始。</p><p><strong>实际上，<code>y</code>修饰符号隐含了头部匹配的标志<code>^</code>。</strong></p><pre><code class="javascript">/b/y.exec(&#39;aba&#39;)
// null
</code></pre><p>上面代码由于不能保证头部匹配，所以返回<code>null</code>。<code>y</code>修饰符的设计本意，就是让头部匹配的标志<code>^</code>在全局匹配中都有效。</p><p>单单一个<code>y</code>修饰符对<code>match</code>方法，只能返回第一个匹配，必须与<code>g</code>修饰符联用，才能返回所有匹配。</p><pre><code class="javascript">&#39;a1a2a3&#39;.match(/a\d/y) // [&quot;a1&quot;]
&#39;a1a2a3&#39;.match(/a\d/gy) // [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;]
</code></pre><p><code>y</code>修饰符的一个应用，是从字符串提取 token（词元），<code>y</code>修饰符确保了匹配之间不会有漏掉的字符。</p><pre><code class="javascript">const TOKEN_Y = /\s*(\+|[0-9]+)\s*/y;
const TOKEN_G  = /\s*(\+|[0-9]+)\s*/g;

tokenize(TOKEN_Y, &#39;3 + 4&#39;)
// [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ]
tokenize(TOKEN_G, &#39;3 + 4&#39;)
// [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ]

function tokenize(TOKEN_REGEX, str) &#123;
  let result = [];
  let match;
  while (match = TOKEN_REGEX.exec(str)) &#123;
    result.push(match[1]);
  &#125;
  return result;
&#125;
</code></pre><p>上面代码中，如果字符串里面没有非法字符，<code>y</code>修饰符与<code>g</code>修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。</p><pre><code class="javascript">tokenize(TOKEN_Y, &#39;3x + 4&#39;)
// [ &#39;3&#39; ]
tokenize(TOKEN_G, &#39;3x + 4&#39;)
// [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ]
</code></pre><p>上面代码中，<code>g</code>修饰符会忽略非法字符，而<code>y</code>修饰符不会，这样就很容易发现错误。</p><hr><h4 id="6-RegExp-prototype-sticky-属性"><a href="#6-RegExp-prototype-sticky-属性" class="headerlink" title="6. RegExp.prototype.sticky 属性"></a>6. RegExp.prototype.sticky 属性</h4><p>与<code>y</code>修饰符相匹配，ES6 的正则实例对象多了<code>sticky</code>属性，表示是否设置了<code>y</code>修饰符。</p><pre><code class="javascript">var r = /hello\d/y;
r.sticky // true
</code></pre><hr><h4 id="7-RegExp-prototype-flags-属性"><a href="#7-RegExp-prototype-flags-属性" class="headerlink" title="7. RegExp.prototype.flags 属性"></a>7. RegExp.prototype.flags 属性</h4><p>ES6 为正则表达式新增了<code>flags</code>属性，会返回正则表达式的修饰符。</p><pre><code class="javascript">// ES5 的 source 属性
// 返回正则表达式的正文
/abc/ig.source
// &quot;abc&quot;

// ES6 的 flags 属性
// 返回正则表达式的修饰符
/abc/ig.flags
// &#39;gi&#39;
</code></pre><hr><h4 id="8-s-修饰符：dotAll-模式"><a href="#8-s-修饰符：dotAll-模式" class="headerlink" title="8. s 修饰符：dotAll 模式"></a>8. s 修饰符：dotAll 模式</h4><p><strong>正则表达式中，点（<code>.</code>）是一个特殊字符，代表任意的单个字符，但是有两个例外</strong>。一个是四个字节的 UTF-16 字符，这个可以用<code>u</code>修饰符解决；另一个是行终止符（line terminator character）。</p><p>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。</p><ul><li>U+000A 换行符（<code>\n</code>）</li><li>U+000D 回车符（<code>\r</code>）</li><li>U+2028 行分隔符（line separator）</li><li>U+2029 段分隔符（paragraph separator）</li></ul><pre><code class="javascript">/foo.bar/.test(&#39;foo\nbar&#39;)
// false
</code></pre><p>上面代码中，因为<code>.</code>不匹配<code>\n</code>，所以正则表达式返回<code>false</code>。</p><p>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。</p><pre><code class="javascript">/foo[^]bar/.test(&#39;foo\nbar&#39;)
// true
</code></pre><p>这种解决方案毕竟不太符合直觉，ES2018 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcmVnZXhwLWRvdGFsbC1mbGFn">引入</span><code>s</code>修饰符，使得<code>.</code>可以匹配任意单个字符。</p><pre><code class="javascript">/foo.bar/s.test(&#39;foo\nbar&#39;) // true
</code></pre><p><strong>这被称为<code>dotAll</code>模式，即点（dot）代表一切字符</strong>。所以，正则表达式还引入了一个<code>dotAll</code>属性，返回一个布尔值，表示该正则表达式是否处在<code>dotAll</code>模式。</p><pre><code class="javascript">const re = /foo.bar/s;
// 另一种写法
// const re = new RegExp(&#39;foo.bar&#39;, &#39;s&#39;);

re.test(&#39;foo\nbar&#39;) // true
re.dotAll // true
re.flags // &#39;s&#39;
</code></pre><p><code>/s</code>修饰符和多行修饰符<code>/m</code>不冲突，两者一起使用的情况下，<code>.</code>匹配所有字符，而<code>^</code>和<code>$</code>匹配每一行的行首和行尾。</p><hr><h4 id="9-后行断言"><a href="#9-后行断言" class="headerlink" title="9. 后行断言"></a>9. 后行断言</h4><blockquote><p>JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcmVnZXhwLWxvb2tiZWhpbmQ=">后行断言</span>，V8 引擎 4.9 版（Chrome 62）已经支持。</p></blockquote><p>**“先行断言”指的是，<code>x</code>只有在<code>y</code>前面才匹配，必须写成<code>/x(?=y)/</code><strong>。比如，只匹配百分号之前的数字，要写成<code>/\d+(?=%)/</code>。</strong>“先行否定断言”指的是，<code>x</code>只有不在<code>y</code>前面才匹配，必须写成<code>/x(?!y)/</code>**。比如，只匹配不在百分号之前的数字，要写成<code>/\d+(?!%)/</code>。</p><pre><code class="javascript">/\d+(?=%)/.exec(&#39;100% of US presidents have been male&#39;)  // [&quot;100&quot;]
/\d+(?!%)/.exec(&#39;that’s all 44 of them&#39;)                 // [&quot;44&quot;]
</code></pre><p>上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（<code>(?=%)</code>），是不计入返回结果的。</p><p><strong>“后行断言”正好与“先行断言”相反，<code>x</code>只有在<code>y</code>后面才匹配，必须写成<code>/(?&lt;=y)x/</code><strong>。比如，只匹配美元符号之后的数字，要写成<code>/(?&lt;=\$)\d+/</code>。</strong>“后行否定断言”则与“先行否定断言”相反，<code>x</code>只有不在<code>y</code>后面才匹配，必须写成<code>/(?&lt;!y)x/</code>。</strong>比如，只匹配不在美元符号后面的数字，要写成<code>/(?&lt;!\$)\d+/</code>。</p><pre><code class="javascript">/(?&lt;=\$)\d+/.exec(&#39;Benjamin Franklin is on the $100 bill&#39;)  // [&quot;100&quot;]
/(?&lt;!\$)\d+/.exec(&#39;it’s is worth about €90&#39;)                // [&quot;90&quot;]
</code></pre><p>上面的例子中，“后行断言”的括号之中的部分（<code>(?&lt;=\$)</code>），也是不计入返回结果。</p><p>下面的例子是使用后行断言进行字符串替换。</p><pre><code class="javascript">const RE_DOLLAR_PREFIX = /(?&lt;=\$)foo/g;
&#39;$foo %foo foo&#39;.replace(RE_DOLLAR_PREFIX, &#39;bar&#39;);
// &#39;$bar %foo foo&#39;
</code></pre><p>上面代码中，只有在美元符号后面的<code>foo</code>才会被替换。</p><p><strong>“后行断言”的实现，需要先匹配<code>/(?&lt;=y)x/</code>的<code>x</code>，然后再回到左边，匹配<code>y</code>的部分</strong>。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。</p><p><strong>首先，后行断言的组匹配，与正常情况下结果是不一样的。</strong></p><pre><code class="javascript">/(?&lt;=(\d+)(\d+))$/.exec(&#39;1053&#39;) // [&quot;&quot;, &quot;1&quot;, &quot;053&quot;]
/^(\d+)(\d+)$/.exec(&#39;1053&#39;) // [&quot;1053&quot;, &quot;105&quot;, &quot;3&quot;]
</code></pre><p>上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是<code>105</code>和<code>3</code>。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是<code>1</code>和<code>053</code>。</p><p>其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。</p><pre><code class="javascript">/(?&lt;=(o)d\1)r/.exec(&#39;hodor&#39;)  // null
/(?&lt;=\1d(o))r/.exec(&#39;hodor&#39;)  // [&quot;r&quot;, &quot;o&quot;]
</code></pre><p>上面代码中，如果后行断言的反斜杠引用（<code>\1</code>）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。</p><hr><h4 id="10-Unicode-属性类"><a href="#10-Unicode-属性类" class="headerlink" title="10. Unicode 属性类"></a>10. Unicode 属性类</h4><p><strong>ES2018 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcmVnZXhwLXVuaWNvZGUtcHJvcGVydHktZXNjYXBlcw==">引入</span>了一种新的类的写法<code>\p&#123;...&#125;</code>和<code>\P&#123;...&#125;</code>，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</strong></p><pre><code class="javascript">const regexGreekSymbol = /\p&#123;Script=Greek&#125;/u;
regexGreekSymbol.test(&#39;π&#39;) // true
</code></pre><p>上面代码中，<code>\p&#123;Script=Greek&#125;</code>指定匹配一个希腊文字母，所以匹配<code>π</code>成功。</p><p>Unicode 属性类要指定属性名和属性值。</p><pre><code class="javascript">\p&#123;UnicodePropertyName=UnicodePropertyValue&#125;
</code></pre><p>对于某些属性，可以只写属性名，或者只写属性值。</p><pre><code class="javascript">\p&#123;UnicodePropertyName&#125;
\p&#123;UnicodePropertyValue&#125;
</code></pre><p><code>\P&#123;…&#125;</code>是<code>\p&#123;…&#125;</code>的反向匹配，即匹配不满足条件的字符。</p><p>注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上<code>u</code>修饰符。如果不加<code>u</code>修饰符，正则表达式使用<code>\p</code>和<code>\P</code>会报错，ECMAScript 预留了这两个类。</p><p>由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。</p><pre><code class="javascript">const regex = /^\p&#123;Decimal_Number&#125;+$/u;
regex.test(&#39;𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼&#39;) // true
</code></pre><p>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。</p><p><code>\p&#123;Number&#125;</code>甚至能匹配罗马数字。</p><pre><code class="javascript">// 匹配所有数字
const regex = /^\p&#123;Number&#125;+$/u;
regex.test(&#39;²³¹¼½¾&#39;) // true
regex.test(&#39;㉛㉜㉝&#39;) // true
regex.test(&#39;ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ&#39;) // true
</code></pre><p>下面是其他一些例子。</p><pre><code class="javascript">// 匹配所有空格
\p&#123;White_Space&#125;

// 匹配各种文字的所有字母，等同于 Unicode 版的 \w
[\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]

// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W
[^\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]

// 匹配 Emoji
/\p&#123;Emoji_Modifier_Base&#125;\p&#123;Emoji_Modifier&#125;?|\p&#123;Emoji_Presentation&#125;|\p&#123;Emoji&#125;\uFE0F/gu

// 匹配所有的箭头字符
const regexArrows = /^\p&#123;Block=Arrows&#125;+$/u;
regexArrows.test(&#39;←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩&#39;) // true
</code></pre><hr><h4 id="11-具名组匹配"><a href="#11-具名组匹配" class="headerlink" title="11. 具名组匹配"></a>11. 具名组匹配</h4><p><strong>简介</strong></p><p>正则表达式使用圆括号进行组匹配。</p><pre><code class="javascript">const RE_DATE = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;
</code></pre><p>上面代码中，正则表达式里面有三组圆括号。使用<code>exec</code>方法，就可以将这三组匹配结果提取出来。</p><pre><code class="javascript">const RE_DATE = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;

const matchObj = RE_DATE.exec(&#39;1999-12-31&#39;);
const year = matchObj[1]; // 1999
const month = matchObj[2]; // 12
const day = matchObj[3]; // 31
</code></pre><p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如<code>matchObj[1]</code>）引用，要是组的顺序变了，引用的时候就必须修改序号。</p><p>ES2018 引入了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcmVnZXhwLW5hbWVkLWdyb3Vwcw==">具名组匹配</span>（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p><pre><code class="javascript">const RE_DATE = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/;

const matchObj = RE_DATE.exec(&#39;1999-12-31&#39;);
const year = matchObj.groups.year; // &quot;1999&quot;
const month = matchObj.groups.month; // &quot;12&quot;
const day = matchObj.groups.day; // &quot;31&quot;
</code></pre><p>上面代码中，<strong>“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（<code>?&lt;year&gt;</code>）</strong>，然后就可以在<code>exec</code>方法返回结果的<code>groups</code>属性上引用该组名。同时，数字序号（<code>matchObj[1]</code>）依然有效。</p><p>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。</p><p>如果具名组没有匹配，那么对应的<code>groups</code>对象属性会是<code>undefined</code>。</p><pre><code class="javascript">const RE_OPT_A = /^(?&lt;as&gt;a+)?$/;
const matchObj = RE_OPT_A.exec(&#39;&#39;);

matchObj.groups.as // undefined
&#39;as&#39; in matchObj.groups // true
</code></pre><p>上面代码中，具名组<code>as</code>没有找到匹配，那么<code>matchObj.groups.as</code>属性值就是<code>undefined</code>，并且<code>as</code>这个键名在<code>groups</code>是始终存在的。</p><p><strong>解构赋值和替换</strong></p><p>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。</p><pre><code class="javascript">let &#123;groups: &#123;one, two&#125;&#125; = /^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u.exec(&#39;foo:bar&#39;);
one  // foo
two  // bar
</code></pre><p><strong>字符串替换时，使用<code>$&lt;组名&gt;</code>引用具名组。</strong></p><pre><code class="javascript">let re = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u;

&#39;2015-01-02&#39;.replace(re, &#39;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#39;)
// &#39;02/01/2015&#39;
</code></pre><p>上面代码中，<code>replace</code>方法的第二个参数是一个字符串，而不是正则表达式。</p><p><code>replace</code>方法的第二个参数也可以是函数，该函数的参数序列如下。</p><pre><code class="javascript">&#39;2015-01-02&#39;.replace(re, (
   matched, // 整个匹配结果 2015-01-02
   capture1, // 第一个组匹配 2015
   capture2, // 第二个组匹配 01
   capture3, // 第三个组匹配 02
   position, // 匹配开始的位置 0
   S, // 原字符串 2015-01-02
   groups // 具名组构成的一个对象 &#123;year, month, day&#125;
 ) =&gt; &#123;
 let &#123;day, month, year&#125; = groups;
 return `$&#123;day&#125;/$&#123;month&#125;/$&#123;year&#125;`;
&#125;);
</code></pre><p>具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。</p><p><strong>引用</strong></p><p><strong>如果要在正则表达式内部引用某个“具名组匹配”，可以使用<code>\k&lt;组名&gt;</code>的写法。</strong></p><pre><code class="javascript">const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/;
RE_TWICE.test(&#39;abc!abc&#39;) // true
RE_TWICE.test(&#39;abc!ab&#39;) // false
</code></pre><p>数字引用（<code>\1</code>）依然有效。</p><pre><code class="javascript">const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\1$/;
RE_TWICE.test(&#39;abc!abc&#39;) // true
RE_TWICE.test(&#39;abc!ab&#39;) // false
</code></pre><p>这两种引用语法还可以同时使用。</p><pre><code class="javascript">const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/;
RE_TWICE.test(&#39;abc!abc!abc&#39;) // true
RE_TWICE.test(&#39;abc!abc!ab&#39;) // false
</code></pre><h4 id="12-正则匹配索引"><a href="#12-正则匹配索引" class="headerlink" title="12. 正则匹配索引"></a>12. 正则匹配索引</h4><p>正则匹配结果的开始位置和结束位置，目前获取并不是很方便。正则实例的<code>exec()</code>方法，返回结果有一个<code>index</code>属性，可以获取整个匹配结果的开始位置，但是如果包含组匹配，每个组匹配的开始位置，很难拿到。</p><p>现在有一个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcmVnZXhwLW1hdGNoLUluZGljZXM=">第三阶段提案</span>，为<code>exec()</code>方法的返回结果加上<code>indices</code>属性，在这个属性上面可以拿到匹配的开始位置和结束位置。</p><pre><code class="javascript">const text = &#39;zabbcdef&#39;;
const re = /ab/;
const result = re.exec(text);

result.index // 1
result.indices // [ [1, 3] ]
</code></pre><p>上面例子中，<code>exec()</code>方法的返回结果<code>result</code>，它的<code>index</code>属性是整个匹配结果（<code>ab</code>）的开始位置，而它的<code>indices</code>属性是一个数组，成员是每个匹配的开始位置和结束位置的数组。由于该例子的正则表达式没有组匹配，所以<code>indices</code>数组只有一个成员，表示整个匹配的开始位置是<code>1</code>，结束位置是<code>3</code>。</p><p>注意，开始位置包含在匹配结果之中，但是结束位置不包含在匹配结果之中。比如，匹配结果为<code>ab</code>，分别是原始字符串的第1位和第2位，那么结束位置就是第3位。</p><p>如果正则表达式包含组匹配，那么<code>indices</code>属性对应的数组就会包含多个成员，提供每个组匹配的开始位置和结束位置。</p><pre><code class="javascript">const text = &#39;zabbcdef&#39;;
const re = /ab+(cd)/;
const result = re.exec(text);

result.indices // [ [ 1, 6 ], [ 4, 6 ] ]
</code></pre><p>上面例子中，正则表达式包含一个组匹配，那么<code>indices</code>属性数组就有两个成员，第一个成员是整个匹配结果（<code>abbcd</code>）的开始位置和结束位置，第二个成员是组匹配（<code>cd</code>）的开始位置和结束位置。</p><p>下面是多个组匹配的例子。</p><pre><code class="javascript">const text = &#39;zabbcdef&#39;;
const re = /ab+(cd(ef))/;
const result = re.exec(text);

result.indices // [ [1, 8], [4, 8], [6, 8] ]
</code></pre><p>上面例子中，正则表达式包含两个组匹配，所以<code>indices</code>属性数组就有三个成员。</p><p>如果正则表达式包含具名组匹配，<code>indices</code>属性数组还会有一个<code>groups</code>属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置。</p><pre><code class="javascript">const text = &#39;zabbcdef&#39;;
const re = /ab+(?&lt;Z&gt;cd)/;
const result = re.exec(text);

result.indices.groups // &#123; Z: [ 4, 6 ] &#125;
</code></pre><p>上面例子中，<code>exec()</code>方法返回结果的<code>indices.groups</code>属性是一个对象，提供具名组匹配<code>Z</code>的开始位置和结束位置。</p><p>如果获取组匹配不成功，<code>indices</code>属性数组的对应成员则为<code>undefined</code>，<code>indices.groups</code>属性对象的对应成员也是<code>undefined</code>。</p><pre><code class="javascript">const text = &#39;zabbcdef&#39;;
const re = /ab+(?&lt;Z&gt;ce)?/;
const result = re.exec(text);

result.indices[1] // undefined
result.indices.groups[&#39;Z&#39;] // undefined
</code></pre><p>上面例子中，由于组匹配不成功，所以<code>indices</code>属性数组和<code>indices.groups</code>属性对象对应的组匹配成员都是<code>undefined</code>。</p><h4 id="13-String-prototype-matchAll"><a href="#13-String-prototype-matchAll" class="headerlink" title="13. String.prototype.matchAll()"></a>13. String.prototype.matchAll()</h4><p>如果一个正则表达式在字符串里面有多个匹配，现在一般使用<code>g</code>修饰符或<code>y</code>修饰符，在循环里面逐一取出。</p><pre><code class="javascript">var regex = /t(e)(st(\d?))/g;
var string = &#39;test1test2test3&#39;;

var matches = [];
var match;
while (match = regex.exec(string)) &#123;
  matches.push(match);
&#125;

matches
// [
//   [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;],
//   [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;],
//   [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]
// ]
</code></pre><p>上面代码中，<code>while</code>循环取出每一轮的正则匹配，一共三轮。</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLW1hdGNoYWxs">ES2020</span> 增加了<code>String.prototype.matchAll()</code>方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。</p><pre><code class="javascript">const string = &#39;test1test2test3&#39;;
const regex = /t(e)(st(\d?))/g;

for (const match of string.matchAll(regex)) &#123;
  console.log(match);
&#125;
// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]
// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]
// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]
</code></pre><p>上面代码中，由于<code>string.matchAll(regex)</code>返回的是遍历器，所以可以用<code>for...of</code>循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。</p><p>遍历器转为数组是非常简单的，使用<code>...</code>运算符和<code>Array.from()</code>方法就可以了。</p><pre><code class="javascript">// 转为数组的方法一
[...string.matchAll(regex)]

// 转为数组的方法二
Array.from(string.matchAll(regex))
</code></pre><h3 id="6、数值的扩展"><a href="#6、数值的扩展" class="headerlink" title="6、数值的扩展"></a>6、数值的扩展</h3><hr><h4 id="1-二进制和八进制表示法"><a href="#1-二进制和八进制表示法" class="headerlink" title="1. 二进制和八进制表示法"></a>1. 二进制和八进制表示法</h4><p>ES6 提供了二进制和八进制数值的新的写法，<strong>分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）</strong>表示。</p><pre><code class="javascript">0b111110111 === 503 // true
0o767 === 503 // true
</code></pre><p>从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀<code>0</code>表示，ES6 进一步明确，要使用前缀<code>0o</code>表示。</p><pre><code class="javascript">// 非严格模式
(function()&#123;
  console.log(0o11 === 011);
&#125;)() // true

// 严格模式
(function()&#123;
  &#39;use strict&#39;;
  console.log(0o11 === 011);
&#125;)() // Uncaught SyntaxError: Octal literals are not allowed in strict mode.
</code></pre><p><strong>如果要将<code>0b</code>和<code>0o</code>前缀的字符串数值转为十进制，要使用<code>Number</code>方法。</strong></p><pre><code class="javascript">Number(&#39;0b111&#39;)  // 7
Number(&#39;0o10&#39;)  // 8
</code></pre><hr><h4 id="2-数值分隔符"><a href="#2-数值分隔符" class="headerlink" title="2. 数值分隔符"></a>2. 数值分隔符</h4><p>欧美语言中，较长的数值允许每三位添加一个分隔符（通常是一个逗号），增加数值的可读性。比如，<code>1000</code>可以写作<code>1,000</code>。</p><p><strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtbnVtZXJpYy1zZXBhcmF0b3I=">ES2021</span>，允许 JavaScript 的数值使用下划线（<code>_</code>）作为分隔符。</strong></p><pre><code class="javascript">let budget = 1_000_000_000_000;
budget === 10 ** 12 // true
</code></pre><p>这个数值分隔符没有指定间隔的位数，也就是说，可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个。</p><pre><code class="javascript">123_00 === 12_300 // true

12345_00 === 123_4500 // true
12345_00 === 1_234_500 // true
</code></pre><p>小数和科学计数法也可以使用数值分隔符。</p><pre><code class="javascript">// 小数
0.000_001

// 科学计数法
1e10_000
</code></pre><p>数值分隔符有几个使用注意点。</p><ul><li>不能放在数值的最前面（leading）或最后面（trailing）。</li><li>不能两个或两个以上的分隔符连在一起。</li><li>小数点的前后不能有分隔符。</li><li>科学计数法里面，表示指数的<code>e</code>或<code>E</code>前后不能有分隔符。</li></ul><p>下面的写法都会报错。</p><pre><code class="javascript">// 全部报错
3_.141
3._141
1_e12
1e_12
123__456
_1464301
1464301_
</code></pre><p>除了十进制，其他进制的数值也可以使用分隔符。</p><pre><code class="javascript">// 二进制
0b1010_0001_1000_0101
// 十六进制
0xA0_B0_C0
</code></pre><p>注意，分隔符不能紧跟着进制的前缀<code>0b</code>、<code>0B</code>、<code>0o</code>、<code>0O</code>、<code>0x</code>、<code>0X</code>。</p><pre><code class="javascript">// 报错
0_b111111000
0b_111111000
</code></pre><p>数值分隔符只是一种书写便利，对于 JavaScript 内部数值的存储和输出，并没有影响。</p><pre><code class="javascript">let num = 12_345;

num // 12345
num.toString() // 12345
</code></pre><p>上面示例中，变量<code>num</code>的值为<code>12_345</code>，但是内部存储和输出的时候，都不会有数值分隔符。</p><p>下面三个将字符串转成数值的函数，不支持数值分隔符。主要原因是语言的设计者认为，数值分隔符主要是为了编码时书写数值的方便，而不是为了处理外部输入的数据。</p><ul><li>Number()</li><li>parseInt()</li><li>parseFloat()</li></ul><pre><code class="javascript">Number(&#39;123_456&#39;) // NaN
parseInt(&#39;123_456&#39;) // 123
</code></pre><hr><h4 id="3-Number-isFinite-Number-isNaN"><a href="#3-Number-isFinite-Number-isNaN" class="headerlink" title="3. Number.isFinite(), Number.isNaN()"></a>3. Number.isFinite(), Number.isNaN()</h4><p>ES6 在<code>Number</code>对象上，新提供了<code>Number.isFinite()</code>和<code>Number.isNaN()</code>两个方法。</p><p><strong><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite），即不是<code>Infinity</code>。</strong></p><pre><code class="javascript">Number.isFinite(15); // true
Number.isFinite(0.8); // true
Number.isFinite(NaN); // false
Number.isFinite(Infinity); // false
Number.isFinite(-Infinity); // false
Number.isFinite(&#39;foo&#39;); // false
Number.isFinite(&#39;15&#39;); // false
Number.isFinite(true); // false
</code></pre><p>注意，如果参数类型不是数值，<code>Number.isFinite</code>一律返回<code>false</code>。</p><p><strong><code>Number.isNaN()</code>用来检查一个值是否为<code>NaN</code>。</strong></p><pre><code class="javascript">Number.isNaN(NaN) // true
Number.isNaN(15) // false
Number.isNaN(&#39;15&#39;) // false
Number.isNaN(true) // false
Number.isNaN(9/NaN) // true
Number.isNaN(&#39;true&#39; / 0) // true
Number.isNaN(&#39;true&#39; / &#39;true&#39;) // true
</code></pre><p>如果参数类型不是<code>NaN</code>，<code>Number.isNaN</code>一律返回<code>false</code>。</p><p><strong>它们与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，</strong><code>Number.isFinite()</code>对于非数值一律返回<code>false</code>, <code>Number.isNaN()</code>只有对于<code>NaN</code>才返回<code>true</code>，非<code>NaN</code>一律返回<code>false</code>。</p><pre><code class="javascript">isFinite(25) // true
isFinite(&quot;25&quot;) // true
Number.isFinite(25) // true
Number.isFinite(&quot;25&quot;) // false

isNaN(NaN) // true
isNaN(&quot;NaN&quot;) // true
Number.isNaN(NaN) // true
Number.isNaN(&quot;NaN&quot;) // false
Number.isNaN(1) // false
</code></pre><hr><h4 id="4-Number-parseInt-Number-parseFloat"><a href="#4-Number-parseInt-Number-parseFloat" class="headerlink" title="4. Number.parseInt(), Number.parseFloat()"></a>4. Number.parseInt(), Number.parseFloat()</h4><p>ES6 将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到<code>Number</code>对象上面，行为完全保持不变。</p><pre><code class="javascript">// ES5的写法
parseInt(&#39;12.34&#39;) // 12
parseFloat(&#39;123.45#&#39;) // 123.45

// ES6的写法
Number.parseInt(&#39;12.34&#39;) // 12
Number.parseFloat(&#39;123.45#&#39;) // 123.45
</code></pre><p>这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</p><pre><code class="javascript">Number.parseInt === parseInt // true
Number.parseFloat === parseFloat // true
</code></pre><hr><h4 id="5-Number-isInteger"><a href="#5-Number-isInteger" class="headerlink" title="5.Number.isInteger()"></a>5.Number.isInteger()</h4><p><code>Number.isInteger()</code>用来判断一个数值是否为整数。</p><pre><code class="javascript">Number.isInteger(25) // true
Number.isInteger(25.1) // false
</code></pre><p>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。</p><pre><code class="javascript">Number.isInteger(25) // true
Number.isInteger(25.0) // true
</code></pre><p>如果参数不是数值，<code>Number.isInteger</code>返回<code>false</code>。</p><pre><code class="javascript">Number.isInteger() // false
Number.isInteger(null) // false
Number.isInteger(&#39;15&#39;) // false
Number.isInteger(true) // false
</code></pre><p>注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，<code>Number.isInteger</code>可能会误判。</p><pre><code class="javascript">Number.isInteger(3.0000000000000002) // true
</code></pre><p>上面代码中，<code>Number.isInteger</code>的参数明明不是整数，但是会返回<code>true</code>。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个<code>2</code>被丢弃了。</p><p>类似的情况还有，如果一个数值的绝对值小于<code>Number.MIN_VALUE</code>（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，<code>Number.isInteger</code>也会误判。</p><pre><code class="javascript">Number.isInteger(5E-324) // false
Number.isInteger(5E-325) // true
</code></pre><p>上面代码中，<code>5E-325</code>由于值太小，会被自动转为0，因此返回<code>true</code>。</p><p><strong>总之，如果对数据精度的要求较高，不建议使用<code>Number.isInteger()</code>判断一个数值是否为整数。</strong></p><hr><h4 id="6-Number-EPSILON"><a href="#6-Number-EPSILON" class="headerlink" title="6. Number.EPSILON"></a>6. Number.EPSILON</h4><p><strong>ES6 在<code>Number</code>对象上面，新增一个极小的常量<code>Number.EPSILON</code>。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</strong></p><p>对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的<code>1.00..001</code>，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。</p><pre><code class="javascript">Number.EPSILON === Math.pow(2, -52)
// true
Number.EPSILON
// 2.220446049250313e-16
Number.EPSILON.toFixed(20)
// &quot;0.00000000000000022204&quot;
</code></pre><p><strong><code>Number.EPSILON</code>实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</strong></p><p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</p><pre><code class="javascript">0.1 + 0.2
// 0.30000000000000004

0.1 + 0.2 - 0.3
// 5.551115123125783e-17

5.551115123125783e-17.toFixed(20)
// &#39;0.00000000000000005551&#39;
</code></pre><p>上面代码解释了，为什么比较<code>0.1 + 0.2</code>与<code>0.3</code>得到的结果是<code>false</code>。</p><pre><code class="javascript">0.1 + 0.2 === 0.3 // false
</code></pre><p><code>Number.EPSILON</code>可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即<code>Number.EPSILON * Math.pow(2, 2)</code>），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。</p><pre><code class="javascript">5.551115123125783e-17 &lt; Number.EPSILON * Math.pow(2, 2)
// true
</code></pre><p>因此，<code>Number.EPSILON</code>的实质是一个可以接受的最小误差范围。</p><pre><code class="javascript">function withinErrorMargin (left, right) &#123;
  return Math.abs(left - right) &lt; Number.EPSILON * Math.pow(2, 2);
&#125;

0.1 + 0.2 === 0.3 // false
withinErrorMargin(0.1 + 0.2, 0.3) // true

1.1 + 1.3 === 2.4 // false
withinErrorMargin(1.1 + 1.3, 2.4) // true
</code></pre><p>上面的代码为浮点数运算，部署了一个误差检查函数。</p><hr><h4 id="7-安全整数和-Number-isSafeInteger"><a href="#7-安全整数和-Number-isSafeInteger" class="headerlink" title="7. 安全整数和 Number.isSafeInteger()"></a>7. 安全整数和 Number.isSafeInteger()</h4><p>JavaScript 能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。</p><pre><code class="javascript">Math.pow(2, 53) // 9007199254740992

9007199254740992  // 9007199254740992
9007199254740993  // 9007199254740992

Math.pow(2, 53) === Math.pow(2, 53) + 1
// true
</code></pre><p>上面代码中，超出 2 的 53 次方之后，一个数就不精确了。</p><p><strong>ES6 引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。</strong></p><pre><code class="javascript">Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1
// true
Number.MAX_SAFE_INTEGER === 9007199254740991
// true

Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER
// true
Number.MIN_SAFE_INTEGER === -9007199254740991
// true
</code></pre><p>上面代码中，可以看到 JavaScript 能够精确表示的极限。</p><p><code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p><pre><code class="javascript">Number.isSafeInteger(&#39;a&#39;) // false
Number.isSafeInteger(null) // false
Number.isSafeInteger(NaN) // false
Number.isSafeInteger(Infinity) // false
Number.isSafeInteger(-Infinity) // false

Number.isSafeInteger(3) // true
Number.isSafeInteger(1.2) // false
Number.isSafeInteger(9007199254740990) // true
Number.isSafeInteger(9007199254740992) // false

Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false
Number.isSafeInteger(Number.MIN_SAFE_INTEGER) // true
Number.isSafeInteger(Number.MAX_SAFE_INTEGER) // true
Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false
</code></pre><p>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。</p><pre><code class="javascript">Number.isSafeInteger = function (n) &#123;
  return (typeof n === &#39;number&#39; &amp;&amp;
    Math.round(n) === n &amp;&amp;
    Number.MIN_SAFE_INTEGER &lt;= n &amp;&amp;
    n &lt;= Number.MAX_SAFE_INTEGER);
&#125;
</code></pre><p><strong>实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。</strong></p><pre><code class="javascript">Number.isSafeInteger(9007199254740993)
// false
Number.isSafeInteger(990)
// true
Number.isSafeInteger(9007199254740993 - 990)
// true
9007199254740993 - 990
// 返回结果 9007199254740002
// 正确答案应该是 9007199254740003
</code></pre><p>上面代码中，<code>9007199254740993</code>不是一个安全整数，但是<code>Number.isSafeInteger</code>会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以<code>9007199254740992</code>的形式储存。</p><pre><code class="javascript">9007199254740993 === 9007199254740992
// true
</code></pre><p>所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。</p><pre><code class="javascript">function trusty (left, right, result) &#123;
  if (
    Number.isSafeInteger(left) &amp;&amp;
    Number.isSafeInteger(right) &amp;&amp;
    Number.isSafeInteger(result)
  ) &#123;
    return result;
  &#125;
  throw new RangeError(&#39;Operation cannot be trusted!&#39;);
&#125;

trusty(9007199254740993, 990, 9007199254740993 - 990)
// RangeError: Operation cannot be trusted!

trusty(1, 2, 3)
// 3
</code></pre><hr><h4 id="8-Math-对象的扩展"><a href="#8-Math-对象的扩展" class="headerlink" title="8. Math 对象的扩展"></a>8. Math 对象的扩展</h4><p>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p><p><strong>Math.trunc()</strong></p><p><strong><code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分。</strong></p><pre><code class="javascript">Math.trunc(4.1) // 4
Math.trunc(4.9) // 4
Math.trunc(-4.1) // -4
Math.trunc(-4.9) // -4
Math.trunc(-0.1234) // -0
</code></pre><p>对于非数值，<code>Math.trunc</code>内部使用<code>Number</code>方法将其先转为数值。</p><pre><code class="javascript">Math.trunc(&#39;123.456&#39;) // 123
Math.trunc(true) //1
Math.trunc(false) // 0
Math.trunc(null) // 0
</code></pre><p>对于空值和无法截取整数的值，返回<code>NaN</code>。</p><pre><code class="javascript">Math.trunc(NaN);      // NaN
Math.trunc(&#39;foo&#39;);    // NaN
Math.trunc();         // NaN
Math.trunc(undefined) // NaN
</code></pre><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><pre><code class="javascript">Math.trunc = Math.trunc || function(x) &#123;
  return x &lt; 0 ? Math.ceil(x) : Math.floor(x);
&#125;;
</code></pre><hr><p><strong>Math.sign()</strong></p><p><strong><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</strong></p><p>它会返回五种值。</p><ul><li>参数为正数，返回<code>+1</code>；</li><li>参数为负数，返回<code>-1</code>；</li><li>参数为 0，返回<code>0</code>；</li><li>参数为-0，返回<code>-0</code>;</li><li>其他值，返回<code>NaN</code>。</li></ul><pre><code class="javascript">Math.sign(-5) // -1
Math.sign(5) // +1
Math.sign(0) // +0
Math.sign(-0) // -0
Math.sign(NaN) // NaN
</code></pre><p>如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回<code>NaN</code>。</p><pre><code class="javascript">Math.sign(&#39;&#39;)  // 0
Math.sign(true)  // +1
Math.sign(false)  // 0
Math.sign(null)  // 0
Math.sign(&#39;9&#39;)  // +1
Math.sign(&#39;foo&#39;)  // NaN
Math.sign()  // NaN
Math.sign(undefined)  // NaN
</code></pre><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><pre><code class="javascript">Math.sign = Math.sign || function(x) &#123;
  x = +x; // convert to a number
  if (x === 0 || isNaN(x)) &#123;
    return x;
  &#125;
  return x &gt; 0 ? 1 : -1;
&#125;;
</code></pre><hr><p><strong>Math.cbrt()</strong></p><p><strong><code>Math.cbrt()</code>方法用于计算一个数的立方根。</strong></p><pre><code class="javascript">Math.cbrt(-1) // -1
Math.cbrt(0)  // 0
Math.cbrt(1)  // 1
Math.cbrt(2)  // 1.2599210498948732
</code></pre><p>对于非数值，<code>Math.cbrt()</code>方法内部也是先使用<code>Number()</code>方法将其转为数值。</p><pre><code class="javascript">Math.cbrt(&#39;8&#39;) // 2
Math.cbrt(&#39;hello&#39;) // NaN
</code></pre><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><pre><code class="javascript">Math.cbrt = Math.cbrt || function(x) &#123;
  var y = Math.pow(Math.abs(x), 1/3);
  return x &lt; 0 ? -y : y;
&#125;;
</code></pre><hr><p><strong>Math.clz32()</strong></p><p><strong><code>Math.clz32()</code>方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。</strong></p><pre><code class="javascript">Math.clz32(0) // 32
Math.clz32(1) // 31
Math.clz32(1000) // 22
Math.clz32(0b01000000000000000000000000000000) // 1
Math.clz32(0b00100000000000000000000000000000) // 2
</code></pre><p>上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是<code>0b1</code>，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是<code>0b1111101000</code>，一共有 10 位，所以 32 位之中有 22 个前导 0。</p><p><code>clz32</code>这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。</p><p>左移运算符（<code>&lt;&lt;</code>）与<code>Math.clz32</code>方法直接相关。</p><pre><code class="javascript">Math.clz32(0) // 32
Math.clz32(1) // 31
Math.clz32(1 &lt;&lt; 1) // 30
Math.clz32(1 &lt;&lt; 2) // 29
Math.clz32(1 &lt;&lt; 29) // 2
</code></pre><p>对于小数，<code>Math.clz32</code>方法只考虑整数部分。</p><pre><code class="javascript">Math.clz32(3.2) // 30
Math.clz32(3.9) // 30
</code></pre><p>对于空值或其他类型的值，<code>Math.clz32</code>方法会将它们先转为数值，然后再计算。</p><pre><code class="javascript">Math.clz32() // 32
Math.clz32(NaN) // 32
Math.clz32(Infinity) // 32
Math.clz32(null) // 32
Math.clz32(&#39;foo&#39;) // 32
Math.clz32([]) // 32
Math.clz32(&#123;&#125;) // 32
Math.clz32(true) // 31
</code></pre><hr><p><strong>Math.imul()</strong></p><p><strong><code>Math.imul</code>方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</strong></p><pre><code class="javascript">Math.imul(2, 4)   // 8
Math.imul(-1, 8)  // -8
Math.imul(-2, -2) // 4
</code></pre><p>如果只考虑最后 32 位，大多数情况下，<code>Math.imul(a, b)</code>与<code>a * b</code>的结果是相同的，即该方法等同于<code>(a * b)|0</code>的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，<code>Math.imul</code>方法可以返回正确的低位数值。</p><pre><code class="javascript">(0x7fffffff * 0x7fffffff)|0 // 0
</code></pre><p>上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。<code>Math.imul</code>方法可以返回正确的值 1。</p><pre><code class="javascript">Math.imul(0x7fffffff, 0x7fffffff) // 1
</code></pre><hr><p><strong>Math.fround()</strong></p><p><strong><code>Math.fround</code>方法返回一个数的32位单精度浮点数形式。</strong></p><p>对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。</p><pre><code class="javascript">Math.fround(0)   // 0
Math.fround(1)   // 1
Math.fround(2 ** 24 - 1)   // 16777215
</code></pre><p>如果参数的绝对值大于 224，返回的结果便开始丢失精度。</p><pre><code class="javascript">Math.fround(2 ** 24)       // 16777216
Math.fround(2 ** 24 + 1)   // 16777216
</code></pre><p><code>Math.fround</code>方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。</p><pre><code class="javascript">// 未丢失有效精度
Math.fround(1.125) // 1.125
Math.fround(7.25)  // 7.25

// 丢失精度
Math.fround(0.3)   // 0.30000001192092896
Math.fround(0.7)   // 0.699999988079071
Math.fround(1.0000000123) // 1
</code></pre><p>对于 <code>NaN</code> 和 <code>Infinity</code>，此方法返回原值。对于其它类型的非数值，<code>Math.fround</code> 方法会先将其转为数值，再返回单精度浮点数。</p><pre><code class="javascript">Math.fround(NaN)      // NaN
Math.fround(Infinity) // Infinity

Math.fround(&#39;5&#39;)      // 5
Math.fround(true)     // 1
Math.fround(null)     // 0
Math.fround([])       // 0
Math.fround(&#123;&#125;)       // NaN
</code></pre><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><pre><code class="javascript">Math.fround = Math.fround || function (x) &#123;
  return new Float32Array([x])[0];
&#125;;
</code></pre><hr><p><strong>Math.hypot()</strong></p><p><strong><code>Math.hypot</code>方法返回所有参数的平方和的平方根。</strong></p><pre><code class="javascript">Math.hypot(3, 4);        // 5
Math.hypot(3, 4, 5);     // 7.0710678118654755
Math.hypot();            // 0
Math.hypot(NaN);         // NaN
Math.hypot(3, 4, &#39;foo&#39;); // NaN
Math.hypot(3, 4, &#39;5&#39;);   // 7.0710678118654755
Math.hypot(-3);          // 3
</code></pre><p>上面代码中，3 的平方加上 4 的平方，等于 5 的平方。</p><p>如果参数不是数值，<code>Math.hypot</code>方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。</p><hr><p><strong>对数方法</strong></p><p>ES6 新增了 4 个对数相关方法。</p><p><strong>（1） Math.expm1()</strong></p><p><code>Math.expm1(x)</code>返回 ex - 1，即<code>Math.exp(x) - 1</code>。</p><pre><code class="javascript">Math.expm1(-1) // -0.6321205588285577
Math.expm1(0)  // 0
Math.expm1(1)  // 1.718281828459045
</code></pre><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><pre><code class="javascript">Math.expm1 = Math.expm1 || function(x) &#123;
  return Math.exp(x) - 1;
&#125;;
</code></pre><p><strong>（2）Math.log1p()</strong></p><p><code>Math.log1p(x)</code>方法返回<code>1 + x</code>的自然对数，即<code>Math.log(1 + x)</code>。如果<code>x</code>小于-1，返回<code>NaN</code>。</p><pre><code class="javascript">Math.log1p(1)  // 0.6931471805599453
Math.log1p(0)  // 0
Math.log1p(-1) // -Infinity
Math.log1p(-2) // NaN
</code></pre><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><pre><code class="javascript">Math.log1p = Math.log1p || function(x) &#123;
  return Math.log(1 + x);
&#125;;
</code></pre><p><strong>（3）Math.log10()</strong></p><p><code>Math.log10(x)</code>返回以 10 为底的<code>x</code>的对数。如果<code>x</code>小于 0，则返回 NaN。</p><pre><code class="javascript">Math.log10(2)      // 0.3010299956639812
Math.log10(1)      // 0
Math.log10(0)      // -Infinity
Math.log10(-2)     // NaN
Math.log10(100000) // 5
</code></pre><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><pre><code class="javascript">Math.log10 = Math.log10 || function(x) &#123;
  return Math.log(x) / Math.LN10;
&#125;;
</code></pre><p><strong>（4）Math.log2()</strong></p><p><code>Math.log2(x)</code>返回以 2 为底的<code>x</code>的对数。如果<code>x</code>小于 0，则返回 NaN。</p><pre><code class="javascript">Math.log2(3)       // 1.584962500721156
Math.log2(2)       // 1
Math.log2(1)       // 0
Math.log2(0)       // -Infinity
Math.log2(-2)      // NaN
Math.log2(1024)    // 10
Math.log2(1 &lt;&lt; 29) // 29
</code></pre><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p><pre><code class="javascript">Math.log2 = Math.log2 || function(x) &#123;
  return Math.log(x) / Math.LN2;
&#125;;
</code></pre><p><strong>双曲函数方法</strong></p><p>ES6 新增了 6 个双曲函数方法。</p><ul><li><code>Math.sinh(x)</code> 返回<code>x</code>的双曲正弦（hyperbolic sine）</li><li><code>Math.cosh(x)</code> 返回<code>x</code>的双曲余弦（hyperbolic cosine）</li><li><code>Math.tanh(x)</code> 返回<code>x</code>的双曲正切（hyperbolic tangent）</li><li><code>Math.asinh(x)</code> 返回<code>x</code>的反双曲正弦（inverse hyperbolic sine）</li><li><code>Math.acosh(x)</code> 返回<code>x</code>的反双曲余弦（inverse hyperbolic cosine）</li><li><code>Math.atanh(x)</code> 返回<code>x</code>的反双曲正切（inverse hyperbolic tangent）</li></ul><hr><h4 id="9-BigInt-数据类型"><a href="#9-BigInt-数据类型" class="headerlink" title="9. BigInt 数据类型"></a>9. BigInt 数据类型</h4><p>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回<code>Infinity</code>。</p><pre><code class="javascript">// 超过 53 个二进制位的数值，无法保持精度
Math.pow(2, 53) === Math.pow(2, 53) + 1 // true

// 超过 2 的 1024 次方的数值，无法表示
Math.pow(2, 1024) // Infinity
</code></pre><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYmlnaW50">ES2020</span> 引入了一种新的数据类型 BigInt（大整数），来解决这个问题，这是 ECMAScript 的第八种数据类型。<strong>BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</strong></p><pre><code class="javascript">const a = 2172141653n;
const b = 15346349309n;

// BigInt 可以保持精度
a * b // 33334444555566667777n

// 普通整数无法保持精度
Number(a) * Number(b) // 33334444555566670000
</code></pre><p><strong>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀<code>n</code>。</strong></p><pre><code class="javascript">1234 // 普通整数
1234n // BigInt

// BigInt 的运算
1n + 2n // 3n
</code></pre><p>BigInt 同样可以使用各种进制表示，都要加上后缀<code>n</code>。</p><pre><code class="javascript">0b1101n // 二进制
0o777n // 八进制
0xFFn // 十六进制
</code></pre><p>BigInt 与普通整数是两种值，它们之间并不相等。</p><pre><code class="javascript">42n === 42 // false
</code></pre><p><code>typeof</code>运算符对于 BigInt 类型的数据返回<code>bigint</code>。</p><pre><code class="javascript">typeof 123n // &#39;bigint&#39;
</code></pre><p>BigInt 可以使用负号（<code>-</code>），但是不能使用正号（<code>+</code>），因为会与 asm.js 冲突。</p><pre><code class="javascript">-42n // 正确
+42n // 报错
</code></pre><p>JavaScript 以前不能计算70的阶乘（即<code>70!</code>），因为超出了可以表示的精度。</p><pre><code class="javascript">let p = 1;
for (let i = 1; i &lt;= 70; i++) &#123;
  p *= i;
&#125;
console.log(p); // 1.197857166996989e+100
</code></pre><p>现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就OK。</p><pre><code class="javascript">let p = 1n;
for (let i = 1n; i &lt;= 70n; i++) &#123;
  p *= i;
&#125;
console.log(p); // 11978571...00000000n
</code></pre><hr><p><strong>BigInt 函数</strong></p><p>JavaScript 原生提供<code>BigInt</code>函数，可以用它生成 BigInt 类型的数值。转换规则基本与<code>Number()</code>一致，将其他类型的值转为 BigInt。</p><pre><code class="javascript">BigInt(123) // 123n
BigInt(&#39;123&#39;) // 123n
BigInt(false) // 0n
BigInt(true) // 1n
</code></pre><p><code>BigInt()</code>函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。</p><pre><code class="javascript">new BigInt() // TypeError
BigInt(undefined) //TypeError
BigInt(null) // TypeError
BigInt(&#39;123n&#39;) // SyntaxError
BigInt(&#39;abc&#39;) // SyntaxError
</code></pre><p>上面代码中，尤其值得注意字符串<code>123n</code>无法解析成 Number 类型，所以会报错。</p><p>参数如果是小数，也会报错。</p><pre><code class="javascript">BigInt(1.5) // RangeError
BigInt(&#39;1.5&#39;) // SyntaxError
</code></pre><p>BigInt 继承了 Object 对象的两个实例方法。</p><ul><li><code>BigInt.prototype.toString()</code></li><li><code>BigInt.prototype.valueOf()</code></li></ul><p>它还继承了 Number 对象的一个实例方法。</p><ul><li><code>BigInt.prototype.toLocaleString()</code></li></ul><p>此外，还提供了三个静态方法。</p><ul><li><code>BigInt.asUintN(width, BigInt)</code>： 给定的 BigInt 转为 0 到 2width - 1 之间对应的值。</li><li><code>BigInt.asIntN(width, BigInt)</code>：给定的 BigInt 转为 -2width - 1 到 2width - 1 - 1 之间对应的值。</li><li><code>BigInt.parseInt(string[, radix])</code>：近似于<code>Number.parseInt()</code>，将一个字符串转换成指定进制的 BigInt。</li></ul><pre><code class="javascript">const max = 2n ** (64n - 1n) - 1n;

BigInt.asIntN(64, max)
// 9223372036854775807n
BigInt.asIntN(64, max + 1n)
// -9223372036854775808n
BigInt.asUintN(64, max + 1n)
// 9223372036854775808n
</code></pre><p>上面代码中，<code>max</code>是64位带符号的 BigInt 所能表示的最大值。如果对这个值加<code>1n</code>，<code>BigInt.asIntN()</code>将会返回一个负值，因为这时新增的一位将被解释为符号位。而<code>BigInt.asUintN()</code>方法由于不存在符号位，所以可以正确返回结果。</p><p>如果<code>BigInt.asIntN()</code>和<code>BigInt.asUintN()</code>指定的位数，小于数值本身的位数，那么头部的位将被舍弃。</p><pre><code class="javascript">const max = 2n ** (64n - 1n) - 1n;

BigInt.asIntN(32, max) // -1n
BigInt.asUintN(32, max) // 4294967295n
</code></pre><p>上面代码中，<code>max</code>是一个64位的 BigInt，如果转为32位，前面的32位都会被舍弃。</p><p>下面是<code>BigInt.parseInt()</code>的例子。</p><pre><code class="javascript">// Number.parseInt() 与 BigInt.parseInt() 的对比
Number.parseInt(&#39;9007199254740993&#39;, 10)
// 9007199254740992
BigInt.parseInt(&#39;9007199254740993&#39;, 10)
// 9007199254740993n
</code></pre><p>上面代码中，由于有效数字超出了最大限度，<code>Number.parseInt</code>方法返回的结果是不精确的，而<code>BigInt.parseInt</code>方法正确返回了对应的 BigInt。</p><p>对于二进制数组，BigInt 新增了两个类型<code>BigUint64Array</code>和<code>BigInt64Array</code>，这两种数据类型返回的都是64位 BigInt。<code>DataView</code>对象的实例方法<code>DataView.prototype.getBigInt64()</code>和<code>DataView.prototype.getBigUint64()</code>，返回的也是 BigInt。</p><hr><p><strong>转换规则</strong></p><p>可以使用<code>Boolean()</code>、<code>Number()</code>和<code>String()</code>这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。</p><pre><code class="javascript">Boolean(0n) // false
Boolean(1n) // true
Number(1n)  // 1
String(1n)  // &quot;1&quot;
</code></pre><p>上面代码中，注意最后一个例子，转为字符串时后缀<code>n</code>会消失。</p><p>另外，取反运算符（<code>!</code>）也可以将 BigInt 转为布尔值。</p><pre><code class="javascript">!0n // true
!1n // false
</code></pre><hr><p><strong>数学运算</strong></p><p>数学运算方面，BigInt 类型的<code>+</code>、<code>-</code>、<code>*</code>和<code>**</code>这四个二元运算符，与 Number 类型的行为一致。除法运算<code>/</code>会舍去小数部分，返回一个整数。</p><pre><code class="javascript">9n / 5n
// 1n
</code></pre><p>几乎所有的数值运算符都可以用在 BigInt，但是有两个例外。</p><ul><li>不带符号的右移位运算符<code>&gt;&gt;&gt;</code></li><li>一元的求正运算符<code>+</code></li></ul><p>上面两个运算符用在 BigInt 会报错。前者是因为<code>&gt;&gt;&gt;</code>运算符是不带符号的，但是 BigInt 总是带有符号的，导致该运算无意义，完全等同于右移运算符<code>&gt;&gt;</code>。后者是因为一元运算符<code>+</code>在 asm.js 里面总是返回 Number 类型，为了不破坏 asm.js 就规定<code>+1n</code>会报错。</p><p>BigInt 不能与普通数值进行混合运算。</p><pre><code class="javascript">1n + 1.3 // 报错
</code></pre><p>上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失精度信息。比如<code>(2n**53n + 1n) + 0.5</code>这个表达式，如果返回 BigInt 类型，<code>0.5</code>这个小数部分会丢失；如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。</p><p>同样的原因，如果一个标准库函数的参数预期是 Number 类型，但是得到的是一个 BigInt，就会报错。</p><pre><code class="javascript">// 错误的写法
Math.sqrt(4n) // 报错

// 正确的写法
Math.sqrt(Number(4n)) // 2
</code></pre><p>上面代码中，<code>Math.sqrt</code>的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用<code>Number</code>方法转一下类型，才能进行计算。</p><p>asm.js 里面，<code>|0</code>跟在一个数值的后面会返回一个32位整数。根据不能与 Number 类型混合运算的规则，BigInt 如果与<code>|0</code>进行运算会报错。</p><pre><code class="javascript">1n | 0 // 报错
</code></pre><hr><p><strong>其他运算</strong></p><p>BigInt 对应的布尔值，与 Number 类型一致，即<code>0n</code>会转为<code>false</code>，其他值转为<code>true</code>。</p><pre><code class="javascript">if (0n) &#123;
  console.log(&#39;if&#39;);
&#125; else &#123;
  console.log(&#39;else&#39;);
&#125;
// else
</code></pre><p>上面代码中，<code>0n</code>对应<code>false</code>，所以会进入<code>else</code>子句。</p><p>比较运算符（比如<code>&gt;</code>）和相等运算符（<code>==</code>）允许 BigInt 与其他类型的值混合计算，因为这样做不会损失精度。</p><pre><code class="javascript">0n &lt; 1 // true
0n &lt; true // true
0n == 0 // true
0n == false // true
0n === 0 // false
</code></pre><p>BigInt 与字符串混合运算时，会先转为字符串，再进行运算。</p><pre><code class="javascript">&#39;&#39; + 123n // &quot;123&quot;
</code></pre><h3 id="7、函数的扩展"><a href="#7、函数的扩展" class="headerlink" title="7、函数的扩展"></a>7、函数的扩展</h3><hr><h4 id="1-函数参数的默认值"><a href="#1-函数参数的默认值" class="headerlink" title="1. 函数参数的默认值"></a>1. 函数参数的默认值</h4><p><strong>基本用法</strong></p><p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p><pre><code class="javascript">function log(x, y) &#123;
  y = y || &#39;World&#39;;
  console.log(x, y);
&#125;

log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
log(&#39;Hello&#39;, &#39;&#39;) // Hello World
</code></pre><p>上面代码检查函数<code>log</code>的参数<code>y</code>有没有赋值，如果没有，则指定默认值为<code>World</code>。这种写法的缺点在于，如果参数<code>y</code>赋值了，但是对应的布尔值为<code>false</code>，则该赋值不起作用。就像上面代码的最后一行，参数<code>y</code>等于空字符，结果被改为默认值。</p><p>为了避免这个问题，通常需要先判断一下参数<code>y</code>是否被赋值，如果没有，再等于默认值。</p><pre><code class="javascript">if (typeof y === &#39;undefined&#39;) &#123;
  y = &#39;World&#39;;
&#125;
</code></pre><p><strong>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</strong></p><pre><code class="javascript">function log(x, y = &#39;World&#39;) &#123;  
    console.log(x, y);
&#125;

log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
log(&#39;Hello&#39;, &#39;&#39;) // Hello
</code></pre><p>以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。</p><pre><code class="javascript">function Point(x = 0, y = 0) &#123;
  this.x = x;
  this.y = y;
&#125;

const p = new Point();
p // &#123; x: 0, y: 0 &#125;
</code></pre><p><strong>除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</strong></p><p><strong>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</strong></p><pre><code class="javascript">function foo(x = 5) &#123;
  let x = 1; // error
  const x = 2; // error
&#125;
</code></pre><p>上面代码中，参数变量<code>x</code>是默认声明的，在函数体中，不能用<code>let</code>或<code>const</code>再次声明，否则会报错。</p><p><strong>使用参数默认值时，函数不能有同名参数。</strong></p><pre><code class="javascript">// 不报错
function foo(x, x, y) &#123;
  // ...
&#125;

// 报错
function foo(x, x, y = 1) &#123;
  // ...
&#125;
// SyntaxError: Duplicate parameter name not allowed in this context
</code></pre><p>另外，一个容易忽略的地方是，<strong>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</strong></p><pre><code class="javascript">let x = 99;
function foo(p = x + 1) &#123;
  console.log(p);
&#125;

foo() // 100

x = 100;
foo() // 101
</code></pre><p>上面代码中，参数<code>p</code>的默认值是<code>x + 1</code>。这时，每次调用函数<code>foo</code>，都会重新计算<code>x + 1</code>，而不是默认<code>p</code>等于 100。</p><hr><p><strong>与解构赋值默认值结合使用</strong></p><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p><pre><code class="javascript">function foo(&#123;x, y = 5&#125;) &#123;
  console.log(x, y);
&#125;

foo(&#123;&#125;) // undefined 5
foo(&#123;x: 1&#125;) // 1 5
foo(&#123;x: 1, y: 2&#125;) // 1 2
foo() // TypeError: Cannot read property &#39;x&#39; of undefined
</code></pre><p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数<code>foo</code>的参数是一个对象时，变量<code>x</code>和<code>y</code>才会通过解构赋值生成。如果函数<code>foo</code>调用时没提供参数，变量<code>x</code>和<code>y</code>就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p><pre><code class="javascript">function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123;
  console.log(x, y);
&#125;

foo() // undefined 5
</code></pre><p>上面代码指定，如果没有提供参数，函数<code>foo</code>的参数默认为一个空对象。</p><p>下面是另一个解构赋值默认值的例子。</p><pre><code class="javascript">function fetch(url, &#123; body = &#39;&#39;, method = &#39;GET&#39;, headers = &#123;&#125; &#125;) &#123;
  console.log(method);
&#125;

fetch(&#39;http://example.com&#39;, &#123;&#125;)
// &quot;GET&quot;

fetch(&#39;http://example.com&#39;)
// 报错
</code></pre><p>上面代码中，如果函数<code>fetch</code>的第二个参数是一个对象，<strong>就可以为它的三个属性设置默认值</strong>。这种写法不能省略第二个参数，如果<strong>结合函数参数的默认值</strong>，就可以省略第二个参数。这时，<strong>就出现了双重默认值</strong>。</p><pre><code class="javascript">function fetch(url, &#123; body = &#39;&#39;, method = &#39;GET&#39;, headers = &#123;&#125; &#125; = &#123;&#125;) &#123;
  console.log(method);
&#125;

fetch(&#39;http://example.com&#39;)
// &quot;GET&quot;
</code></pre><p><strong>function fetch(url, { body = ‘’, method = ‘GET’, headers = {} } = {})</strong></p><p>上面代码中，<strong>函数<code>fetch</code>没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效</strong>，变量<code>method</code>才会取到默认值<code>GET</code>。</p><p>作为练习，请问下面两种写法有什么差别？</p><pre><code class="javascript">// 写法一
function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;
  return [x, y];
&#125;

// 写法二
function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;
  return [x, y];
&#125;
</code></pre><p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p><pre><code class="javascript">// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x 和 y 都有值的情况
m1(&#123;x: 3, y: 8&#125;) // [3, 8]
m2(&#123;x: 3, y: 8&#125;) // [3, 8]

// x 有值，y 无值的情况
m1(&#123;x: 3&#125;) // [3, 0]
m2(&#123;x: 3&#125;) // [3, undefined]

// x 和 y 都无值的情况
m1(&#123;&#125;) // [0, 0];
m2(&#123;&#125;) // [undefined, undefined]

m1(&#123;z: 3&#125;) // [0, 0]
m2(&#123;z: 3&#125;) // [undefined, undefined]
</code></pre><hr><p><strong>参数默认值的位置</strong></p><p>通常情况下，定义了默认值的参数，<strong>应该是函数的尾参数</strong>。因为这样比较容易看出来，到底省略了哪些参数。<strong>如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</strong></p><pre><code class="javascript">// 例一
function f(x = 1, y) &#123;
  return [x, y];
&#125;

f() // [1, undefined]
f(2) // [2, undefined]
f(, 1) // 报错
f(undefined, 1) // [1, 1]

// 例二
function f(x, y = 5, z) &#123;
  return [x, y, z];
&#125;

f() // [undefined, 5, undefined]
f(1) // [1, 5, undefined]
f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]
</code></pre><p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入<code>undefined</code>。</p><p>如果传入<code>undefined</code>，将触发该参数等于默认值，<code>null</code>则没有这个效果。</p><pre><code class="javascript">function foo(x = 5, y = 6) &#123;
  console.log(x, y);
&#125;

foo(undefined, null)
// 5 null
</code></pre><p>上面代码中，<code>x</code>参数对应<code>undefined</code>，结果触发了默认值，<code>y</code>参数等于<code>null</code>，就没有触发默认值。</p><hr><p><strong>函数的 length 属性</strong></p><p>指定了默认值以后，函数的<code>length</code>属性，<strong>将返回没有指定默认值的参数个数</strong>。也就是说，指定了默认值后，**<code>length</code>属性将失真**。</p><pre><code class="javascript">(function (a) &#123;&#125;).length // 1
(function (a = 5) &#123;&#125;).length // 0
(function (a, b, c = 5) &#123;&#125;).length // 2
</code></pre><p>上面代码中，<code>length</code>属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数<code>c</code>指定了默认值，因此<code>length</code>属性等于<code>3</code>减去<code>1</code>，最后得到<code>2</code>。</p><p>这是因为<code>length</code>属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 <strong>rest 参数也不会计入<code>length</code>属性。</strong></p><pre><code class="javascript">(function(...args) &#123;&#125;).length // 0
</code></pre><p><strong>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。</strong></p><pre><code class="javascript">(function (a = 0, b, c) &#123;&#125;).length // 0
(function (a, b = 1, c) &#123;&#125;).length // 1
</code></pre><hr><p><strong>作用域</strong></p><p><strong>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域</strong>（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。<strong>独立于函数作用域和全局作用域</strong></p><pre><code class="javascript">var x = 1;

function f(x, y = x) &#123;
  console.log(y);
&#125;

f(2) // 2
</code></pre><p>上面代码中，参数<code>y</code>的默认值等于变量<code>x</code>。调用函数<code>f</code>时，参数形成一个单独的作用域。在这个作用域里面，默认值变量<code>x</code>指向第一个参数<code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code>。</p><p>再看下面的例子。</p><pre><code class="javascript">let x = 1;

function f(y = x) &#123;
  let x = 2;
  console.log(y);
&#125;

f() // 1
</code></pre><p>上面代码中，函数<code>f</code>调用时，参数<code>y = x</code>形成一个单独的作用域。<strong>这个作用域里面，变量<code>x</code>本身没有定义，所以指向外层的全局变量<code>x</code>。函数调用时，函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>。</strong></p><p><strong>如果此时，全局变量<code>x</code>不存在，就会报错。</strong>内部定义的变量影响不到</p><pre><code class="javascript">function f(y = x) &#123;
  let x = 2;
  console.log(y);
&#125;

f() // ReferenceError: x is not defined
</code></pre><p>下面这样写，也会报错。</p><pre><code class="javascript">var x = 1;

function foo(x = x) &#123;
  // ...
&#125;

foo() // ReferenceError: Cannot access &#39;x&#39; before initialization
</code></pre><p><strong>上面代码中，参数<code>x = x</code>形成一个单独作用域。实际执行的是<code>let x = x</code>，由于暂时性死区的原因，这行代码会报错。</strong></p><p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。</p><pre><code class="javascript">let foo = &#39;outer&#39;;

function bar(func = () =&gt; foo) &#123;
  let foo = &#39;inner&#39;;
  console.log(func());
&#125;

bar(); // outer
</code></pre><p>上面代码中，函数<code>bar</code>的参数<code>func</code>的默认值是一个匿名函数，返回值为变量<code>foo</code>。函数参数形成的单独作用域里面，并没有定义变量<code>foo</code>，所以<code>foo</code>指向外层的全局变量<code>foo</code>，因此输出<code>outer</code>。</p><p>如果写成下面这样，就会报错。</p><pre><code class="javascript">function bar(func = () =&gt; foo) &#123;
  let foo = &#39;inner&#39;;
  console.log(func());
&#125;

bar() // ReferenceError: foo is not defined
</code></pre><p>上面代码中，匿名函数里面的<code>foo</code>指向函数外层，但是函数外层并没有声明变量<code>foo</code>，所以就报错了。</p><p>下面是一个更复杂的例子。</p><pre><code class="javascript">var x = 1;
function foo(x, y = function() &#123; x = 2; &#125;) &#123;
  var x = 3;
  y();
  console.log(x);
&#125;

foo() // 3
x // 1
</code></pre><p>上面代码中，函数<code>foo</code>的参数形成一个单独作用域。这个作用域里面，首先声明了变量<code>x</code>，然后声明了变量<code>y</code>，<code>y</code>的默认值是一个匿名函数。这个匿名函数内部的变量<code>x</code>，指向同一个作用域的第一个参数<code>x</code>。函数<code>foo</code>内部又声明了一个内部变量<code>x</code>，<strong>该变量与第一个参数<code>x</code>由于不是同一个作用域</strong>，所以不是同一个变量，因此执行<code>y</code>后，内部变量<code>x</code>和外部全局变量<code>x</code>的值都没变。</p><p><strong>如果将<code>var x = 3</code>的<code>var</code>去除，函数<code>foo</code>的内部变量<code>x</code>就指向第一个参数<code>x</code>，与匿名函数内部的<code>x</code>是一致的，所以最后输出的就是<code>2</code>，而外层的全局变量<code>x</code>依然不受影响。</strong></p><pre><code class="javascript">var x = 1;
function foo(x, y = function() &#123; x = 2; &#125;) &#123;
  x = 3;
  y();
  console.log(x);
&#125;

foo() // 2
x // 1
</code></pre><hr><p><strong>应用</strong></p><p><strong>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</strong></p><pre><code class="javascript">function throwIfMissing() &#123;
  throw new Error(&#39;Missing parameter&#39;);
&#125;

function foo(mustBeProvided = throwIfMissing()) &#123;
  return mustBeProvided;
&#125;

foo()
// Error: Missing parameter
</code></pre><p>上面代码的<code>foo</code>函数，如果调用的时候没有参数，就会调用默认值<code>throwIfMissing</code>函数，从而抛出一个错误。</p><p>从上面代码还可以看到，参数<code>mustBeProvided</code>的默认值等于<code>throwIfMissing</code>函数的运行结果（注意函数名<code>throwIfMissing</code>之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。</p><p><strong>另外，可以将参数默认值设为<code>undefined</code>，表明这个参数是可以省略的。</strong></p><pre><code class="javascript">function foo(optional = undefined) &#123; ··· &#125;
</code></pre><hr><h4 id="2-rest-参数"><a href="#2-rest-参数" class="headerlink" title="2. rest 参数"></a>2. rest 参数</h4><p><strong>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</strong></p><pre><code class="javascript">function add(...values) &#123;
  let sum = 0;

  for (var val of values) &#123;
    sum += val;
  &#125;

  return sum;
&#125;

add(2, 5, 3) // 10
</code></pre><p>上面代码的<code>add</code>函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p><p>下面是一个 rest 参数代替<code>arguments</code>变量的例子。</p><pre><code class="javascript">// arguments变量的写法
function sortNumbers() &#123;
  return Array.from(arguments).sort();
&#125;

// rest参数的写法
const sortNumbers = (...numbers) =&gt; numbers.sort();
</code></pre><p><code>arguments</code>对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用<code>Array.from</code>先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组<code>push</code>方法的例子。</p><pre><code class="javascript">function push(array, ...items) &#123;
  items.forEach(function(item) &#123;
    array.push(item);
    console.log(item);
  &#125;);
&#125;

var a = [];
push(a, 1, 2, 3)
</code></pre><p><strong>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</strong></p><pre><code class="javascript">// 报错
function f(a, ...b, c) &#123;
  // ...
&#125;
</code></pre><p><strong>函数的<code>length</code>属性，不包括 rest 参数。</strong></p><pre><code class="javascript">(function(a) &#123;&#125;).length  // 1
(function(...a) &#123;&#125;).length  // 0
(function(a, ...b) &#123;&#125;).length  // 1
</code></pre><hr><h4 id="3-严格模式"><a href="#3-严格模式" class="headerlink" title="3.  严格模式"></a>3. 严格模式</h4><p><strong>从 ES5 开始，函数内部可以设定为严格模式。</strong></p><pre><code class="javascript">function doSomething(a, b) &#123;
  &#39;use strict&#39;;
  // code
&#125;
</code></pre><p>ES2016 做了一点修改，规定<strong>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式</strong>，否则会报错。</p><pre><code class="javascript">// 报错
function doSomething(a, b = a) &#123;
  &#39;use strict&#39;;
  // code
&#125;

// 报错
const doSomething = function (&#123;a, b&#125;) &#123;
  &#39;use strict&#39;;
  // code
&#125;;

// 报错
const doSomething = (...a) =&gt; &#123;
  &#39;use strict&#39;;
  // code
&#125;;

const obj = &#123;
  // 报错
  doSomething(&#123;a, b&#125;) &#123;
    &#39;use strict&#39;;
    // code
  &#125;
&#125;;
</code></pre><p>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。</p><pre><code class="javascript">// 报错
function doSomething(value = 070) &#123;
  &#39;use strict&#39;;
  return value;
&#125;
</code></pre><p>上面代码中，参数<code>value</code>的默认值是八进制数<code>070</code>，但是严格模式下不能用前缀<code>0</code>表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行<code>value = 070</code>，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。<strong>即参数没有被严格模式限制，进入函数体内报错</strong>。</p><p>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，<strong>只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</strong></p><p>两种方法可以规避这种限制。第一种是<strong>设定全局性的严格模式</strong>，这是合法的。</p><pre><code class="javascript">&#39;use strict&#39;;

function doSomething(a, b = a) &#123;
  // code
&#125;
</code></pre><p>第二种是<strong>把函数包在一个无参数的立即执行函数</strong>里面。</p><pre><code class="javascript">const doSomething = (function () &#123;
  &#39;use strict&#39;;
  return function(value = 42) &#123;
    return value;
  &#125;;
&#125;());
</code></pre><hr><h4 id="4-name-属性"><a href="#4-name-属性" class="headerlink" title="4. name 属性"></a>4. name 属性</h4><p><strong>函数的<code>name</code>属性，返回该函数的函数名。</strong></p><pre><code class="javascript">function foo() &#123;&#125;
foo.name // &quot;foo&quot;
</code></pre><p>这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</p><p>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的<code>name</code>属性，会返回空字符串，而 <strong>ES6 的<code>name</code>属性会返回实际的函数名。</strong></p><pre><code class="javascript">var f = function () &#123;&#125;;

// ES5
f.name // &quot;&quot;

// ES6
f.name // &quot;f&quot;
</code></pre><p>上面代码中，变量<code>f</code>等于一个匿名函数，ES5 和 ES6 的<code>name</code>属性返回的值不一样。</p><p><strong>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的<code>name</code>属性都返回这个具名函数原本的名字。</strong></p><pre><code class="javascript">const bar = function baz() &#123;&#125;;

// ES5
bar.name // &quot;baz&quot;

// ES6
bar.name // &quot;baz&quot;
</code></pre><p><strong><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code>。</strong></p><pre><code class="javascript">(new Function).name // &quot;anonymous&quot;
</code></pre><p><strong><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀。</strong></p><pre><code class="javascript">function foo() &#123;&#125;;
foo.bind(&#123;&#125;).name // &quot;bound foo&quot;

(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot;
</code></pre><hr><h4 id="5-箭头函数"><a href="#5-箭头函数" class="headerlink" title="5. 箭头函数"></a>5. 箭头函数</h4><p><strong>基本用法</strong></p><p><strong>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</strong></p><pre><code class="javascript">var f = v =&gt; v;

// 等同于
var f = function (v) &#123;
  return v;
&#125;;
</code></pre><p><strong>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</strong></p><pre><code class="javascript">var f = () =&gt; 5;
// 等同于
var f = function () &#123; return 5 &#125;;

var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) &#123;
  return num1 + num2;
&#125;;
</code></pre><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p><pre><code class="javascript">var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;
</code></pre><p><strong>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</strong></p><pre><code class="javascript">// 报错
let getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;

// 不报错
let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);
</code></pre><p>下面是一种特殊情况，虽然可以运行，但会得到错误的结果。</p><pre><code class="javascript">let foo = () =&gt; &#123; a: 1 &#125;;
foo() // undefined
</code></pre><p>上面代码中，原始意图是返回一个对象<code>&#123; a: 1 &#125;</code>，但是由于引擎认为大括号是代码块，所以执行了一行语句<code>a: 1</code>。这时，<code>a</code>可以被解释为语句的标签，因此实际执行的语句是<code>1;</code>，然后函数就结束了，没有返回值。</p><p>如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。</p><pre><code class="javascript">let fn = () =&gt; void doesNotReturn();
</code></pre><p>箭头函数可以与变量解构结合使用。</p><pre><code class="javascript">const full = (&#123; first, last &#125;) =&gt; first + &#39; &#39; + last;

// 等同于
function full(person) &#123;
  return person.first + &#39; &#39; + person.last;
&#125;
</code></pre><p>箭头函数使得表达更加简洁。</p><pre><code class="javascript">const isEven = n =&gt; n % 2 === 0;
const square = n =&gt; n * n;
</code></pre><p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p><p>箭头函数的一个用处是简化回调函数。</p><pre><code class="javascript">// 普通函数写法
[1,2,3].map(function (x) &#123;
  return x * x;
&#125;);

// 箭头函数写法
[1,2,3].map(x =&gt; x * x);
</code></pre><p>另一个例子是</p><pre><code class="javascript">// 普通函数写法
var result = values.sort(function (a, b) &#123;
  return a - b;
&#125;);

// 箭头函数写法
var result = values.sort((a, b) =&gt; a - b);
</code></pre><p>下面是 rest 参数与箭头函数结合的例子。</p><pre><code class="javascript">const numbers = (...nums) =&gt; nums;

numbers(1, 2, 3, 4, 5)
// [1,2,3,4,5]

const headAndTail = (head, ...tail) =&gt; [head, tail];

headAndTail(1, 2, 3, 4, 5)
// [1,[2,3,4,5]]
</code></pre><hr><p><strong>使用注意点</strong></p><p>箭头函数有几个使用注意点。</p><p>（1）<strong>箭头函数没有自己的<code>this</code>对象</strong>（详见下文）。</p><p>（2）<strong>不可以当作构造函数</strong>，也就是说，<strong>不可以对箭头函数使用<code>new</code>命令</strong>，否则会抛出一个错误。</p><p>（3）<strong>不可以使用<code>arguments</code>对象</strong>，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p><p>（4）<strong>不可以使用<code>yield</code>命令</strong>，因此箭头函数不能用作 Generator 函数。</p><p>上面四点中，最重要的是第一点。对于普通函数来说，内部的<code>this</code>指向函数运行时所在的对象，但是这一点对箭头函数不成立。它没有自己的<code>this</code>对象，内部的<code>this</code>就是定义时上层作用域中的<code>this</code>。也就是说，箭头函数内部的<code>this</code>指向是固定的，相比之下，普通函数的<code>this</code>指向是可变的。</p><pre><code class="javascript">function foo() &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;id:&#39;, this.id);
  &#125;, 100);
&#125;

var id = 21;

foo.call(&#123; id: 42 &#125;);
// id: 42
</code></pre><p>上面代码中，<code>setTimeout()</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>&#123;id: 42&#125;</code>），所以打印出来的是<code>42</code>。</p><p>下面例子是回调函数分别为箭头函数和普通函数，对比它们内部的<code>this</code>指向。</p><pre><code class="javascript">function Timer() &#123;
  this.s1 = 0;
  this.s2 = 0;
  // 箭头函数
  setInterval(() =&gt; this.s1++, 1000);
  // 普通函数
  setInterval(function () &#123;
    this.s2++;
  &#125;, 1000);
&#125;

var timer = new Timer();

setTimeout(() =&gt; console.log(&#39;s1: &#39;, timer.s1), 3100);
setTimeout(() =&gt; console.log(&#39;s2: &#39;, timer.s2), 3100);
// s1: 3
// s2: 0
</code></pre><p>上面代码中，<code>Timer</code>函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的<code>this</code>绑定定义时所在的作用域（即<code>Timer</code>函数），后者的<code>this</code>指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，<code>timer.s1</code>被更新了 3 次，而<code>timer.s2</code>一次都没更新。</p><p>箭头函数实际上可以让<code>this</code>指向固定化，绑定<code>this</code>使得它不再可变，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。</p><pre><code class="javascript">var handler = &#123;
  id: &#39;123456&#39;,

  init: function() &#123;
    document.addEventListener(&#39;click&#39;,
      event =&gt; this.doSomething(event.type), false);
  &#125;,

  doSomething: function(type) &#123;
    console.log(&#39;Handling &#39; + type  + &#39; for &#39; + this.id);
  &#125;
&#125;;
</code></pre><p>上面代码的<code>init()</code>方法中，<strong>使用了箭头函数，这导致这个箭头函数里面的<code>this</code>，总是指向<code>handler</code>对象</strong>。如果回调函数是普通函数，那么运行<code>this.doSomething()</code>这一行会报错，因为此时<code>this</code>指向<code>document</code>对象。</p><p>总之，箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数。</p><p>下面是 Babel 转箭头函数产生的 ES5 代码，就能清楚地说明<code>this</code>的指向。</p><pre><code class="javascript">// ES6
function foo() &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;id:&#39;, this.id);
  &#125;, 100);
&#125;

// ES5
function foo() &#123;
  var _this = this;

  setTimeout(function () &#123;
    console.log(&#39;id:&#39;, _this.id);
  &#125;, 100);
&#125;
</code></pre><p>上面代码中，转换后的 ES5 版本清楚地说明了，<strong>箭头函数里面根本没有自己的<code>this</code>，而是引用外层的<code>this</code>。</strong></p><p>请问下面的代码之中，<code>this</code>的指向有几个？</p><pre><code class="javascript">function foo() &#123;
  return () =&gt; &#123;
    return () =&gt; &#123;
      return () =&gt; &#123;
        console.log(&#39;id:&#39;, this.id);
      &#125;;
    &#125;;
  &#125;;
&#125;

var f = foo.call(&#123;id: 1&#125;);

var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1
var t2 = f().call(&#123;id: 3&#125;)(); // id: 1
var t3 = f()().call(&#123;id: 4&#125;); // id: 1
</code></pre><p>答案是<code>this</code>的指向只有一个，就是函数<code>foo</code>的<code>this</code>，这是因为所有的内层函数都是箭头函数，都没有自己的<code>this</code>，它们的<code>this</code>其实都是最外层<code>foo</code>函数的<code>this</code>。所以不管怎么嵌套，<code>t1</code>、<code>t2</code>、<code>t3</code>都输出同样的结果。如果这个例子的所有内层函数都写成普通函数，那么每个函数的<code>this</code>都指向运行时所在的不同对象。</p><p><strong>除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code>。</strong></p><pre><code class="javascript">function foo() &#123;
  setTimeout(() =&gt; &#123;
    console.log(&#39;args:&#39;, arguments);
  &#125;, 100);
&#125;

foo(2, 4, 6, 8)
// args: [2, 4, 6, 8]
</code></pre><p>上面代码中，箭头函数内部的变量<code>arguments</code>，其实是函数<code>foo</code>的<code>arguments</code>变量。</p><p><strong>另外，由于箭头函数没有自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</strong></p><pre><code class="javascript">(function() &#123;
  return [
    (() =&gt; this.x).bind(&#123; x: &#39;inner&#39; &#125;)()
  ];
&#125;).call(&#123; x: &#39;outer&#39; &#125;);
// [&#39;outer&#39;]
</code></pre><p>上面代码中，箭头函数没有自己的<code>this</code>，所以<code>bind</code>方法无效，内部的<code>this</code>指向外部的<code>this</code>。</p><p>长期以来，JavaScript 语言的<code>this</code>对象一直是一个令人头痛的问题，在对象方法中使用<code>this</code>，必须非常小心。箭头函数”绑定”<code>this</code>，很大程度上解决了这个困扰。</p><hr><p><strong>不适用场合</strong></p><p>由于箭头函数使得<code>this</code>从“动态”变成“静态”，下面两个场合不应该使用箭头函数。</p><p><strong>第一个场合是定义对象的方法，且该方法内部包括<code>this</code>。</strong></p><pre><code class="javascript">const cat = &#123;
  lives: 9,
  jumps: () =&gt; &#123;
    this.lives--;
  &#125;
&#125;
</code></pre><p>上面代码中，<code>cat.jumps()</code>方法是一个箭头函数，这是错误的。调用<code>cat.jumps()</code>时，如果是普通函数，该方法内部的<code>this</code>指向<code>cat</code>；如果写成上面那样的箭头函数，使得<code>this</code>指向全局对象，因此不会得到预期结果。<strong>这是因为对象不构成单独的作用域，导致<code>jumps</code>箭头函数定义时的作用域就是全局作用域。</strong></p><p>再看一个例子。</p><pre><code class="javascript">globalThis.s = 21;

const obj = &#123;
  s: 42,
  m: () =&gt; console.log(this.s)
&#125;;

obj.m() // 21
</code></pre><p>上面例子中，<code>obj.m()</code>使用箭头函数定义。JavaScript 引擎的处理方法是，先在全局空间生成这个箭头函数，然后赋值给<code>obj.m</code>，这导致箭头函数内部的<code>this</code>指向全局对象，所以<code>obj.m()</code>输出的是全局空间的<code>21</code>，而不是对象内部的<code>42</code>。上面的代码实际上等同于下面的代码。</p><pre><code class="javascript">globalThis.s = 21;
globalThis.m = () =&gt; console.log(this.s);

const obj = &#123;
  s: 42,
  m: globalThis.m
&#125;;

obj.m() // 21
</code></pre><p>由于上面这个原因，<strong>对象的属性建议使用传统的写法定义，不要用箭头函数定义。</strong></p><p><strong>第二个场合是需要动态<code>this</code>的时候，也不应使用箭头函数。</strong></p><pre><code class="javascript">var button = document.getElementById(&#39;press&#39;);
button.addEventListener(&#39;click&#39;, () =&gt; &#123;
  this.classList.toggle(&#39;on&#39;);
&#125;);
</code></pre><p>上面代码运行时，点击按钮会报错，因为<code>button</code>的监听函数是一个箭头函数，导致里面的<code>this</code>就是全局对象。如果改成普通函数，<code>this</code>就会动态指向被点击的按钮对象。</p><p>另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。</p><hr><p><strong>嵌套的箭头函数</strong></p><p>箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。</p><pre><code class="javascript">function insert(value) &#123;
  return &#123;into: function (array) &#123;
    return &#123;after: function (afterValue) &#123;
      array.splice(array.indexOf(afterValue) + 1, 0, value);
      return array;
    &#125;&#125;;
  &#125;&#125;;
&#125;

insert(2).into([1, 3]).after(1); //[1, 2, 3]
</code></pre><p>上面这个函数，可以使用箭头函数改写。</p><pre><code class="javascript">let insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123;after: (afterValue) =&gt; &#123;
  array.splice(array.indexOf(afterValue) + 1, 0, value);
  return array;
&#125;&#125;)&#125;);

insert(2).into([1, 3]).after(1); //[1, 2, 3]
</code></pre><p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p><pre><code class="javascript">const pipeline = (...funcs) =&gt;
  val =&gt; funcs.reduce((a, b) =&gt; b(a), val);

const plus1 = a =&gt; a + 1;
const mult2 = a =&gt; a * 2;
const addThenMult = pipeline(plus1, mult2);

addThenMult(5)
// 12
</code></pre><p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p><pre><code class="javascript">const plus1 = a =&gt; a + 1;
const mult2 = a =&gt; a * 2;

mult2(plus1(5))
// 12
</code></pre><p>箭头函数还有一个功能，就是可以很方便地改写 λ 演算。</p><pre><code class="javascript">// λ演算的写法
fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))

// ES6的写法
var fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v)))
               (x =&gt; f(v =&gt; x(x)(v)));
</code></pre><p>上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。</p><hr><h4 id="6-尾调用优化"><a href="#6-尾调用优化" class="headerlink" title="6. 尾调用优化"></a>6. 尾调用优化</h4><p><strong>什么是尾调用？</strong></p><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，<strong>就是指某个函数的最后一步是调用另一个函数。</strong></p><pre><code class="javascript">function f(x)&#123;
  return g(x);
&#125;
</code></pre><p>上面代码中，函数<code>f</code>的最后一步是调用函数<code>g</code>，这就叫尾调用。</p><p>以下三种情况，都不属于尾调用。</p><pre><code class="javascript">// 情况一
function f(x)&#123;
  let y = g(x);
  return y;
&#125;

// 情况二
function f(x)&#123;
  return g(x) + 1;
&#125;

// 情况三
function f(x)&#123;
  g(x);
&#125;
</code></pre><p>上面代码中，情况一是调用函数<code>g</code>之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。<strong>情况三等同于下面的代码</strong>。</p><pre><code class="javascript">function f(x)&#123;
  g(x);
  return undefined;
&#125;
</code></pre><p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p><pre><code class="javascript">function f(x) &#123;
  if (x &gt; 0) &#123;
    return m(x)
  &#125;
  return n(x);
&#125;
</code></pre><p>上面代码中，函数<code>m</code>和<code>n</code>都属于尾调用，因为它们都是函数<code>f</code>的最后一步操作。</p><p><strong>尾调用优化</strong></p><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p><p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数<code>A</code>的内部调用函数<code>B</code>，那么在<code>A</code>的调用帧上方，还会形成一个<code>B</code>的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p><pre><code class="javascript">function f() &#123;
  let m = 1;
  let n = 2;
  return g(m + n);
&#125;
f();

// 等同于
function f() &#123;
  return g(3);
&#125;
f();

// 等同于
g(3);
</code></pre><p>上面代码中，如果函数<code>g</code>不是尾调用，函数<code>f</code>就需要保存内部变量<code>m</code>和<code>n</code>的值、<code>g</code>的调用位置等信息。但由于调用<code>g</code>之后，函数<code>f</code>就结束了，所以执行到最后一步，完全可以删除<code>f(x)</code>的调用帧，只保留<code>g(3)</code>的调用帧。</p><p><strong>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</strong></p><p><strong>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</strong></p><pre><code class="javascript">function addOne(a)&#123;
  var one = 1;
  function inner(b)&#123;
    return b + one;
  &#125;
  return inner(a);
&#125;
</code></pre><p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p><p>注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。</p><hr><p><strong>尾递归</strong></p><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p><pre><code class="javascript">function factorial(n) &#123;
  if (n === 1) return 1;
  return n * factorial(n - 1);
&#125;

factorial(5) // 120
</code></pre><p>上面代码是一个阶乘函数，计算<code>n</code>的阶乘，最多需要保存<code>n</code>个调用记录，复杂度 O(n) 。</p><p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p><pre><code class="javascript">function factorial(n, total) &#123;
  if (n === 1) return total;
  return factorial(n - 1, n * total);
&#125;

factorial(5, 1) // 120
</code></pre><p>还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。</p><p>非尾递归的 Fibonacci 数列实现如下。</p><pre><code class="javascript">function Fibonacci (n) &#123;
  if ( n &lt;= 1 ) &#123;return 1&#125;;

  return Fibonacci(n - 1) + Fibonacci(n - 2);
&#125;

Fibonacci(10) // 89
Fibonacci(100) // 超时
Fibonacci(500) // 超时
</code></pre><p>尾递归优化过的 Fibonacci 数列实现如下。</p><pre><code class="javascript">function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123;
  if( n &lt;= 1 ) &#123;return ac2&#125;;

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
&#125;

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
</code></pre><p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。</p><p><strong>递归函数的改写</strong></p><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量<code>total</code>，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算<code>5</code>的阶乘，需要传入两个参数<code>5</code>和<code>1</code>？</p><p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p><pre><code class="javascript">function tailFactorial(n, total) &#123;
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
&#125;

function factorial(n) &#123;
  return tailFactorial(n, 1);
&#125;

factorial(5) // 120
</code></pre><p>上面代码通过一个正常形式的阶乘函数<code>factorial</code>，调用尾递归函数<code>tailFactorial</code>，看起来就正常多了。</p><p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p><pre><code class="javascript">function currying(fn, n) &#123;
  return function (m) &#123;
    return fn.call(this, m, n);
  &#125;;
&#125;

function tailFactorial(n, total) &#123;
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
&#125;

const factorial = currying(tailFactorial, 1);

factorial(5) // 120
</code></pre><p><strong>上面代码通过柯里化，将尾递归函数<code>tailFactorial</code>变为只接受一个参数的<code>factorial</code>。</strong></p><p><strong>第二种方法就简单多了，就是采用 ES6 的函数默认值。</strong></p><pre><code class="javascript">function factorial(n, total = 1) &#123;
  if (n === 1) return total;
  return factorial(n - 1, n * total);
&#125;

factorial(5) // 120
</code></pre><p>上面代码中，参数<code>total</code>有默认值<code>1</code>，所以调用时不用提供这个值。</p><p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p><hr><p><strong>严格模式</strong></p><p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p><p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><ul><li><code>func.arguments</code>：返回调用时函数的参数。</li><li><code>func.caller</code>：返回调用当前函数的那个函数。</li></ul><p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p><pre><code class="javascript">function restricted() &#123;
  &#39;use strict&#39;;
  restricted.caller;    // 报错
  restricted.arguments; // 报错
&#125;
restricted();
</code></pre><p><strong>尾递归优化的实现</strong></p><p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p><p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p><p>下面是一个正常的递归函数。</p><pre><code class="javascript">function sum(x, y) &#123;
  if (y &gt; 0) &#123;
    return sum(x + 1, y - 1);
  &#125; else &#123;
    return x;
  &#125;
&#125;

sum(1, 100000)
// Uncaught RangeError: Maximum call stack size exceeded(…)
</code></pre><p>上面代码中，<code>sum</code>是一个递归函数，参数<code>x</code>是需要累加的值，参数<code>y</code>控制递归次数。一旦指定<code>sum</code>递归 100000 次，就会报错，提示超出调用栈的最大次数。</p><p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p><pre><code class="javascript">function trampoline(f) &#123;
  while (f &amp;&amp; f instanceof Function) &#123;
    f = f();
  &#125;
  return f;
&#125;
</code></pre><p>上面就是蹦床函数的一个实现，它接受一个函数<code>f</code>作为参数。只要<code>f</code>执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p><p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p><pre><code class="javascript">function sum(x, y) &#123;
  if (y &gt; 0) &#123;
    return sum.bind(null, x + 1, y - 1);
  &#125; else &#123;
    return x;
  &#125;
&#125;
</code></pre><p>上面代码中，<code>sum</code>函数的每次执行，都会返回自身的另一个版本。</p><p>现在，使用蹦床函数执行<code>sum</code>，就不会发生调用栈溢出。</p><pre><code class="javascript">trampoline(sum(1, 100000))
// 100001
</code></pre><p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p><pre><code class="javascript">function tco(f) &#123;
  var value;
  var active = false;
  var accumulated = [];

  return function accumulator() &#123;
    accumulated.push(arguments);
    if (!active) &#123;
      active = true;
      while (accumulated.length) &#123;
        value = f.apply(this, accumulated.shift());
      &#125;
      active = false;
      return value;
    &#125;
  &#125;;
&#125;

var sum = tco(function(x, y) &#123;
  if (y &gt; 0) &#123;
    return sum(x + 1, y - 1)
  &#125;
  else &#123;
    return x
  &#125;
&#125;);

sum(1, 100000)
// 100001
</code></pre><p>上面代码中，<code>tco</code>函数是尾递归优化的实现，它的奥妙就在于状态变量<code>active</code>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归<code>sum</code>返回的都是<code>undefined</code>，所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮<code>sum</code>执行的参数，总是有值的，这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p><hr><h4 id="7-函数参数的尾逗号"><a href="#7-函数参数的尾逗号" class="headerlink" title="7. 函数参数的尾逗号"></a>7. 函数参数的尾逗号</h4><p>ES2017 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2plZmZtby9lcy10cmFpbGluZy1mdW5jdGlvbi1jb21tYXM=">允许</span>函数的最后一个参数有尾逗号（trailing comma）。</p><p>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</p><pre><code class="javascript">function clownsEverywhere(
  param1,
  param2
) &#123; /* ... */ &#125;

clownsEverywhere(
  &#39;foo&#39;,
  &#39;bar&#39;
);
</code></pre><p>上面代码中，如果在<code>param2</code>或<code>bar</code>后面加一个逗号，就会报错。</p><p>如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数<code>clownsEverywhere</code>添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。</p><pre><code class="javascript">function clownsEverywhere(
  param1,
  param2,
) &#123; /* ... */ &#125;

clownsEverywhere(
  &#39;foo&#39;,
  &#39;bar&#39;,
);
</code></pre><p>这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。</p><hr><h4 id="8-Function-prototype-toString"><a href="#8-Function-prototype-toString" class="headerlink" title="8. Function.prototype.toString()"></a>8. Function.prototype.toString()</h4><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvRnVuY3Rpb24tcHJvdG90eXBlLXRvU3RyaW5nLXJldmlzaW9u">ES2019</span> 对函数实例的<code>toString()</code>方法做出了修改。</p><p><code>toString()</code>方法返回函数代码本身，以前会省略注释和空格。</p><pre><code class="javascript">function /* foo comment */ foo () &#123;&#125;

foo.toString()
// function foo() &#123;&#125;
</code></pre><p>上面代码中，函数<code>foo</code>的原始代码包含注释，函数名<code>foo</code>和圆括号之间有空格，但是<code>toString()</code>方法都把它们省略了。</p><p>修改后的<code>toString()</code>方法，明确要求返回一模一样的原始代码。</p><pre><code class="javascript">function /* foo comment */ foo () &#123;&#125;

foo.toString()
// &quot;function /* foo comment */ foo () &#123;&#125;&quot;
</code></pre><hr><h4 id="9-catch-命令的参数省略"><a href="#9-catch-命令的参数省略" class="headerlink" title="9. catch 命令的参数省略"></a>9. catch 命令的参数省略</h4><p>JavaScript 语言的<code>try...catch</code>结构，以前明确要求<code>catch</code>命令后面必须跟参数，接受<code>try</code>代码块抛出的错误对象。</p><pre><code class="javascript">try &#123;
  // ...
&#125; catch (err) &#123;
  // 处理错误
&#125;
</code></pre><p>上面代码中，<code>catch</code>命令后面带有参数<code>err</code>。</p><p>很多时候，<code>catch</code>代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb3B0aW9uYWwtY2F0Y2gtYmluZGluZw==">ES2019</span> 做出了改变，允许<code>catch</code>语句省略参数。</p><pre><code class="javascript">try &#123;
  // ...
&#125; catch &#123;
  // ...
&#125;
</code></pre><h3 id="8、数组的扩展"><a href="#8、数组的扩展" class="headerlink" title="8、数组的扩展"></a>8、数组的扩展</h3><hr><h4 id="1-扩展运算符"><a href="#1-扩展运算符" class="headerlink" title="1. 扩展运算符"></a>1. 扩展运算符</h4><p><strong>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</strong></p><pre><code class="javascript">console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll(&#39;div&#39;)]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]
</code></pre><p><strong>该运算符主要用于函数调用。</strong></p><pre><code class="javascript">function push(array, ...items) &#123;
  array.push(...items);
&#125;

function add(x, y) &#123;
  return x + y;
&#125;

const numbers = [4, 38];
add(...numbers) // 42
</code></pre><p>上面代码中，<code>array.push(...items)</code>和<code>add(...numbers)</code>这两行，都是函数的调用，它们都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p><p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p><pre><code class="javascript">function f(v, w, x, y, z) &#123; &#125;
const args = [0, 1];
f(-1, ...args, 2, ...[3]);
</code></pre><p><strong>扩展运算符后面还可以放置表达式。</strong></p><pre><code class="javascript">const arr = [
  ...(x &gt; 0 ? [&#39;a&#39;] : []),
  &#39;b&#39;,
];
</code></pre><p><strong>如果扩展运算符后面是一个空数组，则不产生任何效果。</strong></p><pre><code class="javascript">[...[], 1]
// [1]
</code></pre><p><strong>注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。</strong></p><pre><code class="javascript">(...[1, 2])
// Uncaught SyntaxError: Unexpected number

console.log((...[1, 2]))
// Uncaught SyntaxError: Unexpected number

console.log(...[1, 2])
// 1 2
</code></pre><p>上面三种情况，扩展运算符都放在圆括号里面，但是前两种情况会报错，因为扩展运算符所在的括号不是函数调用。</p><hr><p><strong>替代函数的 apply 方法</strong></p><p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。</p><pre><code class="javascript">// ES5 的写法
function f(x, y, z) &#123;
  // ...
&#125;
var args = [0, 1, 2];
f.apply(null, args);

// ES6的写法
function f(x, y, z) &#123;
  // ...
&#125;
let args = [0, 1, 2];
f(...args);
</code></pre><p>下面是扩展运算符取代<code>apply</code>方法的一个实际的例子，应用<code>Math.max</code>方法，简化求出一个数组最大元素的写法。</p><pre><code class="javascript">// ES5 的写法
Math.max.apply(null, [14, 3, 77])

// ES6 的写法
Math.max(...[14, 3, 77])

// 等同于
Math.max(14, 3, 77);
</code></pre><p>上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用<code>Math.max</code>函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用<code>Math.max</code>了。</p><p>另一个例子是通过<code>push</code>函数，将一个数组添加到另一个数组的尾部。</p><pre><code class="javascript">// ES5的 写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);

// ES6 的写法
let arr1 = [0, 1, 2];
let arr2 = [3, 4, 5];
arr1.push(...arr2);
</code></pre><p>上面代码的 ES5 写法中，<code>push</code>方法的参数不能是数组，所以只好通过<code>apply</code>方法变通使用<code>push</code>方法。有了扩展运算符，就可以直接将数组传入<code>push</code>方法。</p><p>下面是另外一个例子。</p><pre><code class="javascript">// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);
</code></pre><p><strong>扩展运算符的应用</strong></p><p><strong>（1）复制数组</strong></p><p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p><pre><code class="javascript">const a1 = [1, 2];
const a2 = a1;

a2[0] = 2;
a1 // [2, 2]
</code></pre><p>上面代码中，<code>a2</code>并不是<code>a1</code>的克隆，而是指向同一份数据的另一个指针。修改<code>a2</code>，会直接导致<code>a1</code>的变化。</p><p><strong>ES5 只能用变通方法来复制数组。</strong></p><pre><code class="javascript">const a1 = [1, 2];
const a2 = a1.concat();

a2[0] = 2;
a1 // [1, 2]
</code></pre><p>上面代码中，<code>a1</code>会返回原数组的克隆，再修改<code>a2</code>就不会对<code>a1</code>产生影响。</p><p><strong>扩展运算符提供了复制数组的简便写法。</strong></p><pre><code class="javascript">const a1 = [1, 2];
// 写法一
const a2 = [...a1];
// 写法二
const [...a2] = a1;
</code></pre><p>上面的两种写法，<code>a2</code>都是<code>a1</code>的克隆。</p><p><strong>（2）合并数组</strong></p><p>扩展运算符提供了数组合并的新写法。</p><pre><code class="javascript">const arr1 = [&#39;a&#39;, &#39;b&#39;];
const arr2 = [&#39;c&#39;];
const arr3 = [&#39;d&#39;, &#39;e&#39;];

// ES5 的合并数组
arr1.concat(arr2, arr3);
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]

// ES6 的合并数组
[...arr1, ...arr2, ...arr3]
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
</code></pre><p>不过，这两种方法都是浅拷贝，使用的时候需要注意。</p><pre><code class="javascript">const a1 = [&#123; foo: 1 &#125;];
const a2 = [&#123; bar: 2 &#125;];

const a3 = a1.concat(a2);
const a4 = [...a1, ...a2];

a3[0] === a1[0] // true
a4[0] === a1[0] // true
</code></pre><p>上面代码中，<code>a3</code>和<code>a4</code>是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。</p><p><strong>（3）与解构赋值结合</strong></p><p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p><pre><code class="javascript">// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list
</code></pre><p>下面是另外一些例子。</p><pre><code class="javascript">const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...rest] = [];
first // undefined
rest  // []

const [first, ...rest] = [&quot;foo&quot;];
first  // &quot;foo&quot;
rest   // []
</code></pre><p><strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p><pre><code class="javascript">const [...butLast, last] = [1, 2, 3, 4, 5];
// 报错

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错
</code></pre><p><strong>（4）字符串</strong></p><p><strong>扩展运算符还可以将字符串转为真正的数组。</strong></p><pre><code class="javascript">[...&#39;hello&#39;]
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
</code></pre><p><strong>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。</strong></p><pre><code class="javascript">&#39;x\uD83D\uDE80y&#39;.length // 4
[...&#39;x\uD83D\uDE80y&#39;].length // 3
</code></pre><p>上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p><pre><code class="javascript">function length(str) &#123;
  return [...str].length;
&#125;

length(&#39;x\uD83D\uDE80y&#39;) // 3
</code></pre><p>凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p><pre><code class="javascript">let str = &#39;x\uD83D\uDE80y&#39;;

str.split(&#39;&#39;).reverse().join(&#39;&#39;)
// &#39;y\uDE80\uD83Dx&#39;

[...str].reverse().join(&#39;&#39;)
// &#39;y\uD83D\uDE80x&#39;
</code></pre><p>上面代码中，如果不用扩展运算符，字符串的<code>reverse</code>操作就不正确。</p><p><strong>（5）实现了 Iterator 接口的对象</strong></p><p>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p><pre><code class="javascript">let nodeList = document.querySelectorAll(&#39;div&#39;);
let array = [...nodeList];
</code></pre><p>上面代码中，<code>querySelectorAll</code>方法返回的是一个<code>NodeList</code>对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于<code>NodeList</code>对象实现了 Iterator 。</p><pre><code class="javascript">Number.prototype[Symbol.iterator] = function*() &#123;
  let i = 0;
  let num = this.valueOf();
  while (i &lt; num) &#123;
    yield i++;
  &#125;
&#125;

console.log([...5]) // [0, 1, 2, 3, 4]
</code></pre><p>上面代码中，先定义了<code>Number</code>对象的遍历器接口，扩展运算符将<code>5</code>自动转成<code>Number</code>实例以后，就会调用这个接口，就会返回自定义的结果。</p><p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p><pre><code class="javascript">let arrayLike = &#123;
  &#39;0&#39;: &#39;a&#39;,
  &#39;1&#39;: &#39;b&#39;,
  &#39;2&#39;: &#39;c&#39;,
  length: 3
&#125;;

// TypeError: Cannot spread non-iterable object.
let arr = [...arrayLike];
</code></pre><p>上面代码中，<code>arrayLike</code>是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，<strong>可以改为使用<code>Array.from</code>方法将<code>arrayLike</code>转为真正的数组。</strong></p><p><strong>（6）Map 和 Set 结构，Generator 函数</strong></p><p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p><pre><code class="javascript">let map = new Map([
  [1, &#39;one&#39;],
  [2, &#39;two&#39;],
  [3, &#39;three&#39;],
]);

let arr = [...map.keys()]; // [1, 2, 3]
</code></pre><p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p><pre><code class="javascript">const go = function*()&#123;
  yield 1;
  yield 2;
  yield 3;
&#125;;

[...go()] // [1, 2, 3]
</code></pre><p>上面代码中，变量<code>go</code>是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p><p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。</p><pre><code class="javascript">const obj = &#123;a: 1, b: 2&#125;;
let arr = [...obj]; // TypeError: Cannot spread non-iterable object
</code></pre><hr><h4 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2. Array.from()"></a>2. Array.from()</h4><p><strong><code>Array.from</code>方法用于将两类对象转为真正的数组：****类似数组的对象</strong>（array-like object）和<strong>可遍历（iterable）的对象</strong>（包括 ES6 新增的数据结构 Set 和 Map）。</p><p>下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。</p><pre><code class="javascript">let arrayLike = &#123;
    &#39;0&#39;: &#39;a&#39;,
    &#39;1&#39;: &#39;b&#39;,
    &#39;2&#39;: &#39;c&#39;,
    length: 3
&#125;;

// ES5的写法
var arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

// ES6的写法
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre><p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的<code>arguments</code>对象。<code>Array.from</code>都可以将它们转为真正的数组。</p><pre><code class="javascript">// NodeList对象
let ps = document.querySelectorAll(&#39;p&#39;);
Array.from(ps).filter(p =&gt; &#123;
  return p.textContent.length &gt; 100;
&#125;);

// arguments对象
function foo() &#123;
  var args = Array.from(arguments);
  // ...
&#125;
</code></pre><p>上面代码中，<code>querySelectorAll</code>方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用<code>filter</code>方法。</p><p>只要是部署了 Iterator 接口的数据结构，<code>Array.from</code>都能将其转为数组。</p><pre><code class="javascript">Array.from(&#39;hello&#39;)
// [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]

let namesSet = new Set([&#39;a&#39;, &#39;b&#39;])
Array.from(namesSet) // [&#39;a&#39;, &#39;b&#39;]
</code></pre><p>上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被<code>Array.from</code>转为真正的数组。</p><p>如果参数是一个真正的数组，<code>Array.from</code>会返回一个一模一样的新数组。</p><pre><code class="javascript">Array.from([1, 2, 3])
// [1, 2, 3]
</code></pre><p>值得提醒的是，扩展运算符（<code>...</code>）也可以将某些数据结构转为数组。</p><pre><code class="javascript">// arguments对象
function foo() &#123;
  const args = [...arguments];
&#125;

// NodeList对象
[...document.querySelectorAll(&#39;div&#39;)]
</code></pre><p><strong>扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换</strong>。<code>Array.from</code>方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性。因此，<strong>任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组，而此时扩展运算符就无法转换。</strong></p><pre><code class="javascript">Array.from(&#123; length: 3 &#125;);
// [ undefined, undefined, undefined ]
</code></pre><p>上面代码中，<code>Array.from</code>返回了一个具有三个成员的数组，每个位置的值都是<code>undefined</code>。扩展运算符转换不了这个对象。</p><p>对于还没有部署该方法的浏览器，可以用<code>Array.prototype.slice</code>方法替代。</p><pre><code class="javascript">const toArray = (() =&gt;
  Array.from ? Array.from : obj =&gt; [].slice.call(obj)
)();
</code></pre><p><strong><code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</strong></p><pre><code class="javascript">Array.from(arrayLike, x =&gt; x * x);
// 等同于
Array.from(arrayLike).map(x =&gt; x * x);

Array.from([1, 2, 3], (x) =&gt; x * x)
// [1, 4, 9]
</code></pre><p>下面的例子是取出一组 DOM 节点的文本内容。</p><pre><code class="javascript">let spans = document.querySelectorAll(&#39;span.name&#39;);

// map()
let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);

// Array.from()
let names2 = Array.from(spans, s =&gt; s.textContent)
</code></pre><p>下面的例子将数组中布尔值为<code>false</code>的成员转为<code>0</code>。</p><pre><code class="javascript">Array.from([1, , 2, , 3], (n) =&gt; n || 0)
// [1, 0, 2, 0, 3]
</code></pre><p>另一个例子是返回各种数据的类型。</p><pre><code class="javascript">function typesOf () &#123;
  return Array.from(arguments, value =&gt; typeof value)
&#125;
typesOf(null, [], NaN)
// [&#39;object&#39;, &#39;object&#39;, &#39;number&#39;]
</code></pre><p>如果<code>map</code>函数里面用到了<code>this</code>关键字，还可以传入<code>Array.from</code>的第三个参数，用来绑定<code>this</code>。</p><p><code>Array.from()</code>可以将各种值转为真正的数组，并且还提供<code>map</code>功能。这实际上意味着，<strong>只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</strong></p><pre><code class="javascript">Array.from(&#123; length: 2 &#125;, () =&gt; &#39;jack&#39;)
// [&#39;jack&#39;, &#39;jack&#39;]
</code></pre><p>上面代码中，<code>Array.from</code>的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。</p><p><code>Array.from()</code>的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于<code>\uFFFF</code>的 Unicode 字符，算作两个字符的 bug。</p><pre><code class="javascript">function countSymbols(string) &#123;
  return Array.from(string).length;
&#125;
</code></pre><hr><h4 id="3-Array-of"><a href="#3-Array-of" class="headerlink" title="3. Array.of()"></a>3. Array.of()</h4><p><strong><code>Array.of()</code>方法用于将一组值，转换为数组。</strong></p><pre><code class="javascript">Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
</code></pre><p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。<strong>因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</strong></p><pre><code class="javascript">Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
</code></pre><p>上面代码中，<code>Array()</code>方法没有参数、一个参数、三个参数时，返回的结果都不一样。只有当参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组。参数只有一个正整数时，实际上是指定数组的长度。</p><p><code>Array.of()</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p><pre><code class="javascript">Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]
</code></pre><p><code>Array.of()</code>总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p><p><code>Array.of()</code>方法可以用下面的代码模拟实现。</p><pre><code class="javascript">function ArrayOf()&#123;
  return [].slice.call(arguments);
&#125;
</code></pre><hr><h4 id="4-数组实例的-copyWithin"><a href="#4-数组实例的-copyWithin" class="headerlink" title="4. 数组实例的 copyWithin()"></a>4. 数组实例的 copyWithin()</h4><p><strong>数组实例的<code>copyWithin()</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</strong>。也就是说，使用这个方法，<strong>会修改当前数组</strong>。</p><pre><code class="javascript">Array.prototype.copyWithin(target, start = 0, end = this.length)
</code></pre><p>它接受三个参数。</p><ul><li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li><li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li><li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li></ul><p>这三个参数都应该是数值，如果不是，会自动转为数值。</p><pre><code class="javascript">[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]
</code></pre><p>上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。</p><p>下面是更多例子。</p><pre><code class="javascript">// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]

// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]

// 将3号位复制到0号位
[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)
// &#123;0: 1, 3: 1, length: 5&#125;

// 将2号位到数组结束，复制到0号位
let i32a = new Int32Array([1, 2, 3, 4, 5]);
i32a.copyWithin(0, 2);
// Int32Array [3, 4, 5, 4, 5]

// 对于没有部署 TypedArray 的 copyWithin 方法的平台
// 需要采用下面的写法
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);
// Int32Array [4, 2, 3, 4, 5]
</code></pre><hr><h4 id="5-数组实例的-find-和-findIndex"><a href="#5-数组实例的-find-和-findIndex" class="headerlink" title="5. 数组实例的 find() 和 findIndex()"></a>5. 数组实例的 find() 和 findIndex()</h4><p><strong>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</strong></p><pre><code class="javascript">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)
// -5
</code></pre><p>上面代码找出数组中第一个小于 0 的成员。</p><pre><code class="javascript">[1, 5, 10, 15].find(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 10
</code></pre><p>上面代码中，<code>find</code>方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p><p>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</p><pre><code class="javascript">[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;
  return value &gt; 9;
&#125;) // 2
</code></pre><p><strong>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</strong></p><pre><code class="javascript">function f(v)&#123;
  return v &gt; this.age;
&#125;
let person = &#123;name: &#39;John&#39;, age: 20&#125;;
[10, 12, 26, 15].find(f, person);    // 26
</code></pre><p>上面的代码中，<code>find</code>函数接收了第二个参数<code>person</code>对象，回调函数中的<code>this</code>对象指向<code>person</code>对象。</p><p>另外，这两个方法都可以发现<code>NaN</code>，弥补了数组的<code>indexOf</code>方法的不足。</p><pre><code class="javascript">[NaN].indexOf(NaN)
// -1

[NaN].findIndex(y =&gt; Object.is(NaN, y))
// 0
</code></pre><p>上面代码中，<code>indexOf</code>方法无法识别数组的<code>NaN</code>成员，但是<code>findIndex</code>方法可以借助<code>Object.is</code>方法做到。</p><hr><h4 id="6-数组实例的-fill"><a href="#6-数组实例的-fill" class="headerlink" title="6. 数组实例的 fill()"></a>6. 数组实例的 fill()</h4><p><strong><code>fill</code>方法使用给定值，填充一个数组。</strong></p><pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
</code></pre><p>上面代码表明，**<code>fill</code>方法用于空数组的初始化非常方便**。数组中已有的元素，会被全部抹去。</p><p><strong><code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</strong></p><pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)
// [&#39;a&#39;, 7, &#39;c&#39;]
</code></pre><p>上面代码表示，<code>fill</code>方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</p><p><strong>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</strong></p><pre><code class="javascript">let arr = new Array(3).fill(&#123;name: &quot;Mike&quot;&#125;);
arr[0].name = &quot;Ben&quot;;
arr
// [&#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;]

let arr = new Array(3).fill([]);
arr[0].push(5);
arr
// [[5], [5], [5]]
</code></pre><hr><h4 id="7-数组实例的-entries-，keys-和-values"><a href="#7-数组实例的-entries-，keys-和-values" class="headerlink" title="7. 数组实例的 entries()，keys() 和 values()"></a>7. 数组实例的 entries()，keys() 和 values()</h4><p>ES6 提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——<strong>用于遍历数组</strong>。它们都返回一个遍历器对象（详见《Iterator》一章），可以用<code>for...of</code>循环进行遍历，唯一的区别是**<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。**</p><pre><code class="javascript">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) &#123;
  console.log(index);
&#125;
// 0
// 1

for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) &#123;
  console.log(elem);
&#125;
// &#39;a&#39;
// &#39;b&#39;

for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) &#123;
  console.log(index, elem);
&#125;
// 0 &quot;a&quot;
// 1 &quot;b&quot;
</code></pre><p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p><pre><code class="javascript">let letter = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
let entries = letter.entries();
console.log(entries.next().value); // [0, &#39;a&#39;]
console.log(entries.next().value); // [1, &#39;b&#39;]
console.log(entries.next().value); // [2, &#39;c&#39;]
</code></pre><hr><h4 id="8-数组实例的-includes"><a href="#8-数组实例的-includes" class="headerlink" title="8. 数组实例的 includes()"></a>8. 数组实例的 includes()</h4><p><strong><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似</strong>。ES2016 引入了该方法。</p><pre><code class="javascript">[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
</code></pre><p><strong>该方法的第二个参数表示搜索的起始位置，默认为<code>0</code>。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为<code>-4</code>，但数组长度为<code>3</code>），则会重置为从<code>0</code>开始。</strong></p><pre><code class="javascript">[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
</code></pre><p>没有该方法之前，我们通常使用数组的<code>indexOf</code>方法，检查是否包含某个值。</p><pre><code class="javascript">if (arr.indexOf(el) !== -1) &#123;
  // ...
&#125;
</code></pre><p><code>indexOf</code>方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于<code>-1</code>，表达起来不够直观。二是，它内部使用严格相等运算符（<code>===</code>）进行判断，这会导致对<code>NaN</code>的误判。</p><pre><code class="javascript">[NaN].indexOf(NaN)
// -1
</code></pre><p><code>includes</code>使用的是不一样的判断算法，就没有这个问题。</p><pre><code class="javascript">[NaN].includes(NaN)
// true
</code></pre><p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p><pre><code class="javascript">const contains = (() =&gt;
  Array.prototype.includes
    ? (arr, value) =&gt; arr.includes(value)
    : (arr, value) =&gt; arr.some(el =&gt; el === value)
)();
contains([&#39;foo&#39;, &#39;bar&#39;], &#39;baz&#39;); // =&gt; false
</code></pre><p>另外，Map 和 Set 数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p><ul><li>Map 结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li><li>Set 结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</li></ul><hr><h4 id="9-数组实例的-flat-，flatMap"><a href="#9-数组实例的-flat-，flatMap" class="headerlink" title="9. 数组实例的 flat()，flatMap()"></a>9. 数组实例的 flat()，flatMap()</h4><p><strong>数组的成员有时还是数组，<code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</strong></p><pre><code class="javascript">[1, 2, [3, 4]].flat()
// [1, 2, 3, 4]
</code></pre><p>上面代码中，原数组的成员里面有一个数组，<code>flat()</code>方法将子数组的成员取出来，添加在原来的位置。</p><p><strong><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1。</strong></p><pre><code class="javascript">[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]
</code></pre><p>上面代码中，<code>flat()</code>的参数为2，表示要“拉平”两层的嵌套数组。</p><p>如果不管有多少层嵌套，都要转成一维数组，可以用<code>Infinity</code>关键字作为参数。</p><pre><code class="javascript">[1, [2, [3]]].flat(Infinity)
// [1, 2, 3]
</code></pre><p>如果原数组有空位，<code>flat()</code>方法会跳过空位。</p><pre><code class="javascript">[1, 2, , 4, 5].flat()
// [1, 2, 4, 5]
</code></pre><p><code>flatMap()</code>方法对原数组的每个成员执行一个函数（相当于执行<code>Array.prototype.map()</code>），然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组。</p><pre><code class="javascript">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) =&gt; [x, x * 2])
// [2, 4, 3, 6, 4, 8]
</code></pre><p><code>flatMap()</code>只能展开一层数组。</p><pre><code class="javascript">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()
[1, 2, 3, 4].flatMap(x =&gt; [[x * 2]])
// [[2], [4], [6], [8]]
</code></pre><p>上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此<code>flatMap()</code>返回的还是一个嵌套数组。</p><p><code>flatMap()</code>方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。</p><pre><code class="javascript">arr.flatMap(function callback(currentValue[, index[, array]]) &#123;
  // ...
&#125;[, thisArg])
</code></pre><p><code>flatMap()</code>方法还可以有第二个参数，用来绑定遍历函数里面的<code>this</code>。</p><hr><h4 id="10-数组的空位"><a href="#10-数组的空位" class="headerlink" title="10. 数组的空位"></a>10. 数组的空位</h4><p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。</p><pre><code class="javascript">Array(3) // [, , ,]
</code></pre><p>上面代码中，<code>Array(3)</code>返回一个具有 3 个空位的数组。</p><p>注意，空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p><pre><code class="javascript">0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false
</code></pre><p>上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。</p><p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p><ul><li><code>forEach()</code>, <code>filter()</code>, <code>reduce()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。</li><li><code>map()</code>会跳过空位，但会保留这个值</li><li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li></ul><pre><code class="javascript">// forEach方法
[,&#39;a&#39;].forEach((x,i) =&gt; console.log(i)); // 1

// filter方法
[&#39;a&#39;,,&#39;b&#39;].filter(x =&gt; true) // [&#39;a&#39;,&#39;b&#39;]

// every方法
[,&#39;a&#39;].every(x =&gt; x===&#39;a&#39;) // true

// reduce方法
[1,,2].reduce((x,y) =&gt; x+y) // 3

// some方法
[,&#39;a&#39;].some(x =&gt; x !== &#39;a&#39;) // false

// map方法
[,&#39;a&#39;].map(x =&gt; 1) // [,1]

// join方法
[,&#39;a&#39;,undefined,null].join(&#39;#&#39;) // &quot;#a##&quot;

// toString方法
[,&#39;a&#39;,undefined,null].toString() // &quot;,a,,&quot;
</code></pre><p>ES6 则是明确将空位转为<code>undefined</code>。</p><p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p><pre><code class="javascript">Array.from([&#39;a&#39;,,&#39;b&#39;])
// [ &quot;a&quot;, undefined, &quot;b&quot; ]
</code></pre><p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p><pre><code class="javascript">[...[&#39;a&#39;,,&#39;b&#39;]]
// [ &quot;a&quot;, undefined, &quot;b&quot; ]
</code></pre><p><code>copyWithin()</code>会连空位一起拷贝。</p><pre><code class="javascript">[,&#39;a&#39;,&#39;b&#39;,,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;]
</code></pre><p><code>fill()</code>会将空位视为正常的数组位置。</p><pre><code class="javascript">new Array(3).fill(&#39;a&#39;) // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]
</code></pre><p><code>for...of</code>循环也会遍历空位。</p><pre><code class="javascript">let arr = [, ,];
for (let i of arr) &#123;
  console.log(1);
&#125;
// 1
// 1
</code></pre><p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略它们。如果改成<code>map</code>方法遍历，空位是会跳过的。</p><p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。</p><pre><code class="javascript">// entries()
[...[,&#39;a&#39;].entries()] // [[0,undefined], [1,&quot;a&quot;]]

// keys()
[...[,&#39;a&#39;].keys()] // [0,1]

// values()
[...[,&#39;a&#39;].values()] // [undefined,&quot;a&quot;]

// find()
[,&#39;a&#39;].find(x =&gt; true) // undefined

// findIndex()
[,&#39;a&#39;].findIndex(x =&gt; true) // 0
</code></pre><p><strong>由于空位的处理规则非常不统一，所以建议避免出现空位。</strong></p><hr><h4 id="11-Array-prototype-sort-的排序稳定性"><a href="#11-Array-prototype-sort-的排序稳定性" class="headerlink" title="11. Array.prototype.sort() 的排序稳定性"></a>11. Array.prototype.sort() 的排序稳定性</h4><p>排序稳定性（stable sorting）是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变。</p><pre><code class="javascript">const arr = [
  &#39;peach&#39;,
  &#39;straw&#39;,
  &#39;apple&#39;,
  &#39;spork&#39;
];

const stableSorting = (s1, s2) =&gt; &#123;
  if (s1[0] &lt; s2[0]) return -1;
  return 1;
&#125;;

arr.sort(stableSorting)
// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;]
</code></pre><p>上面代码对数组<code>arr</code>按照首字母进行排序。排序结果中，<code>straw</code>在<code>spork</code>的前面，跟原始顺序一致，所以排序算法<code>stableSorting</code>是稳定排序。</p><pre><code class="javascript">const unstableSorting = (s1, s2) =&gt; &#123;
  if (s1[0] &lt;= s2[0]) return -1;
  return 1;
&#125;;

arr.sort(unstableSorting)
// [&quot;apple&quot;, &quot;peach&quot;, &quot;spork&quot;, &quot;straw&quot;]
</code></pre><p>上面代码中，排序结果是<code>spork</code>在<code>straw</code>前面，跟原始顺序相反，所以排序算法<code>unstableSorting</code>是不稳定的。</p><p>常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行。</p><p>早先的 ECMAScript 没有规定，<code>Array.prototype.sort()</code>的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvZWNtYTI2Mi9wdWxsLzEzNDA=">ES2019</span> 明确规定，<code>Array.prototype.sort()</code>的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。</p><h3 id="9、对象的扩展"><a href="#9、对象的扩展" class="headerlink" title="9、对象的扩展"></a>9、对象的扩展</h3><hr><h4 id="1-属性的简洁表达法"><a href="#1-属性的简洁表达法" class="headerlink" title="1. 属性的简洁表达法"></a>1. 属性的简洁表达法</h4><p><strong>ES6 允许在大括号里面，直接写入变量和函数</strong>，作为对象的属性和方法。这样的书写更加简洁。</p><pre><code class="javascript">const foo = &#39;bar&#39;;
const baz = &#123;foo&#125;;
baz // &#123;foo: &quot;bar&quot;&#125;

// 等同于
const baz = &#123;foo: foo&#125;;
</code></pre><p>上面代码中，变量<code>foo</code>直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。</p><pre><code class="javascript">function f(x, y) &#123;
  return &#123;x, y&#125;;
&#125;

// 等同于

function f(x, y) &#123;
  return &#123;x: x, y: y&#125;;
&#125;

f(1, 2) // Object &#123;x: 1, y: 2&#125;
</code></pre><p><strong>除了属性简写，方法也可以简写</strong>。</p><pre><code class="javascript">const o = &#123;
  method() &#123;
    return &quot;Hello!&quot;;
  &#125;
&#125;;

// 等同于

const o = &#123;
  method: function() &#123;
    return &quot;Hello!&quot;;
  &#125;
&#125;;
</code></pre><p>下面是一个实际的例子。</p><pre><code class="javascript">let birth = &#39;2000/01/01&#39;;

const Person = &#123;

  name: &#39;张三&#39;,

  //等同于birth: birth
  birth,

  // 等同于hello: function ()...
  hello() &#123; console.log(&#39;我的名字是&#39;, this.name); &#125;

&#125;;
</code></pre><p>这种写法用于函数的返回值，将会非常方便。</p><pre><code class="javascript">function getPoint() &#123;
  const x = 1;
  const y = 10;
  return &#123;x, y&#125;;
&#125;

getPoint()
// &#123;x:1, y:10&#125;
</code></pre><p>CommonJS 模块输出一组变量，就非常合适使用简洁写法。</p><pre><code class="javascript">let ms = &#123;&#125;;

function getItem (key) &#123;
  return key in ms ? ms[key] : null;
&#125;

function setItem (key, value) &#123;
  ms[key] = value;
&#125;

function clear () &#123;
  ms = &#123;&#125;;
&#125;

module.exports = &#123; getItem, setItem, clear &#125;;
// 等同于
module.exports = &#123;
  getItem: getItem,
  setItem: setItem,
  clear: clear
&#125;;
</code></pre><p>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。</p><pre><code class="javascript">const cart = &#123;
  _wheels: 4,

  get wheels () &#123;
    return this._wheels;
  &#125;,

  set wheels (value) &#123;
    if (value &lt; this._wheels) &#123;
      throw new Error(&#39;数值太小了！&#39;);
    &#125;
    this._wheels = value;
  &#125;
&#125;
</code></pre><p>简洁写法在打印对象时也很有用。</p><pre><code class="javascript">let user = &#123;
  name: &#39;test&#39;
&#125;;

let foo = &#123;
  bar: &#39;baz&#39;
&#125;;

console.log(user, foo)
// &#123;name: &quot;test&quot;&#125; &#123;bar: &quot;baz&quot;&#125;
console.log(&#123;user, foo&#125;)
// &#123;user: &#123;name: &quot;test&quot;&#125;, foo: &#123;bar: &quot;baz&quot;&#125;&#125;
</code></pre><p>上面代码中，<code>console.log</code>直接输出<code>user</code>和<code>foo</code>两个对象时，就是两组键值对，可能会混淆。<strong>把它们放在大括号里面输出，就变成了对象的简洁表示法，</strong>每组键值对前面会打印对象名，这样就比较清晰了。</p><p>注意，简写的对象方法不能用作构造函数，会报错。</p><pre><code class="javascript">const obj = &#123;
  f() &#123;
    this.foo = &#39;bar&#39;;
  &#125;
&#125;;

new obj.f() // 报错
</code></pre><p>上面代码中，<code>f</code>是一个简写的对象方法，所以<code>obj.f</code>不能当作构造函数使用。</p><hr><h4 id="2-属性名表达式"><a href="#2-属性名表达式" class="headerlink" title="2. 属性名表达式"></a>2. 属性名表达式</h4><p>JavaScript 定义对象的属性，有两种方法。</p><pre><code class="javascript">// 方法一
obj.foo = true;

// 方法二
obj[&#39;a&#39; + &#39;bc&#39;] = 123;
</code></pre><p>上面代码的<strong>方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</strong></p><p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p><pre><code class="javascript">var obj = &#123;
  foo: true,
  abc: 123
&#125;;
</code></pre><p><strong>ES6 允许字面量定义对象</strong>时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p><pre><code class="javascript">let propKey = &#39;foo&#39;;

let obj = &#123;
  [propKey]: true,
  [&#39;a&#39; + &#39;bc&#39;]: 123
&#125;;
</code></pre><p>下面是另一个例子。</p><pre><code class="javascript">let lastWord = &#39;last word&#39;;

const a = &#123;
  &#39;first word&#39;: &#39;hello&#39;,
  [lastWord]: &#39;world&#39;
&#125;;

a[&#39;first word&#39;] // &quot;hello&quot;
a[lastWord] // &quot;world&quot;
a[&#39;last word&#39;] // &quot;world&quot;
</code></pre><p>表达式还可以用于定义方法名。</p><pre><code class="javascript">let obj = &#123;
  [&#39;h&#39; + &#39;ello&#39;]() &#123;
    return &#39;hi&#39;;
  &#125;
&#125;;

obj.hello() // hi
</code></pre><p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p><pre><code class="javascript">// 报错
const foo = &#39;bar&#39;;
const bar = &#39;abc&#39;;
const baz = &#123; [foo] &#125;;

// 正确
const foo = &#39;bar&#39;;
const baz = &#123; [foo]: &#39;abc&#39;&#125;;
</code></pre><p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>，这一点要特别小心。</p><pre><code class="javascript">const keyA = &#123;a: 1&#125;;
const keyB = &#123;b: 2&#125;;

const myObject = &#123;
  [keyA]: &#39;valueA&#39;,
  [keyB]: &#39;valueB&#39;
&#125;;

myObject // Object &#123;[object Object]: &quot;valueB&quot;&#125;
</code></pre><p>上面代码中，<code>[keyA]</code>和<code>[keyB]</code>得到的都是<code>[object Object]</code>，所以<code>[keyB]</code>会把<code>[keyA]</code>覆盖掉，而<code>myObject</code>最后只有一个<code>[object Object]</code>属性。</p><hr><h4 id="3-方法的-name-属性"><a href="#3-方法的-name-属性" class="headerlink" title="3. 方法的 name 属性"></a>3. 方法的 name 属性</h4><p>函数的<code>name</code>属性，返回函数名。对象方法也是函数，因此也有<code>name</code>属性。</p><pre><code class="javascript">const person = &#123;
  sayName() &#123;
    console.log(&#39;hello!&#39;);
  &#125;,
&#125;;

person.sayName.name   // &quot;sayName&quot;
</code></pre><p>上面代码中，方法的<code>name</code>属性返回函数名（即方法名）。</p><p><strong>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code>。</strong></p><pre><code class="javascript">const obj = &#123;
  get foo() &#123;&#125;,
  set foo(x) &#123;&#125;
&#125;;

obj.foo.name
// TypeError: Cannot read property &#39;name&#39; of undefined

const descriptor = Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;);

descriptor.get.name // &quot;get foo&quot;
descriptor.set.name // &quot;set foo&quot;
</code></pre><p>有两种特殊情况：**<code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字<strong>；</strong><code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code>。**</p><pre><code class="javascript">(new Function()).name // &quot;anonymous&quot;

var doSomething = function() &#123;
  // ...
&#125;;
doSomething.bind().name // &quot;bound doSomething&quot;
</code></pre><p><strong>如果对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述。</strong></p><pre><code class="javascript">const key1 = Symbol(&#39;description&#39;);
const key2 = Symbol();
let obj = &#123;
  [key1]() &#123;&#125;,
  [key2]() &#123;&#125;,
&#125;;
obj[key1].name // &quot;[description]&quot;
obj[key2].name // &quot;&quot;
</code></pre><p>上面代码中，<code>key1</code>对应的 Symbol 值有描述，<code>key2</code>没有。</p><hr><h4 id="4-属性的可枚举性和遍历"><a href="#4-属性的可枚举性和遍历" class="headerlink" title="4. 属性的可枚举性和遍历"></a>4. 属性的可枚举性和遍历</h4><p><strong>可枚举性</strong></p><p><strong>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</strong></p><pre><code class="javascript">let obj = &#123; foo: 123 &#125;;
Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;)
//  &#123;
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  &#125;
</code></pre><p>描述对象的<code>enumerable</code>属性，称为“可枚举性”，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p><p>目前，<strong>有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</strong></p><ul><li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li><li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li><li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li><li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li></ul><p>这四个操作之中，前三个是 ES5 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。其中，<strong>只有<code>for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性</strong>。实际上<strong>，引入“可枚举”（<code>enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作</strong>，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过“可枚举性”，从而避免被<code>for...in</code>遍历到。</p><pre><code class="javascript">Object.getOwnPropertyDescriptor(Object.prototype, &#39;toString&#39;).enumerable
// false

Object.getOwnPropertyDescriptor([], &#39;length&#39;).enumerable
// false
</code></pre><p>上面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。</p><p>另外，ES6 规定，<strong>所有 Class 的原型的方法都是不可枚举的。</strong></p><pre><code class="javascript">Object.getOwnPropertyDescriptor(class &#123;foo() &#123;&#125;&#125;.prototype, &#39;foo&#39;).enumerable
// false
</code></pre><p>总的来说，<strong>操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</strong></p><p><strong>属性的遍历</strong></p><p>ES6 一共有 5 种方法可以遍历对象的属性。</p><p><strong>（1）for…in</strong></p><p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p><p><strong>（2）Object.keys(obj)</strong></p><p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p><p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p><p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p><p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p><p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p><p><strong>（5）Reflect.ownKeys(obj)</strong></p><p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p><p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p><ul><li>首先遍历所有数值键，按照数值升序排列。</li><li>其次遍历所有字符串键，按照加入时间升序排列。</li><li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li></ul><pre><code class="javascript">Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)
// [&#39;2&#39;, &#39;10&#39;, &#39;b&#39;, &#39;a&#39;, Symbol()]
</code></pre><p>上面代码中，<code>Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性<code>2</code>和<code>10</code>，其次是字符串属性<code>b</code>和<code>a</code>，最后是 Symbol 属性。</p><hr><h4 id="5-super-关键字"><a href="#5-super-关键字" class="headerlink" title="5. super 关键字"></a>5. super 关键字</h4><p>我们知道，**<code>this</code>关键字总是指向函数所在的当前对象<strong>，ES6 又新增了另一个类似的关键字</strong><code>super</code>，指向当前对象的原型对象**。</p><pre><code class="javascript">const proto = &#123;
  foo: &#39;hello&#39;
&#125;;

const obj = &#123;
  foo: &#39;world&#39;,
  find() &#123;
    return super.foo;
  &#125;
&#125;;

Object.setPrototypeOf(obj, proto);
obj.find() // &quot;hello&quot;
</code></pre><p>上面代码中，对象<code>obj.find()</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性。</p><p>注意，**<code>super</code>关键字表示原型对象时，只能用在对象的方法之中**，用在其他地方都会报错。</p><pre><code class="javascript">// 报错
const obj = &#123;
  foo: super.foo
&#125;

// 报错
const obj = &#123;
  foo: () =&gt; super.foo
&#125;

// 报错
const obj = &#123;
  foo: function () &#123;
    return super.foo
  &#125;
&#125;
</code></pre><p>上面三种<code>super</code>的用法都会报错，因为对于 JavaScript 引擎来说，这里的<code>super</code>都没有用在对象的方法之中。第一种写法是<code>super</code>用在属性里面，第二种和第三种写法是<code>super</code>用在一个函数里面，然后赋值给<code>foo</code>属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。</p><p><strong>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。</strong></p><pre><code class="javascript">const proto = &#123;
  x: &#39;hello&#39;,
  foo() &#123;
    console.log(this.x);
  &#125;,
&#125;;

const obj = &#123;
  x: &#39;world&#39;,
  foo() &#123;
    super.foo();
  &#125;
&#125;

Object.setPrototypeOf(obj, proto);

obj.foo() // &quot;world&quot;
</code></pre><p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code>。</p><hr><h4 id="6-对象的扩展运算符"><a href="#6-对象的扩展运算符" class="headerlink" title="6. 对象的扩展运算符"></a>6. 对象的扩展运算符</h4><p>《数组的扩展》一章中，已经介绍过扩展运算符（<code>...</code>）。ES2018 将这个运算符<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtcmVzdC1zcHJlYWQ=">引入</span>了对象。</p><p><strong>解构赋值</strong></p><p><strong>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。</strong>所有的键和它们的值，都会拷贝到新对象上面。</p><pre><code class="javascript">let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;
x // 1
y // 2
z // &#123; a: 3, b: 4 &#125;
</code></pre><p>上面代码中，变量<code>z</code>是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（<code>a</code>和<code>b</code>），将它们连同值一起拷贝过来。</p><p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是<code>undefined</code>或<code>null</code>，就会报错，因为它们无法转为对象。</p><pre><code class="javascript">let &#123; ...z &#125; = null; // 运行时错误
let &#123; ...z &#125; = undefined; // 运行时错误
</code></pre><p><strong>解构赋值必须是最后一个参数</strong>，否则会报错。</p><pre><code class="javascript">let &#123; ...x, y, z &#125; = someObject; // 句法错误
let &#123; x, ...y, ...z &#125; = someObject; // 句法错误
</code></pre><p>上面代码中，解构赋值不是最后一个参数，所以会报错。</p><p>注意，<strong>解构赋值的拷贝是浅拷贝</strong>，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p><pre><code class="javascript">let obj = &#123; a: &#123; b: 1 &#125; &#125;;
let &#123; ...x &#125; = obj;
obj.a.b = 2;
x.a.b // 2
</code></pre><p>上面代码中，<code>x</code>是解构赋值所在的对象，拷贝了对象<code>obj</code>的<code>a</code>属性。<code>a</code>属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p><p>另外，扩展运算符的解构赋值，<strong>不能复制继承自原型对象的属性</strong>。</p><pre><code class="javascript">let o1 = &#123; a: 1 &#125;;
let o2 = &#123; b: 2 &#125;;
o2.__proto__ = o1;
let &#123; ...o3 &#125; = o2;
o3 // &#123; b: 2 &#125;
o3.a // undefined
</code></pre><p>上面代码中，对象<code>o3</code>复制了<code>o2</code>，但是只复制了<code>o2</code>自身的属性，没有复制它的原型对象<code>o1</code>的属性。</p><p>下面是另一个例子。</p><pre><code class="javascript">const o = Object.create(&#123; x: 1, y: 2 &#125;);
o.z = 3;

let &#123; x, ...newObj &#125; = o;
let &#123; y, z &#125; = newObj;
x // 1
y // undefined
z // 3
</code></pre><p>上面代码中，变量<code>x</code>是单纯的解构赋值，所以可以读取对象<code>o</code>继承的属性；变量<code>y</code>和<code>z</code>是扩展运算符的解构赋值，只能读取对象<code>o</code>自身的属性，所以变量<code>z</code>可以赋值成功，变量<code>y</code>取不到值。ES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量<code>newObj</code>，如果写成下面这样会报错。</p><pre><code class="javascript">let &#123; x, ...&#123; y, z &#125; &#125; = o;
// SyntaxError: ... must be followed by an identifier in declaration contexts
</code></pre><p><strong>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</strong></p><pre><code class="javascript">function baseFunction(&#123; a, b &#125;) &#123;
  // ...
&#125;
function wrapperFunction(&#123; x, y, ...restConfig &#125;) &#123;
  // 使用 x 和 y 参数进行操作
  // 其余参数传给原始函数
  return baseFunction(restConfig);
&#125;
</code></pre><p>上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p><hr><p><strong>扩展运算符</strong></p><p><strong>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</strong></p><pre><code class="javascript">let z = &#123; a: 3, b: 4 &#125;;
let n = &#123; ...z &#125;;
n // &#123; a: 3, b: 4 &#125;
</code></pre><p>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</p><pre><code class="javascript">let foo = &#123; ...[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &#125;;
foo
// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;
</code></pre><p>如果扩展运算符后面是一个空对象，则没有任何效果。</p><pre><code class="javascript">&#123;...&#123;&#125;, a: 1&#125;
// &#123; a: 1 &#125;
</code></pre><p>如果扩展运算符后面不是对象，则会自动将其转为对象。</p><pre><code class="javascript">// 等同于 &#123;...Object(1)&#125;
&#123;...1&#125; // &#123;&#125;
</code></pre><p>上面代码中，扩展运算符后面是整数<code>1</code>，会自动转为数值的包装对象<code>Number&#123;1&#125;</code>。由于该对象没有自身属性，所以返回一个空对象。</p><p>下面的例子都是类似的道理。</p><pre><code class="javascript">// 等同于 &#123;...Object(true)&#125;
&#123;...true&#125; // &#123;&#125;

// 等同于 &#123;...Object(undefined)&#125;
&#123;...undefined&#125; // &#123;&#125;

// 等同于 &#123;...Object(null)&#125;
&#123;...null&#125; // &#123;&#125;
</code></pre><p>但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。</p><pre><code class="javascript">&#123;...&#39;hello&#39;&#125;
// &#123;0: &quot;h&quot;, 1: &quot;e&quot;, 2: &quot;l&quot;, 3: &quot;l&quot;, 4: &quot;o&quot;&#125;
</code></pre><p><strong>对象的扩展运算符等同于使用<code>Object.assign()</code>方法。</strong></p><pre><code class="javascript">let aClone = &#123; ...a &#125;;
// 等同于
let aClone = Object.assign(&#123;&#125;, a);
</code></pre><p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。</p><pre><code class="javascript">// 写法一
const clone1 = &#123;
  __proto__: Object.getPrototypeOf(obj),
  ...obj
&#125;;

// 写法二
const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
);

// 写法三
const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)
</code></pre><p>上面代码中，写法一的<code>__proto__</code>属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。</p><p><strong>扩展运算符可以用于合并两个对象。</strong></p><pre><code class="javascript">let ab = &#123; ...a, ...b &#125;;
// 等同于
let ab = Object.assign(&#123;&#125;, a, b);
</code></pre><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><pre><code class="javascript">let aWithOverrides = &#123; ...a, x: 1, y: 2 &#125;;
// 等同于
let aWithOverrides = &#123; ...a, ...&#123; x: 1, y: 2 &#125; &#125;;
// 等同于
let x = 1, y = 2, aWithOverrides = &#123; ...a, x, y &#125;;
// 等同于
let aWithOverrides = Object.assign(&#123;&#125;, a, &#123; x: 1, y: 2 &#125;);
</code></pre><p>上面代码中，<code>a</code>对象的<code>x</code>属性和<code>y</code>属性，拷贝到新对象后会被覆盖掉。</p><p><strong>这用来修改现有对象部分的属性就很方便了。</strong></p><pre><code class="javascript">let newVersion = &#123;
  ...previousVersion,
  name: &#39;New Name&#39; // Override the name property
&#125;;
</code></pre><p>上面代码中，<code>newVersion</code>对象自定义了<code>name</code>属性，其他属性全部复制自<code>previousVersion</code>对象。</p><p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p><pre><code class="javascript">let aWithDefaults = &#123; x: 1, y: 2, ...a &#125;;
// 等同于
let aWithDefaults = Object.assign(&#123;&#125;, &#123; x: 1, y: 2 &#125;, a);
// 等同于
let aWithDefaults = Object.assign(&#123; x: 1, y: 2 &#125;, a);
</code></pre><p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</p><pre><code class="javascript">const obj = &#123;
  ...(x &gt; 1 ? &#123;a: 1&#125; : &#123;&#125;),
  b: 2,
&#125;;
</code></pre><p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p><pre><code class="javascript">let a = &#123;
  get x() &#123;
    throw new Error(&#39;not throw yet&#39;);
  &#125;
&#125;

let aWithXGetter = &#123; ...a &#125;; // 报错
</code></pre><p>上面例子中，取值函数<code>get</code>在扩展<code>a</code>对象时会自动执行，导致报错。</p><hr><h4 id="7-AggregateError-错误对象"><a href="#7-AggregateError-错误对象" class="headerlink" title="7. AggregateError 错误对象"></a>7. AggregateError 错误对象</h4><p>ES2021 标准之中，为了配合新增的<code>Promise.any()</code>方法（详见《Promise 对象》一章），还引入一个新的错误对象<code>AggregateError</code>，也放在这一章介绍。</p><p>AggregateError 在一个错误对象里面，封装了多个错误。如果某个单一操作，同时引发了多个错误，，需要同时抛出这些错误，那么就可以抛出一个 AggregateError 错误对象，把各种错误都放在这个对象里面。</p><p>AggregateError 本身是一个构造函数，用来生成 AggregateError 实例对象。</p><pre><code class="javascript">AggregateError(errors[, message])
</code></pre><p><code>AggregateError()</code>构造函数可以接受两个参数。</p><ul><li>errors：数组，它的每个成员都是一个错误对象。该参数是必须的。</li><li>message：字符串，表示 AggregateError 抛出时的提示信息。该参数是可选的。</li></ul><pre><code class="javascript">const error = new AggregateError([
  new Error(&#39;ERROR_11112&#39;),
  new TypeError(&#39;First name must be a string&#39;),
  new RangeError(&#39;Transaction value must be at least 1&#39;),
  new URIError(&#39;User profile link must be https&#39;),
], &#39;Transaction cannot be processed&#39;)
</code></pre><p>上面示例中，<code>AggregateError()</code>的第一个参数数组里面，一共有四个错误实例。第二个参数字符串则是这四个错误的一个整体的提示。</p><p><code>AggregateError</code>的实例对象有三个属性。</p><ul><li>name：错误名称，默认为“AggregateError”。</li><li>message：错误的提示信息。</li><li>errors：数组，每个成员都是一个错误对象。</li></ul><p>下面是一个示例。</p><pre><code class="javascript">try &#123;
  throw new AggregateError([
    new Error(&quot;some error&quot;),
  ], &#39;Hello&#39;);
&#125; catch (e) &#123;
  console.log(e instanceof AggregateError); // true
  console.log(e.message);                   // &quot;Hello&quot;
  console.log(e.name);                      // &quot;AggregateError&quot;
  console.log(e.errors);                    // [ Error: &quot;some error&quot; ]
&#125;
</code></pre><h3 id="10、-对象的新增方法"><a href="#10、-对象的新增方法" class="headerlink" title="10、 对象的新增方法"></a>10、 对象的新增方法</h3><hr><h4 id="1-Object-is"><a href="#1-Object-is" class="headerlink" title="1. Object.is()"></a>1. Object.is()</h4><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p><p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。<strong>它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</strong></p><pre><code class="javascript">Object.is(&#39;foo&#39;, &#39;foo&#39;)
// true
Object.is(&#123;&#125;, &#123;&#125;)
// false
</code></pre><p><strong>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</strong></p><pre><code class="javascript">+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
</code></pre><p>ES5 可以通过下面的代码，部署<code>Object.is</code>。</p><pre><code class="javascript">Object.defineProperty(Object, &#39;is&#39;, &#123;
  value: function(x, y) &#123;
    if (x === y) &#123;
      // 针对+0 不等于 -0的情况
      return x !== 0 || 1 / x === 1 / y;
    &#125;
    // 针对NaN的情况
    return x !== x &amp;&amp; y !== y;
  &#125;,
  configurable: true,
  enumerable: false,
  writable: true
&#125;);
</code></pre><hr><h4 id="2-Object-assign"><a href="#2-Object-assign" class="headerlink" title="2. Object.assign()"></a>2. Object.assign()</h4><p><strong>基本用法</strong></p><p><strong><code>Object.assign()</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</strong></p><pre><code class="javascript">const target = &#123; a: 1 &#125;;

const source1 = &#123; b: 2 &#125;;
const source2 = &#123; c: 3 &#125;;

Object.assign(target, source1, source2);
target // &#123;a:1, b:2, c:3&#125;
</code></pre><p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p><p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><pre><code class="javascript">const target = &#123; a: 1, b: 1 &#125;;

const source1 = &#123; b: 2, c: 2 &#125;;
const source2 = &#123; c: 3 &#125;;

Object.assign(target, source1, source2);
target // &#123;a:1, b:2, c:3&#125;
</code></pre><p>如果只有一个参数，<code>Object.assign()</code>会直接返回该参数。</p><pre><code class="javascript">const obj = &#123;a: 1&#125;;
Object.assign(obj) === obj // true
</code></pre><p>如果该参数不是对象，则会先转成对象，然后返回。</p><pre><code class="javascript">typeof Object.assign(2) // &quot;object&quot;
</code></pre><p>由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。</p><pre><code class="javascript">Object.assign(undefined) // 报错
Object.assign(null) // 报错
</code></pre><p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。</p><pre><code class="javascript">let obj = &#123;a: 1&#125;;
Object.assign(obj, undefined) === obj // true
Object.assign(obj, null) === obj // true
</code></pre><p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p><pre><code class="javascript">const v1 = &#39;abc&#39;;
const v2 = true;
const v3 = 10;

const obj = Object.assign(&#123;&#125;, v1, v2, v3);
console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;
</code></pre><p>上面代码中，<code>v1</code>、<code>v2</code>、<code>v3</code>分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p><pre><code class="javascript">Object(true) // &#123;[[PrimitiveValue]]: true&#125;
Object(10)  //  &#123;[[PrimitiveValue]]: 10&#125;
Object(&#39;abc&#39;) // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;&#125;
</code></pre><p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面，这个属性是不会被<code>Object.assign()</code>拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p><p><strong><code>Object.assign()</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</strong></p><pre><code class="javascript">Object.assign(&#123;b: &#39;c&#39;&#125;,
  Object.defineProperty(&#123;&#125;, &#39;invisible&#39;, &#123;
    enumerable: false,
    value: &#39;hello&#39;
  &#125;)
)
// &#123; b: &#39;c&#39; &#125;
</code></pre><p>上面代码中，<code>Object.assign()</code>要拷贝的对象只有一个不可枚举属性<code>invisible</code>，这个属性并没有被拷贝进去。</p><p>属性名为 Symbol 值的属性，也会被<code>Object.assign()</code>拷贝。</p><pre><code class="javascript">Object.assign(&#123; a: &#39;b&#39; &#125;, &#123; [Symbol(&#39;c&#39;)]: &#39;d&#39; &#125;)
// &#123; a: &#39;b&#39;, Symbol(c): &#39;d&#39; &#125;
</code></pre><hr><p><strong>注意点</strong></p><p><strong>（1）浅拷贝</strong></p><p><code>Object.assign()</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p><pre><code class="javascript">const obj1 = &#123;a: &#123;b: 1&#125;&#125;;
const obj2 = Object.assign(&#123;&#125;, obj1);

obj1.a.b = 2;
obj2.a.b // 2
</code></pre><p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign()</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p><p><strong>（2）同名属性的替换</strong></p><p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign()</code>的处理方法是替换，而不是添加。</p><pre><code class="javascript">const target = &#123; a: &#123; b: &#39;c&#39;, d: &#39;e&#39; &#125; &#125;
const source = &#123; a: &#123; b: &#39;hello&#39; &#125; &#125;
Object.assign(target, source)
// &#123; a: &#123; b: &#39;hello&#39; &#125; &#125;
</code></pre><p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到<code>&#123; a: &#123; b: &#39;hello&#39;, d: &#39;e&#39; &#125; &#125;</code>的结果。这通常不是开发者想要的，需要特别小心。</p><p>一些函数库提供<code>Object.assign()</code>的定制版本（比如 Lodash 的<code>_.defaultsDeep()</code>方法），可以得到深拷贝的合并。</p><p><strong>（3）数组的处理</strong></p><p><code>Object.assign()</code>可以用来处理数组，但是会把数组视为对象。</p><pre><code class="javascript">Object.assign([1, 2, 3], [4, 5])
// [4, 5, 3]
</code></pre><p>上面代码中，<code>Object.assign()</code>把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性<code>4</code>覆盖了目标数组的 0 号属性<code>1</code>。</p><p><strong>（4）取值函数的处理</strong></p><p><strong><code>Object.assign()</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</strong></p><pre><code class="javascript">const source = &#123;
  get foo() &#123; return 1 &#125;
&#125;;
const target = &#123;&#125;;

Object.assign(target, source)
// &#123; foo: 1 &#125;
</code></pre><p>上面代码中，<code>source</code>对象的<code>foo</code>属性是一个取值函数，<code>Object.assign()</code>不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p><hr><p><strong>常见用途</strong></p><p><code>Object.assign()</code>方法有很多用处。</p><p><strong>（1）为对象添加属性</strong></p><pre><code class="javascript">class Point &#123;
  constructor(x, y) &#123;
    Object.assign(this, &#123;x, y&#125;);
  &#125;
&#125;
</code></pre><p>上面方法通过<code>Object.assign()</code>方法，将<code>x</code>属性和<code>y</code>属性添加到<code>Point</code>类的对象实例。</p><p><strong>（2）为对象添加方法</strong></p><pre><code class="javascript">Object.assign(SomeClass.prototype, &#123;
  someMethod(arg1, arg2) &#123;
    ···
  &#125;,
  anotherMethod() &#123;
    ···
  &#125;
&#125;);

// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) &#123;
  ···
&#125;;
SomeClass.prototype.anotherMethod = function () &#123;
  ···
&#125;;
</code></pre><p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用<code>assign()</code>方法添加到<code>SomeClass.prototype</code>之中。</p><p><strong>（3）克隆对象</strong></p><pre><code class="javascript">function clone(origin) &#123;
  return Object.assign(&#123;&#125;, origin);
&#125;
</code></pre><p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p><p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p><pre><code class="javascript">function clone(origin) &#123;
  let originProto = Object.getPrototypeOf(origin);
  return Object.assign(Object.create(originProto), origin);
&#125;
</code></pre><p><strong>（4）合并多个对象</strong></p><p>将多个对象合并到某个对象。</p><pre><code class="javascript">const merge =
  (target, ...sources) =&gt; Object.assign(target, ...sources);
</code></pre><p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p><pre><code class="javascript">const merge =
  (...sources) =&gt; Object.assign(&#123;&#125;, ...sources);
</code></pre><p><strong>（5）为属性指定默认值</strong></p><pre><code class="javascript">const DEFAULTS = &#123;
  logLevel: 0,
  outputFormat: &#39;html&#39;
&#125;;

function processContent(options) &#123;
  options = Object.assign(&#123;&#125;, DEFAULTS, options);
  console.log(options);
  // ...
&#125;
</code></pre><p>上面代码中，<code>DEFAULTS</code>对象是默认值，<code>options</code>对象是用户提供的参数。<code>Object.assign()</code>方法将<code>DEFAULTS</code>和<code>options</code>合并成一个新对象，如果两者有同名属性，则<code>options</code>的属性值会覆盖<code>DEFAULTS</code>的属性值。</p><p>注意，由于存在浅拷贝的问题，<code>DEFAULTS</code>对象和<code>options</code>对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，<code>DEFAULTS</code>对象的该属性很可能不起作用。</p><pre><code class="javascript">const DEFAULTS = &#123;
  url: &#123;
    host: &#39;example.com&#39;,
    port: 7070
  &#125;,
&#125;;

processContent(&#123; url: &#123;port: 8000&#125; &#125;)
// &#123;
//   url: &#123;port: 8000&#125;
// &#125;
</code></pre><p>上面代码的原意是将<code>url.port</code>改成 8000，<code>url.host</code>不变。实际结果却是<code>options.url</code>覆盖掉<code>DEFAULTS.url</code>，所以<code>url.host</code>就不存在了。</p><hr><h4 id="3-Object-getOwnPropertyDescriptors"><a href="#3-Object-getOwnPropertyDescriptors" class="headerlink" title="3. Object.getOwnPropertyDescriptors()"></a>3. Object.getOwnPropertyDescriptors()</h4><p>ES5 的<code>Object.getOwnPropertyDescriptor()</code>方法会返回某个对象属性的描述对象（descriptor）。<strong>ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</strong></p><pre><code class="javascript">const obj = &#123;
  foo: 123,
  get bar() &#123; return &#39;abc&#39; &#125;
&#125;;

Object.getOwnPropertyDescriptors(obj)
// &#123; foo:
//    &#123; value: 123,
//      writable: true,
//      enumerable: true,
//      configurable: true &#125;,
//   bar:
//    &#123; get: [Function: get bar],
//      set: undefined,
//      enumerable: true,
//      configurable: true &#125; &#125;
</code></pre><p>上面代码中，<code>Object.getOwnPropertyDescriptors()</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p><p>该方法的实现非常容易。</p><pre><code class="javascript">function getOwnPropertyDescriptors(obj) &#123;
  const result = &#123;&#125;;
  for (let key of Reflect.ownKeys(obj)) &#123;
    result[key] = Object.getOwnPropertyDescriptor(obj, key);
  &#125;
  return result;
&#125;
</code></pre><p><strong>该方法的引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。</strong></p><pre><code class="javascript">const source = &#123;
  set foo(value) &#123;
    console.log(value);
  &#125;
&#125;;

const target1 = &#123;&#125;;
Object.assign(target1, source);

Object.getOwnPropertyDescriptor(target1, &#39;foo&#39;)
// &#123; value: undefined,
//   writable: true,
//   enumerable: true,
//   configurable: true &#125;
</code></pre><p>上面代码中，<code>source</code>对象的<code>foo</code>属性的值是一个赋值函数，<code>Object.assign</code>方法将这个属性拷贝给<code>target1</code>对象，结果该属性的值变成了<code>undefined</code>。这是因为<code>Object.assign</code>方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p><p>这时，<code>Object.getOwnPropertyDescriptors()</code>方法配合<code>Object.defineProperties()</code>方法，就可以实现正确拷贝。</p><pre><code class="javascript">const source = &#123;
  set foo(value) &#123;
    console.log(value);
  &#125;
&#125;;

const target2 = &#123;&#125;;
Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
Object.getOwnPropertyDescriptor(target2, &#39;foo&#39;)
// &#123; get: undefined,
//   set: [Function: set foo],
//   enumerable: true,
//   configurable: true &#125;
</code></pre><p>上面代码中，两个对象合并的逻辑可以写成一个函数。</p><pre><code class="javascript">const shallowMerge = (target, source) =&gt; Object.defineProperties(
  target,
  Object.getOwnPropertyDescriptors(source)
);
</code></pre><p><strong><code>Object.getOwnPropertyDescriptors()</code>方法的另一个用处，是配合<code>Object.create()</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝。</strong></p><pre><code class="javascript">const clone = Object.create(Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj));

// 或者

const shallowClone = (obj) =&gt; Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
</code></pre><p>上面代码会克隆对象<code>obj</code>。</p><p>另外，<code>Object.getOwnPropertyDescriptors()</code>方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p><pre><code class="javascript">const obj = &#123;
  __proto__: prot,
  foo: 123,
&#125;;
</code></pre><p>ES6 规定<code>__proto__</code>只有浏览器要部署，其他环境不用部署。如果去除<code>__proto__</code>，上面代码就要改成下面这样。</p><pre><code class="javascript">const obj = Object.create(prot);
obj.foo = 123;

// 或者

const obj = Object.assign(
  Object.create(prot),
  &#123;
    foo: 123,
  &#125;
);
</code></pre><p>有了<code>Object.getOwnPropertyDescriptors()</code>，我们就有了另一种写法。</p><pre><code class="javascript">const obj = Object.create(
  prot,
  Object.getOwnPropertyDescriptors(&#123;
    foo: 123,
  &#125;)
);
</code></pre><p><code>Object.getOwnPropertyDescriptors()</code>也可以用来实现 Mixin（混入）模式。</p><pre><code class="javascript">let mix = (object) =&gt; (&#123;
  with: (...mixins) =&gt; mixins.reduce(
    (c, mixin) =&gt; Object.create(
      c, Object.getOwnPropertyDescriptors(mixin)
    ), object)
&#125;);

// multiple mixins example
let a = &#123;a: &#39;a&#39;&#125;;
let b = &#123;b: &#39;b&#39;&#125;;
let c = &#123;c: &#39;c&#39;&#125;;
let d = mix(c).with(a, b);

d.c // &quot;c&quot;
d.b // &quot;b&quot;
d.a // &quot;a&quot;
</code></pre><p>上面代码返回一个新的对象<code>d</code>，代表了对象<code>a</code>和<code>b</code>被混入了对象<code>c</code>的操作。</p><p>出于完整性的考虑，<code>Object.getOwnPropertyDescriptors()</code>进入标准以后，以后还会新增<code>Reflect.getOwnPropertyDescriptors()</code>方法。</p><hr><h4 id="4-proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#4-proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="4. __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a>4. <code>__proto__属性</code>，Object.setPrototypeOf()，Object.getPrototypeOf()</h4><p>JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。</p><p><strong><code>__proto__</code>属性</strong></p><p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）。目前，所有浏览器（包括 IE11）都部署了这个属性。</p><pre><code class="javascript">// es5 的写法
const obj = &#123;
  method: function() &#123; ... &#125;
&#125;;
obj.__proto__ = someOtherObj;

// es6 的写法
var obj = Object.create(someOtherObj);
obj.method = function() &#123; ... &#125;;
</code></pre><p>该属性没有写入 ES6 的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，<strong>而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</strong></p><p>实现上，<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>，具体实现如下。</p><pre><code class="javascript">Object.defineProperty(Object.prototype, &#39;__proto__&#39;, &#123;
  get() &#123;
    let _thisObj = Object(this);
    return Object.getPrototypeOf(_thisObj);
  &#125;,
  set(proto) &#123;
    if (this === undefined || this === null) &#123;
      throw new TypeError();
    &#125;
    if (!isObject(this)) &#123;
      return undefined;
    &#125;
    if (!isObject(proto)) &#123;
      return undefined;
    &#125;
    let status = Reflect.setPrototypeOf(this, proto);
    if (!status) &#123;
      throw new TypeError();
    &#125;
  &#125;,
&#125;);

function isObject(value) &#123;
  return Object(value) === value;
&#125;
</code></pre><p>如果一个对象本身部署了<code>__proto__</code>属性，该属性的值就是对象的原型。</p><pre><code class="javascript">Object.getPrototypeOf(&#123; __proto__: null &#125;)
// null
</code></pre><p><strong>Object.setPrototypeOf</strong>()</p><p><strong><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</strong></p><pre><code class="javascript">// 格式
Object.setPrototypeOf(object, prototype)

// 用法
const o = Object.setPrototypeOf(&#123;&#125;, null);
</code></pre><p>该方法等同于下面的函数。</p><pre><code class="javascript">function setPrototypeOf(obj, proto) &#123;
  obj.__proto__ = proto;
  return obj;
&#125;
</code></pre><p>下面是一个例子。</p><pre><code class="javascript">let proto = &#123;&#125;;
let obj = &#123; x: 10 &#125;;
Object.setPrototypeOf(obj, proto);

proto.y = 20;
proto.z = 40;

obj.x // 10
obj.y // 20
obj.z // 40
</code></pre><p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性。</p><p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p><pre><code class="javascript">Object.setPrototypeOf(1, &#123;&#125;) === 1 // true
Object.setPrototypeOf(&#39;foo&#39;, &#123;&#125;) === &#39;foo&#39; // true
Object.setPrototypeOf(true, &#123;&#125;) === true // true
</code></pre><p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错。</p><pre><code class="javascript">Object.setPrototypeOf(undefined, &#123;&#125;)
// TypeError: Object.setPrototypeOf called on null or undefined

Object.setPrototypeOf(null, &#123;&#125;)
// TypeError: Object.setPrototypeOf called on null or undefined
</code></pre><p><strong>Object.getPrototypeOf()</strong></p><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。</p><pre><code class="javascript">Object.getPrototypeOf(obj);
</code></pre><p>下面是一个例子。</p><pre><code class="javascript">function Rectangle() &#123;
  // ...
&#125;

const rec = new Rectangle();

Object.getPrototypeOf(rec) === Rectangle.prototype
// true

Object.setPrototypeOf(rec, Object.prototype);
Object.getPrototypeOf(rec) === Rectangle.prototype
// false
</code></pre><p>如果参数不是对象，会被自动转为对象。</p><pre><code class="javascript">// 等同于 Object.getPrototypeOf(Number(1))
Object.getPrototypeOf(1)
// Number &#123;[[PrimitiveValue]]: 0&#125;

// 等同于 Object.getPrototypeOf(String(&#39;foo&#39;))
Object.getPrototypeOf(&#39;foo&#39;)
// String &#123;length: 0, [[PrimitiveValue]]: &quot;&quot;&#125;

// 等同于 Object.getPrototypeOf(Boolean(true))
Object.getPrototypeOf(true)
// Boolean &#123;[[PrimitiveValue]]: false&#125;

Object.getPrototypeOf(1) === Number.prototype // true
Object.getPrototypeOf(&#39;foo&#39;) === String.prototype // true
Object.getPrototypeOf(true) === Boolean.prototype // true
</code></pre><p>如果参数是<code>undefined</code>或<code>null</code>，它们无法转为对象，所以会报错。</p><pre><code class="javascript">Object.getPrototypeOf(null)
// TypeError: Cannot convert undefined or null to object

Object.getPrototypeOf(undefined)
// TypeError: Cannot convert undefined or null to object
</code></pre><hr><h4 id="5-Object-keys-，Object-values-，Object-entries"><a href="#5-Object-keys-，Object-values-，Object-entries" class="headerlink" title="5. Object.keys()，Object.values()，Object.entries()"></a>5. Object.keys()，Object.values()，Object.entries()</h4><p><strong>Object.keys</strong>()</p><p><strong>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</strong></p><pre><code class="javascript">var obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;
Object.keys(obj)
// [&quot;foo&quot;, &quot;baz&quot;]
</code></pre><p>ES2017 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVz">引入</span>了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。</p><pre><code class="javascript">let &#123;keys, values, entries&#125; = Object;
let obj = &#123; a: 1, b: 2, c: 3 &#125;;

for (let key of keys(obj)) &#123;
  console.log(key); // &#39;a&#39;, &#39;b&#39;, &#39;c&#39;
&#125;

for (let value of values(obj)) &#123;
  console.log(value); // 1, 2, 3
&#125;

for (let [key, value] of entries(obj)) &#123;
  console.log([key, value]); // [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]
&#125;
</code></pre><p><strong>Object.values()</strong></p><p><strong><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</strong></p><pre><code class="javascript">const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;
Object.values(obj)
// [&quot;bar&quot;, 42]
</code></pre><p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p><pre><code class="javascript">const obj = &#123; 100: &#39;a&#39;, 2: &#39;b&#39;, 7: &#39;c&#39; &#125;;
Object.values(obj)
// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]
</code></pre><p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code>b</code>、<code>c</code>、<code>a</code>。</p><p><code>Object.values</code>只返回对象自身的可遍历属性。</p><pre><code class="javascript">const obj = Object.create(&#123;&#125;, &#123;p: &#123;value: 42&#125;&#125;);
Object.values(obj) // []
</code></pre><p>上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性（属性<code>p</code>），如果不显式声明，默认是不可遍历的，因为<code>p</code>的属性描述对象的<code>enumerable</code>默认是<code>false</code>，<code>Object.values</code>不会返回这个属性。只要把<code>enumerable</code>改成<code>true</code>，<code>Object.values</code>就会返回属性<code>p</code>的值。</p><pre><code class="javascript">const obj = Object.create(&#123;&#125;, &#123;p:
  &#123;
    value: 42,
    enumerable: true
  &#125;
&#125;);
Object.values(obj) // [42]
</code></pre><p><code>Object.values</code>会过滤属性名为 Symbol 值的属性。</p><pre><code class="javascript">Object.values(&#123; [Symbol()]: 123, foo: &#39;abc&#39; &#125;);
// [&#39;abc&#39;]
</code></pre><p>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。</p><pre><code class="javascript">Object.values(&#39;foo&#39;)
// [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]
</code></pre><p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code>Object.values</code>返回每个属性的键值，就是各个字符组成的一个数组。</p><p>如果参数不是对象，<code>Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code>会返回空数组。</p><pre><code class="javascript">Object.values(42) // []
Object.values(true) // []
</code></pre><p><strong>Object.entries</strong>()</p><p><strong><code>Object.entries()</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</strong></p><pre><code class="javascript">const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;
Object.entries(obj)
// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]
</code></pre><p>除了返回值不一样，该方法的行为与<code>Object.values</code>基本一致。</p><p>如果原对象的属性名是一个 Symbol 值，该属性会被忽略。</p><pre><code class="javascript">Object.entries(&#123; [Symbol()]: 123, foo: &#39;abc&#39; &#125;);
// [ [ &#39;foo&#39;, &#39;abc&#39; ] ]
</code></pre><p>上面代码中，原对象有两个属性，<code>Object.entries</code>只输出属性名非 Symbol 值的属性。将来可能会有<code>Reflect.ownEntries()</code>方法，返回对象自身的所有属性。</p><p><code>Object.entries</code>的基本用途是遍历对象的属性。</p><pre><code class="javascript">let obj = &#123; one: 1, two: 2 &#125;;
for (let [k, v] of Object.entries(obj)) &#123;
  console.log(
    `$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;`
  );
&#125;
// &quot;one&quot;: 1
// &quot;two&quot;: 2
</code></pre><p><code>Object.entries</code>方法的另一个用处是，将对象转为真正的<code>Map</code>结构。</p><pre><code class="javascript">const obj = &#123; foo: &#39;bar&#39;, baz: 42 &#125;;
const map = new Map(Object.entries(obj));
map // Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;
</code></pre><p>自己实现<code>Object.entries</code>方法，非常简单。</p><pre><code class="javascript">// Generator函数的版本
function* entries(obj) &#123;
  for (let key of Object.keys(obj)) &#123;
    yield [key, obj[key]];
  &#125;
&#125;

// 非Generator函数的版本
function entries(obj) &#123;
  let arr = [];
  for (let key of Object.keys(obj)) &#123;
    arr.push([key, obj[key]]);
  &#125;
  return arr;
&#125;
</code></pre><hr><h4 id="6-Object-fromEntries"><a href="#6-Object-fromEntries" class="headerlink" title="6. Object.fromEntries()"></a>6. Object.fromEntries()</h4><p><strong><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。</strong></p><pre><code class="javascript">Object.fromEntries([
  [&#39;foo&#39;, &#39;bar&#39;],
  [&#39;baz&#39;, 42]
])
// &#123; foo: &quot;bar&quot;, baz: 42 &#125;
</code></pre><p><strong>该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。</strong></p><pre><code class="javascript">// 例一
const entries = new Map([
  [&#39;foo&#39;, &#39;bar&#39;],
  [&#39;baz&#39;, 42]
]);

Object.fromEntries(entries)
// &#123; foo: &quot;bar&quot;, baz: 42 &#125;

// 例二
const map = new Map().set(&#39;foo&#39;, true).set(&#39;bar&#39;, false);
Object.fromEntries(map)
// &#123; foo: true, bar: false &#125;
</code></pre><p><strong>该方法的一个用处是配合<code>URLSearchParams</code>对象，将查询字符串转为对象。</strong></p><pre><code class="javascript">Object.fromEntries(new URLSearchParams(&#39;foo=bar&amp;baz=qux&#39;))
// &#123; foo: &quot;bar&quot;, baz: &quot;qux&quot; &#125;
</code></pre><h3 id="11、运算符的扩展"><a href="#11、运算符的扩展" class="headerlink" title="11、运算符的扩展"></a>11、运算符的扩展</h3><hr><h4 id="1-指数运算符"><a href="#1-指数运算符" class="headerlink" title="1. 指数运算符**"></a>1. 指数运算符**</h4><p>ES2016 新增了一个指数运算符（<code>**</code>）。</p><pre><code class="javascript">2 ** 2 // 4
2 ** 3 // 8
</code></pre><p>这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，<strong>是从最右边开始计算的。</strong></p><pre><code class="javascript">// 相当于 2 ** (3 ** 2)
2 ** 3 ** 2
// 512
</code></pre><p>上面代码中，首先计算的是第二个指数运算符，而不是第一个。</p><p>指数运算符可以与等号结合，形成一个新的赋值运算符（<code>**=</code>）。</p><pre><code class="javascript">let a = 1.5;
a **= 2;
// 等同于 a = a * a;

let b = 4;
b **= 3;
// 等同于 b = b * b * b;
</code></pre><hr><h4 id="2-链判断运算符？"><a href="#2-链判断运算符？" class="headerlink" title="2. 链判断运算符？."></a>2. 链判断运算符？.</h4><p><strong>编程实务中，如果读取对象内部的某个属性，往往需要判断一下，属性的上层对象是否存在</strong>。比如，读取<code>message.body.user.firstName</code>这个属性，安全的写法是写成下面这样。</p><pre><code class="javascript">// 错误的写法
const  firstName = message.body.user.firstName || &#39;default&#39;;

// 正确的写法
const firstName = (message
  &amp;&amp; message.body
  &amp;&amp; message.body.user
  &amp;&amp; message.body.user.firstName) || &#39;default&#39;;
</code></pre><p>上面例子中，<code>firstName</code>属性在对象的第四层，所以需要判断四次，每一层是否有值。</p><p>三元运算符<code>?:</code>也常用于判断对象是否存在。</p><pre><code class="javascript">const fooInput = myForm.querySelector(&#39;input[name=foo]&#39;)
const fooValue = fooInput ? fooInput.value : undefined
</code></pre><p>上面例子中，必须先判断<code>fooInput</code>是否存在，才能读取<code>fooInput.value</code>。</p><p><strong>这样的层层判断非常麻烦，因此 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb3B0aW9uYWwtY2hhaW5pbmc=">ES2020</span> 引入了“链判断运算符”（optional chaining operator）<code>?.</code>，简化上面的写法。</strong></p><pre><code class="javascript">const firstName = message?.body?.user?.firstName || &#39;default&#39;;
const fooValue = myForm.querySelector(&#39;input[name=foo]&#39;)?.value
</code></pre><p>上面代码使用了<code>?.</code>运算符，直接在链式调用的时候判断，左侧的对象是否为<code>null</code>或<code>undefined</code>。如果是的，就不再往下运算，而是返回<code>undefined</code>。</p><p>下面是判断对象方法是否存在，如果存在就立即执行的例子。</p><pre><code class="javascript">iterator.return?.()
</code></pre><p>上面代码中，<code>iterator.return</code>如果有定义，就会调用该方法，否则<code>iterator.return</code>直接返回<code>undefined</code>，不再执行<code>?.</code>后面的部分。</p><p>对于那些可能没有实现的方法，这个运算符尤其有用。</p><pre><code class="javascript">if (myForm.checkValidity?.() === false) &#123;
  // 表单校验失败
  return;
&#125;
</code></pre><p>上面代码中，老式浏览器的表单对象可能没有<code>checkValidity()</code>这个方法，这时<code>?.</code>运算符就会返回<code>undefined</code>，判断语句就变成了<code>undefined === false</code>，所以就会跳过下面的代码。</p><p><strong>链判断运算符<code>?.</code>有三种写法。</strong></p><ul><li><strong><code>obj?.prop</code> // 对象属性是否存在</strong></li><li><strong><code>obj?.[expr]</code> // 同上</strong></li><li><strong><code>func?.(...args)</code> // 函数或对象方法是否存在</strong></li></ul><p>下面是<code>obj?.[expr]</code>用法的一个例子。</p><pre><code class="bash">let hex = &quot;#C0FFEE&quot;.match(/#([A-Z]+)/i)?.[1];
</code></pre><p>上面例子中，字符串的<code>match()</code>方法，如果没有发现匹配会返回<code>null</code>，如果发现匹配会返回一个数组，<code>?.</code>运算符起到了判断作用。</p><p>下面是<code>?.</code>运算符常见形式，以及不使用该运算符时的等价形式。</p><pre><code class="javascript">a?.b
// 等同于
a == null ? undefined : a.b

a?.[x]
// 等同于
a == null ? undefined : a[x]

a?.b()
// 等同于
a == null ? undefined : a.b()

a?.()
// 等同于
a == null ? undefined : a()
</code></pre><p>上面代码中，特别注意后两种形式，如果<code>a?.b()</code>和<code>a?.()</code>。如果<code>a?.b()</code>里面的<code>a.b</code>有值，但不是函数，不可调用，那么<code>a?.b()</code>是会报错的。<code>a?.()</code>也是如此，<strong>如果<code>a</code>不是<code>null</code>或<code>undefined</code>，但也不是函数，那么<code>a?.()</code>会报错。</strong></p><p>使用这个运算符，有几个注意点。</p><p>（1）短路机制</p><p><strong>本质上，<code>?.</code>运算符相当于一种短路机制，只要不满足条件，就不再往下执行。</strong></p><pre><code class="javascript">a?.[++x]
// 等同于
a == null ? undefined : a[++x]
</code></pre><p>上面代码中，如果<code>a</code>是<code>undefined</code>或<code>null</code>，那么<code>x</code>不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。</p><p>（2）括号的影响</p><p>如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。</p><pre><code class="javascript">(a?.b).c
// 等价于
(a == null ? undefined : a.b).c
</code></pre><p>上面代码中，<code>?.</code>对圆括号外部没有影响，不管<code>a</code>对象是否存在，圆括号后面的<code>.c</code>总是会执行。</p><p><strong>一般来说，使用<code>?.</code>运算符的场合，不应该使用圆括号。</strong></p><p>（3）报错场合</p><p>以下写法是禁止的，会报错。</p><pre><code class="javascript">// 构造函数
new a?.()
new a?.b()

// 链判断运算符的右侧有模板字符串
a?.`&#123;b&#125;`
a?.b`&#123;c&#125;`

// 链判断运算符的左侧是 super
super?.()
super?.foo

// 链运算符用于赋值运算符左侧
a?.b = c
</code></pre><p>（4）右侧不得为十进制数值</p><p>为了保证兼容以前的代码，允许<code>foo?.3:0</code>被解析成<code>foo ? .3 : 0</code>，因此规定如果<code>?.</code>后面紧跟一个十进制数字，<strong>那么<code>?.</code>不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。</strong></p><hr><h4 id="3-Null-判断运算符？？"><a href="#3-Null-判断运算符？？" class="headerlink" title="3. Null 判断运算符？？"></a>3. Null 判断运算符？？</h4><p>读取对象属性的时候，如果某个属性的值是<code>null</code>或<code>undefined</code>，有时候需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值。</p><pre><code class="javascript">const headerText = response.settings.headerText || &#39;Hello, world!&#39;;
const animationDuration = response.settings.animationDuration || 300;
const showSplashScreen = response.settings.showSplashScreen || true;
</code></pre><p><strong>上面的三行代码都通过<code>||</code>运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为<code>null</code>或<code>undefined</code>，默认值就会生效，但是属性的值如果为空字符串或<code>false</code>或<code>0</code>，默认值也会生效。</strong></p><p><strong>为了避免这种情况，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtbnVsbGlzaC1jb2FsZXNjaW5n">ES2020</span> 引入了一个新的 Null 判断运算符<code>??</code>。它的行为类似<code>||</code>，但是只有运算符左侧的值为<code>null</code>或<code>undefined</code>时，才会返回右侧的值。</strong></p><pre><code class="javascript">const headerText = response.settings.headerText ?? &#39;Hello, world!&#39;;
const animationDuration = response.settings.animationDuration ?? 300;
const showSplashScreen = response.settings.showSplashScreen ?? true;
</code></pre><p>上面代码中，默认值只有在左侧属性值为<code>null</code>或<code>undefined</code>时，才会生效。</p><p><strong>这个运算符的一个目的，就是跟链判断运算符<code>?.</code>配合使用，为<code>null</code>或<code>undefined</code>的值设置默认值</strong>。</p><pre><code class="javascript">const animationDuration = response.settings?.animationDuration ?? 300;
</code></pre><p>上面代码中，如果<code>response.settings</code>是<code>null</code>或<code>undefined</code>，或者<code>response.settings.animationDuration</code>是<code>null</code>或<code>undefined</code>，就会返回默认值300。也就是说，这一行代码包括了两级属性的判断。</p><p>这个运算符很适合判断函数参数是否赋值。</p><pre><code class="javascript">function Component(props) &#123;
  const enable = props.enabled ?? true;
  // …
&#125;
</code></pre><p>上面代码判断<code>props</code>参数的<code>enabled</code>属性是否赋值，基本等同于下面的写法。</p><pre><code class="javascript">function Component(props) &#123;
  const &#123;
    enabled: enable = true,
  &#125; = props;
  // …
&#125;
</code></pre><p><strong><code>??</code>本质上是逻辑运算，它与其他两个逻辑运算符<code>&amp;&amp;</code>和<code>||</code>有一个优先级问题</strong>，它们之间的优先级到底孰高孰低。优先级的不同，往往会导致逻辑运算的结果不同。</p><p>现在的规则是，如果多个逻辑运算符一起使用，<strong>必须用括号表明优先级，否则会报错。</strong></p><pre><code class="javascript">// 报错
lhs &amp;&amp; middle ?? rhs
lhs ?? middle &amp;&amp; rhs
lhs || middle ?? rhs
lhs ?? middle || rhs
</code></pre><p>上面四个表达式都会报错，必须加入表明优先级的括号。</p><pre><code class="javascript">(lhs &amp;&amp; middle) ?? rhs;
lhs &amp;&amp; (middle ?? rhs);

(lhs ?? middle) &amp;&amp; rhs;
lhs ?? (middle &amp;&amp; rhs);

(lhs || middle) ?? rhs;
lhs || (middle ?? rhs);

(lhs ?? middle) || rhs;
lhs ?? (middle || rhs);
</code></pre><hr><h4 id="4-逻辑赋值运算符"><a href="#4-逻辑赋值运算符" class="headerlink" title="4. 逻辑赋值运算符"></a>4. 逻辑赋值运算符</h4><p>ES2021 引入了三个新的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtbG9naWNhbC1hc3NpZ25tZW50">逻辑赋值运算符</span>（logical assignment operators），将逻辑运算符与赋值运算符进行结合。</p><pre><code class="javascript">// 或赋值运算符
x ||= y
// 等同于
x || (x = y)

// 与赋值运算符
x &amp;&amp;= y
// 等同于
x &amp;&amp; (x = y)

// Null 赋值运算符
x ??= y
// 等同于
x ?? (x = y)
</code></pre><p><strong>这三个运算符<code>||=</code>、<code>&amp;&amp;=</code>、<code>??=</code>相当于先进行逻辑运算，然后根据运算结果，再视情况进行赋值运算。</strong></p><p><strong>它们的一个用途是，为变量或属性设置默认值。</strong></p><pre><code class="javascript">// 老的写法
user.id = user.id || 1;

// 新的写法
user.id ||= 1;
</code></pre><p>上面示例中，<code>user.id</code>属性如果不存在，则设为<code>1</code>，新的写法比老的写法更紧凑一些。</p><p>下面是另一个例子。</p><pre><code class="javascript">function example(opts) &#123;
  opts.foo = opts.foo ?? &#39;bar&#39;;
  opts.baz ?? (opts.baz = &#39;qux&#39;);
&#125;
</code></pre><p>上面示例中，参数对象<code>opts</code>如果不存在属性<code>foo</code>和属性<code>baz</code>，则为这两个属性设置默认值。有了“Null 赋值运算符”以后，就可以统一写成下面这样。</p><pre><code class="javascript">function example(opts) &#123;
  opts.foo ??= &#39;bar&#39;;
  opts.baz ??= &#39;qux&#39;;
&#125;
</code></pre><h3 id="12、-Symbol"><a href="#12、-Symbol" class="headerlink" title="12、 Symbol"></a>12、 Symbol</h3><hr><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。<strong>如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</strong></p><p><strong>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</strong></p><p>Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><pre><code class="javascript">let s = Symbol();

typeof s
// &quot;symbol&quot;
</code></pre><p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是 Symbol 数据类型，而不是字符串之类的其他类型。</p><p>注意，**<code>Symbol</code>函数前不能使用<code>new</code>命令**，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><p><strong><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述</strong>，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><pre><code class="javascript">let s1 = Symbol(&#39;foo&#39;);
let s2 = Symbol(&#39;bar&#39;);

s1 // Symbol(foo)
s2 // Symbol(bar)

s1.toString() // &quot;Symbol(foo)&quot;
s2.toString() // &quot;Symbol(bar)&quot;
</code></pre><p>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p><p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。</p><pre><code class="javascript">const obj = &#123;
  toString() &#123;
    return &#39;abc&#39;;
  &#125;
&#125;;
const sym = Symbol(obj);
sym // Symbol(abc)
</code></pre><p>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此<strong>相同参数的<code>Symbol</code>函数的返回值是不相等的。</strong></p><pre><code class="javascript">// 没有参数的情况
let s1 = Symbol();
let s2 = Symbol();

s1 === s2 // false

// 有参数的情况
let s1 = Symbol(&#39;foo&#39;);
let s2 = Symbol(&#39;foo&#39;);

s1 === s2 // false
</code></pre><p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。</p><p><strong>Symbol 值不能与其他类型的值进行运算，会报错。</strong></p><pre><code class="javascript">let sym = Symbol(&#39;My symbol&#39;);

&quot;your symbol is &quot; + sym
// TypeError: can&#39;t convert symbol to string
`your symbol is $&#123;sym&#125;`
// TypeError: can&#39;t convert symbol to string
</code></pre><p>但是，<strong>Symbol 值可以显式转为字符串。</strong></p><pre><code class="javascript">let sym = Symbol(&#39;My symbol&#39;);

String(sym) // &#39;Symbol(My symbol)&#39;
sym.toString() // &#39;Symbol(My symbol)&#39;
</code></pre><p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p><pre><code class="javascript">let sym = Symbol();
Boolean(sym) // true
!sym  // false

if (sym) &#123;
  // ...
&#125;

Number(sym) // TypeError
sym + 2 // TypeError
</code></pre><hr><h4 id="2-Symbol-prototype-description"><a href="#2-Symbol-prototype-description" class="headerlink" title="2. Symbol.prototype.description"></a>2. Symbol.prototype.description</h4><p>创建 Symbol 的时候，可以添加一个描述。</p><pre><code class="javascript">const sym = Symbol(&#39;foo&#39;);
</code></pre><p>上面代码中，<code>sym</code>的描述就是字符串<code>foo</code>。</p><p>但是，读取这个描述需要将 Symbol 显式转为字符串，即下面的写法。</p><pre><code class="javascript">const sym = Symbol(&#39;foo&#39;);

String(sym) // &quot;Symbol(foo)&quot;
sym.toString() // &quot;Symbol(foo)&quot;
</code></pre><p>上面的用法不是很方便。**<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtU3ltYm9sLWRlc2NyaXB0aW9u">ES2019</span> 提供了一个实例属性<code>description</code>，直接返回 Symbol 的描述。**</p><pre><code class="javascript">const sym = Symbol(&#39;foo&#39;);

sym.description // &quot;foo&quot;
</code></pre><hr><h4 id="3-作为属性名的-Symbol"><a href="#3-作为属性名的-Symbol" class="headerlink" title="3. 作为属性名的 Symbol"></a>3. 作为属性名的 Symbol</h4><p>由于每一个 Symbol 值都是不相等的，<strong>这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性</strong>。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p><pre><code class="javascript">let mySymbol = Symbol();

// 第一种写法
let a = &#123;&#125;;
a[mySymbol] = &#39;Hello!&#39;;

// 第二种写法
let a = &#123;
  [mySymbol]: &#39;Hello!&#39;
&#125;;

// 第三种写法
let a = &#123;&#125;;
Object.defineProperty(a, mySymbol, &#123; value: &#39;Hello!&#39; &#125;);

// 以上写法都得到同样结果
a[mySymbol] // &quot;Hello!&quot;
</code></pre><p>上面代码通过方括号结构和<code>Object.defineProperty</code>，将对象的属性名指定为一个 Symbol 值。</p><p><strong>注意，Symbol 值作为对象属性名时，不能用点运算符。</strong></p><pre><code class="javascript">const mySymbol = Symbol();
const a = &#123;&#125;;

a.mySymbol = &#39;Hello!&#39;;
a[mySymbol] // undefined
a[&#39;mySymbol&#39;] // &quot;Hello!&quot;
</code></pre><p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。</p><p>同理，<strong>在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中</strong>。</p><pre><code class="javascript">let s = Symbol();

let obj = &#123;
  [s]: function (arg) &#123; ... &#125;
&#125;;

obj[s](123);
</code></pre><p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个 Symbol 值。</p><p>采用增强的对象写法，上面代码的<code>obj</code>对象可以写得更简洁一些。</p><pre><code class="javascript">let obj = &#123;
  [s](arg) &#123; ... &#125;
&#125;;
</code></pre><p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p><pre><code class="javascript">const log = &#123;&#125;;

log.levels = &#123;
  DEBUG: Symbol(&#39;debug&#39;),
  INFO: Symbol(&#39;info&#39;),
  WARN: Symbol(&#39;warn&#39;)
&#125;;
console.log(log.levels.DEBUG, &#39;debug message&#39;);
console.log(log.levels.INFO, &#39;info message&#39;);
</code></pre><p>下面是另外一个例子。</p><pre><code class="javascript">const COLOR_RED    = Symbol();
const COLOR_GREEN  = Symbol();

function getComplement(color) &#123;
  switch (color) &#123;
    case COLOR_RED:
      return COLOR_GREEN;
    case COLOR_GREEN:
      return COLOR_RED;
    default:
      throw new Error(&#39;Undefined color&#39;);
    &#125;
&#125;
</code></pre><p>常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的<code>switch</code>语句会按设计的方式工作。</p><p>还有一点需要注意，<strong>Symbol 值作为属性名时，该属性还是公开属性，不是私有属性</strong>。</p><hr><h4 id="4-实例：消除魔术字符串"><a href="#4-实例：消除魔术字符串" class="headerlink" title="4. 实例：消除魔术字符串"></a>4. 实例：消除魔术字符串</h4><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p><pre><code class="javascript">function getArea(shape, options) &#123;
  let area = 0;

  switch (shape) &#123;
    case &#39;Triangle&#39;: // 魔术字符串
      area = .5 * options.width * options.height;
      break;
    /* ... more code ... */
  &#125;

  return area;
&#125;

getArea(&#39;Triangle&#39;, &#123; width: 100, height: 100 &#125;); // 魔术字符串
</code></pre><p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p><p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p><pre><code class="javascript">const shapeType = &#123;
  triangle: &#39;Triangle&#39;
&#125;;

function getArea(shape, options) &#123;
  let area = 0;
  switch (shape) &#123;
    case shapeType.triangle:
      area = .5 * options.width * options.height;
      break;
  &#125;
  return area;
&#125;

getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;);
</code></pre><p>上面代码中，我们把<code>Triangle</code>写成<code>shapeType</code>对象的<code>triangle</code>属性，这样就消除了强耦合。</p><p>如果仔细分析，可以发现<code>shapeType.triangle</code>等于哪个值并不重要，只要确保不会跟其他<code>shapeType</code>属性的值冲突即可。因此，这里就很适合改用 Symbol 值。</p><pre><code class="javascript">const shapeType = &#123;
  triangle: Symbol()
&#125;;
</code></pre><p>上面代码中，除了将<code>shapeType.triangle</code>的值设为一个 Symbol，其他地方都不用修改。</p><hr><h4 id="5-属性名的遍历"><a href="#5-属性名的遍历" class="headerlink" title="5. 属性名的遍历"></a>5. 属性名的遍历</h4><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p><p>但是，<strong>它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。</strong>该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><pre><code class="javascript">const obj = &#123;&#125;;
let a = Symbol(&#39;a&#39;);
let b = Symbol(&#39;b&#39;);

obj[a] = &#39;Hello&#39;;
obj[b] = &#39;World&#39;;

const objectSymbols = Object.getOwnPropertySymbols(obj);

objectSymbols
// [Symbol(a), Symbol(b)]
</code></pre><p>上面代码是<code>Object.getOwnPropertySymbols()</code>方法的示例，可以获取所有 Symbol 属性名。</p><p>下面是另一个例子，<code>Object.getOwnPropertySymbols()</code>方法与<code>for...in</code>循环、<code>Object.getOwnPropertyNames</code>方法进行对比的例子。</p><pre><code class="javascript">const obj = &#123;&#125;;
const foo = Symbol(&#39;foo&#39;);

obj[foo] = &#39;bar&#39;;

for (let i in obj) &#123;
  console.log(i); // 无输出
&#125;

Object.getOwnPropertyNames(obj) // []
Object.getOwnPropertySymbols(obj) // [Symbol(foo)]
</code></pre><p>上面代码中，使用<code>for...in</code>循环和<code>Object.getOwnPropertyNames()</code>方法都得不到 Symbol 键名，需要使用<code>Object.getOwnPropertySymbols()</code>方法。</p><p>另一个新的 API，**<code>Reflect.ownKeys()</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。**</p><pre><code class="javascript">let obj = &#123;
  [Symbol(&#39;my_key&#39;)]: 1,
  enum: 2,
  nonEnum: 3
&#125;;

Reflect.ownKeys(obj)
//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]
</code></pre><p>由于以 Symbol 值作为键名，不会被常规方法遍历得到。<strong>我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法</strong>。</p><pre><code class="javascript">let size = Symbol(&#39;size&#39;);

class Collection &#123;
  constructor() &#123;
    this[size] = 0;
  &#125;

  add(item) &#123;
    this[this[size]] = item;
    this[size]++;
  &#125;

  static sizeOf(instance) &#123;
    return instance[size];
  &#125;
&#125;

let x = new Collection();
Collection.sizeOf(x) // 0

x.add(&#39;foo&#39;);
Collection.sizeOf(x) // 1

Object.keys(x) // [&#39;0&#39;]
Object.getOwnPropertyNames(x) // [&#39;0&#39;]
Object.getOwnPropertySymbols(x) // [Symbol(size)]
</code></pre><p>上面代码中，对象<code>x</code>的<code>size</code>属性是一个 Symbol 值，所以<code>Object.keys(x)</code>、<code>Object.getOwnPropertyNames(x)</code>都无法获取它。这就造成了一种非私有的内部方法的效果。</p><hr><h4 id="6-Symbol-for-，Symbol-keyFor"><a href="#6-Symbol-for-，Symbol-keyFor" class="headerlink" title="6. Symbol.for()，Symbol.keyFor()"></a>6. Symbol.for()，Symbol.keyFor()</h4><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p><pre><code class="javascript">let s1 = Symbol.for(&#39;foo&#39;);
let s2 = Symbol.for(&#39;foo&#39;);

s1 === s2 // true
</code></pre><p>上面代码中，**<code>s1</code>和<code>s2</code>都是 Symbol 值，但是它们都是由同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。**</p><p><strong><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会</strong>。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。</p><pre><code class="javascript">Symbol.for(&quot;bar&quot;) === Symbol.for(&quot;bar&quot;)
// true

Symbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;)
// false
</code></pre><p>上面代码中，<strong>由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</strong></p><p><strong><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</strong></p><pre><code class="javascript">let s1 = Symbol.for(&quot;foo&quot;);
Symbol.keyFor(s1) // &quot;foo&quot;

let s2 = Symbol(&quot;foo&quot;);
Symbol.keyFor(s2) // undefined
</code></pre><p>上面代码中，变量<code>s2</code>属于未登记的 Symbol 值，所以返回<code>undefined</code>。</p><p>注意，**<code>Symbol.for()</code>为 Symbol 值登记的名字，是全局环境的**，不管有没有在全局环境运行。</p><pre><code class="javascript">function foo() &#123;
  return Symbol.for(&#39;bar&#39;);
&#125;

const x = foo();
const y = Symbol.for(&#39;bar&#39;);
console.log(x === y); // true
</code></pre><p>上面代码中，<code>Symbol.for(&#39;bar&#39;)</code>是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的。所以，第二次运行<code>Symbol.for(&#39;bar&#39;)</code>可以取到这个 Symbol 值。</p><p><code>Symbol.for()</code>的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。</p><pre><code class="javascript">iframe = document.createElement(&#39;iframe&#39;);
iframe.src = String(window.location);
document.body.appendChild(iframe);

iframe.contentWindow.Symbol.for(&#39;foo&#39;) === Symbol.for(&#39;foo&#39;)
// true
</code></pre><p>上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。</p><hr><h4 id="7-实例：模块的-Singleton-模式"><a href="#7-实例：模块的-Singleton-模式" class="headerlink" title="7.实例：模块的 Singleton 模式"></a>7.实例：模块的 Singleton 模式</h4><p>Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。</p><p>对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p><p>很容易想到，可以把实例放到顶层对象<code>global</code>。</p><pre><code class="javascript">// mod.js
function A() &#123;
  this.foo = &#39;hello&#39;;
&#125;

if (!global._foo) &#123;
  global._foo = new A();
&#125;

module.exports = global._foo;
</code></pre><p>然后，加载上面的<code>mod.js</code>。</p><pre><code class="javascript">const a = require(&#39;./mod.js&#39;);
console.log(a.foo);
</code></pre><p>上面代码中，变量<code>a</code>任何时候加载的都是<code>A</code>的同一个实例。</p><p>但是，这里有一个问题，全局变量<code>global._foo</code>是可写的，任何文件都可以修改。</p><pre><code class="javascript">global._foo = &#123; foo: &#39;world&#39; &#125;;

const a = require(&#39;./mod.js&#39;);
console.log(a.foo);
</code></pre><p>上面的代码，会使得加载<code>mod.js</code>的脚本都失真。</p><p>为了防止这种情况出现，我们就可以使用 Symbol。</p><pre><code class="javascript">// mod.js
const FOO_KEY = Symbol.for(&#39;foo&#39;);

function A() &#123;
  this.foo = &#39;hello&#39;;
&#125;

if (!global[FOO_KEY]) &#123;
  global[FOO_KEY] = new A();
&#125;

module.exports = global[FOO_KEY];
</code></pre><p>上面代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p><pre><code class="javascript">global[Symbol.for(&#39;foo&#39;)] = &#123; foo: &#39;world&#39; &#125;;

const a = require(&#39;./mod.js&#39;);
</code></pre><p>如果键名使用<code>Symbol</code>方法生成，那么外部将无法引用这个值，当然也就无法改写。</p><pre><code class="javascript">// mod.js
const FOO_KEY = Symbol(&#39;foo&#39;);

// 后面代码相同 ……
</code></pre><p>上面代码将导致其他脚本都无法引用<code>FOO_KEY</code>。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的<code>FOO_KEY</code>都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。</p><hr><h4 id="8-内置的-Symbol-值"><a href="#8-内置的-Symbol-值" class="headerlink" title="8. 内置的 Symbol 值"></a>8. 内置的 Symbol 值</h4><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p><p><strong>Symbol.hasInstance</strong></p><p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。<strong>当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法</strong>。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p><pre><code class="javascript">class MyClass &#123;
  [Symbol.hasInstance](foo) &#123;
    return foo instanceof Array;
  &#125;
&#125;

[1, 2, 3] instanceof new MyClass() // true
</code></pre><p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</p><p>下面是另一个例子。</p><pre><code class="javascript">class Even &#123;
  static [Symbol.hasInstance](obj) &#123;
    return Number(obj) % 2 === 0;
  &#125;
&#125;

// 等同于
const Even = &#123;
  [Symbol.hasInstance](obj) &#123;
    return Number(obj) % 2 === 0;
  &#125;
&#125;;

1 instanceof Even // false
2 instanceof Even // true
12345 instanceof Even // false
</code></pre><hr><p><strong>Symbol.isConcatSpreadable</strong></p><p><strong>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。</strong></p><pre><code class="javascript">let arr1 = [&#39;c&#39;, &#39;d&#39;];
[&#39;a&#39;, &#39;b&#39;].concat(arr1, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
arr1[Symbol.isConcatSpreadable] // undefined

let arr2 = [&#39;c&#39;, &#39;d&#39;];
arr2[Symbol.isConcatSpreadable] = false;
[&#39;a&#39;, &#39;b&#39;].concat(arr2, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, [&#39;c&#39;,&#39;d&#39;], &#39;e&#39;]
</code></pre><p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</p><p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。</p><pre><code class="javascript">let obj = &#123;length: 2, 0: &#39;c&#39;, 1: &#39;d&#39;&#125;;
[&#39;a&#39;, &#39;b&#39;].concat(obj, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, obj, &#39;e&#39;]

obj[Symbol.isConcatSpreadable] = true;
[&#39;a&#39;, &#39;b&#39;].concat(obj, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
</code></pre><p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面。</p><pre><code class="javascript">class A1 extends Array &#123;
  constructor(args) &#123;
    super(args);
    this[Symbol.isConcatSpreadable] = true;
  &#125;
&#125;
class A2 extends Array &#123;
  constructor(args) &#123;
    super(args);
  &#125;
  get [Symbol.isConcatSpreadable] () &#123;
    return false;
  &#125;
&#125;
let a1 = new A1();
a1[0] = 3;
a1[1] = 4;
let a2 = new A2();
a2[0] = 5;
a2[1] = 6;
[1, 2].concat(a1).concat(a2)
// [1, 2, 3, 4, [5, 6]]
</code></pre><p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果。</p><p>注意，<code>Symbol.isConcatSpreadable</code>的位置差异，<code>A1</code>是定义在实例上，<code>A2</code>是定义在类本身，效果相同。</p><hr><p><strong>Symbol.species</strong></p><p><strong>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性。</strong></p><pre><code class="javascript">class MyArray extends Array &#123;
&#125;

const a = new MyArray(1, 2, 3);
const b = a.map(x =&gt; x);
const c = a.filter(x =&gt; x &gt; 1);

b instanceof MyArray // true
c instanceof MyArray // true
</code></pre><p>上面代码中，子类<code>MyArray</code>继承了父类<code>Array</code>，<code>a</code>是<code>MyArray</code>的实例，<code>b</code>和<code>c</code>是<code>a</code>的衍生对象。你可能会认为，<code>b</code>和<code>c</code>都是调用数组方法生成的，所以应该是数组（<code>Array</code>的实例），但实际上它们也是<code>MyArray</code>的实例。</p><p><code>Symbol.species</code>属性就是为了解决这个问题而提供的。现在，我们可以为<code>MyArray</code>设置<code>Symbol.species</code>属性。</p><pre><code class="javascript">class MyArray extends Array &#123;
  static get [Symbol.species]() &#123; return Array; &#125;
&#125;
</code></pre><p>上面代码中，由于定义了<code>Symbol.species</code>属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义<code>Symbol.species</code>属性要采用<code>get</code>取值器。默认的<code>Symbol.species</code>属性等同于下面的写法。</p><pre><code class="javascript">static get [Symbol.species]() &#123;
  return this;
&#125;
</code></pre><p>现在，再来看前面的例子。</p><pre><code class="javascript">class MyArray extends Array &#123;
  static get [Symbol.species]() &#123; return Array; &#125;
&#125;

const a = new MyArray();
const b = a.map(x =&gt; x);

b instanceof MyArray // false
b instanceof Array // true
</code></pre><p>上面代码中，<code>a.map(x =&gt; x)</code>生成的衍生对象，就不是<code>MyArray</code>的实例，而直接就是<code>Array</code>的实例。</p><p>再看一个例子。</p><pre><code class="javascript">class T1 extends Promise &#123;
&#125;

class T2 extends Promise &#123;
  static get [Symbol.species]() &#123;
    return Promise;
  &#125;
&#125;

new T1(r =&gt; r()).then(v =&gt; v) instanceof T1 // true
new T2(r =&gt; r()).then(v =&gt; v) instanceof T2 // false
</code></pre><p>上面代码中，<code>T2</code>定义了<code>Symbol.species</code>属性，<code>T1</code>没有。结果就导致了创建衍生对象时（<code>then</code>方法），<code>T1</code>调用的是自身的构造方法，而<code>T2</code>调用的是<code>Promise</code>的构造方法。</p><p>总之，<code>Symbol.species</code>的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p><hr><p><strong>Symbol.match</strong></p><p><strong>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</strong></p><pre><code class="javascript">String.prototype.match(regexp)
// 等同于
regexp[Symbol.match](this)

class MyMatcher &#123;
  [Symbol.match](string) &#123;
    return &#39;hello world&#39;.indexOf(string);
  &#125;
&#125;

&#39;e&#39;.match(new MyMatcher()) // 1
</code></pre><p><strong>Symbol.replace</strong></p><p><strong>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</strong></p><pre><code class="javascript">String.prototype.replace(searchValue, replaceValue)
// 等同于
searchValue[Symbol.replace](this, replaceValue)
</code></pre><p>下面是一个例子。</p><pre><code class="javascript">const x = &#123;&#125;;
x[Symbol.replace] = (...s) =&gt; console.log(s);

&#39;Hello&#39;.replace(x, &#39;World&#39;) // [&quot;Hello&quot;, &quot;World&quot;]
</code></pre><p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code>。</p><hr><p><strong>Symbol.search</strong></p><p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p><pre><code class="javascript">String.prototype.search(regexp)
// 等同于
regexp[Symbol.search](this)

class MySearch &#123;
  constructor(value) &#123;
    this.value = value;
  &#125;
  [Symbol.search](string) &#123;
    return string.indexOf(this.value);
  &#125;
&#125;
&#39;foobar&#39;.search(new MySearch(&#39;foo&#39;)) // 0
</code></pre><hr><p><strong>Symbol.split</strong></p><p><strong>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</strong></p><pre><code class="javascript">String.prototype.split(separator, limit)
// 等同于
separator[Symbol.split](this, limit)
</code></pre><p>下面是一个例子。</p><pre><code class="javascript">class MySplitter &#123;
  constructor(value) &#123;
    this.value = value;
  &#125;
  [Symbol.split](string) &#123;
    let index = string.indexOf(this.value);
    if (index === -1) &#123;
      return string;
    &#125;
    return [
      string.substr(0, index),
      string.substr(index + this.value.length)
    ];
  &#125;
&#125;

&#39;foobar&#39;.split(new MySplitter(&#39;foo&#39;))
// [&#39;&#39;, &#39;bar&#39;]

&#39;foobar&#39;.split(new MySplitter(&#39;bar&#39;))
// [&#39;foo&#39;, &#39;&#39;]

&#39;foobar&#39;.split(new MySplitter(&#39;baz&#39;))
// &#39;foobar&#39;
</code></pre><p>上面方法使用<code>Symbol.split</code>方法，重新定义了字符串对象的<code>split</code>方法的行为，</p><hr><p><strong>Symbol.iterator</strong></p><p><strong>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法。</strong></p><pre><code class="javascript">const myIterable = &#123;&#125;;
myIterable[Symbol.iterator] = function* () &#123;
  yield 1;
  yield 2;
  yield 3;
&#125;;

[...myIterable] // [1, 2, 3]
</code></pre><p>对象进行<code>for...of</code>循环时，会调用<code>Symbol.iterator</code>方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for…of 循环》一章。</p><pre><code class="javascript">class Collection &#123;
  *[Symbol.iterator]() &#123;
    let i = 0;
    while(this[i] !== undefined) &#123;
      yield this[i];
      ++i;
    &#125;
  &#125;
&#125;

let myCollection = new Collection();
myCollection[0] = 1;
myCollection[1] = 2;

for(let value of myCollection) &#123;
  console.log(value);
&#125;
// 1
// 2
</code></pre><hr><p><strong>Symbol.toPrimitive</strong></p><p><strong>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</strong></p><p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p><ul><li>Number：该场合需要转成数值</li><li>String：该场合需要转成字符串</li><li>Default：该场合可以转成数值，也可以转成字符串</li></ul><pre><code class="javascript">let obj = &#123;
  [Symbol.toPrimitive](hint) &#123;
    switch (hint) &#123;
      case &#39;number&#39;:
        return 123;
      case &#39;string&#39;:
        return &#39;str&#39;;
      case &#39;default&#39;:
        return &#39;default&#39;;
      default:
        throw new Error();
     &#125;
   &#125;
&#125;;

2 * obj // 246
3 + obj // &#39;3default&#39;
obj == &#39;default&#39; // true
String(obj) // &#39;str&#39;
</code></pre><hr><p><strong>Symbol.toStringTag</strong></p><p><strong>对象的<code>Symbol.toStringTag</code>属性，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串。</strong></p><pre><code class="javascript">// 例一
(&#123;[Symbol.toStringTag]: &#39;Foo&#39;&#125;.toString())
// &quot;[object Foo]&quot;

// 例二
class Collection &#123;
  get [Symbol.toStringTag]() &#123;
    return &#39;xxx&#39;;
  &#125;
&#125;
let x = new Collection();
Object.prototype.toString.call(x) // &quot;[object xxx]&quot;
</code></pre><p>ES6 新增内置对象的<code>Symbol.toStringTag</code>属性值如下。</p><ul><li><code>JSON[Symbol.toStringTag]</code>：’JSON’</li><li><code>Math[Symbol.toStringTag]</code>：’Math’</li><li>Module 对象<code>M[Symbol.toStringTag]</code>：’Module’</li><li><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>：’ArrayBuffer’</li><li><code>DataView.prototype[Symbol.toStringTag]</code>：’DataView’</li><li><code>Map.prototype[Symbol.toStringTag]</code>：’Map’</li><li><code>Promise.prototype[Symbol.toStringTag]</code>：’Promise’</li><li><code>Set.prototype[Symbol.toStringTag]</code>：’Set’</li><li><code>%TypedArray%.prototype[Symbol.toStringTag]</code>：’Uint8Array’等</li><li><code>WeakMap.prototype[Symbol.toStringTag]</code>：’WeakMap’</li><li><code>WeakSet.prototype[Symbol.toStringTag]</code>：’WeakSet’</li><li><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>：’Map Iterator’</li><li><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>：’Set Iterator’</li><li><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>：’String Iterator’</li><li><code>Symbol.prototype[Symbol.toStringTag]</code>：’Symbol’</li><li><code>Generator.prototype[Symbol.toStringTag]</code>：’Generator’</li><li><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>：’GeneratorFunction’</li></ul><hr><p><strong>Symbol.unscopables</strong></p><p><strong>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</strong></p><pre><code class="javascript">Array.prototype[Symbol.unscopables]
// &#123;
//   copyWithin: true,
//   entries: true,
//   fill: true,
//   find: true,
//   findIndex: true,
//   includes: true,
//   keys: true
// &#125;

Object.keys(Array.prototype[Symbol.unscopables])
// [&#39;copyWithin&#39;, &#39;entries&#39;, &#39;fill&#39;, &#39;find&#39;, &#39;findIndex&#39;, &#39;includes&#39;, &#39;keys&#39;]
</code></pre><p>上面代码说明，数组有 7 个属性，会被<code>with</code>命令排除。</p><pre><code class="javascript">// 没有 unscopables 时
class MyClass &#123;
  foo() &#123; return 1; &#125;
&#125;

var foo = function () &#123; return 2; &#125;;

with (MyClass.prototype) &#123;
  foo(); // 1
&#125;

// 有 unscopables 时
class MyClass &#123;
  foo() &#123; return 1; &#125;
  get [Symbol.unscopables]() &#123;
    return &#123; foo: true &#125;;
  &#125;
&#125;

var foo = function () &#123; return 2; &#125;;

with (MyClass.prototype) &#123;
  foo(); // 2
&#125;
</code></pre><p>上面代码通过指定<code>Symbol.unscopables</code>属性，使得<code>with</code>语法块不会在当前作用域寻找<code>foo</code>属性，即<code>foo</code>将指向外层作用域的变量。</p><h3 id="13、-Set-和-Map-数据结构"><a href="#13、-Set-和-Map-数据结构" class="headerlink" title="13、 Set 和 Map 数据结构"></a>13、 Set 和 Map 数据结构</h3><hr><h4 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h4><p><strong>基本用法</strong></p><p>ES6 提供了新的数据结构 Set。<strong>它类似于数组，但是成员的值都是唯一的，没有<code>重复</code>的值。</strong></p><p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p><pre><code class="javascript">const s = new Set();

[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));

for (let i of s) &#123;
  console.log(i);
&#125;
// 2 3 5 4
</code></pre><p>上面代码通过<code>add()</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p><p><strong><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</strong></p><pre><code class="javascript">// 例一
const set = new Set([1, 2, 3, 4, 4]);
[...set]
// [1, 2, 3, 4]

// 例二
const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 5

// 例三
const set = new Set(document.querySelectorAll(&#39;div&#39;));
set.size // 56

// 类似于
const set = new Set();
document
 .querySelectorAll(&#39;div&#39;)
 .forEach(div =&gt; set.add(div));
set.size // 56
</code></pre><p>上面代码中，例一和例二都是<code>Set</code>函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p><p>上面代码也展示了<strong>一种去除数组重复成员的方法。</strong></p><pre><code class="javascript">// 去除数组的重复成员
[...new Set(array)]
</code></pre><p>上面的方法也可以用于，<strong>去除字符串里面的重复字符。</strong></p><pre><code class="javascript">[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)
// &quot;abc&quot;
</code></pre><p><strong>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。</strong>Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），<strong>主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</strong></p><pre><code class="javascript">let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // Set &#123;NaN&#125;
</code></pre><p>上面代码向 Set 实例添加了两次<code>NaN</code>，但是只会加入一个。这表明，在 Set 内部，两个<code>NaN</code>是相等的。</p><p>另外，<strong>两个对象总是不相等的。</strong></p><pre><code class="javascript">let set = new Set();

set.add(&#123;&#125;);
set.size // 1

set.add(&#123;&#125;);
set.size // 2
</code></pre><p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p><hr><p><strong>Set 实例的属性和方法</strong></p><p>Set 结构的实例有以下属性。</p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li></ul><p>Set 实例的方法分为两大类：<strong>操作方法（用于操作数据）和遍历方法（用于遍历成员）</strong>。下面先介绍四个操作方法。</p><ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><p>上面这些属性和方法的实例如下。</p><pre><code class="javascript">s.add(1).add(2).add(2);
// 注意2被加入了两次

s.size // 2

s.has(1) // true
s.has(2) // true
s.has(3) // false

s.delete(2);
s.has(2) // false
</code></pre><p>下面是一个对比，看看在判断是否包括一个键上面，<code>Object</code>结构和<code>Set</code>结构的写法不同。</p><pre><code class="javascript">// 对象的写法
const properties = &#123;
  &#39;width&#39;: 1,
  &#39;height&#39;: 1
&#125;;

if (properties[someName]) &#123;
  // do something
&#125;

// Set的写法
const properties = new Set();

properties.add(&#39;width&#39;);
properties.add(&#39;height&#39;);

if (properties.has(someName)) &#123;
  // do something
&#125;
</code></pre><p><strong><code>Array.from</code>方法可以将 Set 结构转为数组。</strong></p><pre><code class="javascript">const items = new Set([1, 2, 3, 4, 5]);
const array = Array.from(items);
</code></pre><p>这就提供了<strong>去除数组重复成员的另一种方法。</strong></p><pre><code class="javascript">function dedupe(array) &#123;
  return Array.from(new Set(array));
&#125;

dedupe([1, 1, 2, 3]) // [1, 2, 3]
</code></pre><hr><p><strong>遍历操作</strong></p><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul><p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p><p><strong>（1）<code>keys()</code>，<code>values()</code>，<code>entries()</code></strong></p><p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），<strong>所以<code>keys</code>方法和<code>values</code>方法的行为完全一致</strong>。</p><pre><code class="javascript">let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);

for (let item of set.keys()) &#123;
  console.log(item);
&#125;
// red
// green
// blue

for (let item of set.values()) &#123;
  console.log(item);
&#125;
// red
// green
// blue

for (let item of set.entries()) &#123;
  console.log(item);
&#125;
// [&quot;red&quot;, &quot;red&quot;]
// [&quot;green&quot;, &quot;green&quot;]
// [&quot;blue&quot;, &quot;blue&quot;]
</code></pre><p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p><p><strong>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</strong></p><pre><code class="javascript">Set.prototype[Symbol.iterator] === Set.prototype.values
// true
</code></pre><p>这意味着，<strong>可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 Set。</strong></p><pre><code class="javascript">let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);

for (let x of set) &#123;
  console.log(x);
&#125;
// red
// green
// blue
</code></pre><p><strong>（2）<code>forEach()</code></strong></p><p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p><pre><code class="javascript">let set = new Set([1, 4, 9]);
set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))
// 1 : 1
// 4 : 4
// 9 : 9
</code></pre><p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p><p>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。</p><p><strong>（3）遍历的应用</strong></p><p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 Set 结构。</p><pre><code class="javascript">let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]);
let arr = [...set];
// [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]
</code></pre><p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p><pre><code class="javascript">let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)];
// [3, 5, 2]
</code></pre><p>而且，数组的<code>map</code>和<code>filter</code>方法也可以间接用于 Set 了。</p><pre><code class="javascript">let set = new Set([1, 2, 3]);
set = new Set([...set].map(x =&gt; x * 2));
// 返回Set结构：&#123;2, 4, 6&#125;

let set = new Set([1, 2, 3, 4, 5]);
set = new Set([...set].filter(x =&gt; (x % 2) == 0));
// 返回Set结构：&#123;2, 4&#125;
</code></pre><p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p><pre><code class="javascript">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set &#123;1, 2, 3, 4&#125;

// 交集
let intersect = new Set([...a].filter(x =&gt; b.has(x)));
// set &#123;2, 3&#125;

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x =&gt; !b.has(x)));
// Set &#123;1&#125;
</code></pre><p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用<code>Array.from</code>方法。</p><pre><code class="javascript">// 方法一
let set = new Set([1, 2, 3]);
set = new Set([...set].map(val =&gt; val * 2));
// set的值是2, 4, 6

// 方法二
let set = new Set([1, 2, 3]);
set = new Set(Array.from(set, val =&gt; val * 2));
// set的值是2, 4, 6
</code></pre><p>上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。</p><hr><h4 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2. WeakSet"></a>2. WeakSet</h4><p><strong>含义</strong></p><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><p><strong>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</strong></p><pre><code class="javascript">const ws = new WeakSet();
ws.add(1)
// TypeError: Invalid value used in weak set
ws.add(Symbol())
// TypeError: invalid value used in weak set
</code></pre><p>上面代码试图向 WeakSet 添加一个数值和<code>Symbol</code>值，结果报错，因为 WeakSet 只能放置对象。</p><p>其次，<strong>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用</strong>，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p><p>这是因为垃圾回收机制根据对象的可达性（reachability）来判断回收，如果对象还能被访问到，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。<strong>WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题</strong>。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p><p>由于上面这个特点，<strong>WeakSet 的成员是不适合引用的</strong>，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 <strong>ES6 规定 WeakSet 不可遍历</strong>。</p><p>这些特点同样适用于本章后面要介绍的 WeakMap 结构。</p><p><strong>语法</strong></p><p>WeakSet 是一个构造函数，可以使用<code>new</code>命令，创建 WeakSet 数据结构。</p><pre><code class="javascript">const ws = new WeakSet();
</code></pre><p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，<strong>任何具有 Iterable 接口的对象</strong>，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p><pre><code class="javascript">const a = [[1, 2], [3, 4]];
const ws = new WeakSet(a);
// WeakSet &#123;[1, 2], [3, 4]&#125;
</code></pre><p>上面代码中，<code>a</code>是一个数组，它有两个成员，也都是数组。将<code>a</code>作为 WeakSet 构造函数的参数，<code>a</code>的成员会自动成为 WeakSet 的成员。</p><p>注意，是<code>a</code>数组的成员成为 WeakSet 的成员，而不是<code>a</code>数组本身。这意味着，数组的成员只能是对象。</p><pre><code class="javascript">const b = [3, 4];
const ws = new WeakSet(b);
// Uncaught TypeError: Invalid value used in weak set(…)
</code></pre><p>上面代码中，数组<code>b</code>的成员不是对象，加入 WeakSet 就会报错。</p><p>WeakSet 结构有以下三个方法。</p><ul><li>**WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。</li><li>**WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。</li><li>**WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li></ul><p>下面是一个例子。</p><pre><code class="javascript">const ws = new WeakSet();
const obj = &#123;&#125;;
const foo = &#123;&#125;;

ws.add(window);
ws.add(obj);

ws.has(window); // true
ws.has(foo);    // false

ws.delete(window);
ws.has(window);    // false
</code></pre><p><strong>WeakSet 没有<code>size</code>属性，没有办法遍历它的成员。</strong></p><pre><code class="javascript">ws.size // undefined
ws.forEach // undefined

ws.forEach(function(item)&#123; console.log(&#39;WeakSet has &#39; + item)&#125;)
// TypeError: undefined is not a function
</code></pre><p>上面代码试图获取<code>size</code>和<code>forEach</code>属性，结果都不能成功。</p><p><strong>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失</strong>，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p><p>下面是 WeakSet 的另一个例子。</p><pre><code class="javascript">const foos = new WeakSet()
class Foo &#123;
  constructor() &#123;
    foos.add(this)
  &#125;
  method () &#123;
    if (!foos.has(this)) &#123;
      throw new TypeError(&#39;Foo.prototype.method 只能在Foo的实例上调用！&#39;);
    &#125;
  &#125;
&#125;
</code></pre><p>上面代码保证了<code>Foo</code>的实例方法，只能在<code>Foo</code>的实例上调用。这里使用 WeakSet 的好处是，<code>foos</code>对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑<code>foos</code>，也不会出现内存泄漏。</p><hr><h4 id="3-Map"><a href="#3-Map" class="headerlink" title="3. Map"></a>3. Map</h4><p><strong>含义和基本用法</strong></p><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><pre><code class="javascript">const data = &#123;&#125;;
const element = document.getElementById(&#39;myDiv&#39;);

data[element] = &#39;metadata&#39;;
data[&#39;[object HTMLDivElement]&#39;] // &quot;metadata&quot;
</code></pre><p>上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p><p>为了解决这个问题，<strong>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键</strong>。也就是说，Object 结构提供了“字符串—值”的对应，<strong>Map 结构提供了“值—值”的对应</strong>，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><pre><code class="javascript">const m = new Map();
const o = &#123;p: &#39;Hello World&#39;&#125;;

m.set(o, &#39;content&#39;)
m.get(o) // &quot;content&quot;

m.has(o) // true
m.delete(o) // true
m.has(o) // false
</code></pre><p>上面代码使用 Map 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p><p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p><pre><code class="javascript">const map = new Map([
  [&#39;name&#39;, &#39;张三&#39;],
  [&#39;title&#39;, &#39;Author&#39;]
]);

map.size // 2
map.has(&#39;name&#39;) // true
map.get(&#39;name&#39;) // &quot;张三&quot;
map.has(&#39;title&#39;) // true
map.get(&#39;title&#39;) // &quot;Author&quot;
</code></pre><p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>title</code>。</p><p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</p><pre><code class="javascript">const items = [
  [&#39;name&#39;, &#39;张三&#39;],
  [&#39;title&#39;, &#39;Author&#39;]
];

const map = new Map();

items.forEach(
  ([key, value]) =&gt; map.set(key, value)
);
</code></pre><p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数。这就是说，**<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。**</p><pre><code class="javascript">const set = new Set([
  [&#39;foo&#39;, 1],
  [&#39;bar&#39;, 2]
]);
const m1 = new Map(set);
m1.get(&#39;foo&#39;) // 1

const m2 = new Map([[&#39;baz&#39;, 3]]);
const m3 = new Map(m2);
m3.get(&#39;baz&#39;) // 3
</code></pre><p>上面代码中，我们分别使用 Set 对象和 Map 对象，当作<code>Map</code>构造函数的参数，结果都生成了新的 Map 对象。</p><p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p><pre><code class="javascript">const map = new Map();

map
.set(1, &#39;aaa&#39;)
.set(1, &#39;bbb&#39;);

map.get(1) // &quot;bbb&quot;
</code></pre><p>上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值。</p><p>如果读取一个未知的键，则返回<code>undefined</code>。</p><pre><code class="javascript">new Map().get(&#39;asfddfsasadf&#39;)
// undefined
</code></pre><p>注意，<strong>只有对同一个对象的引用，Map 结构才将其视为同一个键</strong>。这一点要非常小心。</p><pre><code class="javascript">const map = new Map();

map.set([&#39;a&#39;], 555);
map.get([&#39;a&#39;]) // undefined
</code></pre><p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p><p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p><pre><code class="javascript">const map = new Map();

const k1 = [&#39;a&#39;];
const k2 = [&#39;a&#39;];

map
.set(k1, 111)
.set(k2, 222);

map.get(k1) // 111
map.get(k2) // 222
</code></pre><p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在 Map 结构中被视为两个键。</p><p>由上可知，<strong>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。</strong>这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p><p><strong>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键</strong>，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。<strong>虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</strong></p><pre><code class="javascript">let map = new Map();

map.set(-0, 123);
map.get(+0) // 123

map.set(true, 1);
map.set(&#39;true&#39;, 2);
map.get(true) // 1

map.set(undefined, 3);
map.set(null, 4);
map.get(undefined) // 3

map.set(NaN, 123);
map.get(NaN) // 123
</code></pre><hr><p><strong>实例的属性和操作方法</strong></p><p>Map 结构的实例有以下属性和操作方法。</p><p><strong>（1）size 属性</strong></p><p><code>size</code>属性返回 Map 结构的成员总数。</p><pre><code class="javascript">const map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);

map.size // 2
</code></pre><p><strong>（2）Map.prototype.set(key, value)</strong></p><p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p><pre><code class="javascript">const m = new Map();

m.set(&#39;edition&#39;, 6)        // 键是字符串
m.set(262, &#39;standard&#39;)     // 键是数值
m.set(undefined, &#39;nah&#39;)    // 键是 undefined
</code></pre><p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p><pre><code class="javascript">let map = new Map()
  .set(1, &#39;a&#39;)
  .set(2, &#39;b&#39;)
  .set(3, &#39;c&#39;);
</code></pre><p><strong>（3）Map.prototype.get(key)</strong></p><p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p><pre><code class="javascript">const m = new Map();

const hello = function() &#123;console.log(&#39;hello&#39;);&#125;;
m.set(hello, &#39;Hello ES6!&#39;) // 键是函数

m.get(hello)  // Hello ES6!
</code></pre><p><strong>（4）Map.prototype.has(key)</strong></p><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p><pre><code class="javascript">const m = new Map();

m.set(&#39;edition&#39;, 6);
m.set(262, &#39;standard&#39;);
m.set(undefined, &#39;nah&#39;);

m.has(&#39;edition&#39;)     // true
m.has(&#39;years&#39;)       // false
m.has(262)           // true
m.has(undefined)     // true
</code></pre><p><strong>（5）Map.prototype.delete(key)</strong></p><p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p><pre><code class="javascript">const m = new Map();
m.set(undefined, &#39;nah&#39;);
m.has(undefined)     // true

m.delete(undefined)
m.has(undefined)       // false
</code></pre><p><strong>（6）Map.prototype.clear()</strong></p><p><code>clear</code>方法清除所有成员，没有返回值。</p><pre><code class="javascript">let map = new Map();
map.set(&#39;foo&#39;, true);
map.set(&#39;bar&#39;, false);

map.size // 2
map.clear()
map.size // 0
</code></pre><hr><p><strong>遍历方法</strong></p><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li></ul><p><strong>需要特别注意的是，Map 的遍历顺序就是插入顺序。</strong></p><pre><code class="javascript">const map = new Map([
  [&#39;F&#39;, &#39;no&#39;],
  [&#39;T&#39;,  &#39;yes&#39;],
]);

for (let key of map.keys()) &#123;
  console.log(key);
&#125;
// &quot;F&quot;
// &quot;T&quot;

for (let value of map.values()) &#123;
  console.log(value);
&#125;
// &quot;no&quot;
// &quot;yes&quot;

for (let item of map.entries()) &#123;
  console.log(item[0], item[1]);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

// 或者
for (let [key, value] of map.entries()) &#123;
  console.log(key, value);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;

// 等同于使用map.entries()
for (let [key, value] of map) &#123;
  console.log(key, value);
&#125;
// &quot;F&quot; &quot;no&quot;
// &quot;T&quot; &quot;yes&quot;
</code></pre><p>上面代码最后的那个例子，<strong>表示 Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</strong></p><pre><code class="javascript">map[Symbol.iterator] === map.entries
// true
</code></pre><p><strong>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</strong></p><pre><code class="javascript">const map = new Map([
  [1, &#39;one&#39;],
  [2, &#39;two&#39;],
  [3, &#39;three&#39;],
]);

[...map.keys()]
// [1, 2, 3]

[...map.values()]
// [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]

[...map.entries()]
// [[1,&#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;]]

[...map]
// [[1,&#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;]]
</code></pre><p><strong>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 Map 的遍历和过滤（Map 本身没有<code>map</code>和<code>filter</code>方法）。</strong></p><pre><code class="javascript">const map0 = new Map()
  .set(1, &#39;a&#39;)
  .set(2, &#39;b&#39;)
  .set(3, &#39;c&#39;);

const map1 = new Map(
  [...map0].filter(([k, v]) =&gt; k &lt; 3)
);
// 产生 Map 结构 &#123;1 =&gt; &#39;a&#39;, 2 =&gt; &#39;b&#39;&#125;

const map2 = new Map(
  [...map0].map(([k, v]) =&gt; [k * 2, &#39;_&#39; + v])
    );
// 产生 Map 结构 &#123;2 =&gt; &#39;_a&#39;, 4 =&gt; &#39;_b&#39;, 6 =&gt; &#39;_c&#39;&#125;
</code></pre><p>此外，Map 还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p><pre><code class="javascript">map.forEach(function(value, key, map) &#123;
  console.log(&quot;Key: %s, Value: %s&quot;, key, value);
&#125;);
</code></pre><p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p><pre><code class="javascript">const reporter = &#123;
  report: function(key, value) &#123;
    console.log(&quot;Key: %s, Value: %s&quot;, key, value);
  &#125;
&#125;;

map.forEach(function(value, key, map) &#123;
  this.report(key, value);
&#125;, reporter);
</code></pre><p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p><hr><p><strong>与其他数据结构的互相转换</strong></p><p><strong>（1）Map 转为数组</strong></p><p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）。</p><pre><code class="javascript">const myMap = new Map()
  .set(true, 7)
  .set(&#123;foo: 3&#125;, [&#39;abc&#39;]);
[...myMap]
// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#39;abc&#39; ] ] ]
</code></pre><p><strong>（2）数组 转为 Map</strong></p><p>将数组传入 Map 构造函数，就可以转为 Map。</p><pre><code class="javascript">new Map([
  [true, 7],
  [&#123;foo: 3&#125;, [&#39;abc&#39;]]
])
// Map &#123;
//   true =&gt; 7,
//   Object &#123;foo: 3&#125; =&gt; [&#39;abc&#39;]
// &#125;
</code></pre><p><strong>（3）Map 转为对象</strong></p><p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p><pre><code class="javascript">function strMapToObj(strMap) &#123;
  let obj = Object.create(null);
  for (let [k,v] of strMap) &#123;
    obj[k] = v;
  &#125;
  return obj;
&#125;

const myMap = new Map()
  .set(&#39;yes&#39;, true)
  .set(&#39;no&#39;, false);
strMapToObj(myMap)
// &#123; yes: true, no: false &#125;
</code></pre><p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p><p><strong>（4）对象转为 Map</strong></p><p>对象转为 Map 可以通过<code>Object.entries()</code>。</p><pre><code class="javascript">let obj = &#123;&quot;a&quot;:1, &quot;b&quot;:2&#125;;
let map = new Map(Object.entries(obj));
</code></pre><p>此外，也可以自己实现一个转换函数。</p><pre><code class="javascript">function objToStrMap(obj) &#123;
  let strMap = new Map();
  for (let k of Object.keys(obj)) &#123;
    strMap.set(k, obj[k]);
  &#125;
  return strMap;
&#125;

objToStrMap(&#123;yes: true, no: false&#125;)
// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;
</code></pre><p><strong>（5）Map 转为 JSON</strong></p><p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p><pre><code class="javascript">function strMapToJson(strMap) &#123;
  return JSON.stringify(strMapToObj(strMap));
&#125;

let myMap = new Map().set(&#39;yes&#39;, true).set(&#39;no&#39;, false);
strMapToJson(myMap)
// &#39;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#39;
</code></pre><p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p><pre><code class="javascript">function mapToArrayJson(map) &#123;
  return JSON.stringify([...map]);
&#125;

let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&#39;abc&#39;]);
mapToArrayJson(myMap)
// &#39;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#39;
</code></pre><p><strong>（6）JSON 转为 Map</strong></p><p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p><pre><code class="javascript">function jsonToStrMap(jsonStr) &#123;
  return objToStrMap(JSON.parse(jsonStr));
&#125;

jsonToStrMap(&#39;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#39;)
// Map &#123;&#39;yes&#39; =&gt; true, &#39;no&#39; =&gt; false&#125;
</code></pre><p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p><pre><code class="javascript">function jsonToMap(jsonStr) &#123;
  return new Map(JSON.parse(jsonStr));
&#125;

jsonToMap(&#39;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#39;)
// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#39;abc&#39;]&#125;
</code></pre><hr><h4 id="4-WeakMap"><a href="#4-WeakMap" class="headerlink" title="4. WeakMap"></a>4. WeakMap</h4><p><strong>含义</strong></p><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p><pre><code class="javascript">// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap();
const key = &#123;foo: 1&#125;;
wm1.set(key, 2);
wm1.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3];
const k2 = [4, 5, 6];
const wm2 = new WeakMap([[k1, &#39;foo&#39;], [k2, &#39;bar&#39;]]);
wm2.get(k2) // &quot;bar&quot;
</code></pre><p><code>WeakMap</code>与<code>Map</code>的区别有两点。</p><p><strong>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</strong></p><pre><code class="javascript">const map = new WeakMap();
map.set(1, 2)
// TypeError: 1 is not an object!
map.set(Symbol(), 2)
// TypeError: Invalid value used as weak map key
map.set(null, 2)
// TypeError: Invalid value used as weak map key
</code></pre><p>上面代码中，如果将数值<code>1</code>和<code>Symbol</code>值作为 WeakMap 的键名，都会报错。</p><p><strong>其次，<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</strong></p><p><code>WeakMap</code>的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。</p><pre><code class="javascript">const e1 = document.getElementById(&#39;foo&#39;);
const e2 = document.getElementById(&#39;bar&#39;);
const arr = [
  [e1, &#39;foo 元素&#39;],
  [e2, &#39;bar 元素&#39;],
];
</code></pre><p>上面代码中，<code>e1</code>和<code>e2</code>是两个对象，我们通过<code>arr</code>数组对这两个对象添加一些文字说明。这就形成了<code>arr</code>对<code>e1</code>和<code>e2</code>的引用。</p><p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放<code>e1</code>和<code>e2</code>占用的内存。</p><pre><code class="javascript">// 不需要 e1 和 e2 的时候
// 必须手动删除引用
arr [0] = null;
arr [1] = null;
</code></pre><p>上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。</p><p>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，<strong>一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</strong></p><p><strong>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</strong></p><pre><code class="javascript">const wm = new WeakMap();

const element = document.getElementById(&#39;example&#39;);

wm.set(element, &#39;some information&#39;);
wm.get(element) // &quot;some information&quot;
</code></pre><p>上面代码中，先新建一个 WeakMap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p><p>也就是说，上面的 DOM 节点对象除了 WeakMap 的弱引用外，其他位置对该对象的引用一旦消除，该对象占用的内存就会被垃圾回收机制释放。WeakMap 保存的这个键值对，也会自动消失。</p><p><strong>总之，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</strong></p><p><strong>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</strong></p><pre><code class="javascript">const wm = new WeakMap();
let key = &#123;&#125;;
let obj = &#123;foo: 1&#125;;

wm.set(key, obj);
obj = null;
wm.get(key)
// Object &#123;foo: 1&#125;
</code></pre><p>上面代码中，键值<code>obj</code>是正常引用。所以，即使在 WeakMap 外部消除了<code>obj</code>的引用，WeakMap 内部的引用依然存在。</p><p><strong>WeakMap 的语法</strong></p><p>WeakMap 与 Map 在 API 上的区别主要是两个，<strong>一是没有遍历操作（即没有<code>keys()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性。</strong>因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。<strong>二是无法清空，即不支持<code>clear</code>方法。</strong>因此，**<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。**</p><pre><code class="javascript">const wm = new WeakMap();

// size、forEach、clear 方法都不存在
wm.size // undefined
wm.forEach // undefined
wm.clear // undefined
</code></pre><p><strong>WeakMap 的示例</strong></p><p>WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。</p><p>贺师俊老师<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1YW55Zi9lczZ0dXRvcmlhbC9pc3N1ZXMvMzYyI2lzc3VlY29tbWVudC0yOTIxMDkxMDQ=">提示</span>，如果引用所指向的值占用特别多的内存，就可以通过 Node 的<code>process.memoryUsage</code>方法看出来。根据这个思路，网友<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1YW55Zi9lczZ0dXRvcmlhbC9pc3N1ZXMvMzYyI2lzc3VlY29tbWVudC0yOTI0NTE5MjU=">vtxf</span>补充了下面的例子。</p><p>首先，打开 Node 命令行。</p><pre><code class="bash">$ node --expose-gc
</code></pre><p>上面代码中，<code>--expose-gc</code>参数表示允许手动执行垃圾回收机制。</p><p>然后，执行下面的代码。</p><pre><code class="javascript">// 手动执行一次垃圾回收，保证获取的内存使用状态准确
&gt; global.gc();
undefined

// 查看内存占用的初始状态，heapUsed 为 4M 左右
&gt; process.memoryUsage();
&#123; rss: 21106688,
  heapTotal: 7376896,
  heapUsed: 4153936,
  external: 9059 &#125;

&gt; let wm = new WeakMap();
undefined

// 新建一个变量 key，指向一个 5*1024*1024 的数组
&gt; let key = new Array(5 * 1024 * 1024);
undefined

// 设置 WeakMap 实例的键名，也指向 key 数组
// 这时，key 数组实际被引用了两次，
// 变量 key 引用一次，WeakMap 的键名引用了第二次
// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1
&gt; wm.set(key, 1);
WeakMap &#123;&#125;

&gt; global.gc();
undefined

// 这时内存占用 heapUsed 增加到 45M 了
&gt; process.memoryUsage();
&#123; rss: 67538944,
  heapTotal: 7376896,
  heapUsed: 45782816,
  external: 8945 &#125;

// 清除变量 key 对数组的引用，
// 但没有手动清除 WeakMap 实例的键名对数组的引用
&gt; key = null;
null

// 再次执行垃圾回收
&gt; global.gc();
undefined

// 内存占用 heapUsed 变回 4M 左右，
// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收
&gt; process.memoryUsage();
&#123; rss: 20639744,
  heapTotal: 8425472,
  heapUsed: 3979792,
  external: 8956 &#125;
</code></pre><p>上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。</p><p>Chrome 浏览器的 Dev Tools 的 Memory 面板，有一个垃圾桶的按钮，可以强制垃圾回收（garbage collect）。这个按钮也能用来观察 WeakMap 里面的引用是否消失。</p><p><strong>WeakMap 的用途</strong></p><p>前文说过，<strong>WeakMap 应用的典型场合就是 DOM 节点作为键名</strong>。下面是一个例子。</p><pre><code class="javascript">let myWeakmap = new WeakMap();

myWeakmap.set(
  document.getElementById(&#39;logo&#39;),
  &#123;timesClicked: 0&#125;)
;

document.getElementById(&#39;logo&#39;).addEventListener(&#39;click&#39;, function() &#123;
  let logoData = myWeakmap.get(document.getElementById(&#39;logo&#39;));
  logoData.timesClicked++;
&#125;, false);
</code></pre><p>上面代码中，<code>document.getElementById(&#39;logo&#39;)</code>是一个 DOM 节点，每当发生<code>click</code>事件，就更新一下状态。<strong>我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险</strong>。</p><p><strong>WeakMap 的另一个用处是部署私有属性。</strong></p><pre><code class="javascript">const _counter = new WeakMap();
const _action = new WeakMap();

class Countdown &#123;
  constructor(counter, action) &#123;
    _counter.set(this, counter);
    _action.set(this, action);
  &#125;
  dec() &#123;
    let counter = _counter.get(this);
    if (counter &lt; 1) return;
    counter--;
    _counter.set(this, counter);
    if (counter === 0) &#123;
      _action.get(this)();
    &#125;
  &#125;
&#125;

const c = new Countdown(2, () =&gt; console.log(&#39;DONE&#39;));

c.dec()
c.dec()
// DONE
</code></pre><p>上面代码中，<code>Countdown</code>类的两个内部属性<code>_counter</code>和<code>_action</code>，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p><hr><h4 id="5-WeakRef"><a href="#5-WeakRef" class="headerlink" title="5. WeakRef"></a>5. WeakRef</h4><p>WeakSet 和 WeakMap 是基于弱引用的数据结构，**<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtd2Vha3JlZnM=">ES2021</span> 更进一步，提供了 WeakRef 对象，用于直接创建对象的弱引用。**</p><pre><code class="javascript">let target = &#123;&#125;;
let wr = new WeakRef(target);
</code></pre><p>上面示例中，<code>target</code>是原始对象，构造函数<code>WeakRef()</code>创建了一个基于<code>target</code>的新对象<code>wr</code>。这里，<code>wr</code>就是一个 WeakRef 的实例，属于对<code>target</code>的弱引用，垃圾回收机制不会计入这个引用，也就是说，<code>wr</code>的引用不会妨碍原始对象<code>target</code>被垃圾回收机制清除。</p><p><strong>WeakRef 实例对象有一个<code>deref()</code>方法，如果原始对象存在，该方法返回原始对象；如果原始对象已经被垃圾回收机制清除，该方法返回<code>undefined</code>。</strong></p><pre><code class="javascript">let target = &#123;&#125;;
let wr = new WeakRef(target);

let obj = wr.deref();
if (obj) &#123; // target 未被垃圾回收机制清除
  // ...
&#125;
</code></pre><p>上面示例中，<code>deref()</code>方法可以判断原始对象是否已被清除。</p><p>弱引用对象的一大用处，就是作为缓存，未被清除时可以从缓存取值，一旦清除缓存就自动失效。</p><pre><code class="javascript">function makeWeakCached(f) &#123;
  const cache = new Map();
  return key =&gt; &#123;
    const ref = cache.get(key);
    if (ref) &#123;
      const cached = ref.deref();
      if (cached !== undefined) return cached;
    &#125;

    const fresh = f(key);
    cache.set(key, new WeakRef(fresh));
    return fresh;
  &#125;;
&#125;

const getImageCached = makeWeakCached(getImage);
</code></pre><p>上面示例中，<code>makeWeakCached()</code>用于建立一个缓存，缓存里面保存对原始文件的弱引用。</p><p>注意，标准规定，一旦使用<code>WeakRef()</code>创建了原始对象的弱引用，那么在本轮事件循环（event loop），原始对象肯定不会被清除，只会在后面的事件循环才会被清除。</p><hr><h4 id="6-FinalizationRegistry"><a href="#6-FinalizationRegistry" class="headerlink" title="6. FinalizationRegistry"></a>6. FinalizationRegistry</h4><p><strong><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtd2Vha3JlZnMjZmluYWxpemVycw==">ES2021</span> 引入了清理器注册表功能 FinalizationRegistry，用来指定目标对象被垃圾回收机制清除以后，所要执行的回调函数。</strong></p><p>首先，新建一个注册表实例。</p><pre><code class="javascript">const registry = new FinalizationRegistry(heldValue =&gt; &#123;
  // ....
&#125;);
</code></pre><p>上面代码中，<code>FinalizationRegistry()</code>是系统提供的构造函数，返回一个清理器注册表实例，里面登记了所要执行的回调函数。回调函数作为<code>FinalizationRegistry()</code>的参数传入，它本身有一个参数<code>heldValue</code>。</p><p>然后，注册表实例的<code>register()</code>方法，用来注册所要观察的目标对象。</p><pre><code class="javascript">registry.register(theObject, &quot;some value&quot;);
</code></pre><p>上面示例中，<code>theObject</code>就是所要观察的目标对象，一旦该对象被垃圾回收机制清除，注册表就会在清除完成后，调用早前注册的回调函数，并将<code>some value</code>作为参数（前面的<code>heldValue</code>）传入回调函数。</p><p>注意，注册表不对目标对象<code>theObject</code>构成强引用，属于弱引用。因为强引用的话，原始对象就不会被垃圾回收机制清除，这就失去使用注册表的意义了。</p><p>回调函数的参数<code>heldValue</code>可以是任意类型的值，字符串、数值、布尔值、对象，甚至可以是<code>undefined</code>。</p><p><strong>最后，如果以后还想取消已经注册的回调函数，则要向<code>register()</code>传入第三个参数，作为标记值。这个标记值必须是对象，一般都用原始对象。接着，再使用注册表实例对象的<code>unregister()</code>方法取消注册。</strong></p><pre><code class="javascript">registry.register(theObject, &quot;some value&quot;, theObject);
// ...其他操作...
registry.unregister(theObject);
</code></pre><p>上面代码中，<code>register()</code>方法的第三个参数就是标记值<code>theObject</code>。取消回调函数时，要使用<code>unregister()</code>方法，并将标记值作为该方法的参数。这里<code>register()</code>方法对第三个参数的引用，也属于弱引用。如果没有这个参数，则回调函数无法取消。</p><p>由于回调函数被调用以后，就不再存在于注册表之中了，所以执行<code>unregister()</code>应该是在回调函数还没被调用之前。</p><p>下面使用<code>FinalizationRegistry</code>，对前一节的缓存函数进行增强。</p><pre><code class="javascript">function makeWeakCached(f) &#123;
  const cache = new Map();
  const cleanup = new FinalizationRegistry(key =&gt; &#123;
    const ref = cache.get(key);
    if (ref &amp;&amp; !ref.deref()) cache.delete(key);
  &#125;);

  return key =&gt; &#123;
    const ref = cache.get(key);
    if (ref) &#123;
      const cached = ref.deref();
      if (cached !== undefined) return cached;
    &#125;

    const fresh = f(key);
    cache.set(key, new WeakRef(fresh));
    cleanup.register(fresh, key);
    return fresh;
  &#125;;
&#125;

const getImageCached = makeWeakCached(getImage);
</code></pre><p>上面示例与前一节的例子相比，就是增加一个清理器注册表，一旦缓存的原始对象被垃圾回收机制清除，会自动执行一个回调函数。该回调函数会清除缓存里面已经失效的键。</p><p>下面是另一个例子。</p><pre><code class="javascript">class Thingy &#123;
  #file;
  #cleanup = file =&gt; &#123;
    console.error(
      `The \`release\` method was never called for the \`Thingy\` for the file &quot;$&#123;file.name&#125;&quot;`
    );
  &#125;;
  #registry = new FinalizationRegistry(this.#cleanup);

  constructor(filename) &#123;
    this.#file = File.open(filename);
    this.#registry.register(this, this.#file, this.#file);
  &#125;

  release() &#123;
    if (this.#file) &#123;
      this.#registry.unregister(this.#file);
      File.close(this.#file);
      this.#file = null;
    &#125;
  &#125;
&#125;
</code></pre><p>上面示例中，如果由于某种原因，<code>Thingy</code>类的实例对象没有调用<code>release()</code>方法，就被垃圾回收机制清除了，那么清理器就会调用回调函数<code>#cleanup()</code>，输出一条错误信息。</p><p><strong>由于无法知道清理器何时会执行，所以最好避免使用它</strong>。另外，如果浏览器窗口关闭或者进程意外退出，清理器则不会运行。</p><div class="tags"><a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"><i class="ic i-tag"></i> 前端</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-03-27 18:33:50" itemprop="dateModified" datetime="2022-03-27T18:33:50+08:00">2022-03-27</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="sparkle 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="sparkle 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="sparkle 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>sparkle <i class="ic i-at"><em>@</em></i>Sparkle</li><li class="link"><strong>本文链接：</strong> <a href="https://1234cas.github.io/1234cas.github.io/qianduan/ES6/ES6%E4%B8%8A/" title="ES6上">https://1234cas.github.io/1234cas.github.io/qianduan/ES6/ES6上/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/qianduan/TCP%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipewr8iypj20zk0m8b29.jpg" title="TCP协议"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 前端</span><h3>TCP协议</h3></a></div><div class="item right"><a href="/qianduan/ES6/ES6%E4%B8%8B/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeu1usa7j20zk0m8b29.jpg" title="ES6下"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> ES6</span><h3>ES6下</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81let-%E5%92%8C-const-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.</span> <span class="toc-text">1、let 和 const 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-let-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.</span> <span class="toc-text">1. let 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2. 块级作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-const-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.</span> <span class="toc-text">3. const 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">4. 顶层对象的属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">2.</span> <span class="toc-text">2、变量的解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">2.1.</span> <span class="toc-text">1. 数组的解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">2.2.</span> <span class="toc-text">2. 对象的解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">2.3.</span> <span class="toc-text">3. 函数参数的解构赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%94%A8%E9%80%94"><span class="toc-number">2.4.</span> <span class="toc-text">4. 用途</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">3.</span> <span class="toc-text">3、字符串的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E7%9A%84-Unicode-%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">1. 字符的 Unicode 表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%81%8D%E5%8E%86%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.2.</span> <span class="toc-text">2. 字符串的遍历器接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.3.</span> <span class="toc-text">3. 模板字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91"><span class="toc-number">3.4.</span> <span class="toc-text">4. 实例：模板编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF"><span class="toc-number">3.5.</span> <span class="toc-text">5. 标签模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">4、字符串的新增方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-String-fromCodePoint"><span class="toc-number">4.1.</span> <span class="toc-text">1. String.fromCodePoint()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-String-raw"><span class="toc-number">4.2.</span> <span class="toc-text">2. String.raw()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9AcodePointAt"><span class="toc-number">4.3.</span> <span class="toc-text">3. 实例方法：codePointAt()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9Anormalize"><span class="toc-number">4.4.</span> <span class="toc-text">4. 实例方法：normalize()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9Aincludes-startsWith-endsWith"><span class="toc-number">4.5.</span> <span class="toc-text">5. 实例方法：includes(), startsWith(), endsWith()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9Arepeat"><span class="toc-number">4.6.</span> <span class="toc-text">6. 实例方法：repeat()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9ApadStart-%EF%BC%8CpadEnd"><span class="toc-number">4.7.</span> <span class="toc-text">7. 实例方法：padStart()，padEnd()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9AtrimStart-%EF%BC%8CtrimEnd"><span class="toc-number">4.8.</span> <span class="toc-text">8. 实例方法：trimStart()，trimEnd()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9AmatchAll"><span class="toc-number">4.9.</span> <span class="toc-text">9. 实例方法：matchAll()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9AreplaceAll"><span class="toc-number">4.10.</span> <span class="toc-text">10. 实例方法：replaceAll()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">5.</span> <span class="toc-text">5、正则的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-RegExp-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">1. RegExp 构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AD%A3%E5%88%99%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">2. 字符串的正则方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-u%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">5.3.</span> <span class="toc-text">3. u修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-RegExp-prototype-unicode-%E5%B1%9E%E6%80%A7"><span class="toc-number">5.4.</span> <span class="toc-text">4. RegExp.prototype.unicode 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-y-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">5.5.</span> <span class="toc-text">5. y 修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-RegExp-prototype-sticky-%E5%B1%9E%E6%80%A7"><span class="toc-number">5.6.</span> <span class="toc-text">6. RegExp.prototype.sticky 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-RegExp-prototype-flags-%E5%B1%9E%E6%80%A7"><span class="toc-number">5.7.</span> <span class="toc-text">7. RegExp.prototype.flags 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-s-%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9AdotAll-%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.8.</span> <span class="toc-text">8. s 修饰符：dotAll 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80"><span class="toc-number">5.9.</span> <span class="toc-text">9. 后行断言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-Unicode-%E5%B1%9E%E6%80%A7%E7%B1%BB"><span class="toc-number">5.10.</span> <span class="toc-text">10. Unicode 属性类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%85%B7%E5%90%8D%E7%BB%84%E5%8C%B9%E9%85%8D"><span class="toc-number">5.11.</span> <span class="toc-text">11. 具名组匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E7%B4%A2%E5%BC%95"><span class="toc-number">5.12.</span> <span class="toc-text">12. 正则匹配索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-String-prototype-matchAll"><span class="toc-number">5.13.</span> <span class="toc-text">13. String.prototype.matchAll()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">6.</span> <span class="toc-text">6、数值的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">1. 二进制和八进制表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E5%80%BC%E5%88%86%E9%9A%94%E7%AC%A6"><span class="toc-number">6.2.</span> <span class="toc-text">2. 数值分隔符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Number-isFinite-Number-isNaN"><span class="toc-number">6.3.</span> <span class="toc-text">3. Number.isFinite(), Number.isNaN()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Number-parseInt-Number-parseFloat"><span class="toc-number">6.4.</span> <span class="toc-text">4. Number.parseInt(), Number.parseFloat()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Number-isInteger"><span class="toc-number">6.5.</span> <span class="toc-text">5.Number.isInteger()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Number-EPSILON"><span class="toc-number">6.6.</span> <span class="toc-text">6. Number.EPSILON</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%AE%89%E5%85%A8%E6%95%B4%E6%95%B0%E5%92%8C-Number-isSafeInteger"><span class="toc-number">6.7.</span> <span class="toc-text">7. 安全整数和 Number.isSafeInteger()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Math-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">6.8.</span> <span class="toc-text">8. Math 对象的扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-BigInt-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.9.</span> <span class="toc-text">9. BigInt 数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">7.</span> <span class="toc-text">7、函数的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">7.1.</span> <span class="toc-text">1. 函数参数的默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-rest-%E5%8F%82%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">2. rest 参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.3.</span> <span class="toc-text">3. 严格模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-name-%E5%B1%9E%E6%80%A7"><span class="toc-number">7.4.</span> <span class="toc-text">4. name 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">7.5.</span> <span class="toc-text">5. 箭头函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96"><span class="toc-number">7.6.</span> <span class="toc-text">6. 尾调用优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%B0%BE%E9%80%97%E5%8F%B7"><span class="toc-number">7.7.</span> <span class="toc-text">7. 函数参数的尾逗号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Function-prototype-toString"><span class="toc-number">7.8.</span> <span class="toc-text">8. Function.prototype.toString()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-catch-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8F%82%E6%95%B0%E7%9C%81%E7%95%A5"><span class="toc-number">7.9.</span> <span class="toc-text">9. catch 命令的参数省略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">8.</span> <span class="toc-text">8、数组的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.1.</span> <span class="toc-text">1. 扩展运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Array-from"><span class="toc-number">8.2.</span> <span class="toc-text">2. Array.from()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Array-of"><span class="toc-number">8.3.</span> <span class="toc-text">3. Array.of()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-copyWithin"><span class="toc-number">8.4.</span> <span class="toc-text">4. 数组实例的 copyWithin()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-find-%E5%92%8C-findIndex"><span class="toc-number">8.5.</span> <span class="toc-text">5. 数组实例的 find() 和 findIndex()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-fill"><span class="toc-number">8.6.</span> <span class="toc-text">6. 数组实例的 fill()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-entries-%EF%BC%8Ckeys-%E5%92%8C-values"><span class="toc-number">8.7.</span> <span class="toc-text">7. 数组实例的 entries()，keys() 和 values()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-includes"><span class="toc-number">8.8.</span> <span class="toc-text">8. 数组实例的 includes()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-flat-%EF%BC%8CflatMap"><span class="toc-number">8.9.</span> <span class="toc-text">9. 数组实例的 flat()，flatMap()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E6%95%B0%E7%BB%84%E7%9A%84%E7%A9%BA%E4%BD%8D"><span class="toc-number">8.10.</span> <span class="toc-text">10. 数组的空位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-Array-prototype-sort-%E7%9A%84%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">8.11.</span> <span class="toc-text">11. Array.prototype.sort() 的排序稳定性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">9.</span> <span class="toc-text">9、对象的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AE%80%E6%B4%81%E8%A1%A8%E8%BE%BE%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">1. 属性的简洁表达法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B1%9E%E6%80%A7%E5%90%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">2. 属性名表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E7%9A%84-name-%E5%B1%9E%E6%80%A7"><span class="toc-number">9.3.</span> <span class="toc-text">3. 方法的 name 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%AF%E6%9E%9A%E4%B8%BE%E6%80%A7%E5%92%8C%E9%81%8D%E5%8E%86"><span class="toc-number">9.4.</span> <span class="toc-text">4. 属性的可枚举性和遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-super-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">9.5.</span> <span class="toc-text">5. super 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">9.6.</span> <span class="toc-text">6. 对象的扩展运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-AggregateError-%E9%94%99%E8%AF%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.7.</span> <span class="toc-text">7. AggregateError 错误对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">10、 对象的新增方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Object-is"><span class="toc-number">10.1.</span> <span class="toc-text">1. Object.is()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Object-assign"><span class="toc-number">10.2.</span> <span class="toc-text">2. Object.assign()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Object-getOwnPropertyDescriptors"><span class="toc-number">10.3.</span> <span class="toc-text">3. Object.getOwnPropertyDescriptors()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-proto-%E5%B1%9E%E6%80%A7%EF%BC%8CObject-setPrototypeOf-%EF%BC%8CObject-getPrototypeOf"><span class="toc-number">10.4.</span> <span class="toc-text">4. __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Object-keys-%EF%BC%8CObject-values-%EF%BC%8CObject-entries"><span class="toc-number">10.5.</span> <span class="toc-text">5. Object.keys()，Object.values()，Object.entries()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Object-fromEntries"><span class="toc-number">10.6.</span> <span class="toc-text">6. Object.fromEntries()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">11.</span> <span class="toc-text">11、运算符的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8C%87%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">11.1.</span> <span class="toc-text">1. 指数运算符**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%93%BE%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9F"><span class="toc-number">11.2.</span> <span class="toc-text">2. 链判断运算符？.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Null-%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9F%EF%BC%9F"><span class="toc-number">11.3.</span> <span class="toc-text">3. Null 判断运算符？？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%BB%E8%BE%91%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">11.4.</span> <span class="toc-text">4. 逻辑赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81-Symbol"><span class="toc-number">12.</span> <span class="toc-text">12、 Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">12.1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Symbol-prototype-description"><span class="toc-number">12.2.</span> <span class="toc-text">2. Symbol.prototype.description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84-Symbol"><span class="toc-number">12.3.</span> <span class="toc-text">3. 作为属性名的 Symbol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%B6%88%E9%99%A4%E9%AD%94%E6%9C%AF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">12.4.</span> <span class="toc-text">4. 实例：消除魔术字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">12.5.</span> <span class="toc-text">5. 属性名的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Symbol-for-%EF%BC%8CSymbol-keyFor"><span class="toc-number">12.6.</span> <span class="toc-text">6. Symbol.for()，Symbol.keyFor()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%A8%A1%E5%9D%97%E7%9A%84-Singleton-%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.7.</span> <span class="toc-text">7.实例：模块的 Singleton 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%86%85%E7%BD%AE%E7%9A%84-Symbol-%E5%80%BC"><span class="toc-number">12.8.</span> <span class="toc-text">8. 内置的 Symbol 值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81-Set-%E5%92%8C-Map-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">13.</span> <span class="toc-text">13、 Set 和 Map 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Set"><span class="toc-number">13.1.</span> <span class="toc-text">1. Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-WeakSet"><span class="toc-number">13.2.</span> <span class="toc-text">2. WeakSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Map"><span class="toc-number">13.3.</span> <span class="toc-text">3. Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-WeakMap"><span class="toc-number">13.4.</span> <span class="toc-text">4. WeakMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-WeakRef"><span class="toc-number">13.5.</span> <span class="toc-text">5. WeakRef</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-FinalizationRegistry"><span class="toc-number">13.6.</span> <span class="toc-text">6. FinalizationRegistry</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/qianduan/ES6/ES6%E4%B8%8A/" rel="bookmark" title="ES6上">ES6上</a></li><li><a href="/qianduan/ES6/ES6%E4%B8%8B/" rel="bookmark" title="ES6下">ES6下</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="sparkle" data-src="/images/avatar.jpg"><p class="name" itemprop="name">sparkle</p><div class="description" itemprop="description">好好读书</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">11</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">3</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></span> <span class="exturl item google" data-url="aHR0cHM6Ly9wbHVzLmdvb2dsZS5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;plus.google.com&#x2F;yourname"><i class="ic i-google"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnlvdXJuYW1lQG1haWwuY29t" title="mailto:yourname@mail.com"><i class="ic i-envelope"></i></span> <span class="exturl item facebook" data-url="aHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname"><i class="ic i-facebook"></i></span> <span class="exturl item stackoverflow" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname"><i class="ic i-stack-overflow"></i></span> <span class="exturl item youtube" data-url="aHR0cHM6Ly95b3V0dWJlLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;youtube.com&#x2F;yourname"><i class="ic i-youtube"></i></span> <span class="exturl item instagram" data-url="aHR0cHM6Ly9pbnN0YWdyYW0uY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;instagram.com&#x2F;yourname"><i class="ic i-instagram"></i></span> <span class="exturl item skype" data-url="c2t5cGU6eW91cm5hbWU/Y2FsbHxjaGF0" title="skype:yourname?call|chat"><i class="ic i-skype"></i></span> <span class="exturl item douban" data-url="aHR0cHM6Ly93d3cuZG91YmFuLmNvbS9wZW9wbGUveW91cm5hbWUv" title="https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;yourname&#x2F;"><i class="ic i-douban"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>链接</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/qianduan/TCP%E5%8D%8F%E8%AE%AE/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/qianduan/ES6/ES6%E4%B8%8B/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/qianduan/Vue/vue-router/" title="Vue router">Vue router</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/qianduan/Vue/vue%E7%AC%94%E8%AE%B0/" title="Vue笔记">Vue笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a></div><span><a href="/%E5%9F%BA%E7%A1%80/" title="基础">基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a></div><span><a href="/qianduan/TCP%E5%8D%8F%E8%AE%AE/" title="TCP协议">TCP协议</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/qianduan/Vue/vue%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Vue面试题">Vue面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/hexo/" title="分类于 hexo">hexo</a></div><span><a href="/hexo/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reading-minutes/" title="分类于 读书笔记">读书笔记</a></div><span><a href="/reading-minutes/%E5%85%B3%E4%BA%8E%E7%AC%94%E8%AE%B0/" title="关于笔记">关于笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/ES6/" title="分类于 ES6">ES6</a></div><span><a href="/qianduan/ES6/ES6%E4%B8%8A/" title="ES6上">ES6上</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reading-minutes/" title="分类于 读书笔记">读书笔记</a></div><span><a href="/reading-minutes/%E5%85%B3%E4%BA%8E%E8%AF%BB%E4%B9%A6/" title="关于读书">关于读书</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/qianduan/Vue/vuex/" title="vuex">vuex</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">sparkle @ Sparkle</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"qianduan/ES6/ES6上/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:{placeholder:"1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"},fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->