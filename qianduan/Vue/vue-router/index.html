<!-- build time:Tue Mar 29 2022 11:15:37 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="前端,Vue"><link rel="canonical" href="https://1234cas.github.io/1234cas.github.io/qianduan/Vue/vue-router/"><title>Vue router - Vue - 前端 | Sparkle = Sparkle = 加油</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Vue router</h1><div class="meta"><span class="item" title="创建时间：2022-03-27 17:02:29"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-03-27T17:02:29+08:00">2022-03-27</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Sparkle</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeyonbf9j20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicitht3xtj20zk0m8k5v.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclip4jbpj20zk0m87cv.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipew28b65j20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicliwyw55j20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclhnx9glj20zk0m8npd.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/qianduan/" itemprop="item" rel="index" title="分类于 前端"><span itemprop="name">前端</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/qianduan/Vue/" itemprop="item" rel="index" title="分类于 Vue"><span itemprop="name">Vue</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://1234cas.github.io/1234cas.github.io/qianduan/Vue/vue-router/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="sparkle"><meta itemprop="description" content="加油, 好好读书"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sparkle"></span><div class="body md" itemprop="articleBody"><h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h2><p><strong>官方例子<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1yb3V0ZXIvdHJlZS9kZXYvZXhhbXBsZXM=">https://github.com/vuejs/vue-router/tree/dev/examples</span></strong></p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><strong>基础的router/index.js文件</strong></p><pre><code class="js">import Vue from &#39;vue&#39; 
import VueRouter from &#39;vue-router&#39;
// 导入需要的路由组件
import Home from &#39;@/views/Home.vue&#39;

Vue.use(VueRouter)

const router = new VueRouter(&#123;
    routes:[&#123;
        &#123; path: &#39;&#39;, component: Home, name: &#39;home&#39; &#125;,
        &#123; path: &#39;/home&#39;, component: Home &#125;
    &#125;]
&#125;)

export default router
</code></pre><p>必要的内容：</p><ul><li>引入vue和vue-router</li><li>使用Vue.use(Router)</li><li>配置路由</li><li>对外开放router</li></ul><p>可以通过vue-cli创建项目时一键生成</p><p>还需要在main.js入口文件中导入挂载</p><pre><code class="js">import router from &#39;./router&#39;
new Vue(&#123;
  router,
  render: h =&gt; h(App)
&#125;).$mount(&#39;#app&#39;)
</code></pre><p>同样也可以一键生成</p><hr><h4 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h4><pre><code class="js">    &#123; path: &#39;/user/:id&#39;, component: User &#125;
</code></pre><p>可以通过<code>$route.params</code>来获取</p><p>注意，当使用路由参数时，例如从 <code>/user/foo</code> 导航到 <code>/user/bar</code>，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会再被调用</strong>。</p><p>可以使用 watch (监测变化) <code>$route</code> 对象：</p><pre><code class="js">watch: &#123;
    $route(to, from) &#123;
    // 对路由变化作出响应...
    &#125;
&#125;
</code></pre><p>或者使用beforeRouterUpadte导航守卫</p><pre><code class="js">beforeRouteUpdate(to, from, next) &#123;
    // react to route changes...
    // don&#39;t forget to call next()
&#125;
</code></pre><p>如果想匹配<strong>任意路径</strong>，我们可以使用通配符 (<code>*</code>)：</p><pre><code class="js">&#123; path: &#39;*&#39; &#125;
&#123; path: &#39;user/*&#39; &#125;
</code></pre><p>含有<em>通配符</em>的路由应该放在最后。路由 <code>&#123; path: &#39;*&#39; &#125;</code> 通常用于客户端 404 错误。</p><p>当使用一个<em>通配符</em>时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数。它包含了 URL 通过<em>通配符</em>被匹配的部分：</p><pre><code class="js">// 给出一个路由 &#123; path: &#39;/user-*&#39; &#125;
this.$router.push(&#39;/user-admin&#39;)
this.$route.params.pathMatch // &#39;admin&#39;
// 给出一个路由 &#123; path: &#39;*&#39; &#125;
this.$router.push(&#39;/non-existing&#39;)
this.$route.params.pathMatch // &#39;/non-existing&#39;
</code></pre><p><strong><code>vue-router</code> 使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BpbGxhcmpzL3BhdGgtdG8tcmVnZXhwL3RyZWUvdjEuNy4w">path-to-regexp (opens new window)</span>作为路径匹配引擎</strong></p><p><strong>路由定义得越早，优先级就越高。</strong></p><hr><h4 id="嵌套路由-子路由"><a href="#嵌套路由-子路由" class="headerlink" title="嵌套路由(子路由)"></a>嵌套路由(子路由)</h4><p>在 <code>VueRouter</code> 的参数中使用 <code>children</code> 配置：</p><pre><code class="js">routes:[
    &#123; 
        path: &#39;/home&#39;, 
        component: Home,
        children:[
            &#123; path: &#39;left&#39;, component: Left &#125;,
            //基于上面的配置，当我们访问`/home`时，不会渲染任何东西，得添加一个空的子路由
            &#123; path: &#39;&#39;, component: Home &#125;,
        ]    
    &#125;,
]
</code></pre><p><strong>注意，以 <code>/</code> 开头的嵌套路径会被当作根路径，因此不要在子路由中用 <code>/</code></strong></p><p>可套娃</p><hr><h4 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h4><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现</p><p><code>router.push(location, onComplete?, onAbort?)</code></p><p>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code>。</p><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td><td><code>router.push(...)</code></td></tr></tbody></table><p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如</p><pre><code class="js">// 字符串
router.push(&#39;home&#39;)

// 对象
router.push(&#123; path: &#39;home&#39; &#125;)

// 命名的路由
router.push(&#123; name: &#39;user&#39;, params: &#123; userId: &#39;123&#39; &#125;&#125;)

// 带查询参数，变成 /register?plan=private
router.push(&#123; path: &#39;register&#39;, query: &#123; plan: &#39;private&#39; &#125;&#125;)
</code></pre><p><strong>注意：如果提供了<code>path</code>，<code>params</code>会被忽略，而查询参数<code>query</code>不会</strong></p><pre><code class="js">const userId = &#39;123&#39;
router.push(&#123; name: &#39;user&#39;, params: &#123; userId &#125;&#125;) // -&gt; /user/123
router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123
// 这里的 params 不生效
router.push(&#123; path: &#39;/user&#39;, params: &#123; userId &#125;&#125;) // -&gt; /user
</code></pre><p>所以要么使用<code>name</code>加params要么<code>path</code>用模板字符串手写完整路径</p><p>同样的规则也适用于 <code>router-link</code> 组件的 <code>to</code> 属性。</p><p><code>router.replace(location, onComplete?, onAbort?)</code></p><p>跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td><td><code>router.replace(...)</code></td></tr></tbody></table><p><code>router.go(n)</code></p><p>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 <code>window.history.go(n)</code>。</p><hr><h4 id="同级多视图"><a href="#同级多视图" class="headerlink" title="同级多视图"></a>同级多视图</h4><p>用命名视图和命名路由一一对应 components要带上s</p><pre><code class="html">&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;
&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;
&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt;
</code></pre><pre><code class="js">const router = new VueRouter(&#123;
  routes: [
    &#123;
      path: &#39;/&#39;,
      components: &#123;
        default: Foo,
        a: Bar,
        b: Baz
      &#125;
    &#125;
  ]
&#125;)
</code></pre><hr><h4 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h4><p>当用户访问 <code>/a</code>时，URL 将会被替换成 <code>/b</code>，然后匹配路由为 <code>/b</code></p><p>重定向也是通过 <code>routes</code> 配置来完成，下面例子是从 <code>/a</code> 重定向到 <code>/b</code>：</p><pre><code class="js">const router = new VueRouter(&#123;
  routes: [
    &#123; path: &#39;/a&#39;, redirect: &#39;/b&#39; &#125;
    &#123; path: &#39;/a&#39;, redirect: &#123; name: &#39;foo&#39; &#125;&#125;
    &#123; path: &#39;/a&#39;, redirect: to =&gt; &#123;
      // 方法接收 目标路由 作为参数
      // return 重定向的 字符串路径/路径对象
    &#125;&#125;
  ]
&#125;)
</code></pre><p>问题？这里加导航守卫是a生效还是b生效</p><p><code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，URL 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。即实际访问内容被替换问<code>/a</code></p><pre><code class="js">const router = new VueRouter(&#123;
  routes: [
    &#123; path: &#39;/a&#39;, component: A, alias: &#39;/b&#39; &#125;
  ]
&#125;)
</code></pre><hr><h4 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h4><p>在组件中使用 <code>$route</code> 会使之与其对应路由形成高度耦合(即$route.params.id)，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。</p><p>使用 <code>props</code> 将组件和路由解耦：</p><pre><code class="js">    &#123; path: &#39;/user/:id&#39;, component: User, props: true &#125;,
    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：
    &#123;
      path: &#39;/user/:id&#39;,
      components: &#123; default: User, sidebar: Sidebar &#125;,
      props: &#123; default: true, sidebar: false &#125;
    &#125;
</code></pre><hr><h4 id="HTML5-History-模式"><a href="#HTML5-History-模式" class="headerlink" title="HTML5 History 模式"></a>HTML5 History 模式</h4><p><code>vue-router</code> 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</p><p>如果不想要很丑的 hash，我们可以用路由的 <strong>history 模式</strong>，这种模式充分利用 <code>history.pushState</code> API 来完成 URL 跳转而无须重新加载页面。</p><pre><code class="js">const router = new VueRouter(&#123;
  mode: &#39;history&#39;,
  routes: [...]
&#125;)
</code></pre><hr><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h4><p>记住<strong>参数或查询的改变并不会触发进入/离开的导航守卫</strong>。你可以通过<strong>watch<code>$route</code>对象</strong>来应对这些变化，或使用 <code>beforeRouteUpdate</code> 的组件内守卫</p><p><strong>全局前置守卫</strong></p><pre><code class="js">router.beforeEach((to, from, next) =&gt; &#123;
  // ...
&#125;)
</code></pre><p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 <strong>等待中</strong>。即跳转会等到所有守卫结束后进行</p><p>每个守卫方法接收三个参数：</p><ul><li><p><strong><code>to: Route</code></strong>: 即将要进入的目标 路由对象</p></li><li><p><strong><code>from: Route</code></strong>: 当前导航正要离开的路由</p></li><li><p><strong><code>next: Function</code></strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。</p><ul><li><strong><code>next()</code></strong>: 进行管道中的下一个钩子，即放行。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> (确认的)。</li><li><strong><code>next(false)</code></strong>: 中断当前的导航，即不动。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。</li><li><strong><code>next(&#39;/&#39;)</code> 或者 <code>next(&#123; path: &#39;/&#39; &#125;)</code></strong>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/api/#to"><code>router-link</code> 的 <code>to</code> prop</a> 或 <a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/api/#router-push"><code>router.push</code></a> 中的选项。</li></ul></li></ul><p><strong>注意，要确保<code>next</code>函数至少能够调用一次，也可以调用多次，但是只能在逻辑路径不重叠的情况下</strong></p><p><strong>全局解析守卫</strong></p><p><code>router.beforeResolve</code>和 <code>router.beforeEach</code> 类似，区别是在导航被确认之前，<strong>同时在所有组件内守卫和异步路由组件被解析之后</strong>，解析守卫就被调用。即在跳转前最后调用</p><p><strong>全局后置钩子</strong></p><p>这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p><pre><code class="js">router.afterEach((to, from) =&gt; &#123;
  // ...
&#125;)
</code></pre><p><strong>路由独享的守卫</strong></p><p>可以在路由配置上直接定义 <code>beforeEnter</code> 守卫，和全局前置守卫的方法参数是一样的：</p><pre><code class="js">const router = new VueRouter(&#123;
  routes: [
    &#123;
      path: &#39;/foo&#39;,
      component: Foo,
      beforeEnter: (to, from, next) =&gt; &#123;
        // ...
      &#125;
    &#125;
  ]
&#125;)
</code></pre><p><strong>组件内的守卫</strong></p><p>你可以在路由组件内直接定义以下路由导航守卫：</p><ul><li><code>beforeRouteEnter</code></li><li><code>beforeRouteUpdate</code></li><li><code>beforeRouteLeave</code></li></ul><pre><code class="js">&lt;script&gt;
export default &#123;
  // 和data同级
  data()&#123;&#125;,  
  beforeRouteEnter(to, from, next) &#123;
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  &#125;,
  beforeRouteUpdate(to, from, next) &#123;
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  &#125;,
  beforeRouteLeave(to, from, next) &#123;
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  &#125;
&#125;
&lt;/script&gt;
</code></pre><p><strong>完整的导航解析流程</strong></p><ol><li>导航被触发。</li><li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><hr><h4 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h4><p>定义路由的时候可以配置 <code>meta</code> 字段：</p><pre><code class="js">&#123;
    path: &#39;bar&#39;,
    component: Bar,
    // a meta field
    meta: &#123; requiresAuth: true &#125;
&#125;
</code></pre><p>那么如何访问这个 <code>meta</code> 字段呢？</p><p>一个路由匹配到的所有路由记录会暴露为 <code>$route</code> 对象 (还有在导航守卫中的路由对象) 的 <code>$route.matched</code> 数组。因此，我们需要遍历 <code>$route.matched</code> 来检查路由记录中的 <code>meta</code> 字段。<code>$route.matched.some(record =&gt; record.meta.requiresAuth)</code></p><pre><code class="js">router.beforeEach((to, from, next) =&gt; &#123;
  if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123;
    // this route requires auth, check if logged in
    // if not, redirect to login page.
    if (!auth.loggedIn()) &#123;
      next(&#123;
        path: &#39;/login&#39;,
        query: &#123; redirect: to.fullPath &#125;
      &#125;)
    &#125; else &#123;
      next()
    &#125;
  &#125; else &#123;
    next() // 确保一定要调用 next()
  &#125;
&#125;)
</code></pre><hr><h4 id="过渡动画"><a href="#过渡动画" class="headerlink" title="过渡动画"></a>过渡动画</h4><p><code>&lt;router-view&gt;</code> 是基本的动态组件，所以我们可以用 <code>&lt;transition&gt;</code> 组件给它添加一些过渡效果：</p><pre><code class="html">&lt;transition&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/transition&gt;
</code></pre><p><strong>单个路由的过渡</strong></p><p>上面的用法会给所有路由设置一样的过渡效果，如果你想让每个路由组件有各自的过渡效果，可以在各路由组件内使用 <code>&lt;transition&gt;</code> 并设置不同的 name</p><pre><code class="js">&lt;transition name=&quot;slide&quot;&gt;
    &lt;div class=&quot;foo&quot;&gt;...&lt;/div&gt;
&lt;/transition&gt;
&lt;transition name=&quot;fade&quot;&gt;
    &lt;div class=&quot;bar&quot;&gt;...&lt;/div&gt;
&lt;/transition&gt;
</code></pre><p><strong>基于路由的动态过渡</strong></p><p>还可以基于当前路由与目标路由的变化关系，动态设置过渡效果：</p><pre><code class="html">&lt;!-- 使用动态的 transition name --&gt;
&lt;transition :name=&quot;transitionName&quot;&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/transition&gt;
</code></pre><pre><code class="js">// 接着在父组件内
// watch $route 决定使用哪种过渡
watch: &#123;
  &#39;$route&#39; (to, from) &#123;
    const toDepth = to.path.split(&#39;/&#39;).length
    const fromDepth = from.path.split(&#39;/&#39;).length
    this.transitionName = toDepth &lt; fromDepth ? &#39;slide-right&#39; : &#39;slide-left&#39;
  &#125;
&#125;
</code></pre><hr><h4 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h4><p>在进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：</p><ul><li><strong>导航完成之后获取</strong>：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。</li><li><strong>导航完成之前获取</strong>：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。</li></ul><p><strong>导航完成后获取数据</strong></p><p>当使用这种方式时，会马上导航和渲染组件，然后在组件的 <code>created</code> 钩子中获取数据。这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。</p><pre><code class="js">export default &#123;
  data () &#123;
    return &#123;
      loading: false,
      post: null,
      error: null
    &#125;
  &#125;,
  created () &#123;
    // 组件创建完后获取数据，
    // 此时 data 已经被 observed 了
    this.fetchData()
  &#125;,
  watch: &#123;
    // 如果路由有变化，会再次执行该方法
    &#39;$route&#39;: &#39;fetchData&#39;
  &#125;,
  methods: &#123;
    fetchData () &#123;
      this.error = this.post = null
      this.loading = true
      // replace getPost with your data fetching util / API wrapper
      getPost(this.$route.params.id, (err, post) =&gt; &#123;
        this.loading = false
        if (err) &#123;
          this.error = err.toString()
        &#125; else &#123;
          this.post = post
        &#125;
      &#125;)
    &#125;
  &#125;
&#125;
</code></pre><p><strong>在导航完成前获取数据</strong></p><p>通过这种方式，我们在导航转入新的路由前获取数据，会在原页面短暂停留。我们可以在接下来的组件的 <code>beforeRouteEnter</code> 守卫中获取数据，当数据获取成功后只调用 <code>next</code> 方法。</p><pre><code class="js">export default &#123;
  data () &#123;
    return &#123;
      post: null,
      error: null
    &#125;
  &#125;,
  beforeRouteEnter (to, from, next) &#123;
    getPost(to.params.id, (err, post) =&gt; &#123;
      next(vm =&gt; vm.setData(err, post))
    &#125;)
  &#125;,
  // 路由改变前，组件就已经渲染完了
  // 逻辑稍稍不同
  beforeRouteUpdate (to, from, next) &#123;
    this.post = null
    getPost(to.params.id, (err, post) =&gt; &#123;
      this.setData(err, post)
      next()
    &#125;)
  &#125;,
  methods: &#123;
    setData (err, post) &#123;
      if (err) &#123;
        this.error = err.toString()
      &#125; else &#123;
        this.post = post
      &#125;
    &#125;
  &#125;
&#125;
</code></pre><p>在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条或者别的指示。如果数据获取失败，同样有必要展示一些全局的错误提醒。</p><hr><h4 id="滚动行为（不明白）"><a href="#滚动行为（不明白）" class="headerlink" title="滚动行为（不明白）"></a>滚动行为（不明白）</h4><p>使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 <code>vue-router</code> 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。</p><p><strong>注意: 这个功能只在支持 <code>history.pushState</code> 的浏览器中可用。</strong></p><p>当创建一个 Router 实例，你可以提供一个 <code>scrollBehavior</code> 方法：</p><pre><code class="js">const router = new VueRouter(&#123;
  routes: [...],
  scrollBehavior (to, from, savedPosition) &#123;
    // return 期望滚动到哪个的位置
  &#125;
&#125;)
</code></pre><p><code>scrollBehavior</code> 方法接收 <code>to</code> 和 <code>from</code> 路由对象。第三个参数 <code>savedPosition</code> 当且仅当 <code>popstate</code> 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。</p><p>这个方法返回滚动位置的对象信息，长这样：</p><ul><li><code>&#123; x: number, y: number &#125;</code></li><li><code>&#123; selector: string, offset? : &#123; x: number, y: number &#125;&#125;</code> (offset 只在 2.6.0+ 支持)</li></ul><p>如果返回一个 falsy (译者注：falsy 不是 <code>false</code>，<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9HbG9zc2FyeS9GYWxzeQ==">参考这里 (opens new window)</span>)的值，或者是一个空对象，那么不会发生滚动。</p><p>举例：</p><pre><code class="js">scrollBehavior (to, from, savedPosition) &#123;
  return &#123; x: 0, y: 0 &#125;
&#125;
</code></pre><p>对于所有路由导航，简单地让页面滚动到顶部。</p><p>返回 <code>savedPosition</code>，在按下 后退/前进 按钮时，就会像浏览器的原生表现那样：</p><pre><code class="js">scrollBehavior (to, from, savedPosition) &#123;
  if (savedPosition) &#123;
    return savedPosition
  &#125; else &#123;
    return &#123; x: 0, y: 0 &#125;
  &#125;
&#125;
</code></pre><p>如果你要模拟“滚动到锚点”的行为：</p><pre><code class="js">scrollBehavior (to, from, savedPosition) &#123;
  if (to.hash) &#123;
    return &#123;
      selector: to.hash
    &#125;
  &#125;
&#125;
</code></pre><p>查看完整例子请<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1yb3V0ZXIvYmxvYi9kZXYvZXhhbXBsZXMvc2Nyb2xsLWJlaGF2aW9yL2FwcC5qcw==">移步这里</span></p><p><strong>异步滚动</strong></p><blockquote><p>2.8.0 新增</p></blockquote><p>你也可以返回一个 Promise 来得出预期的位置描述：</p><pre><code class="js">scrollBehavior (to, from, savedPosition) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
      resolve(&#123; x: 0, y: 0 &#125;)
    &#125;, 500)
  &#125;)
&#125;
</code></pre><p>将其挂载到从页面级别的过渡组件的事件上，令其滚动行为和页面过渡一起良好运行是可能的。但是考虑到用例的多样性和复杂性，我们仅提供这个原始的接口，以支持不同用户场景的具体实现。</p><p><strong>平滑滚动</strong></p><p>只需将 <code>behavior</code> 选项添加到 <code>scrollBehavior</code> 内部返回的对象中，就可以为<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Njcm9sbFRvT3B0aW9ucy9iZWhhdmlvcg==">支持它的浏览器 (opens new window)</span>启用原生平滑滚动：</p><pre><code class="js">scrollBehavior (to, from, savedPosition) &#123;
  if (to.hash) &#123;
    return &#123;
      selector: to.hash,
      behavior: &#39;smooth&#39;,
    &#125;
  &#125;
&#125;
</code></pre><hr><h4 id="路由懒加载（不明白）"><a href="#路由懒加载（不明白）" class="headerlink" title="路由懒加载（不明白）"></a>路由懒加载（不明白）</h4><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了</p><pre><code>// 将
// import UserDetails from &#39;./views/UserDetails&#39;
// 替换成
const UserDetails = () =&gt; import(&#39;./views/UserDetails&#39;)

const router = createRouter(&#123;
  // ...
  routes: [&#123; path: &#39;/users/:id&#39;, component: UserDetails &#125;],
&#125;)
</code></pre><p>结合 Vue 的<span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy1keW5hbWljLWFzeW5jLmh0bWwjJUU1JUJDJTgyJUU2JUFEJUE1JUU3JUJCJTg0JUU0JUJCJUI2">异步组件 (opens new window)</span>和 Webpack 的<span class="exturl" data-url="aHR0cHM6Ly9kb2Mud2VicGFjay1jaGluYS5vcmcvZ3VpZGVzL2NvZGUtc3BsaXR0aW5nLWFzeW5jLyNyZXF1aXJlLWVuc3VyZS0v">代码分割功能 (opens new window)</span>，轻松实现路由组件的懒加载。</p><p>首先，可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)：</p><pre><code class="js">const Foo = () =&gt;
  Promise.resolve(&#123;
    /* 组件定义对象 */
  &#125;)
</code></pre><p>第二，在 Webpack 2 中，我们可以使用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZHluYW1pYy1pbXBvcnQ=">动态 import (opens new window)</span>语法来定义代码分块点 (split point)：</p><pre><code class="js">import(&#39;./Foo.vue&#39;) // 返回 Promise
</code></pre><p>结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件。</p><pre><code class="js">const Foo = () =&gt; import(&#39;./Foo.vue&#39;)
</code></pre><p>在路由配置中什么都不需要改变，只需要像往常一样使用 <code>Foo</code>：</p><pre><code class="js">const router = new VueRouter(&#123;
  routes: [&#123; path: &#39;/foo&#39;, component: Foo &#125;]
&#125;)
</code></pre><p><strong>把组件按组分块</strong></p><p>有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 <span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9ndWlkZXMvY29kZS1zcGxpdHRpbmctcmVxdWlyZS8jY2h1bmtuYW1l">命名 chunk (opens new window)</span>，一个特殊的注释语法来提供 chunk name (需要 Webpack &gt; 2.4)。</p><pre><code class="js">const Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Foo.vue&#39;)
const Bar = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Bar.vue&#39;)
const Baz = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#39;./Baz.vue&#39;)
</code></pre><p>Webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。</p><p>主要参考Vue Router官方文档</p><div class="tags"><a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"><i class="ic i-tag"></i> 前端</a> <a href="/tags/Vue/" rel="tag"><i class="ic i-tag"></i> Vue</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-03-27 17:21:22" itemprop="dateModified" datetime="2022-03-27T17:21:22+08:00">2022-03-27</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="sparkle 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="sparkle 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="sparkle 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>sparkle <i class="ic i-at"><em>@</em></i>Sparkle</li><li class="link"><strong>本文链接：</strong> <a href="https://1234cas.github.io/1234cas.github.io/qianduan/Vue/vue-router/" title="Vue router">https://1234cas.github.io/1234cas.github.io/qianduan/Vue/vue-router/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/qianduan/ES6/ES6%E4%B8%8B/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicm0fdw5cj20zk0m8hdt.jpg" title="ES6下"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> ES6</span><h3>ES6下</h3></a></div><div class="item right"><a href="/qianduan/Vue/vuex/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclfdu6exj20zk0m87hw.jpg" title="vuex"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Vue</span><h3>vuex</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-Router"><span class="toc-number">1.</span> <span class="toc-text">Vue Router</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">动态路由匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1-%E5%AD%90%E8%B7%AF%E7%94%B1"><span class="toc-number">1.1.2.</span> <span class="toc-text">嵌套路由(子路由)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA"><span class="toc-number">1.1.3.</span> <span class="toc-text">编程式导航</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E7%BA%A7%E5%A4%9A%E8%A7%86%E5%9B%BE"><span class="toc-number">1.1.4.</span> <span class="toc-text">同级多视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E5%88%AB%E5%90%8D"><span class="toc-number">1.1.5.</span> <span class="toc-text">重定向和别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82"><span class="toc-number">1.1.6.</span> <span class="toc-text">路由组件传参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML5-History-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.7.</span> <span class="toc-text">HTML5 History 模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6"><span class="toc-number">1.2.</span> <span class="toc-text">进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB"><span class="toc-number">1.2.1.</span> <span class="toc-text">导航守卫</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.2.</span> <span class="toc-text">路由元信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB"><span class="toc-number">1.2.3.</span> <span class="toc-text">过渡动画</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96"><span class="toc-number">1.2.4.</span> <span class="toc-text">数据获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA%EF%BC%88%E4%B8%8D%E6%98%8E%E7%99%BD%EF%BC%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">滚动行为（不明白）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%B8%8D%E6%98%8E%E7%99%BD%EF%BC%89"><span class="toc-number">1.2.6.</span> <span class="toc-text">路由懒加载（不明白）</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/qianduan/Vue/vue%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="bookmark" title="Vue面试题">Vue面试题</a></li><li class="active"><a href="/qianduan/Vue/vue-router/" rel="bookmark" title="Vue router">Vue router</a></li><li><a href="/qianduan/Vue/vuex/" rel="bookmark" title="vuex">vuex</a></li><li><a href="/qianduan/Vue/vue%E7%AC%94%E8%AE%B0/" rel="bookmark" title="Vue笔记">Vue笔记</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="sparkle" data-src="/images/avatar.jpg"><p class="name" itemprop="name">sparkle</p><div class="description" itemprop="description">好好读书</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">11</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">3</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></span> <span class="exturl item google" data-url="aHR0cHM6Ly9wbHVzLmdvb2dsZS5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;plus.google.com&#x2F;yourname"><i class="ic i-google"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnlvdXJuYW1lQG1haWwuY29t" title="mailto:yourname@mail.com"><i class="ic i-envelope"></i></span> <span class="exturl item facebook" data-url="aHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname"><i class="ic i-facebook"></i></span> <span class="exturl item stackoverflow" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname"><i class="ic i-stack-overflow"></i></span> <span class="exturl item youtube" data-url="aHR0cHM6Ly95b3V0dWJlLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;youtube.com&#x2F;yourname"><i class="ic i-youtube"></i></span> <span class="exturl item instagram" data-url="aHR0cHM6Ly9pbnN0YWdyYW0uY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;instagram.com&#x2F;yourname"><i class="ic i-instagram"></i></span> <span class="exturl item skype" data-url="c2t5cGU6eW91cm5hbWU/Y2FsbHxjaGF0" title="skype:yourname?call|chat"><i class="ic i-skype"></i></span> <span class="exturl item douban" data-url="aHR0cHM6Ly93d3cuZG91YmFuLmNvbS9wZW9wbGUveW91cm5hbWUv" title="https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;yourname&#x2F;"><i class="ic i-douban"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>链接</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/qianduan/ES6/ES6%E4%B8%8B/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/qianduan/Vue/vuex/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/hexo/" title="分类于 hexo">hexo</a></div><span><a href="/hexo/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reading-minutes/" title="分类于 读书笔记">读书笔记</a></div><span><a href="/reading-minutes/%E5%85%B3%E4%BA%8E%E7%AC%94%E8%AE%B0/" title="关于笔记">关于笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/qianduan/Vue/vue%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Vue面试题">Vue面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reading-minutes/" title="分类于 读书笔记">读书笔记</a></div><span><a href="/reading-minutes/%E5%85%B3%E4%BA%8E%E8%AF%BB%E4%B9%A6/" title="关于读书">关于读书</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/qianduan/Vue/vue-router/" title="Vue router">Vue router</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/ES6/" title="分类于 ES6">ES6</a></div><span><a href="/qianduan/ES6/ES6%E4%B8%8B/" title="ES6下">ES6下</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/qianduan/Vue/vuex/" title="vuex">vuex</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a></div><span><a href="/%E5%9F%BA%E7%A1%80/" title="基础">基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a></div><span><a href="/qianduan/TCP%E5%8D%8F%E8%AE%AE/" title="TCP协议">TCP协议</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/ES6/" title="分类于 ES6">ES6</a></div><span><a href="/qianduan/ES6/ES6%E4%B8%8A/" title="ES6上">ES6上</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">sparkle @ Sparkle</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"qianduan/Vue/vue-router/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:{placeholder:"1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"},fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->