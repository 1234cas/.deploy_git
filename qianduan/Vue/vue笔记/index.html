<!-- build time:Tue Mar 29 2022 11:15:37 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/atom.xml"><link rel="alternate" type="application/json" title="Sparkle" href="https://1234cas.github.io/1234cas.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="前端,Vue"><link rel="canonical" href="https://1234cas.github.io/1234cas.github.io/qianduan/Vue/vue%E7%AC%94%E8%AE%B0/"><title>Vue笔记 - Vue - 前端 | Sparkle = Sparkle = 加油</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Vue笔记</h1><div class="meta"><span class="item" title="创建时间：2022-03-27 23:06:47"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-03-27T23:06:47+08:00">2022-03-27</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Sparkle</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giciusoyjnj219g0u0x56.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicit4jrvuj20zk0m8785.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicitspjpbj20zk0m81ky.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipet8c1a2j20zk0m8kct.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclga70tsj20zk0m84mr.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicitht3xtj20zk0m8k5v.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/qianduan/" itemprop="item" rel="index" title="分类于 前端"><span itemprop="name">前端</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/qianduan/Vue/" itemprop="item" rel="index" title="分类于 Vue"><span itemprop="name">Vue</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://1234cas.github.io/1234cas.github.io/qianduan/Vue/vue%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="sparkle"><meta itemprop="description" content="加油, 好好读书"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sparkle"></span><div class="body md" itemprop="articleBody"><h1 id="Vue笔记"><a href="#Vue笔记" class="headerlink" title="Vue笔记"></a>Vue笔记</h1><h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>前端开发:模块化 组件化 规范化 自动化<br>npm run dev 会先去webpack.config里面查看配置 然后再执行<br>项目源码 在页面中导入的是经webpack处理过的代码 所以要修改代码都要 修改源码再run 页面才会变<br>Source Map:1.省略devtool选项 防止暴露源码<br>2.把devtool设置为nosource-source-map 只定位行数不暴露源码<br>3.把devtool设置为source-map 定位行数且显示源码<br>开发环境第三种 生产环境第一种或者第二种</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p><strong>数据驱动视图</strong><br><strong>双向数据绑定</strong><br><strong>MVVM <code>Model</code> <code>View</code> <code>ViewModel</code></strong></p><pre><code class="javascript">v-text &#123;&#125;&#123;&#125; v-html 
v-on简写@ v-bind简写:
v-model 
this===vm 在方法中访问data的数据可以用this.数据名 在data中声明的数据都会挂载到vm的属性上
方法add:function()&#123;&#125;简写为add()&#123;&#125;
@click=&quot;add(1,$event)&quot;
只要接收的值被覆盖都可以用$event
@click.prevent=&quot;add&quot; 事件修饰符 .stop .esc .enter
表单元素用v-model 修饰符 .number .trim .lazy
v-if和v-show一般都用v-if 还可以搭配if-else或者if-else-if 但是直接写三元就可以
在&quot;&quot;里面写字符串要加单引号(就当成在写js)
&lt;tr v-for=&quot;(item ,index) in list&quot; :title=&quot;item.name+index&quot; :key=&quot;item.id&quot;&gt;
v-for(item in items)item是每一项 items是被循环的数组 要搭配使用:key=&quot;item.id&quot;
</code></pre><p><code>过滤器filter&#123;&#123;mes | capi | format(arg1) &#125;&#125; 在filters节点定义过滤器 可以连续使用多个过滤器 过滤器的本质是js函数 所以可以接收参数</code></p><pre><code class="js">filters:&#123;
    capi(mes)&#123;
        return mes.charAt(0).toUpperCase()+mes.slice(1)
    &#125;
&#125;
上面定义的是私有过滤器 在入口函数main.js里面可以定义全局过滤器
Vue.filter(&#39;capi&#39;,mes=&gt;&#123;
    return mes.charAt(0).toUpperCase()+mes.slice(1)
&#125;)
Vue.filter(&#39;format&#39;,(mes,arg)=&gt;&#123;&#125;)
</code></pre><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p><strong>监听器<code>watch</code> 可以用来监听值的变化 并且发起请求 比对值是否可用</strong></p><pre><code class="js">watch:&#123;
    async username(oldVal,newVal)&#123;
        console(oldVal,newVal)
        if(newVal.trim()===&#39;&#39;) return
        const &#123;data:res&#125;=await axios.get(&#39;https://www.escook.cn/api/finduser&#39;+newVal)
        console.log(res)
    &#125;
&#125;
如果需要immediate或者deep就需要把username改为对象形式
username:&#123;
    handle:async function(newVal)&#123;
        if(newVal.trim()===&#39;&#39;) return
        const &#123;data :res&#125;=await axios.get(&#39;https://www.escook.cn/api/finduser&#39;+newVal)
        console.log(res)
    &#125;,
    //如果需要初次加载就立即被调用
    immediate:true,
    //如果监听的是一个对象 如果对象的属性发生了变化 则无法监听到 这时候需要deep选项
    deep:true
&#125;
如果只想监听一个属性也可以写成这样
&#39;info.username&#39;:&#123;
&#125;
</code></pre><p><strong>计算属性<code>computed</code></strong><br><strong>计算属性指的是通过一系列运算之后 最终得到一个属性值 这个动态计算出来的属性值可以被模板结构或 methods 方法使用。</strong></p><pre><code class="js">computed:&#123;
    rgb()&#123;return `rgb($&#123;this.r&#125;,$&#123;this.g&#125;,$&#123;this.b&#125;)`&#125;
&#125;
</code></pre><p>计算属性的特点<br>① 虽然计算属性在声明的时候被定义为方法，但是<strong>计算属性的本质是一个属性</strong><br>② 计算属性会缓存计算的结果，<strong>只有计算属性依赖的数据变化时，才会重新进行运算</strong></p><p>日期格式用day.js</p><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a><code>axios</code></h3><pre><code class="js">axios(&#123;
    method:&quot;GET&quot;,
    url:&quot;&quot;,
    //get参数
    params:&#123;&#125;,
    //post参数
    data:&#123;&#125;,
&#125;).then(res=&gt;&#123;console.log(res)&#125;)

写模板 import Test from &#39;./Test.vue&#39; 导入 渲染
&lt;button id=&quot;btnPost&quot;&gt;&lt;/button&gt;
&lt;button id=&quot;btnGet&quot;&gt;&lt;/button&gt;

&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    document.querySelector(&#39;#btnPost&#39;).addEventListener(&#39;click&#39;, async function () &#123;
        const &#123; data &#125; = await axios(&#123;
            method: &quot;POST&quot;,
            url: &quot;http://www.liulongbin.top:3006/api/post&quot;,
            data: &#123;
                name: &quot;zs&quot;,
                age: 20
            &#125;
        &#125;)
        console.log(data);
    &#125;)
    document.querySelector(&#39;#btnGet&#39;).addEventListener(&#39;click&#39;, async function () &#123;
        //解构赋值的时候 使用:进行重命名
        //调用axios,使用async/await进行简化
        //使用解构赋值 从axios封装的对象中 把data属性解构出来
        //解构出来的属性用:进行重命名 一般都重命名为&#123;data:res&#125;
        const &#123; data: res &#125; = await axios(&#123;
            method: &quot;GET&quot;,
            url: &quot;http://www.liulongbin.top:3006/api/getbooks&quot;
        &#125;)
        console.log(res.data);
    &#125;)
&lt;/script&gt;
</code></pre><p>在main.js文件中</p><pre><code class="js">import axios from &#39;axios&#39;
//全局配置axios的请求根路径
axios.defaults.baseURL=&quot;请求根路径&quot;
//把axios挂载到Vue.prototype上 供每个.vue的实例直接使用
Vue.prototype.$http=axios
//以后再.vue组件中组件要发起请求 直接调用this.$http.xxx
//但是把axios挂载到Vue.prototype上不利于API接口的复用
</code></pre><h3 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a><code>vue-cli</code></h3><pre><code class="js">npm install -g @vue/cli
vue create 项目的名称
new Vue(&#123;
    // render 函数中，渲染的是哪个 .vue 组件，那么这个组件就叫做 “根组件”
    render: h =&gt; h(App)
&#125;).$mount(&#39;#app&#39;)
$mount()和el的作用一样
import Left from &#39;@/components/Left.vue&#39; @指向src目录
在webpack.config.js里面的module.exports=&#123;
    resolve:&#123;
        alias:&#123;
           @:path.join(__dirname,&#39;./src&#39;)
        &#125;
    &#125;
&#125;
</code></pre><h3 id="使用组件三步骤"><a href="#使用组件三步骤" class="headerlink" title="使用组件三步骤"></a>使用组件三步骤</h3><pre><code class="js">&lt;template&gt;
    &lt;div&gt;
        &lt;!-- 以标签的形式使用注册好的组件 --&gt;
        &lt;Left&gt;&lt;/Left&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre><pre><code class="js">&lt;script&gt;
    //导入需要使用的.vue组件
    import Left from &#39;@/components/Left.vue&#39;
    export default &#123;
        //注册组件
        //.vue 组件中的 data 必须是函数
        components: &#123;
            Left,
            right
        &#125;
    &#125;
&lt;/script&gt;
</code></pre><p>上面这种注册的是私有子组件 注册全局组件要在main.js里面 通过Vue.component()方法</p><pre><code class="js">//导入需要的全局注册的组件
import Count form &#39;@/component/Count.vue&#39;
//参数1: 字符串 声明组件的注册名称 参数2 需要被全局注册的组件
Vue.component(&#39;MyCount&#39;,Count)
//props 是组件的自定义属性，在封装通用组件的时候，合理地使用 props 可以极大的提高组件的复用性！
exports default&#123;
    props:[&#39;init&#39;,&#39;age&#39;]
    //vue 规定：组件中封装的自定义属性是只读的，程序员不能直接修改 props 的值。否则会直接报错：
    //要想修改 props 的值，可以把 props 的值转存到 data 中，因为 data 中的数据都是可读可写的！
    data()&#123;
        return&#123;
            count:this.init
        &#125;
    &#125;
&#125;
</code></pre><p><strong>定义默认值时 <code>props</code>要改为对象模式</strong></p><pre><code class="js">export default&#123;
    props:&#123;
        default:0,
        type:Number,
        //多个可能的类型
        //type:[Number,String]
        required:true
    &#125;
&#125;
</code></pre><p>vue文件所有内容都要被解析成js才能渲染在浏览器中<br>Count组件只有使用的时候才会生成实例</p><p><strong>组件样式之间会有冲突时 给style节点添加<code>scoped</code>属性</strong><br>给HTML的dom节点添加一个不重复的data属性(例如: data-v-5558831a)来唯一标识这个dom 元素<br>在每句css选择器的末尾(编译后生成的css语句)加一个当前组件的data属性选择器(例如：[data-v-5558831a])来私有化样式<br><strong>但是scoped对子组件是不生效的 要让某些样式对子组件生效 可以在其选择器前面加<code>/deep/</code></strong><br>通过 v-html 创建的 DOM 内容不受 scoped 样式影响，但是你仍然可以通过深度作用选择器来为他们设置样式。</p><h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><p>生命周期<br><strong>生命周期（Life Cycle）是指一个组件从创建 -&gt; 运行 -&gt; 销毁的整个阶段，强调的是一个时间段。</strong><br>生命周期函数：是由 vue 框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行。<br>注意：生命周期强调的是时间段，生命周期函数强调的是时间点。<br>beforeCreate不重要<br><strong><code>created</code>重要 经常在created阶段发起axios请求 因为可以最早发起请求 然后把请求到的数据转存在data里 但是这时不能操作DOM 因为模板结构尚未创建</strong><br>beforeMount也还操作不了DOM 不重要<br><strong><code>mounted</code>已经把DOM结构渲染到页面中了 在这可以最早操作DOM结构</strong><br>beforeUpdate这时DOM结构还是旧的 但是数据是最新的<br><strong><code>updated</code>数据和结构都是最新的 在这可以操作最新的DOM结构</strong><br>updated数据变化时就会触发 使用动态组件来回切换组件会触发两次</p><h3 id="组件间的数据关系"><a href="#组件间的数据关系" class="headerlink" title="组件间的数据关系"></a>组件间的数据关系</h3><pre><code class="js">父组件向子组件共享数据需要使用自定义属性props 不建议修改props的值
04-9
子组件向父组件共享数据使用自定义事件 
04-10
在 vue2.x 中 兄弟组件之间数据共享的方案是 EventBus
04-11
在数据的发送方定义要发送的数据 在数据的接收方定义要接收的数据
创建eventBus.js 就是new一个Vue的实例 然后向外共享
发送方和接收方都导入eventBus 发送方绑定$emit 接收方绑定$on事件
发送方methods:&#123;
    sendMsg()&#123;
        //第一个参数是自定义事件名 第二个是要处理的数据
        bus.$emit(&#39;share&#39;,this.msg)
    &#125;
&#125;
接收方created()&#123;
    bus.$on(&#39;share&#39;,val=&gt;&#123;
        this.msgFromLeft=val;
    &#125;)
&#125;
</code></pre><h3 id="ref引用"><a href="#ref引用" class="headerlink" title="ref引用"></a>ref引用</h3><p>在vue中获取DOM元素使用ref</p><pre><code class="js">给想要操作的DOM元素添加ref属性 然后可以通过this.$refs.属性值来获取
ref除了引用DOM 还可以引用组件
在父组件中要去调子组件的值用ref是最简单的
this.$refs.ww.dialogVisible
this.$refs.ipt.focus()
$nextTick可以解决数据更新都是DOM结构还没有更新导致的报错
this.$nextTick(func)
组件的 $nextTick(cb) 方法，会把 cb 回调推迟到下一个 DOM 更新周期之后执行。
通俗的理解是：等组件的DOM 更新完成之后，再执行 cb 回调函数。从而能保证 cb 回调函数可以操作到最新的 DOM 元素。
</code></pre><h3 id="ES6中的数组方法"><a href="#ES6中的数组方法" class="headerlink" title="ES6中的数组方法"></a>ES6中的数组方法</h3><pre><code class="js">some 
const arr=[1,2,3,4,5]
forEach可以实现查找数组的某一元素但是forEach一旦开始无法停止 性能较差
arr.some((item,index)=&gt;&#123;
    if(item===&#39;xx&#39;) return true
&#125;)
some在找到对应的项之后可以通过return true来终止some循环

every 
需求:判断数组中 每一项的状态是否都为true
arr.every(item=&gt;item.state)  把item.state===true简写
arr.filter(item =&gt; item.id == 1) return item.id==1的
arr.filter(item =&gt; item.id ) return 有item.id这个属性的
reduce
需求:把购物车数组中 已勾选的水果 总价累加起来
let amt = 0;
arr.filter(item=&gt;item.state).forEach(item=&gt;&#123;
   amt += item.price * item count
&#125;)
filter
arr.filter(item=&gt;item.state).reduce((累加的结果,当前循环项)=&gt;&#123;&#125;,初始值)
const result = arr.filter(item=&gt;item.state).reduce((amt,item)=&gt;&#123;
    retuen amt +=item.price * item.count
    //return的值会作为第二次累加的初始值
&#125;,0)
arr.filter(item=&gt;item.state).reduce((amt,item)=&gt;amt+=item.price * item.count,0)
简写代码会把那一行代码默认作为return的返回值
</code></pre><h2 id="05动态组件"><a href="#05动态组件" class="headerlink" title="05动态组件"></a>05动态组件</h2><p><strong>vue 提供了一个内置的<code>&lt;component :is=&quot;comName&quot; include=&quot;aside&quot;&gt;</code> 组件，专门用来实现动态组件的渲染</strong><br>通过&lt;button @click=”comName=’Left”&gt;&lt;button @click=”comName=’Right”&gt;来切换组件<br><strong>默认情况下，切换动态组件时无法保持组件的状态-即会重新加载。此时可以使用 vue 内置的 <code>&lt;keep-alive&gt;</code>组件保持动态组件的状态。</strong><br>用keep-alive包住动态组件 keep-alive 对应的生命周期函数<br>当组件被缓存时，会自动触发组件的 deactivated 生命周期函数。<br>当组件被激活时，会自动触发组件的 activated 生命周期函数。<br><strong>当组件第一次被创建的时候，会先执行created 生命周期，再会执行activated 生命周期</strong><br><strong>当组件被激活的时候，只会触发 activated 生命周期，不再触发 created。因为组件没有被重新创建</strong><br>include 属性用来指定：只有名称匹配的组件会被缓存，不匹配的会销毁。多个组件名之间使用英文的逗号分隔<br>exclude 指定组件不被缓存 两个属性不能同时使用<br>如果在“声明组件”的时候，没有为组件指定 name名称，则组件的名称默认就是“注册时候的名称”<br>当提供了name属性之后，组件的名称，就是name属性的值 在开发中一般都会指定name 首字母大写<br>根节点就xxx-container xxx就组件名<br>对比:<br>1.组件的“注册名称”的主要应用场景是:以标签的形式，把注册好的组件，渲染和使用到页面结构之中<br>2.组件声明时候的“name”名称的主要应用场景:结合<keep-alive>标签实现组件缓存功能;以及在调试工具中看到组件的name名称</keep-alive></p><pre><code class="js">&lt;keep-alive include=&quot;Myleft,Myright&quot;&gt;
    &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;&gt;
&lt;/keep-alive&gt;
&lt;button @click=&quot;comName=&#39;Left&quot;&gt;&lt;/button&gt;
&lt;button @click=&quot;comName=&#39;Right&quot;&gt;&lt;/button&gt;
</code></pre><h3 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h3><p>是在组件里的一部分 可以把插槽认为是组件封装期间，为用户预留的内容的占位符<br>可以通过 <strong><code>&lt;slot&gt;</code></strong> 元素定义插槽，从而为用户预留内容占位符。<br>封装组件时，可以为预留的<slot>插槽提供后备内容,直接写在slot标签里面。如果组件的使用者没有为插槽提供任何内容，则后备内容会生效。<br>如果在封装组件时需要预留多个插槽节点，则需要为每个<slot>插槽指定具体的 name 名称。这种带有具体名称的插槽叫做 <strong><code>具名插槽</code></strong><br>没有指定 name 名称的插槽，会有隐含的名称叫做 “default”<br>在向具名插槽提供内容的时候，我们可以在一个<template>元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称。<br>v-slot后面要跟上插槽的名字 v-slot不能直接使用在元素身上 必须用在template或者组件上<br>template只起到一个包裹的作用 不会渲染成任何元素<br><strong>v-slot:可以简写为<code>#</code></strong><br>在封装组件的过程中，可以为预留的<slot>插槽绑定 props 数据，这种带有 props 数据的<slot>叫做 <strong><code>“作用域插槽”</code></strong><br>通过#content=”scope”接收作用域插槽对外提供的数据<code>&#123;&#123;scope.msg&#125;&#125;</code><br>可以在接收的时候直接解构<code>#content=&quot;&#123;msg,user&#125;&quot; &#123;&#123;msg&#125;&#125;</code><br>声明组件:</slot></slot></template></slot></slot></p><pre><code class="js">&lt;template&gt;
    &lt;div&gt;
        &lt;slot&gt;&lt;/slot&gt;
        &lt;!-- 具名插槽 --&gt;
        &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
        &lt;!-- 作用域插槽 --&gt;
        &lt;slot :user=&quot;username&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre><p>调用组件:</p><pre><code class="js">&lt;Nav&gt;
    &lt;!-- 对应默认插槽 --&gt;
    &lt;p&gt;123&lt;/p&gt;
    &lt;!-- 对应具名插槽 --&gt;
    &lt;template #header&gt;
        &lt;h1&gt;456&lt;/h1&gt;
    &lt;/template&gt;
    &lt;!-- 对应作用域插槽 --&gt;
    &lt;template #default=&quot;scope&quot;&gt;
        &lt;p&gt;&#123;\&#123; scope &#125;&#125;&lt;/p&gt;
    &lt;/template&gt;
&lt;/Nav&gt;
</code></pre><p>table组件</p><pre><code class="js">&lt;template&gt;
    &lt;table class=&quot;table table-bordered table-striped&quot;&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;!-- 表格的主体区域 --&gt;
        &lt;tbody&gt;
            &lt;!-- 使用 v-for 指令，循环渲染表格的数据行 --&gt;
            &lt;tr v-for=&quot;(item, index) in data&quot; :key=&quot;item.id&quot;&gt;
                &lt;!-- 为数据行的 td 预留的“作用域插槽” --&gt;
                &lt;slot name=&quot;body&quot; :row=&quot;item&quot; :index=&quot;index&quot;&gt;&lt;/slot&gt;
            &lt;/tr&gt;
        &lt;/tbody&gt;
    &lt;/table&gt;
&lt;/template&gt;
</code></pre><p>使用表格组件</p><pre><code class="js">&lt;!-- 使用表格组件 --&gt;
&lt;!-- 在 MyTable.vue 组件的 props 节点中声明表格的 data 数据源： --&gt;
&lt;!-- 在使用 MyTable.vue 组件时，通过属性绑定的形式为表格指定 data 数据源： --&gt;
&lt;my-table :data=&quot;goodslist&quot;&gt;
    &lt;!-- 表格的标题 --&gt;

    &lt;template v-slot:header&gt;
        &lt;th&gt;#&lt;/th&gt;
        &lt;th&gt;商品名称&lt;/th&gt;
        &lt;th&gt;价格&lt;/th&gt;
        &lt;th&gt;标签&lt;/th&gt;
        &lt;th&gt;操作&lt;/th&gt;
    &lt;/template&gt;

​    &lt;!-- 表格每行的单元格 --&gt;

    &lt;template v-slot:body=&quot;&#123; row, index &#125;&quot;&gt;
        &lt;td&gt;&#123;\&#123; index + 1 &#125;&#125;&lt;/td&gt;
        &lt;td&gt;&#123;\&#123; row.goods_name &#125;&#125;&lt;/td&gt;
        &lt;td&gt;￥&#123;\&#123; row.goods_price &#125;&#125;&lt;/td&gt;
        &lt;td&gt;&#123;\&#123; row.tags &#125;&#125;&lt;/td&gt;
        &lt;td&gt;
            &lt;button type=&quot;button&quot; class=&quot;btn btn-danger btn-sm&quot;&gt;删除
            &lt;/button&gt;
        &lt;/td&gt;
    &lt;/template&gt;

&lt;/my-table&gt;
</code></pre><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><pre><code class="js">在directives节点下声明私有自定义指令
v-color:opacity=&quot;&#123; color: &#39;white&#39;, text: &#39;hello!&#39; &#125;&quot;
directives&#123;
    color:&#123;
        bind(el)&#123;
            el.style.color=&#39;red&#39;
        &#125;
        update(el,binding)&#123;
            el.style.color=binging.value
        &#125;
    &#125;
&#125;
</code></pre><p>在使用自定义指令时，需要加上 v- 前缀 声明时不需要<br>在 template 结构中使用自定义指令时，可以通过等号（=）的方式，为当前指令动态绑定参数值<br>在声明自定义指令时，可以通过形参中的第二个参数binding来接收指令的参数值：<br>通过binding对象的.value属性获取动态的参数值 el.style.color=binding.value<br>bind函数只调用 1 次：当指令第一次绑定到元素时调用 当DOM更新时bind函数不会被触发<br>update函数第一次不会调用 但会在每次DOM更新时被调用</p><pre><code class="js">函数简写 bind和update的逻辑相同时 可以简写为以下形式
color(el,binging)&#123;
    el.style.color=binging.value
&#125;
全局自定义指令 一般都定义全局
Vue.directive(&#39;color&#39;,function(el,binging)&#123;
    el.style.color=binging.value
&#125;)
</code></pre><h2 id="06"><a href="#06" class="headerlink" title="06"></a>06</h2><p>location.href返回#哈希地址 哈希地址会产生前进后退<br>简易路由</p><pre><code class="js">window.onhashchange=()=&gt;&#123;
    console.log(location.hash)
    switch(location.hash)&#123;
        case &#39;#/home&#39;:
            this.comName=&#39;Home&#39;
            break
        case &#39;#/movie&#39;:
            this.comName=&#39;movie&#39;
            break
    &#125;
&#125;
</code></pre><h3 id="vue-router插件"><a href="#vue-router插件" class="headerlink" title="vue.router插件"></a>vue.router插件</h3><p>使用方法:</p><pre><code class="js">npm i vue-router@3.5.2 -S
1.导入Vue和VueRouter 2.Vue.use(VueRouter)
3.new一个实例 const router =new VueRouter()
4.向外共享 export default router
然后在main.js中导入router
new Vue(&#123;
    render:h=&gt;(App),
    router
&#125;).$mount(&#39;$app&#39;)
</code></pre><p>以后使用时可以一键生成<br><strong><code>this.$route是路由对象</code><br><code>this.$router是导航对象</code></strong><br>路由链接<br>使用 vue-router 提供的<router-link to="/home">(不用加#)和<router-view>声明路由链接和占位符：</router-view></router-link></p><pre><code class="js">const router =new VueRouter(&#123;
    routes:[
        &#123;path:&#39;/home&#39;,component:Home&#125;
        &#123;path:&#39;/movie&#39;,component:Movie&#125;
        &#123;path:&#39;/about&#39;,component:About&#125;
    ]
&#125;)
</code></pre><p>路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 C ，从而展示特定的组件页面。<br>通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便地设置路由的重定向<code>&#123;path:&#39;/&#39;,redirect:&#39;/home&#39;&#125;</code></p><p><strong>嵌套路由 套娃</strong><br>通过 children 属性声明子路由规则</p><pre><code class="js">&#123;
    path:&#39;/about&#39;,
    component:About,
    &lt;!-- redirect:&#39;/about/tab1&#39; --&gt;
    children:[
    &lt;!-- 默认子路由 在children数组中如果path为空字符串 则这条路由就是默认子路由 就不用重定向 --&gt;
    &lt;!-- 子路由不用/开头 --&gt;
        &#123;path:&#39;&#39;,component:Tab1&#125;
        &lt;!-- &#123;path:&#39;tab1&#39;,component:Tab1&#125; --&gt;
        &#123;path:&#39;tab2&#39;,component:Tab2&#125;
    ]
&#125;
</code></pre><p><strong>动态路由 :id</strong><br><code>&#123;path:&#39;/movie/:id&#39;,component:Movie&#125;</code></p><pre><code class="js">在Movie组件中获取id可以通过$route.params.id
也可以使用 props 接收路由参数 在组件的props中声明id变量
&#123;path:&#39;/movie/:id&#39;,component:Movie,props:true&#125;
通过$route.query来获取查询参数 就是url?后面的值 fullPath是完整路径
</code></pre><p>声明式导航 链接 &amp; 编程式导航 (js)</p><pre><code class="js">this.$router
1 this.$router.push(&#39;hash 地址&#39;)
跳转到指定 hash 地址，并增加一条历史记录
2 this.$router.replace(&#39;hash 地址&#39;)  
跳转到指定的 hash 地址，并替换掉当前的历史记录
3 this.$router.go(数值 n)
this.$router.back()/forward()
</code></pre><p>实现导航历史前进、后退 如果超过上限则不动<br>在行内使用编程式导航跳转的时候, <strong>this 必要省略</strong>,否则报错</p><p><strong>全局前置守卫</strong><br><code>router.beforeEach((to,from,next)=&gt;&#123;&#125;)</code><br>每次发生路由的导航跳转时，都会触发全局前置守卫<br><strong>必须调用next()</strong></p><ol><li>当前用户拥有后台主页的访问权限，直接放行：next()</li><li>当前用户没有后台主页的访问权限，强制其跳转到登录页面：next(‘/login’)</li><li>当前用户没有后台主页的访问权限，不允许跳转到后台主页 停留在当前页面：next(false)</li></ol><pre><code class="js">router.beforeEach((to,from,next)=&gt;&#123;
    if(to.path===&#39;/main&#39;)&#123;
        const token = localStorage,getItem(&#39;key&#39;);
        if(token)&#123;
            next()
        &#125;else&#123;
            next(&#39;/login&#39;)
        &#125;
    &#125;else&#123;
        next();
    &#125;
&#125;)
</code></pre><h2 id="07-other"><a href="#07-other" class="headerlink" title="07 other"></a>07 other</h2><h3 id="Vant"><a href="#Vant" class="headerlink" title="Vant"></a>Vant</h3><pre><code class="js">npm install vant -S
全引入
import Vue from &#39;vue&#39;;
import Vant from &#39;vant&#39;;
import &#39;vant/lib/index.css&#39;;

Vue.use(Vant);
1.创建项目
2.初始化
3.加组件
4.实现功能
</code></pre><h3 id="axios请求改进"><a href="#axios请求改进" class="headerlink" title="axios请求改进"></a>axios请求改进</h3><pre><code class="js">导入request模块
import axios from &#39;axios&#39;

const request = axios.create(&#123;
  baseURL: &#39;https://www.escook.cn&#39;
&#125;)

export default request

调用方法请求参数
//改进前
methods: &#123;
    async initArticleList() &#123;
        const &#123; data: res &#125; = await request.get(&#39;/articles&#39;, &#123;
            params: &#123;
                _page: this.page,
                _limit: this.limit
            &#125;
        &#125;)
        console.log(res)
    &#125;
&#125;,
created() &#123;
    this.initArticleList()
&#125;
如果请求多个服务器可以封装request来创建多个axios来对应服务器
如果多个页面要调用同一个接口会导致重复
就封装一个api 请求就封装到api中
//改进后
//导入axios
import request from &#39;@/utils/request.js&#39;
//返回封装的API
export const getArticleListAPI = (_page, _limit) =&gt; &#123;
    return request.get(&#39;/article&#39;, &#123;
        params: &#123;
            _page,
            _limit
        &#125;
    &#125;)
&#125;
//按需导入API接口
import &#123; getArticleListAPI &#125; from &#39;@/api/articleAPI.js&#39;

methods: &#123;
    async initArticleList() &#123;
        const &#123; data: res &#125; = await getArticleListAPI(this.page,this.limit)
        console.log(res)
    &#125;
&#125;,
</code></pre><h3 id="覆盖第三方组件的样式"><a href="#覆盖第三方组件的样式" class="headerlink" title="覆盖第三方组件的样式"></a>覆盖第三方组件的样式</h3><pre><code class="js">单页面
.home-container&#123;
    padding: 46px 0 50px 0;
    *&#123;
        background-color: red;
    &#125;
    /deep/ *&#123;
        color: blue;
    &#125;
&#125;
全局 定制主题
//覆盖默认的less变量
import &#39;vant/lib/index.less&#39;
// 这个文件是 vue-cli 创建出来的项目的配置文件
// 在 vue.config.js 这个配置文件中，可以对整个项目的打包、构建进行全局性的配置

// webpack 在进行打包的时候，底层用到了 node.js
// 因此,在 vue.config.js 配置文件中，可以导入并使用 node.js 中的核心模块
const path = require(&#39;path&#39;)
const themePath = path.join(__dirname, &#39;./src/theme.less&#39;)

module.exports = &#123;
    publicPath: &#39;./&#39;,
    css: &#123;
        loaderOptions: &#123;
            less: &#123;
                modifyVars: &#123;
                    // 直接覆盖变量
                    // &#39;nav-bar-background-color&#39;: &#39;orange&#39;
                    // 或者可以通过 less 文件覆盖（文件路径为绝对路径）
                    // ../ ./ theme.less
                    // 从盘符开始的路径，叫做绝对路径 C:\\Users\liulongbin\\theme.less
                    hack: `true; @import &quot;$&#123;themePath&#125;&quot;;`
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><h3 id="配置vscode"><a href="#配置vscode" class="headerlink" title="配置vscode"></a>配置vscode</h3><pre><code class="js">下载eslint和prettier插件
&quot;editor.formatOnSave&quot;: true,
//ESLint插件的配置
&quot;editor.codeActionsOnSave&quot;: &#123;
&quot;source.fixAll&quot;: true,
&#125;,

//.prettierrc文件里写&#123;semi: false, singleQuote: true, printWidth: 300&#125;
&quot;prettier.configPath&quot;: &quot;C:\\Users\\Admin\\.prettierrc&quot;,
&quot;eslint.alwaysShowStatus&quot;: true,
&quot;prettier.trailingComma&quot;: &quot;none&quot;,
&quot;prettier.semi&quot;: false,
// 每行文字个数超出此限制将会被迫换行
&quot;prettier.printWidth&quot;: 300,
// 使用单引号替换双引号
&quot;prettier.singleQuote&quot;: true,
&quot;prettier.arrowParens&quot;: &quot;avoid&quot;,
// 设置 .vue 文件中，HTML代码的格式化插件
&quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;,
&quot;vetur.ignoreProjectWarning&quot;: true,
&quot;vetur.format.defaultFormatterOptions&quot;: &#123;
&quot;js-beautify-html&quot;: &#123;
&quot;wrap_attributes&quot;: false
&#125;,
&quot;prettier&quot;: &#123;
&quot;printWidth&quot;: 300,
&quot;trailingComma&quot;: &quot;none&quot;,
&quot;semi&quot;: false,
&quot;singleQuote&quot;: true,
&quot;arrowParens&quot;: &quot;avoid&quot;
&#125;
&#125;js ,
</code></pre><h2 id="NOTICE"><a href="#NOTICE" class="headerlink" title="NOTICE"></a>NOTICE</h2><ol><li>views放路由的组件 component放其他组件</li><li>路由规则和地址要一一对应</li><li>使用插件或者库想要实现更多功能先查看官方文档 尽量不要手写</li><li>属性值默认值为false 想改为true 直接写属性名就可以</li><li>提高axios请求的复用性 const axios1=axios.create({baseURL:’xx’})</li><li>如果重复调用接口 可以封装到模块中 放在API文件夹下</li><li>获取数据的函数函数名以init开头 API函数以API结尾</li><li>在使用组件的时候，如果某个属性名是“小驼峰”形式，则绑定属性的时候,建议改写成“连字符”格式</li><li>例如cmtCount建议写成cmt-count props里面就接着写成cmtCount</li><li>eslint在porps中有有默认值的对象时 默认值为{}会报错 通过不设或者工厂函数来解决</li><li>在v-for中没id可以用索引 但是前面有复选框时必须用id</li><li>触发load事件时loading变为true就不会重复触发 在初始化请求数据时也会触发一次</li><li>所以一开始设置为true 在created中重新设为false</li><li>通过判断请求数据来判断是否到底</li><li>实现上拉加载 1.加页码 再请求 2.[…arr,…arr1]数据拼接 3.判断是否为最后一页</li><li>不在main.js中use(Vuex)在store.js中use(Vuex)就不会报错</li></ol><h2 id="after"><a href="#after" class="headerlink" title="after"></a>after</h2><p>element-ui</p><p>more axios</p><pre><code class="js">// 全局配置 axios
axios.defaults.baseURL = &#39;https://www.escook.cn&#39;
Vue.prototype.\$http = axios
proxy跨域代理
axios.defaults.baseURL = &#39;http://localhost:1245&#39;
module.exports = &#123;
    devServer: &#123;
        port: 1245,
        open: true,
        proxy: &#39;https://www.escook.cn&#39;
    &#125;
&#125;
拦截器
let loadingInstance = null
axios.interceptors.request.use(config =&gt; &#123;
    config.header.Authorization=&#39;Bearer xxx&#39;
    loadingInstance = Loading.service(&#123; fullscreen: true &#125;)
    return config
&#125;)

axios.interceptors.response.use(response =&gt; &#123;
    loadingInstance.close()
    return response
&#125;)
</code></pre><div class="tags"><a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"><i class="ic i-tag"></i> 前端</a> <a href="/tags/Vue/" rel="tag"><i class="ic i-tag"></i> Vue</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-03-28 14:51:25" itemprop="dateModified" datetime="2022-03-28T14:51:25+08:00">2022-03-28</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="sparkle 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="sparkle 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="sparkle 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>sparkle <i class="ic i-at"><em>@</em></i>Sparkle</li><li class="link"><strong>本文链接：</strong> <a href="https://1234cas.github.io/1234cas.github.io/qianduan/Vue/vue%E7%AC%94%E8%AE%B0/" title="Vue笔记">https://1234cas.github.io/1234cas.github.io/qianduan/Vue/vue笔记/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/reading-minutes/%E5%85%B3%E4%BA%8E%E8%AF%BB%E4%B9%A6/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeyvx1d4j20zk0m8hdt.jpg" title="关于读书"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 读书笔记</span><h3>关于读书</h3></a></div><div class="item right"><a href="/reading-minutes/%E5%85%B3%E4%BA%8E%E7%AC%94%E8%AE%B0/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicljgocqbj20zk0m8e81.jpg" title="关于笔记"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 读书笔记</span><h3>关于笔记</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">Vue笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01"><span class="toc-number">1.1.</span> <span class="toc-text">01</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02"><span class="toc-number">1.2.</span> <span class="toc-text">02</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03"><span class="toc-number">1.3.</span> <span class="toc-text">03</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#axios"><span class="toc-number">1.3.1.</span> <span class="toc-text">axios</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-cli"><span class="toc-number">1.3.2.</span> <span class="toc-text">vue-cli</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E4%B8%89%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.3.3.</span> <span class="toc-text">使用组件三步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04"><span class="toc-number">1.4.</span> <span class="toc-text">04</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">组件间的数据关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref%E5%BC%95%E7%94%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">ref引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">ES6中的数组方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6"><span class="toc-number">1.5.</span> <span class="toc-text">05动态组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E6%A7%BDslot"><span class="toc-number">1.5.1.</span> <span class="toc-text">插槽slot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">1.5.2.</span> <span class="toc-text">自定义指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06"><span class="toc-number">1.6.</span> <span class="toc-text">06</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-router%E6%8F%92%E4%BB%B6"><span class="toc-number">1.6.1.</span> <span class="toc-text">vue.router插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07-other"><span class="toc-number">1.7.</span> <span class="toc-text">07 other</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vant"><span class="toc-number">1.7.1.</span> <span class="toc-text">Vant</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios%E8%AF%B7%E6%B1%82%E6%94%B9%E8%BF%9B"><span class="toc-number">1.7.2.</span> <span class="toc-text">axios请求改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6%E7%9A%84%E6%A0%B7%E5%BC%8F"><span class="toc-number">1.7.3.</span> <span class="toc-text">覆盖第三方组件的样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEvscode"><span class="toc-number">1.7.4.</span> <span class="toc-text">配置vscode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NOTICE"><span class="toc-number">1.8.</span> <span class="toc-text">NOTICE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#after"><span class="toc-number">1.9.</span> <span class="toc-text">after</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/qianduan/Vue/vue%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="bookmark" title="Vue面试题">Vue面试题</a></li><li><a href="/qianduan/Vue/vue-router/" rel="bookmark" title="Vue router">Vue router</a></li><li><a href="/qianduan/Vue/vuex/" rel="bookmark" title="vuex">vuex</a></li><li class="active"><a href="/qianduan/Vue/vue%E7%AC%94%E8%AE%B0/" rel="bookmark" title="Vue笔记">Vue笔记</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="sparkle" data-src="/images/avatar.jpg"><p class="name" itemprop="name">sparkle</p><div class="description" itemprop="description">好好读书</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">11</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">5</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">3</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></span> <span class="exturl item google" data-url="aHR0cHM6Ly9wbHVzLmdvb2dsZS5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;plus.google.com&#x2F;yourname"><i class="ic i-google"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnlvdXJuYW1lQG1haWwuY29t" title="mailto:yourname@mail.com"><i class="ic i-envelope"></i></span> <span class="exturl item facebook" data-url="aHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;www.facebook.com&#x2F;yourname"><i class="ic i-facebook"></i></span> <span class="exturl item stackoverflow" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;yourname"><i class="ic i-stack-overflow"></i></span> <span class="exturl item youtube" data-url="aHR0cHM6Ly95b3V0dWJlLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;youtube.com&#x2F;yourname"><i class="ic i-youtube"></i></span> <span class="exturl item instagram" data-url="aHR0cHM6Ly9pbnN0YWdyYW0uY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;instagram.com&#x2F;yourname"><i class="ic i-instagram"></i></span> <span class="exturl item skype" data-url="c2t5cGU6eW91cm5hbWU/Y2FsbHxjaGF0" title="skype:yourname?call|chat"><i class="ic i-skype"></i></span> <span class="exturl item douban" data-url="aHR0cHM6Ly93d3cuZG91YmFuLmNvbS9wZW9wbGUveW91cm5hbWUv" title="https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;yourname&#x2F;"><i class="ic i-douban"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>链接</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/reading-minutes/%E5%85%B3%E4%BA%8E%E8%AF%BB%E4%B9%A6/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/reading-minutes/%E5%85%B3%E4%BA%8E%E7%AC%94%E8%AE%B0/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/hexo/" title="分类于 hexo">hexo</a></div><span><a href="/hexo/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/reading-minutes/" title="分类于 读书笔记">读书笔记</a></div><span><a href="/reading-minutes/%E5%85%B3%E4%BA%8E%E7%AC%94%E8%AE%B0/" title="关于笔记">关于笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/qianduan/Vue/vuex/" title="vuex">vuex</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a></div><span><a href="/%E5%9F%BA%E7%A1%80/" title="基础">基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a></div><span><a href="/qianduan/TCP%E5%8D%8F%E8%AE%AE/" title="TCP协议">TCP协议</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/qianduan/Vue/vue-router/" title="Vue router">Vue router</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/ES6/" title="分类于 ES6">ES6</a></div><span><a href="/qianduan/ES6/ES6%E4%B8%8B/" title="ES6下">ES6下</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/qianduan/Vue/vue%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Vue面试题">Vue面试题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/qianduan/Vue/vue%E7%AC%94%E8%AE%B0/" title="Vue笔记">Vue笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/qianduan/" title="分类于 前端">前端</a> <i class="ic i-angle-right"></i> <a href="/categories/qianduan/ES6/" title="分类于 ES6">ES6</a></div><span><a href="/qianduan/ES6/ES6%E4%B8%8A/" title="ES6上">ES6上</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">sparkle @ Sparkle</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"qianduan/Vue/vue笔记/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:{placeholder:"1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，祝食用愉快💪"},fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->